#!/usr/bin/env python

# ██████╗ ██╗   ██╗███████╗███╗   ███╗███████╗████████╗██╗   ██╗██╗   ██╗███████╗
# ██╔══██╗╚██╗ ██╔╝██╔════╝████╗ ████║██╔════╝╚══██╔══╝██║   ██║██║   ██║██╔════╝
# ██████╔╝ ╚████╔╝ ███████╗██╔████╔██║███████╗   ██║   ██║   ██║██║   ██║███████╗
# ██╔═══╝   ╚██╔╝  ╚════██║██║╚██╔╝██║╚════██║   ██║   ██║   ██║██║   ██║╚════██║
# ██║        ██║   ███████║██║ ╚═╝ ██║███████║   ██║   ╚██████╔╝╚██████╔╝███████║
# ╚═╝        ╚═╝   ╚══════╝╚═╝     ╚═╝╚══════╝   ╚═╝    ╚═════╝  ╚═════╝ ╚══════╝
# Pyrmethus - Unified Scalping Spell v2.2 (Fortified Configuration & Clarity)
# Conjures high-frequency trades on Bybit Futures with enhanced precision, adaptable strategies, and Termux integration.

"""High-Frequency Trading Bot (Scalping) for Bybit USDT Futures
Version: 2.2.0 (Unified: Selectable Strategies + Precision + Native SL/TSL + Fortified Config + Pyrmethus Enhancements).

Features:
- Multiple strategies selectable via config: "DUAL_SUPERTREND", "STOCHRSI_MOMENTUM", "EHLERS_FISHER", "EHLERS_MA_CROSS".
- Enhanced Precision: Uses Decimal for critical financial calculations.
- Fortified Configuration Loading: Correctly handles type casting for default values.
- Exchange-native Trailing Stop Loss (TSL) placed immediately after entry.
- Exchange-native fixed Stop Loss placed immediately after entry.
- ATR for volatility measurement and initial Stop-Loss calculation.
- Optional Volume spike and Order Book pressure confirmation.
- Risk-based position sizing with margin checks.
- Termux SMS alerts for critical events and trade actions (with Termux:API check).
- Robust error handling and logging with vibrant Neon color support via Colorama.
- Graceful shutdown on KeyboardInterrupt with position/order closing attempt.
- Stricter position detection logic (Bybit V5 API).

Disclaimer:
- **EXTREME RISK**: Arcane energies are volatile. Educational purposes ONLY. High-risk. Use at own absolute risk.
- **EXCHANGE-NATIVE SL/TSL DEPENDENCE**: Relies on exchange-native orders. Subject to exchange performance, slippage, API reliability.
- Parameter Sensitivity: Requires significant tuning and testing in the astral plane (testnet).
- API Rate Limits: Monitor usage lest the exchange spirits grow wary.
- Slippage: Market orders are prone to slippage in turbulent ether.
- Test Thoroughly: **DO NOT RUN LIVE WITHOUT EXTENSIVE TESTNET/DEMO TESTING.**
- Termux Dependency: Requires Termux:API for SMS communication scrolls. Ensure `pkg install termux-api`.
- API Changes: Code targets Bybit V5 via CCXT, updates may be needed as the digital cosmos shifts.
"""

# Standard Library Imports - The Foundational Runes
import logging
import os
import shutil  # For checking command existence
import subprocess
import sys
import time
import traceback
from decimal import ROUND_HALF_UP, Decimal, InvalidOperation, getcontext
from typing import Any

# Third-party Libraries - Summoned Essences
try:
    import ccxt
    import pandas as pd
    import pandas_ta as ta  # type: ignore[import]
    from colorama import Back, Fore, Style
    from colorama import init as colorama_init
    from dotenv import load_dotenv
except ImportError as e:
    missing_pkg = e.name
    # Use Colorama's raw codes here as it might not be initialized yet
    sys.exit(1)

# --- Initializations - Preparing the Ritual Chamber ---
colorama_init(autoreset=True)  # Activate Colorama's magic
load_dotenv()  # Load secrets from the hidden .env scroll
getcontext().prec = 18  # Set Decimal precision for financial exactitude


# --- Configuration Class - Defining the Spell's Parameters ---
class Config:
    """Loads and validates configuration parameters from environment variables."""
    def __init__(self) -> None:
        logger.info(f"{Fore.MAGENTA}--- Summoning Configuration Runes ---{Style.RESET_ALL}")
        # --- API Credentials - Keys to the Exchange Vault ---
        self.api_key: str | None = self._get_env("BYBIT_API_KEY", required=True, color=Fore.RED)
        self.api_secret: str | None = self._get_env("BYBIT_API_SECRET", required=True, color=Fore.RED)

        # --- Trading Parameters - Core Incantation Variables ---
        self.symbol: str = self._get_env("SYMBOL", "BTC/USDT:USDT", color=Fore.YELLOW)
        self.interval: str = self._get_env("INTERVAL", "1m", color=Fore.YELLOW)  # Timeframe focus
        self.leverage: int = self._get_env("LEVERAGE", 10, cast_type=int, color=Fore.YELLOW)  # Power multiplier
        self.sleep_seconds: int = self._get_env("SLEEP_SECONDS", 10, cast_type=int, color=Fore.YELLOW)  # Pause between observations

        # --- Strategy Selection - Choosing the Path of Magic ---
        self.strategy_name: str = self._get_env("STRATEGY_NAME", "DUAL_SUPERTREND", color=Fore.CYAN).upper()
        self.valid_strategies: list[str] = ["DUAL_SUPERTREND", "STOCHRSI_MOMENTUM", "EHLERS_FISHER", "EHLERS_MA_CROSS"]
        if self.strategy_name not in self.valid_strategies:
            logger.critical(f"{Back.RED}{Fore.WHITE}Invalid STRATEGY_NAME '{self.strategy_name}'. Valid paths: {self.valid_strategies}{Style.RESET_ALL}")
            raise ValueError(f"Invalid STRATEGY_NAME '{self.strategy_name}'.")
        logger.info(f"{Fore.CYAN}Chosen Strategy Path: {self.strategy_name}{Style.RESET_ALL}")

        # --- Risk Management - Wards Against Ruin ---
        self.risk_per_trade_percentage: Decimal = self._get_env("RISK_PER_TRADE_PERCENTAGE", "0.005", cast_type=Decimal, color=Fore.GREEN)  # 0.5% risk per venture
        self.atr_stop_loss_multiplier: Decimal = self._get_env("ATR_STOP_LOSS_MULTIPLIER", "1.5", cast_type=Decimal, color=Fore.GREEN)  # Volatility-based ward distance
        self.max_order_usdt_amount: Decimal = self._get_env("MAX_ORDER_USDT_AMOUNT", "500.0", cast_type=Decimal, color=Fore.GREEN)  # Limit on position value
        self.required_margin_buffer: Decimal = self._get_env("REQUIRED_MARGIN_BUFFER", "1.05", cast_type=Decimal, color=Fore.GREEN)  # 5% safety margin

        # --- Trailing Stop Loss (Exchange Native) - The Adaptive Shield ---
        self.trailing_stop_percentage: Decimal = self._get_env("TRAILING_STOP_PERCENTAGE", "0.005", cast_type=Decimal, color=Fore.GREEN)  # 0.5% trailing distance
        self.trailing_stop_activation_offset_percent: Decimal = self._get_env("TRAILING_STOP_ACTIVATION_PRICE_OFFSET_PERCENT", "0.001", cast_type=Decimal, color=Fore.GREEN)  # 0.1% offset before activation

        # --- Strategy-Specific Parameters - Tuning the Chosen Path ---
        # Dual Supertrend
        self.st_atr_length: int = self._get_env("ST_ATR_LENGTH", 7, cast_type=int, color=Fore.CYAN)
        self.st_multiplier: Decimal = self._get_env("ST_MULTIPLIER", "2.5", cast_type=Decimal, color=Fore.CYAN)
        self.confirm_st_atr_length: int = self._get_env("CONFIRM_ST_ATR_LENGTH", 5, cast_type=int, color=Fore.CYAN)
        self.confirm_st_multiplier: Decimal = self._get_env("CONFIRM_ST_MULTIPLIER", "2.0", cast_type=Decimal, color=Fore.CYAN)
        # StochRSI + Momentum
        self.stochrsi_rsi_length: int = self._get_env("STOCHRSI_RSI_LENGTH", 14, cast_type=int, color=Fore.CYAN)
        self.stochrsi_stoch_length: int = self._get_env("STOCHRSI_STOCH_LENGTH", 14, cast_type=int, color=Fore.CYAN)
        self.stochrsi_k_period: int = self._get_env("STOCHRSI_K_PERIOD", 3, cast_type=int, color=Fore.CYAN)
        self.stochrsi_d_period: int = self._get_env("STOCHRSI_D_PERIOD", 3, cast_type=int, color=Fore.CYAN)
        self.stochrsi_overbought: Decimal = self._get_env("STOCHRSI_OVERBOUGHT", "80.0", cast_type=Decimal, color=Fore.CYAN)
        self.stochrsi_oversold: Decimal = self._get_env("STOCHRSI_OVERSOLD", "20.0", cast_type=Decimal, color=Fore.CYAN)
        self.momentum_length: int = self._get_env("MOMENTUM_LENGTH", 5, cast_type=int, color=Fore.CYAN)
        # Ehlers Fisher Transform
        self.ehlers_fisher_length: int = self._get_env("EHLERS_FISHER_LENGTH", 10, cast_type=int, color=Fore.CYAN)
        self.ehlers_fisher_signal_length: int = self._get_env("EHLERS_FISHER_SIGNAL_LENGTH", 1, cast_type=int, color=Fore.CYAN)  # Default to 1 (often just the Fisher line itself)
        # Ehlers MA Cross (Placeholder - see function note)
        self.ehlers_fast_period: int = self._get_env("EHLERS_FAST_PERIOD", 10, cast_type=int, color=Fore.CYAN)
        self.ehlers_slow_period: int = self._get_env("EHLERS_SLOW_PERIOD", 30, cast_type=int, color=Fore.CYAN)

        # --- Confirmation Filters - Seeking Concordance in the Ether ---
        # Volume Analysis
        self.volume_ma_period: int = self._get_env("VOLUME_MA_PERIOD", 20, cast_type=int, color=Fore.YELLOW)
        self.volume_spike_threshold: Decimal = self._get_env("VOLUME_SPIKE_THRESHOLD", "1.5", cast_type=Decimal, color=Fore.YELLOW)  # Multiplier over MA
        self.require_volume_spike_for_entry: bool = self._get_env("REQUIRE_VOLUME_SPIKE_FOR_ENTRY", "false", cast_type=bool, color=Fore.YELLOW)
        # Order Book Analysis
        self.order_book_depth: int = self._get_env("ORDER_BOOK_DEPTH", 10, cast_type=int, color=Fore.YELLOW)  # Levels to analyze
        self.order_book_ratio_threshold_long: Decimal = self._get_env("ORDER_BOOK_RATIO_THRESHOLD_LONG", "1.2", cast_type=Decimal, color=Fore.YELLOW)  # Bid/Ask ratio for long
        self.order_book_ratio_threshold_short: Decimal = self._get_env("ORDER_BOOK_RATIO_THRESHOLD_SHORT", "0.8", cast_type=Decimal, color=Fore.YELLOW)  # Bid/Ask ratio for short
        self.fetch_order_book_per_cycle: bool = self._get_env("FETCH_ORDER_BOOK_PER_CYCLE", "false", cast_type=bool, color=Fore.YELLOW)  # Fetch OB every cycle or only on signal?

        # --- ATR Calculation (for Initial SL) ---
        self.atr_calculation_period: int = self._get_env("ATR_CALCULATION_PERIOD", 14, cast_type=int, color=Fore.GREEN)

        # --- Termux SMS Alerts - Whispers Through the Digital Veil ---
        self.enable_sms_alerts: bool = self._get_env("ENABLE_SMS_ALERTS", "false", cast_type=bool, color=Fore.MAGENTA)
        self.sms_recipient_number: str | None = self._get_env("SMS_RECIPIENT_NUMBER", None, color=Fore.MAGENTA)
        self.sms_timeout_seconds: int = self._get_env("SMS_TIMEOUT_SECONDS", 30, cast_type=int, color=Fore.MAGENTA)

        # --- CCXT / API Parameters - Tuning the Connection ---
        self.default_recv_window: int = 10000  # Milliseconds for API request validity
        self.order_book_fetch_limit: int = max(25, self.order_book_depth)  # Ensure sufficient depth fetched
        self.shallow_ob_fetch_depth: int = 5  # For quick price estimates
        self.order_fill_timeout_seconds: int = self._get_env("ORDER_FILL_TIMEOUT_SECONDS", 15, cast_type=int, color=Fore.YELLOW)  # Wait time for market order fill

        # --- Internal Constants - Fixed Arcane Symbols ---
        self.side_buy: str = "buy"
        self.side_sell: str = "sell"
        self.pos_long: str = "Long"
        self.pos_short: str = "Short"
        self.pos_none: str = "None"
        self.usdt_symbol: str = "USDT"  # The stable anchor
        self.retry_count: int = 3  # Attempts for certain API calls
        self.retry_delay_seconds: int = 2  # Pause between retries
        self.api_fetch_limit_buffer: int = 10  # Extra candles to fetch
        self.position_qty_epsilon: Decimal = Decimal("1e-9")  # Small value for float comparisons
        self.post_close_delay_seconds: int = 3  # Brief pause after closing a position

        logger.info(f"{Fore.MAGENTA}--- Configuration Runes Summoned and Verified ---{Style.RESET_ALL}")

    def _get_env(self, key: str, default: Any = None, cast_type: type = str, required: bool = False, color: str = Fore.WHITE) -> Any:
        """Fetches env var, casts type (including defaults), logs, handles defaults/errors with arcane grace.
        Ensures that default values are also cast to the specified type.
        """
        value_str = os.getenv(key)  # Get raw string value from environment
        final_value: Any = None  # Variable to hold the final, potentially casted value

        if value_str is None:
            # Environment variable not found, use the default
            if required:
                logger.critical(f"{Back.RED}{Fore.WHITE}CRITICAL: Required configuration rune '{key}' not found in the environment scroll (.env).{Style.RESET_ALL}")
                raise ValueError(f"Required environment variable '{key}' not set.")
            logger.debug(f"{color}Summoning {key}: Not Set (Using Default: '{default}'){Style.RESET_ALL}")
            final_value = default  # Assign default, still needs casting below
        else:
            # Environment variable found
            logger.debug(f"{color}Summoning {key}: Found Env Value '{value_str}'{Style.RESET_ALL}")
            final_value = value_str  # Assign found string, needs casting below

        # --- Attempt Casting (applies to both env var value and default value) ---
        if final_value is None and required:
            # This case handles if the default was None and it was required
            logger.critical(f"{Back.RED}{Fore.WHITE}CRITICAL: Required configuration rune '{key}' has no value or default.{Style.RESET_ALL}")
            raise ValueError(f"Required environment variable '{key}' has no value or default.")
        elif final_value is None:
            # Not required and no value/default, return None
            return None

        # Proceed with casting if a value (from env or default) exists
        try:
            if cast_type == bool:
                # Handle boolean casting explicitly
                final_value = str(final_value).lower() in ['true', '1', 'yes', 'y']
            elif cast_type == Decimal:
                # Handle Decimal casting
                final_value = Decimal(str(final_value))
            elif cast_type == int:
                # Handle Integer casting
                final_value = int(str(final_value))
            elif cast_type == float:
                 # Handle Float casting
                final_value = float(str(final_value))
            elif cast_type == str:
                # Already string or cast to string
                final_value = str(final_value)
            # Add other types if needed
            # else: No specific cast needed beyond string, leave as is (or handle error)

        except (ValueError, TypeError, InvalidOperation) as e:
            # Casting failed! Log error and use default (if possible), but try casting default again
            logger.error(f"{Fore.RED}Invalid type/value for {key}: '{final_value}' (from env or default). Expected {cast_type.__name__}. Error: {e}. Attempting default '{default}' again.{Style.RESET_ALL}")
            if default is None:
                 # If default is also None, and required, we have a problem (handled above)
                 # If not required, return None
                 if required:  # Should have been caught earlier, but double check
                     raise ValueError(f"Required env var '{key}' failed casting and has no valid default.")
                 return None
            else:
                # Try casting the default value one more time
                try:
                    if cast_type == bool: final_value = str(default).lower() in ['true', '1', 'yes', 'y']
                    elif cast_type == Decimal: final_value = Decimal(str(default))
                    elif cast_type == int: final_value = int(str(default))
                    elif cast_type == float: final_value = float(str(default))
                    elif cast_type == str: final_value = str(default)
                    # else: leave default as is
                    logger.warning(f"{Fore.YELLOW}Successfully used casted default value for {key}: '{final_value}'{Style.RESET_ALL}")
                except (ValueError, TypeError, InvalidOperation) as e_default:
                    # If even the default fails casting, it's a critical config issue
                    logger.critical(f"{Back.RED}{Fore.WHITE}CRITICAL: Failed to cast BOTH provided value and default value for {key}. Default='{default}', Type={cast_type.__name__}. Error: {e_default}{Style.RESET_ALL}")
                    raise ValueError(f"Configuration error: Cannot cast value or default for key '{key}' to {cast_type.__name__}.")

        # Log the final type and value being used
        logger.debug(f"{color}Using final value for {key}: {final_value} (Type: {type(final_value).__name__}){Style.RESET_ALL}")
        return final_value


# --- Logger Setup - The Oracle's Voice ---
LOGGING_LEVEL: int = logging.DEBUG if os.getenv("DEBUG", "false").lower() == "true" else logging.INFO
logging.basicConfig(
    level=LOGGING_LEVEL,
    format="%(asctime)s [%(levelname)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
    handlers=[logging.StreamHandler(sys.stdout)]  # Output to the Termux console
)
logger: logging.Logger = logging.getLogger(__name__)

# Custom SUCCESS level and Neon Color Formatting for the Oracle
SUCCESS_LEVEL: int = 25
logging.addLevelName(SUCCESS_LEVEL, "SUCCESS")


def log_success(self: logging.Logger, message: str, *args: Any, **kwargs: Any) -> None:
    """Logs a success message with mystical flair."""
    if self.isEnabledFor(SUCCESS_LEVEL): self._log(SUCCESS_LEVEL, message, args, **kwargs)  # pylint: disable=protected-access


logging.Logger.success = log_success  # type: ignore

# Apply colors if outputting to a TTY (like Termux)
if sys.stdout.isatty():
    logging.addLevelName(logging.DEBUG, f"{Fore.CYAN}{Style.DIM}{logging.getLevelName(logging.DEBUG)}{Style.RESET_ALL}")  # Dim Cyan for Debug
    logging.addLevelName(logging.INFO, f"{Fore.BLUE}{logging.getLevelName(logging.INFO)}{Style.RESET_ALL}")  # Blue for Info
    logging.addLevelName(SUCCESS_LEVEL, f"{Fore.MAGENTA}{Style.BRIGHT}{logging.getLevelName(SUCCESS_LEVEL)}{Style.RESET_ALL}")  # Bright Magenta for Success
    logging.addLevelName(logging.WARNING, f"{Fore.YELLOW}{Style.BRIGHT}{logging.getLevelName(logging.WARNING)}{Style.RESET_ALL}")  # Bright Yellow for Warning
    logging.addLevelName(logging.ERROR, f"{Fore.RED}{Style.BRIGHT}{logging.getLevelName(logging.ERROR)}{Style.RESET_ALL}")  # Bright Red for Error
    logging.addLevelName(logging.CRITICAL, f"{Back.RED}{Fore.WHITE}{Style.BRIGHT}{logging.getLevelName(logging.CRITICAL)}{Style.RESET_ALL}")  # White on Red for Critical

# --- Global Objects - Instantiated Arcana ---
try:
    CONFIG = Config()  # Forge the configuration object
except ValueError:
    # Error already logged within Config init or _get_env
    sys.exit(1)


# --- Helper Functions - Minor Cantrips ---
def safe_decimal_conversion(value: Any, default: Decimal = Decimal("0.0")) -> Decimal:
    """Safely converts a value to Decimal, returning default if conversion fails."""
    try:
        return Decimal(str(value)) if value is not None else default
    except (InvalidOperation, TypeError, ValueError):
        logger.warning(f"Could not convert '{value}' to Decimal, using default {default}")
        return default


def format_order_id(order_id: str | int | None) -> str:
    """Returns the last 6 characters of an order ID or 'N/A' for brevity."""
    return str(order_id)[-6:] if order_id else "N/A"


# --- Precision Formatting - Shaping the Numbers ---
def format_price(exchange: ccxt.Exchange, symbol: str, price: float | Decimal) -> str:
    """Formats price according to market precision rules, guided by the exchange spirits."""
    try:
        # CCXT formatting methods often expect float input
        return exchange.price_to_precision(symbol, float(price))
    except Exception as e:
        logger.error(f"{Fore.RED}Error shaping price {price} for {symbol}: {e}{Style.RESET_ALL}")
        return str(Decimal(str(price)).normalize())  # Fallback to Decimal string representation


def format_amount(exchange: ccxt.Exchange, symbol: str, amount: float | Decimal) -> str:
    """Formats amount according to market precision rules, guided by the exchange spirits."""
    try:
        # CCXT formatting methods often expect float input
        return exchange.amount_to_precision(symbol, float(amount))
    except Exception as e:
        logger.error(f"{Fore.RED}Error shaping amount {amount} for {symbol}: {e}{Style.RESET_ALL}")
        return str(Decimal(str(amount)).normalize())  # Fallback to Decimal string representation


# --- Termux SMS Alert Function - Sending Whispers ---
_termux_sms_command_exists: bool | None = None  # Cache check result


def send_sms_alert(message: str) -> bool:
    """Sends an SMS alert using Termux API, a whisper through the digital veil."""
    global _termux_sms_command_exists

    if not CONFIG.enable_sms_alerts:
        logger.debug("SMS alerts disabled by configuration.")
        return False

    # Check for command existence only once
    if _termux_sms_command_exists is None:
        _termux_sms_command_exists = shutil.which('termux-sms-send') is not None
        if not _termux_sms_command_exists:
             logger.warning(f"{Fore.YELLOW}SMS failed: 'termux-sms-send' command not found. Ensure Termux:API is installed (`pkg install termux-api`) and configured.{Style.RESET_ALL}")

    if not _termux_sms_command_exists:
        return False  # Don't proceed if command is missing

    if not CONFIG.sms_recipient_number:
        logger.warning(f"{Fore.YELLOW}SMS alerts enabled, but SMS_RECIPIENT_NUMBER rune is missing.{Style.RESET_ALL}")
        return False

    try:
        # Prepare the command spell
        command: list[str] = ['termux-sms-send', '-n', CONFIG.sms_recipient_number, message]
        logger.info(f"{Fore.MAGENTA}Dispatching SMS whisper to {CONFIG.sms_recipient_number} (Timeout: {CONFIG.sms_timeout_seconds}s)...{Style.RESET_ALL}")
        # Execute the spell via subprocess
        result = subprocess.run(command, capture_output=True, text=True, check=False, timeout=CONFIG.sms_timeout_seconds)
        if result.returncode == 0:
            logger.success(f"{Fore.MAGENTA}SMS whisper dispatched successfully.{Style.RESET_ALL}")
            return True
        else:
            logger.error(f"{Fore.RED}SMS whisper failed. RC: {result.returncode}, Stderr: {result.stderr.strip()}{Style.RESET_ALL}")
            return False
    except FileNotFoundError:
        # This shouldn't happen due to the check above, but handle defensively
        logger.error(f"{Fore.RED}SMS failed: 'termux-sms-send' vanished unexpectedly?{Style.RESET_ALL}")
        _termux_sms_command_exists = False  # Update cache
        return False
    except subprocess.TimeoutExpired:
        logger.error(f"{Fore.RED}SMS failed: Command timed out after {CONFIG.sms_timeout_seconds}s.{Style.RESET_ALL}")
        return False
    except Exception as e:
        logger.error(f"{Fore.RED}SMS failed: Unexpected disturbance: {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())
        return False


# --- Exchange Initialization - Opening the Portal ---
def initialize_exchange() -> ccxt.Exchange | None:
    """Initializes and returns the CCXT Bybit exchange instance, opening a portal."""
    logger.info(f"{Fore.BLUE}Opening portal to Bybit via CCXT...{Style.RESET_ALL}")
    if not CONFIG.api_key or not CONFIG.api_secret:
        logger.critical(f"{Back.RED}{Fore.WHITE}CRITICAL: API Key/Secret runes missing. Cannot open portal.{Style.RESET_ALL}")
        send_sms_alert("[ScalpBot] CRITICAL: API keys missing. Spell failed.")
        return None
    try:
        # Forging the connection
        exchange = ccxt.bybit({
            "apiKey": CONFIG.api_key,
            "secret": CONFIG.api_secret,
            "enableRateLimit": True,  # Respect the exchange spirits' limits
            "options": {
                "defaultType": "linear",  # Assuming USDT perpetuals
                "recvWindow": CONFIG.default_recv_window,
                "adjustForTimeDifference": True,  # Sync with exchange time
            },
        })
        logger.debug("Loading market structures...")
        exchange.load_markets(True)  # Force reload for fresh data
        logger.debug("Checking initial balance...")
        exchange.fetch_balance()  # Initial check for authentication success
        logger.success(f"{Fore.GREEN}{Style.BRIGHT}Portal to Bybit Opened (LIVE SCALPING MODE - EXTREME CAUTION!).{Style.RESET_ALL}")
        send_sms_alert(f"[ScalpBot/{CONFIG.strategy_name}] Portal opened & authenticated.")  # Added strategy name
        return exchange
    except ccxt.AuthenticationError as e:
        logger.critical(f"{Back.RED}{Fore.WHITE}Authentication failed: {e}. Check keys/IP/permissions.{Style.RESET_ALL}")
        send_sms_alert(f"[ScalpBot] CRITICAL: Authentication FAILED: {e}. Spell failed.")
    except ccxt.NetworkError as e:
        logger.critical(f"{Back.RED}{Fore.WHITE}Network disturbance during portal opening: {e}. Check connection/Bybit status.{Style.RESET_ALL}")
        send_sms_alert(f"[ScalpBot] CRITICAL: Network Error on Init: {e}. Spell failed.")
    except ccxt.ExchangeError as e:
        logger.critical(f"{Back.RED}{Fore.WHITE}Exchange spirit rejected portal opening: {e}. Check Bybit status/API docs.{Style.RESET_ALL}")
        send_sms_alert(f"[ScalpBot] CRITICAL: Exchange Error on Init: {e}. Spell failed.")
    except Exception as e:
        logger.critical(f"{Back.RED}{Fore.WHITE}Unexpected chaos during portal opening: {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())
        send_sms_alert(f"[ScalpBot] CRITICAL: Unexpected Init Error: {type(e).__name__}. Spell failed.")
    return None


# --- Indicator Calculation Functions - Scrying the Market ---
# (Indicator functions remain largely the same as v2.1, focusing on clarity and Decimal usage)
def calculate_supertrend(df: pd.DataFrame, length: int, multiplier: Decimal, prefix: str = "") -> pd.DataFrame:
    """Calculates the Supertrend indicator using pandas_ta, returning Decimal where applicable."""
    col_prefix = f"{prefix}" if prefix else ""
    target_cols = [f"{col_prefix}supertrend", f"{col_prefix}trend", f"{col_prefix}st_long", f"{col_prefix}st_short"]
    st_col = f"SUPERT_{length}_{float(multiplier)}"  # pandas_ta uses float in name
    st_trend_col = f"SUPERTd_{length}_{float(multiplier)}"
    st_long_col = f"SUPERTl_{length}_{float(multiplier)}"
    st_short_col = f"SUPERTs_{length}_{float(multiplier)}"
    required_input_cols = ["high", "low", "close"]

    if df is None or df.empty or not all(c in df.columns for c in required_input_cols) or len(df) < length + 1:
        logger.warning(f"{Fore.YELLOW}Scrying ({col_prefix}ST): Insufficient data (Len: {len(df) if df is not None else 0}, Need: {length + 1}).{Style.RESET_ALL}")
        for col in target_cols: df[col] = pd.NA
        return df

    try:
        # pandas_ta expects float multiplier
        logger.debug(f"Scrying ({col_prefix}ST): Calculating with length={length}, multiplier={float(multiplier)}")
        df.ta.supertrend(length=length, multiplier=float(multiplier), append=True)
        if st_col not in df.columns or st_trend_col not in df.columns:
            raise KeyError(f"pandas_ta failed to create expected raw columns: {st_col}, {st_trend_col}")

        # Convert Supertrend value to Decimal, interpret trend
        df[f"{col_prefix}supertrend"] = df[st_col].apply(safe_decimal_conversion)
        df[f"{col_prefix}trend"] = df[st_trend_col] == 1  # Boolean: True for Uptrend (1), False for Downtrend (-1)
        prev_trend = df[st_trend_col].shift(1)
        df[f"{col_prefix}st_long"] = (prev_trend == -1) & (df[st_trend_col] == 1)  # Boolean: Trend flipped to Long
        df[f"{col_prefix}st_short"] = (prev_trend == 1) & (df[st_trend_col] == -1)  # Boolean: Trend flipped to Short

        # Clean up raw columns from pandas_ta
        raw_st_cols = [st_col, st_trend_col, st_long_col, st_short_col]
        df.drop(columns=raw_st_cols, errors='ignore', inplace=True)

        # Log the latest reading
        last_st_val = df[f'{col_prefix}supertrend'].iloc[-1]
        if pd.notna(last_st_val):
            last_trend = 'Up' if df[f'{col_prefix}trend'].iloc[-1] else 'Down'
            signal = 'LONG FLIP' if df[f'{col_prefix}st_long'].iloc[-1] else ('SHORT FLIP' if df[f'{col_prefix}st_short'].iloc[-1] else 'Hold')
            logger.debug(f"Scrying ({col_prefix}ST({length},{multiplier})): Trend={Fore.GREEN if last_trend == 'Up' else Fore.RED}{last_trend}{Style.RESET_ALL}, Val={last_st_val:.4f}, Signal={signal}")
        else:
            logger.debug(f"Scrying ({col_prefix}ST({length},{multiplier})): Resulted in NA for last candle.")

    except Exception as e:
        logger.error(f"{Fore.RED}Scrying ({col_prefix}ST): Error during calculation: {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())
        for col in target_cols: df[col] = pd.NA  # Nullify results on error
    return df


def analyze_volume_atr(df: pd.DataFrame, atr_len: int, vol_ma_len: int) -> dict[str, Decimal | None]:
    """Calculates ATR, Volume MA, checks spikes. Returns Decimals representing volatility and energy."""
    results: dict[str, Decimal | None] = {"atr": None, "volume_ma": None, "last_volume": None, "volume_ratio": None}
    required_cols = ["high", "low", "close", "volume"]
    min_len = max(atr_len, vol_ma_len) + 1  # Need at least period+1

    if df is None or df.empty or not all(c in df.columns for c in required_cols) or len(df) < min_len:
        logger.warning(f"{Fore.YELLOW}Scrying (Vol/ATR): Insufficient data (Len: {len(df) if df is not None else 0}, Need: {min_len}).{Style.RESET_ALL}")
        return results

    try:
        # Calculate ATR (Average True Range) - Measure of volatility
        logger.debug(f"Scrying (ATR): Calculating with length={atr_len}")
        atr_col = f"ATRr_{atr_len}"
        df.ta.atr(length=atr_len, append=True)
        if atr_col in df.columns:
            last_atr = df[atr_col].iloc[-1]
            if pd.notna(last_atr): results["atr"] = safe_decimal_conversion(last_atr)
            df.drop(columns=[atr_col], errors='ignore', inplace=True)  # Clean up raw column

        # Calculate Volume Moving Average and Ratio - Measure of market energy
        logger.debug(f"Scrying (Volume): Calculating MA with length={vol_ma_len}")
        volume_ma_col = 'volume_ma'
        df[volume_ma_col] = df['volume'].rolling(window=vol_ma_len, min_periods=max(1, vol_ma_len // 2)).mean()
        last_vol_ma = df[volume_ma_col].iloc[-1]
        last_vol = df['volume'].iloc[-1]

        if pd.notna(last_vol_ma): results["volume_ma"] = safe_decimal_conversion(last_vol_ma)
        if pd.notna(last_vol): results["last_volume"] = safe_decimal_conversion(last_vol)

        # Calculate Volume Ratio (Last Volume / Volume MA)
        if results["volume_ma"] is not None and results["volume_ma"] > CONFIG.position_qty_epsilon and results["last_volume"] is not None:
            try:
                results["volume_ratio"] = results["last_volume"] / results["volume_ma"]
            except Exception:  # Handles potential division by zero if MA is epsilon
                 results["volume_ratio"] = None
        else:
            results["volume_ratio"] = None  # Cannot calculate ratio

        if volume_ma_col in df.columns: df.drop(columns=[volume_ma_col], errors='ignore', inplace=True)  # Clean up MA column

        # Log results
        atr_str = f"{results['atr']:.5f}" if results['atr'] else 'N/A'
        vol_ma_str = f"{results['volume_ma']:.2f}" if results['volume_ma'] else 'N/A'
        vol_ratio_str = f"{results['volume_ratio']:.2f}" if results['volume_ratio'] else 'N/A'
        logger.debug(f"Scrying Results: ATR({atr_len})={Fore.CYAN}{atr_str}{Style.RESET_ALL}, VolMA({vol_ma_len})={vol_ma_str}, VolRatio={Fore.YELLOW}{vol_ratio_str}{Style.RESET_ALL}")

    except Exception as e:
        logger.error(f"{Fore.RED}Scrying (Vol/ATR): Error during calculation: {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())
        results = dict.fromkeys(results)  # Nullify results on error
    return results


def calculate_stochrsi_momentum(df: pd.DataFrame, rsi_len: int, stoch_len: int, k: int, d: int, mom_len: int) -> pd.DataFrame:
    """Calculates StochRSI and Momentum, gauging overbought/oversold and trend strength."""
    target_cols = ['stochrsi_k', 'stochrsi_d', 'momentum']
    min_len = max(rsi_len + stoch_len, mom_len) + 5  # Add buffer for calculation stability
    if df is None or df.empty or not all(c in df.columns for c in ["close"]) or len(df) < min_len:
        logger.warning(f"{Fore.YELLOW}Scrying (StochRSI/Mom): Insufficient data (Len: {len(df) if df is not None else 0}, Need ~{min_len}).{Style.RESET_ALL}")
        for col in target_cols: df[col] = pd.NA
        return df
    try:
        # Calculate StochRSI
        logger.debug(f"Scrying (StochRSI): Calculating with RSI={rsi_len}, Stoch={stoch_len}, K={k}, D={d}")
        stochrsi_df = df.ta.stochrsi(length=stoch_len, rsi_length=rsi_len, k=k, d=d, append=False)  # Calculate separately
        k_col, d_col = f"STOCHRSIk_{stoch_len}_{rsi_len}_{k}_{d}", f"STOCHRSId_{stoch_len}_{rsi_len}_{k}_{d}"
        if k_col in stochrsi_df.columns: df['stochrsi_k'] = stochrsi_df[k_col].apply(safe_decimal_conversion)
        else: logger.warning("StochRSI K column not found after calculation"); df['stochrsi_k'] = pd.NA
        if d_col in stochrsi_df.columns: df['stochrsi_d'] = stochrsi_df[d_col].apply(safe_decimal_conversion)
        else: logger.warning("StochRSI D column not found after calculation"); df['stochrsi_d'] = pd.NA

        # Calculate Momentum
        logger.debug(f"Scrying (Momentum): Calculating with length={mom_len}")
        mom_col = f"MOM_{mom_len}"
        df.ta.mom(length=mom_len, append=True)
        if mom_col in df.columns:
            df['momentum'] = df[mom_col].apply(safe_decimal_conversion)
            df.drop(columns=[mom_col], errors='ignore', inplace=True)  # Clean up raw column
        else: logger.warning("Momentum column not found after calculation"); df['momentum'] = pd.NA

        # Log latest values
        k_val, d_val, mom_val = df['stochrsi_k'].iloc[-1], df['stochrsi_d'].iloc[-1], df['momentum'].iloc[-1]
        if pd.notna(k_val) and pd.notna(d_val) and pd.notna(mom_val):
            k_color = Fore.RED if k_val > CONFIG.stochrsi_overbought else (Fore.GREEN if k_val < CONFIG.stochrsi_oversold else Fore.CYAN)
            d_color = Fore.RED if d_val > CONFIG.stochrsi_overbought else (Fore.GREEN if d_val < CONFIG.stochrsi_oversold else Fore.CYAN)
            mom_color = Fore.GREEN if mom_val > 0 else (Fore.RED if mom_val < 0 else Fore.WHITE)
            logger.debug(f"Scrying (StochRSI/Mom): K={k_color}{k_val:.2f}{Style.RESET_ALL}, D={d_color}{d_val:.2f}{Style.RESET_ALL}, Mom={mom_color}{mom_val:.4f}{Style.RESET_ALL}")
        else:
            logger.debug("Scrying (StochRSI/Mom): Resulted in NA for last candle.")

    except Exception as e:
        logger.error(f"{Fore.RED}Scrying (StochRSI/Mom): Error during calculation: {e}{Style.RESET_ALL}"); logger.debug(traceback.format_exc())
        for col in target_cols: df[col] = pd.NA  # Nullify results on error
    return df


def calculate_ehlers_fisher(df: pd.DataFrame, length: int, signal: int) -> pd.DataFrame:
    """Calculates Ehlers Fisher Transform, seeking cyclical turning points."""
    target_cols = ['ehlers_fisher', 'ehlers_signal']
    if df is None or df.empty or not all(c in df.columns for c in ["high", "low"]) or len(df) < length + 1:
        logger.warning(f"{Fore.YELLOW}Scrying (EhlersFisher): Insufficient data (Len: {len(df) if df is not None else 0}, Need {length + 1}).{Style.RESET_ALL}")
        for col in target_cols: df[col] = pd.NA
        return df
    try:
        logger.debug(f"Scrying (EhlersFisher): Calculating with length={length}, signal={signal}")
        fisher_df = df.ta.fisher(length=length, signal=signal, append=False)  # Calculate separately
        fish_col, signal_col = f"FISHERT_{length}_{signal}", f"FISHERTs_{length}_{signal}"
        if fish_col in fisher_df.columns: df['ehlers_fisher'] = fisher_df[fish_col].apply(safe_decimal_conversion)
        else: logger.warning("Ehlers Fisher column not found after calculation"); df['ehlers_fisher'] = pd.NA
        if signal_col in fisher_df.columns: df['ehlers_signal'] = fisher_df[signal_col].apply(safe_decimal_conversion)
        else: logger.warning("Ehlers Signal column not found after calculation"); df['ehlers_signal'] = pd.NA

        # Log latest values
        fish_val, sig_val = df['ehlers_fisher'].iloc[-1], df['ehlers_signal'].iloc[-1]
        if pd.notna(fish_val) and pd.notna(sig_val):
             logger.debug(f"Scrying (EhlersFisher({length},{signal})): Fisher={Fore.CYAN}{fish_val:.4f}{Style.RESET_ALL}, Signal={Fore.MAGENTA}{sig_val:.4f}{Style.RESET_ALL}")
        else:
             logger.debug("Scrying (EhlersFisher): Resulted in NA for last candle.")
    except Exception as e:
        logger.error(f"{Fore.RED}Scrying (EhlersFisher): Error during calculation: {e}{Style.RESET_ALL}"); logger.debug(traceback.format_exc())
        for col in target_cols: df[col] = pd.NA  # Nullify results on error
    return df


def calculate_ehlers_ma(df: pd.DataFrame, fast_len: int, slow_len: int) -> pd.DataFrame:
    """Calculates Ehlers Super Smoother Moving Averages (Placeholder: Uses EMA)."""
    target_cols = ['fast_ema', 'slow_ema']
    min_len = max(fast_len, slow_len) + 5  # Add buffer for calculation stability
    if df is None or df.empty or not all(c in df.columns for c in ["close"]) or len(df) < min_len:
        logger.warning(f"{Fore.YELLOW}Scrying (EhlersMA): Insufficient data (Len: {len(df) if df is not None else 0}, Need ~{min_len}).{Style.RESET_ALL}")
        for col in target_cols: df[col] = pd.NA
        return df
    try:
        # *** PYRMETHUS NOTE: Using standard EMA as a placeholder. ***
        # The true Ehlers Super Smoother involves a more complex filter.
        # If `pandas_ta.supersmoother` exists and is reliable, use it. Otherwise, implement the filter manually
        # or accept EMA as an approximation for this strategy path.
        logger.warning(f"{Fore.YELLOW}{Style.DIM}Scrying (EhlersMA): Using EMA as placeholder for Ehlers Super Smoother. Verify suitability.{Style.RESET_ALL}")
        logger.debug(f"Scrying (EhlersMA - EMA Placeholder): Calculating Fast EMA({fast_len}), Slow EMA({slow_len})")
        df['fast_ema'] = df.ta.ema(length=fast_len).apply(safe_decimal_conversion)
        df['slow_ema'] = df.ta.ema(length=slow_len).apply(safe_decimal_conversion)

        # Log latest values
        fast_val, slow_val = df['fast_ema'].iloc[-1], df['slow_ema'].iloc[-1]
        if pd.notna(fast_val) and pd.notna(slow_val):
            logger.debug(f"Scrying (EhlersMA({fast_len},{slow_len})): Fast={Fore.GREEN}{fast_val:.4f}{Style.RESET_ALL}, Slow={Fore.RED}{slow_val:.4f}{Style.RESET_ALL}")
        else:
             logger.debug("Scrying (EhlersMA): Resulted in NA for last candle.")
    except Exception as e:
        logger.error(f"{Fore.RED}Scrying (EhlersMA): Error during calculation: {e}{Style.RESET_ALL}"); logger.debug(traceback.format_exc())
        for col in target_cols: df[col] = pd.NA  # Nullify results on error
    return df


def analyze_order_book(exchange: ccxt.Exchange, symbol: str, depth: int, fetch_limit: int) -> dict[str, Decimal | None]:
    """Fetches and analyzes L2 order book pressure and spread, peering into market intent."""
    results: dict[str, Decimal | None] = {"bid_ask_ratio": None, "spread": None, "best_bid": None, "best_ask": None}
    logger.debug(f"Order Book Scrying: Fetching L2 {symbol} (Depth:{depth}, Limit:{fetch_limit})...")
    if not exchange.has.get('fetchL2OrderBook'):
        logger.warning(f"{Fore.YELLOW}Order Book Scrying: fetchL2OrderBook not supported by {exchange.id}. Cannot peer into depth.{Style.RESET_ALL}")
        return results
    try:
        # Fetching the order book's current state
        order_book = exchange.fetch_l2_order_book(symbol, limit=fetch_limit)
        bids: list[list[float | str]] = order_book.get('bids', [])
        asks: list[list[float | str]] = order_book.get('asks', [])

        # Extract best bid/ask with Decimal precision
        best_bid = safe_decimal_conversion(bids[0][0]) if bids and len(bids[0]) > 0 else None
        best_ask = safe_decimal_conversion(asks[0][0]) if asks and len(asks[0]) > 0 else None
        results["best_bid"] = best_bid
        results["best_ask"] = best_ask

        # Calculate spread
        if best_bid is not None and best_ask is not None and best_bid > 0 and best_ask > 0:
            results["spread"] = best_ask - best_bid
            logger.debug(f"OB Scrying: Best Bid={Fore.GREEN}{best_bid:.4f}{Style.RESET_ALL}, Ask={Fore.RED}{best_ask:.4f}{Style.RESET_ALL}, Spread={Fore.YELLOW}{results['spread']:.4f}{Style.RESET_ALL}")
        else:
            logger.debug(f"OB Scrying: Bid={best_bid or 'N/A'}, Ask={best_ask or 'N/A'} (Spread N/A)")

        # Sum volumes within the specified depth using Decimal
        bid_vol = sum(safe_decimal_conversion(bid[1]) for bid in bids[:depth] if len(bid) > 1)
        ask_vol = sum(safe_decimal_conversion(ask[1]) for ask in asks[:depth] if len(ask) > 1)
        logger.debug(f"OB Scrying (Depth {depth}): BidVol={Fore.GREEN}{bid_vol:.4f}{Style.RESET_ALL}, AskVol={Fore.RED}{ask_vol:.4f}{Style.RESET_ALL}")

        # Calculate Bid/Ask Volume Ratio
        if ask_vol > CONFIG.position_qty_epsilon:
            try:
                results["bid_ask_ratio"] = bid_vol / ask_vol
                ratio_color = Fore.GREEN if results["bid_ask_ratio"] >= CONFIG.order_book_ratio_threshold_long else (Fore.RED if results["bid_ask_ratio"] <= CONFIG.order_book_ratio_threshold_short else Fore.YELLOW)
                logger.debug(f"OB Scrying Ratio: {ratio_color}{results['bid_ask_ratio']:.3f}{Style.RESET_ALL}")
            except Exception as e:
                logger.warning(f"Error calculating OB ratio: {e}")
                results["bid_ask_ratio"] = None
        else:
            logger.debug("OB Scrying Ratio: N/A (Ask volume zero or negligible)")

    except (ccxt.NetworkError, ccxt.ExchangeError, IndexError, Exception) as e:
        logger.warning(f"{Fore.YELLOW}Order Book Scrying Error for {symbol}: {type(e).__name__} - {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())
        results = dict.fromkeys(results)  # Reset on error
    return results


# --- Data Fetching - Gathering Etheric Data Streams ---
def get_market_data(exchange: ccxt.Exchange, symbol: str, interval: str, limit: int) -> pd.DataFrame | None:
    """Fetches and prepares OHLCV data, ensuring numeric types and handling gaps."""
    if not exchange.has.get("fetchOHLCV"):
        logger.error(f"{Fore.RED}Data Fetch: Exchange '{exchange.id}' does not support fetchOHLCV.{Style.RESET_ALL}")
        return None
    try:
        logger.debug(f"Data Fetch: Gathering {limit} OHLCV candles for {symbol} ({interval})...")
        # Channeling the data stream
        ohlcv: list[list[int | float | str]] = exchange.fetch_ohlcv(symbol, timeframe=interval, limit=limit)
        if not ohlcv:
            logger.warning(f"{Fore.YELLOW}Data Fetch: No OHLCV data returned for {symbol} ({interval}). Market asleep?{Style.RESET_ALL}")
            return None

        # Weaving data into a DataFrame structure
        df = pd.DataFrame(ohlcv, columns=["timestamp", "open", "high", "low", "close", "volume"])
        df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms", utc=True)  # Time magic
        df.set_index("timestamp", inplace=True)

        # Convert to numeric, coercing errors, check NaNs robustly
        for col in ["open", "high", "low", "close", "volume"]:
            df[col] = pd.to_numeric(df[col], errors='coerce')  # Ensure numeric essence

        # Check for and handle gaps (NaNs)
        if df.isnull().values.any():
            nan_counts = df.isnull().sum()
            logger.warning(f"{Fore.YELLOW}Data Fetch: OHLCV contains gaps (NaNs) after conversion:\n{nan_counts[nan_counts > 0]}\nAttempting forward fill...{Style.RESET_ALL}")
            df.ffill(inplace=True)  # Attempt to fill gaps with previous values
            if df.isnull().values.any():  # Check again
                logger.warning(f"{Fore.YELLOW}Gaps remain after ffill, attempting backward fill...{Style.RESET_ALL}")
                df.bfill(inplace=True)  # Attempt to fill remaining gaps with next values
                if df.isnull().values.any():
                    logger.error(f"{Fore.RED}Data Fetch: Gaps persist after ffill/bfill. Cannot proceed with unreliable data.{Style.RESET_ALL}")
                    return None  # Cannot proceed if gaps remain at start/end

        logger.debug(f"Data Fetch: Woven {len(df)} OHLCV candles for {symbol}.")
        return df

    except (ccxt.NetworkError, ccxt.ExchangeError, Exception) as e:
        logger.warning(f"{Fore.YELLOW}Data Fetch: Disturbance gathering OHLCV for {symbol}: {type(e).__name__} - {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())
    return None


# --- Position & Order Management - Manipulating Market Presence ---
def get_current_position(exchange: ccxt.Exchange, symbol: str) -> dict[str, Any]:
    """Fetches current position details (Bybit V5 focus), returns Decimals representing market presence."""
    default_pos: dict[str, Any] = {'side': CONFIG.pos_none, 'qty': Decimal("0.0"), 'entry_price': Decimal("0.0")}
    market_id = None
    market = None
    try:
        # Identify the market structure
        market = exchange.market(symbol)
        market_id = market['id']  # The exchange's name for the symbol
    except Exception as e:
        logger.error(f"{Fore.RED}Position Check: Failed to identify market structure for '{symbol}': {e}{Style.RESET_ALL}")
        return default_pos

    try:
        if not exchange.has.get('fetchPositions'):
            logger.warning(f"{Fore.YELLOW}Position Check: fetchPositions spell not available for {exchange.id}.{Style.RESET_ALL}")
            return default_pos

        # Bybit V5 requires 'category' parameter (linear/inverse)
        params = {'category': 'linear'} if market.get('linear') else ({'category': 'inverse'} if market.get('inverse') else {})
        logger.debug(f"Position Check: Querying positions for {symbol} (MarketID: {market_id}) with params: {params}")

        # Summon position data from the exchange
        fetched_positions = exchange.fetch_positions(symbols=[symbol], params=params)

        # Bybit V5 might return multiple entries; find the active one for One-Way mode (positionIdx=0)
        active_pos = None
        for pos in fetched_positions:
            pos_info = pos.get('info', {})
            pos_market_id = pos_info.get('symbol')
            position_idx = pos_info.get('positionIdx', -1)  # Use -1 default to catch issues
            pos_side_v5 = pos_info.get('side', 'None')  # 'Buy' for long, 'Sell' for short, 'None' if flat
            size_str = pos_info.get('size')

            # Filter for the correct symbol and One-Way mode active position
            if pos_market_id == market_id and position_idx == 0 and pos_side_v5 != 'None':
                size = safe_decimal_conversion(size_str)
                if abs(size) > CONFIG.position_qty_epsilon:  # Check if size is non-negligible
                    active_pos = pos  # Found the active position
                    logger.debug(f"Found potential active position entry: {pos_info}")
                    break  # Assume only one active position in One-Way mode

        if active_pos:
            try:
                # Parse details from the active position info
                size = safe_decimal_conversion(active_pos.get('info', {}).get('size'))
                # Use 'avgPrice' from info for V5 entry price
                entry_price = safe_decimal_conversion(active_pos.get('info', {}).get('avgPrice'))
                # Determine side based on V5 'side' field ('Buy' or 'Sell')
                side = CONFIG.pos_long if active_pos.get('info', {}).get('side') == 'Buy' else CONFIG.pos_short

                pos_color = Fore.GREEN if side == CONFIG.pos_long else Fore.RED
                logger.info(f"{pos_color}Position Check: Found ACTIVE {side} position: Qty={abs(size):.8f} @ Entry={entry_price:.4f}{Style.RESET_ALL}")
                return {'side': side, 'qty': abs(size), 'entry_price': entry_price}
            except Exception as parse_err:
                 logger.warning(f"{Fore.YELLOW}Position Check: Error parsing active position data: {parse_err}. Data: {active_pos}{Style.RESET_ALL}")
                 return default_pos  # Return default on parsing error
        else:
            logger.info(f"{Fore.BLUE}Position Check: No active One-Way position found for {market_id}. Currently Flat.{Style.RESET_ALL}")
            return default_pos

    except (ccxt.NetworkError, ccxt.ExchangeError, Exception) as e:
        logger.warning(f"{Fore.YELLOW}Position Check: Disturbance querying positions for {symbol}: {type(e).__name__} - {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())
    return default_pos  # Return default on API error


def set_leverage(exchange: ccxt.Exchange, symbol: str, leverage: int) -> bool:
    """Sets leverage for a futures symbol (Bybit V5 focus), adjusting the power multiplier."""
    logger.info(f"{Fore.CYAN}Leverage Conjuring: Attempting to set {leverage}x for {symbol}...{Style.RESET_ALL}")
    try:
        # Verify it's a contract market where leverage applies
        market = exchange.market(symbol)
        if not market.get('contract'):
            logger.error(f"{Fore.RED}Leverage Conjuring: Cannot set leverage for non-contract market: {symbol}.{Style.RESET_ALL}")
            return False
    except Exception as e:
         logger.error(f"{Fore.RED}Leverage Conjuring: Failed to identify market structure for '{symbol}': {e}{Style.RESET_ALL}")
         return False

    for attempt in range(CONFIG.retry_count):
        try:
            # Bybit V5 requires setting buy and sell leverage separately
            params = {'buyLeverage': str(leverage), 'sellLeverage': str(leverage)}
            response = exchange.set_leverage(leverage=leverage, symbol=symbol, params=params)
            logger.success(f"{Fore.GREEN}Leverage Conjuring: Set to {leverage}x for {symbol}. Response: {response}{Style.RESET_ALL}")
            return True
        except ccxt.ExchangeError as e:
            # Check for common "already set" or "no modification needed" messages
            err_str = str(e).lower()
            if "leverage not modified" in err_str or "same as requested" in err_str or "same leverage" in err_str:
                logger.info(f"{Fore.CYAN}Leverage Conjuring: Already set to {leverage}x for {symbol}.{Style.RESET_ALL}")
                return True
            logger.warning(f"{Fore.YELLOW}Leverage Conjuring: Exchange resistance (Attempt {attempt + 1}/{CONFIG.retry_count}): {e}{Style.RESET_ALL}")
            if attempt < CONFIG.retry_count - 1: time.sleep(CONFIG.retry_delay_seconds)
            else: logger.error(f"{Fore.RED}Leverage Conjuring: Failed after {CONFIG.retry_count} attempts.{Style.RESET_ALL}")
        except (ccxt.NetworkError, Exception) as e:
            logger.warning(f"{Fore.YELLOW}Leverage Conjuring: Network/Other disturbance (Attempt {attempt + 1}/{CONFIG.retry_count}): {e}{Style.RESET_ALL}")
            if attempt < CONFIG.retry_count - 1: time.sleep(CONFIG.retry_delay_seconds)
            else: logger.error(f"{Fore.RED}Leverage Conjuring: Failed after {CONFIG.retry_count} attempts.{Style.RESET_ALL}")
    return False  # Failed after retries


def close_position(exchange: ccxt.Exchange, symbol: str, position_to_close: dict[str, Any], reason: str = "Signal") -> dict[str, Any] | None:
    """Closes the specified active position with re-validation, banishing market presence."""
    initial_side = position_to_close.get('side', CONFIG.pos_none)
    initial_qty = position_to_close.get('qty', Decimal("0.0"))
    market_base = symbol.split('/')[0]  # For concise alerts
    logger.info(f"{Fore.YELLOW}Banish Position: Initiated for {symbol}. Reason: {reason}. Initial state: {initial_side} Qty={initial_qty:.8f}{Style.RESET_ALL}")

    # Re-validate the position just before closing - ensure it still exists
    live_position = get_current_position(exchange, symbol)
    if live_position['side'] == CONFIG.pos_none:
        logger.warning(f"{Fore.YELLOW}Banish Position: Re-validation shows NO active position for {symbol}. Aborting banishment.{Style.RESET_ALL}")
        if initial_side != CONFIG.pos_none: logger.warning(f"{Fore.YELLOW}Banish Position: Discrepancy detected (was {initial_side}, now None).{Style.RESET_ALL}")
        return None  # Nothing to close

    live_amount_to_close = live_position['qty']
    live_position_side = live_position['side']
    # Determine the opposite side needed to close the position
    side_to_execute_close = CONFIG.side_sell if live_position_side == CONFIG.pos_long else CONFIG.side_buy

    try:
        # Format amount according to market rules
        amount_str = format_amount(exchange, symbol, live_amount_to_close)
        amount_float = float(amount_str)  # CCXT create order often expects float

        # Check if the amount is negligible after formatting
        if amount_float <= float(CONFIG.position_qty_epsilon):
            logger.error(f"{Fore.RED}Banish Position: Closing amount negligible ({amount_str}) after precision shaping. Aborting.{Style.RESET_ALL}")
            return None

        # Execute the market close order with reduceOnly flag
        logger.warning(f"{Back.YELLOW}{Fore.BLACK}Banish Position: Attempting to CLOSE {live_position_side} ({reason}): "
                       f"Exec {side_to_execute_close.upper()} MARKET {amount_str} {symbol} (reduce_only=True)...{Style.RESET_ALL}")
        params = {'reduceOnly': True}  # Ensure this order only closes, not opens
        order = exchange.create_market_order(symbol=symbol, side=side_to_execute_close, amount=amount_float, params=params)

        # Parse order response safely using Decimal
        fill_price = safe_decimal_conversion(order.get('average'))
        filled_qty = safe_decimal_conversion(order.get('filled'))
        cost = safe_decimal_conversion(order.get('cost'))
        order_id_short = format_order_id(order.get('id'))

        close_color = Fore.GREEN if (live_position_side == CONFIG.pos_long and side_to_execute_close == CONFIG.side_sell) or \
                                     (live_position_side == CONFIG.pos_short and side_to_execute_close == CONFIG.side_buy) else Fore.YELLOW  # Should always be green if logic is right

        logger.success(f"{close_color}{Style.BRIGHT}Banish Position: Order ({reason}) placed for {symbol}. "
                       f"Filled: {filled_qty:.8f}/{amount_str}, AvgFill: {fill_price:.4f}, Cost: {cost:.2f} USDT. ID:...{order_id_short}{Style.RESET_ALL}")
        send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] BANISHED {live_position_side} {amount_str} @ ~{fill_price:.4f} ({reason}). ID:...{order_id_short}")
        return order  # Return the filled close order details

    except (ccxt.InsufficientFunds, ccxt.NetworkError, ccxt.ExchangeError, ValueError, Exception) as e:
        logger.error(f"{Fore.RED}Banish Position ({reason}): Failed for {symbol}: {type(e).__name__} - {e}{Style.RESET_ALL}")
        # Check for specific Bybit errors indicating already closed or zero position
        err_str = str(e).lower()
        if isinstance(e, ccxt.ExchangeError) and ("order would not reduce position size" in err_str or "position is zero" in err_str or "position size is zero" in err_str or "cannot be less than" in err_str):  # Added common size error
             logger.warning(f"{Fore.YELLOW}Banish Position: Exchange indicates position already closed/closing or zero size. Assuming banished.{Style.RESET_ALL}")
             return None  # Treat as success (or non-actionable) in this case
        send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] ERROR Banishing ({reason}): {type(e).__name__}. Check logs.")
    return None  # Failed to close


def calculate_position_size(equity: Decimal, risk_per_trade_pct: Decimal, entry_price: Decimal, stop_loss_price: Decimal,
                            leverage: int, symbol: str, exchange: ccxt.Exchange) -> tuple[Decimal | None, Decimal | None]:
    """Calculates position size and estimated margin based on risk, using Decimal precision."""
    logger.debug(f"Risk Calc: Equity={equity:.4f}, Risk%={risk_per_trade_pct:.4%}, Entry={entry_price:.4f}, SL={stop_loss_price:.4f}, Lev={leverage}x")
    # --- Input Validation ---
    if not (entry_price > 0 and stop_loss_price > 0):
        logger.error(f"{Fore.RED}Risk Calc: Invalid entry/SL price (<= 0).{Style.RESET_ALL}"); return None, None
    price_diff = abs(entry_price - stop_loss_price)
    if price_diff < CONFIG.position_qty_epsilon:
        logger.error(f"{Fore.RED}Risk Calc: Entry/SL prices too close ({price_diff:.8f}). Cannot calculate risk.{Style.RESET_ALL}"); return None, None
    if not 0 < risk_per_trade_pct < 1:
        logger.error(f"{Fore.RED}Risk Calc: Invalid risk percentage: {risk_per_trade_pct:.4%}. Must be between 0 and 1.{Style.RESET_ALL}"); return None, None
    if equity <= 0:
        logger.error(f"{Fore.RED}Risk Calc: Invalid equity: {equity:.4f}.{Style.RESET_ALL}"); return None, None
    if leverage <= 0:
        logger.error(f"{Fore.RED}Risk Calc: Invalid leverage: {leverage}.{Style.RESET_ALL}"); return None, None

    # --- Calculation ---
    risk_amount_usdt = equity * risk_per_trade_pct  # Max USDT amount to risk on this trade
    # Assuming linear contract where 1 unit = 1 base currency (e.g., 1 BTC)
    # Risk per unit of the asset = price_diff (difference between entry and stop loss)
    # Quantity = Total Risk Amount / Risk per Unit
    quantity_raw = risk_amount_usdt / price_diff

    # --- Apply Market Precision ---
    try:
        # Format according to market precision *then* convert back to Decimal
        quantity_precise_str = format_amount(exchange, symbol, quantity_raw)
        quantity_precise = Decimal(quantity_precise_str)
        logger.debug(f"Risk Calc: Raw Qty={quantity_raw:.8f}, Precise Qty={quantity_precise:.8f}")
    except Exception as e:
        logger.warning(f"{Fore.YELLOW}Risk Calc: Failed precision shaping for quantity {quantity_raw:.8f}. Using raw with fallback quantization. Error: {e}{Style.RESET_ALL}")
        # Fallback: Quantize to a reasonable number of decimal places if formatting fails
        quantity_precise = quantity_raw.quantize(Decimal('1e-8'), rounding=ROUND_HALF_UP)

    # --- Final Checks & Margin Estimation ---
    if quantity_precise <= CONFIG.position_qty_epsilon:
        logger.warning(f"{Fore.YELLOW}Risk Calc: Calculated quantity negligible ({quantity_precise:.8f}). RiskAmt={risk_amount_usdt:.4f}, PriceDiff={price_diff:.4f}{Style.RESET_ALL}")
        return None, None

    # Estimate position value and margin required
    pos_value_usdt = quantity_precise * entry_price
    required_margin = pos_value_usdt / Decimal(leverage)
    logger.debug(f"Risk Calc Result: Qty={Fore.CYAN}{quantity_precise:.8f}{Style.RESET_ALL}, EstValue={pos_value_usdt:.4f}, EstMargin={required_margin:.4f}")
    return quantity_precise, required_margin


def wait_for_order_fill(exchange: ccxt.Exchange, order_id: str, symbol: str, timeout_seconds: int) -> dict[str, Any] | None:
    """Waits for a specific order to be filled (status 'closed'), observing the order's fate."""
    start_time = time.time()
    order_id_short = format_order_id(order_id)
    logger.info(f"{Fore.CYAN}Observing order ...{order_id_short} ({symbol}) for fill (Timeout: {timeout_seconds}s)...{Style.RESET_ALL}")
    while time.time() - start_time < timeout_seconds:
        try:
            # Query the order's status
            order = exchange.fetch_order(order_id, symbol)
            status = order.get('status')
            logger.debug(f"Order ...{order_id_short} status: {status}")

            if status == 'closed':  # 'closed' usually means fully filled for market orders
                logger.success(f"{Fore.GREEN}Order ...{order_id_short} confirmed FILLED.{Style.RESET_ALL}")
                return order  # Success
            elif status in ['canceled', 'rejected', 'expired']:
                logger.error(f"{Fore.RED}Order ...{order_id_short} failed with status '{status}'.{Style.RESET_ALL}")
                return None  # Failed state
            # Continue polling if 'open', 'partially_filled', or None/unknown status

            time.sleep(0.5)  # Check every 500ms

        except ccxt.OrderNotFound:
            # This might happen briefly after placing, especially on busy exchanges. Keep trying.
            logger.warning(f"{Fore.YELLOW}Order ...{order_id_short} not found yet by exchange spirits. Retrying...{Style.RESET_ALL}")
            time.sleep(1)  # Wait a bit longer if not found initially
        except (ccxt.NetworkError, ccxt.ExchangeError, Exception) as e:
            logger.warning(f"{Fore.YELLOW}Disturbance checking order ...{order_id_short}: {type(e).__name__} - {e}. Retrying...{Style.RESET_ALL}")
            time.sleep(1)  # Wait longer on error before retrying

    # If the loop finishes without returning, it timed out
    logger.error(f"{Fore.RED}Order ...{order_id_short} did not fill within {timeout_seconds}s timeout.{Style.RESET_ALL}")
    return None  # Timeout failure


def place_risked_market_order(exchange: ccxt.Exchange, symbol: str, side: str,
                            risk_percentage: Decimal, current_atr: Decimal | None, sl_atr_multiplier: Decimal,
                            leverage: int, max_order_cap_usdt: Decimal, margin_check_buffer: Decimal,
                            tsl_percent: Decimal, tsl_activation_offset_percent: Decimal) -> dict[str, Any] | None:
    """Places market entry, waits for fill, then places exchange-native fixed SL and TSL using Decimal precision."""
    market_base = symbol.split('/')[0]  # For concise alerts
    order_side_color = Fore.GREEN if side == CONFIG.side_buy else Fore.RED
    logger.info(f"{order_side_color}{Style.BRIGHT}Place Order Ritual: Initiating {side.upper()} for {symbol}...{Style.RESET_ALL}")

    # --- Pre-computation & Validation ---
    if current_atr is None or current_atr <= Decimal("0"):
        logger.error(f"{Fore.RED}Place Order ({side.upper()}): Invalid ATR ({current_atr}). Cannot calculate SL distance.{Style.RESET_ALL}")
        return None

    entry_price_estimate: Decimal | None = None
    initial_sl_price_estimate: Decimal | None = None
    final_quantity: Decimal | None = None
    market: dict | None = None

    try:
        # === 1. Gather Resources: Balance, Market Info, Limits ===
        logger.debug("Gathering resources: Balance, Market Structure, Limits...")
        balance = exchange.fetch_balance()
        market = exchange.market(symbol)
        limits = market.get('limits', {})
        amount_limits = limits.get('amount', {})
        price_limits = limits.get('price', {})
        min_qty_str = amount_limits.get('min')
        max_qty_str = amount_limits.get('max')
        min_price_str = price_limits.get('min')
        min_qty = safe_decimal_conversion(min_qty_str) if min_qty_str else None
        max_qty = safe_decimal_conversion(max_qty_str) if max_qty_str else None
        min_price = safe_decimal_conversion(min_price_str) if min_price_str else None

        # Extract USDT balance details
        usdt_balance = balance.get(CONFIG.usdt_symbol, {})
        usdt_total = safe_decimal_conversion(usdt_balance.get('total'))  # Total equity including PnL
        usdt_free = safe_decimal_conversion(usdt_balance.get('free'))   # Available for new orders
        # Use total equity for risk calculation if available, otherwise fall back to free
        usdt_equity = usdt_total if usdt_total > 0 else usdt_free

        if usdt_equity <= Decimal("0"):
            logger.error(f"{Fore.RED}Place Order ({side.upper()}): Zero or Invalid equity ({usdt_equity:.4f}). Cannot proceed.{Style.RESET_ALL}"); return None
        if usdt_free < Decimal("0"):  # Free margin shouldn't be negative
            logger.error(f"{Fore.RED}Place Order ({side.upper()}): Invalid free margin ({usdt_free:.4f}). Cannot proceed.{Style.RESET_ALL}"); return None
        logger.debug(f"Resources: Equity={usdt_equity:.4f}, Free={usdt_free:.4f} {CONFIG.usdt_symbol}")

        # === 2. Estimate Entry Price - Peering into the immediate future ===
        # Use shallow order book fetch for a quick estimate
        ob_data = analyze_order_book(exchange, symbol, CONFIG.shallow_ob_fetch_depth, CONFIG.shallow_ob_fetch_depth)
        best_ask = ob_data.get("best_ask")
        best_bid = ob_data.get("best_bid")
        if side == CONFIG.side_buy and best_ask: entry_price_estimate = best_ask  # Estimate buying at best ask
        elif side == CONFIG.side_sell and best_bid: entry_price_estimate = best_bid  # Estimate selling at best bid
        else:
            # Fallback: Fetch last traded price if OB data is unavailable
            try:
                ticker = exchange.fetch_ticker(symbol)
                entry_price_estimate = safe_decimal_conversion(ticker.get('last'))
                logger.debug(f"Using ticker last price for estimate: {entry_price_estimate}")
            except Exception as e:
                logger.error(f"{Fore.RED}Failed to fetch ticker price for estimate: {e}{Style.RESET_ALL}"); return None
        if not entry_price_estimate or entry_price_estimate <= 0:
            logger.error(f"{Fore.RED}Invalid entry price estimate ({entry_price_estimate}). Cannot proceed.{Style.RESET_ALL}"); return None
        logger.debug(f"Estimated Entry Price ~ {entry_price_estimate:.4f}")

        # === 3. Calculate Initial Stop Loss Price (Estimate) - The First Ward ===
        sl_distance = current_atr * sl_atr_multiplier  # Calculate stop distance based on volatility
        initial_sl_price_raw = (entry_price_estimate - sl_distance) if side == CONFIG.side_buy else (entry_price_estimate + sl_distance)
        # Ensure SL price respects minimum price limit if applicable
        if min_price is not None and initial_sl_price_raw < min_price:
            logger.warning(f"{Fore.YELLOW}Initial SL price {initial_sl_price_raw:.4f} below min price {min_price}. Adjusting SL to min price.{Style.RESET_ALL}")
            initial_sl_price_raw = min_price
        if initial_sl_price_raw <= 0:
            logger.error(f"{Fore.RED}Invalid Initial SL price calculation resulted in {initial_sl_price_raw:.4f}. Cannot proceed.{Style.RESET_ALL}"); return None
        # Format the estimated SL price according to market rules
        initial_sl_price_estimate = safe_decimal_conversion(format_price(exchange, symbol, initial_sl_price_raw))
        logger.info(f"Calculated Initial SL Price (Estimate) ~ {Fore.YELLOW}{initial_sl_price_estimate:.4f}{Style.RESET_ALL} (ATR Dist: {sl_distance:.4f})")

        # === 4. Calculate Position Size - Determining the Energy Input ===
        calc_qty, req_margin = calculate_position_size(usdt_equity, risk_percentage, entry_price_estimate, initial_sl_price_estimate, leverage, symbol, exchange)
        if calc_qty is None or req_margin is None:
            logger.error(f"{Fore.RED}Failed risk calculation. Cannot determine position size.{Style.RESET_ALL}"); return None
        final_quantity = calc_qty

        # === 5. Apply Max Order Cap - Limiting the Power ===
        pos_value_estimate = final_quantity * entry_price_estimate
        if pos_value_estimate > max_order_cap_usdt:
            logger.warning(f"{Fore.YELLOW}Calculated order value {pos_value_estimate:.4f} > Cap {max_order_cap_usdt:.4f}. Capping quantity.{Style.RESET_ALL}")
            final_quantity = max_order_cap_usdt / entry_price_estimate
            # Format the capped quantity according to market rules
            final_quantity = safe_decimal_conversion(format_amount(exchange, symbol, final_quantity))
            # Recalculate estimated margin based on the capped quantity
            req_margin = (max_order_cap_usdt / Decimal(leverage))
            logger.info(f"Capped Qty: {final_quantity:.8f}, New Est. Margin: {req_margin:.4f}")

        # === 6. Check Limits & Margin Availability - Final Preparations ===
        if final_quantity <= CONFIG.position_qty_epsilon:
            logger.error(f"{Fore.RED}Final Quantity negligible after capping/formatting: {final_quantity:.8f}{Style.RESET_ALL}"); return None
        # Check against minimum order size
        if min_qty is not None and final_quantity < min_qty:
            logger.error(f"{Fore.RED}Final Quantity {final_quantity:.8f} < Min Allowed {min_qty}. Cannot place order.{Style.RESET_ALL}"); return None
        # Check against maximum order size (though capping should handle this, double-check)
        if max_qty is not None and final_quantity > max_qty:
            logger.warning(f"{Fore.YELLOW}Final Quantity {final_quantity:.8f} > Max Allowed {max_qty}. Capping to max.{Style.RESET_ALL}")
            final_quantity = max_qty
            # Re-format capped amount one last time
            final_quantity = safe_decimal_conversion(format_amount(exchange, symbol, final_quantity))

        # Final margin calculation based on potentially adjusted final_quantity
        final_req_margin = (final_quantity * entry_price_estimate) / Decimal(leverage)
        req_margin_buffered = final_req_margin * margin_check_buffer  # Add safety buffer
        logger.debug(f"Final Margin Check: Need ~{final_req_margin:.4f} (Buffered: {req_margin_buffered:.4f}), Have Free: {usdt_free:.4f}")

        # Check if sufficient free margin is available
        if usdt_free < req_margin_buffered:
            logger.error(f"{Fore.RED}Insufficient FREE margin. Need ~{req_margin_buffered:.4f} (incl. buffer), Have {usdt_free:.4f}{Style.RESET_ALL}")
            send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] ORDER FAIL ({side.upper()}): Insufficient Free Margin (Need ~{req_margin_buffered:.2f})")
            return None
        logger.info(f"{Fore.GREEN}Final Order Details: Qty={final_quantity:.8f}, EstValue={final_quantity * entry_price_estimate:.4f}, EstMargin={final_req_margin:.4f}. Margin check OK.{Style.RESET_ALL}")

        # === 7. Place Entry Market Order - Unleashing the Energy ===
        entry_order: dict[str, Any] | None = None
        order_id: str | None = None
        try:
            qty_float = float(final_quantity)  # CCXT expects float for amount
            entry_color = Back.GREEN if side == CONFIG.side_buy else Back.RED
            logger.warning(f"{entry_color}{Fore.BLACK}{Style.BRIGHT}*** Placing {side.upper()} MARKET ENTRY: {qty_float:.8f} {symbol} ***{Style.RESET_ALL}")
            # Create the market order (not reduceOnly)
            entry_order = exchange.create_market_order(symbol=symbol, side=side, amount=qty_float, params={'reduce_only': False})
            order_id = entry_order.get('id')
            if not order_id:
                # This is unexpected and problematic
                logger.error(f"{Back.RED}{Fore.WHITE}Entry order placed but NO ID returned! Cannot track. Response: {entry_order}{Style.RESET_ALL}")
                send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] CRITICAL ORDER FAIL ({side.upper()}): Entry placed but NO ID received!")
                # Attempt to find position manually? Difficult. Best to stop or handle manually.
                return None  # Cannot proceed without order ID
            logger.success(f"{Fore.GREEN}Market Entry Order submitted. ID: ...{format_order_id(order_id)}. Awaiting confirmation...{Style.RESET_ALL}")
        except Exception as e:
            logger.error(f"{Back.RED}{Fore.WHITE}{Style.BRIGHT}FAILED TO PLACE ENTRY ORDER: {e}{Style.RESET_ALL}")
            logger.debug(traceback.format_exc())
            send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] ORDER FAIL ({side.upper()}): Entry placement failed: {type(e).__name__}")
            return None  # Failed to place entry

        # === 8. Wait for Entry Fill Confirmation - Observing the Impact ===
        filled_entry = wait_for_order_fill(exchange, order_id, symbol, CONFIG.order_fill_timeout_seconds)
        if not filled_entry:
            logger.error(f"{Fore.RED}Entry order ...{format_order_id(order_id)} did not fill or failed confirmation.{Style.RESET_ALL}")
            send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] ORDER FAIL ({side.upper()}): Entry ...{format_order_id(order_id)} fill timeout/fail.")
            # Try to cancel the potentially stuck order (might fail if already filled/gone)
            try:
                logger.warning(f"Attempting to cancel potentially stuck/unconfirmed order ...{format_order_id(order_id)}")
                exchange.cancel_order(order_id, symbol)
            except Exception as cancel_e:
                logger.warning(f"Could not cancel order ...{format_order_id(order_id)} (may be filled or already gone): {cancel_e}")
            return None  # Cannot proceed without confirmed entry

        # === 9. Extract Actual Fill Details - Reading the Result ===
        avg_fill_price = safe_decimal_conversion(filled_entry.get('average'))
        filled_qty = safe_decimal_conversion(filled_entry.get('filled'))
        cost = safe_decimal_conversion(filled_entry.get('cost'))  # Total cost in quote currency (USDT)

        # Validate fill details
        if avg_fill_price <= 0 or filled_qty <= CONFIG.position_qty_epsilon:
            logger.error(f"{Back.RED}{Fore.WHITE}Invalid fill details for ...{format_order_id(order_id)}: Price={avg_fill_price}, Qty={filled_qty}. Position state unknown!{Style.RESET_ALL}")
            send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] CRITICAL ORDER FAIL ({side.upper()}): Invalid fill details ...{format_order_id(order_id)}!")
            # Position might be open with bad data. Manual check needed.
            return filled_entry  # Return problematic order details

        fill_color = Back.GREEN if side == CONFIG.side_buy else Back.RED
        logger.success(f"{fill_color}{Fore.BLACK}{Style.BRIGHT}ENTRY CONFIRMED: ...{format_order_id(order_id)}. Filled: {filled_qty:.8f} @ {avg_fill_price:.4f}, Cost: {cost:.4f} USDT{Style.RESET_ALL}")

        # === 10. Calculate ACTUAL Stop Loss Price - Setting the Ward ===
        # Use the actual average fill price for SL calculation
        actual_sl_price_raw = (avg_fill_price - sl_distance) if side == CONFIG.side_buy else (avg_fill_price + sl_distance)
        # Apply min price constraint again based on actual fill
        if min_price is not None and actual_sl_price_raw < min_price:
             logger.warning(f"{Fore.YELLOW}Actual SL price {actual_sl_price_raw:.4f} below min price {min_price}. Adjusting SL to min price.{Style.RESET_ALL}")
             actual_sl_price_raw = min_price
        if actual_sl_price_raw <= 0:
            logger.error(f"{Back.RED}{Fore.WHITE}CRITICAL: Invalid ACTUAL SL price ({actual_sl_price_raw:.4f}) calculated based on fill price {avg_fill_price:.4f}. Cannot place SL!{Style.RESET_ALL}")
            # Position is open without SL protection. Attempt emergency close.
            send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] CRITICAL ({side.upper()}): Invalid ACTUAL SL price! Attempting emergency close.")
            close_position(exchange, symbol, {'side': side, 'qty': filled_qty}, reason="Invalid SL Calc")  # Use filled details
            return filled_entry  # Return filled entry, but signal failure state
        # Format the final SL price
        actual_sl_price_str = format_price(exchange, symbol, actual_sl_price_raw)
        actual_sl_price_float = float(actual_sl_price_str)  # For CCXT param

        # === 11. Place Initial Fixed Stop Loss Order - The Static Ward ===
        sl_order_id = "N/A"
        try:
            sl_side = CONFIG.side_sell if side == CONFIG.side_buy else CONFIG.side_buy  # Opposite side for SL
            sl_qty_str = format_amount(exchange, symbol, filled_qty)  # Use actual filled quantity
            sl_qty_float = float(sl_qty_str)

            logger.info(f"{Fore.CYAN}Weaving Initial Fixed SL ({sl_atr_multiplier}*ATR)... Side: {sl_side.upper()}, Qty: {sl_qty_float:.8f}, TriggerPx: {actual_sl_price_str}{Style.RESET_ALL}")
            # Bybit V5 stop order params: stopPrice (trigger price), reduceOnly (must be true for SL/TP)
            sl_params = {'stopPrice': actual_sl_price_float, 'reduceOnly': True}
            # Use 'stopMarket' type for market execution when trigger price is hit
            sl_order = exchange.create_order(symbol, 'stopMarket', sl_side, sl_qty_float, params=sl_params)
            sl_order_id = format_order_id(sl_order.get('id'))
            logger.success(f"{Fore.GREEN}Initial Fixed SL ward placed. ID: ...{sl_order_id}, Trigger: {actual_sl_price_str}{Style.RESET_ALL}")
        except Exception as e:
            logger.error(f"{Back.RED}{Fore.WHITE}{Style.BRIGHT}FAILED to place Initial Fixed SL ward: {e}{Style.RESET_ALL}")
            logger.debug(traceback.format_exc())
            send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] ERROR ({side.upper()}): Failed initial SL placement: {type(e).__name__}")
            # Don't necessarily close here, TSL might still work, or user might want manual intervention. Logged failure is key.

        # === 12. Place Trailing Stop Loss Order - The Adaptive Shield ===
        tsl_order_id = "N/A"
        tsl_act_price_str = "N/A"
        try:
            # Calculate TSL activation price based on actual fill price
            act_offset = avg_fill_price * tsl_activation_offset_percent
            act_price_raw = (avg_fill_price + act_offset) if side == CONFIG.side_buy else (avg_fill_price - act_offset)
            # Apply min price constraint to activation price
            if min_price is not None and act_price_raw < min_price:
                logger.warning(f"{Fore.YELLOW}TSL activation price {act_price_raw:.4f} below min price {min_price}. Adjusting to min price.{Style.RESET_ALL}")
                act_price_raw = min_price
            if act_price_raw <= 0: raise ValueError(f"Invalid TSL activation price {act_price_raw:.4f}")

            tsl_act_price_str = format_price(exchange, symbol, act_price_raw)  # Format activation price
            tsl_act_price_float = float(tsl_act_price_str)  # For CCXT param
            tsl_side = CONFIG.side_sell if side == CONFIG.side_buy else CONFIG.side_buy  # Opposite side
            # Bybit V5 uses 'trailingStop' for percentage distance (e.g., "0.5" for 0.5%)
            # Convert our decimal percentage (e.g., 0.005) to percentage string (e.g., "0.5")
            tsl_trail_value_str = str((tsl_percent * Decimal("100")).normalize())
            tsl_qty_str = format_amount(exchange, symbol, filled_qty)  # Use actual filled quantity
            tsl_qty_float = float(tsl_qty_str)

            logger.info(f"{Fore.CYAN}Weaving Trailing SL ({tsl_percent:.2%})... Side: {tsl_side.upper()}, Qty: {tsl_qty_float:.8f}, Trail%: {tsl_trail_value_str}, ActPx: {tsl_act_price_str}{Style.RESET_ALL}")
            # Bybit V5 TSL params via CCXT:
            # 'trailingStop': Percentage value as a string (e.g., "0.5")
            # 'activePrice': Activation trigger price (float)
            # 'reduceOnly': Must be True
            tsl_params = {
                'trailingStop': tsl_trail_value_str,
                'activePrice': tsl_act_price_float,
                'reduceOnly': True,
            }
            # Use 'stopMarket' type with TSL params for Bybit V5 via CCXT
            tsl_order = exchange.create_order(symbol, 'stopMarket', tsl_side, tsl_qty_float, params=tsl_params)
            tsl_order_id = format_order_id(tsl_order.get('id'))
            logger.success(f"{Fore.GREEN}Trailing SL shield placed. ID: ...{tsl_order_id}, Trail%: {tsl_trail_value_str}, ActPx: {tsl_act_price_str}{Style.RESET_ALL}")

            # --- Final Comprehensive SMS Alert ---
            sms_msg = (f"[{market_base}/{CONFIG.strategy_name}] ENTERED {side.upper()} {filled_qty:.8f} @ {avg_fill_price:.4f}. "
                       f"Init SL ~{actual_sl_price_str}. TSL {tsl_percent:.2%} act@{tsl_act_price_str}. "
                       f"IDs E:...{format_order_id(order_id)}, SL:...{sl_order_id}, TSL:...{tsl_order_id}")
            send_sms_alert(sms_msg)

        except Exception as e:
            logger.error(f"{Back.RED}{Fore.WHITE}{Style.BRIGHT}FAILED to place Trailing SL shield: {e}{Style.RESET_ALL}")
            logger.debug(traceback.format_exc())
            send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] ERROR ({side.upper()}): Failed TSL placement: {type(e).__name__}")
            # If TSL fails but initial SL was placed, the position is still protected initially.

        # Return the details of the successfully filled entry order
        return filled_entry

    except (ccxt.InsufficientFunds, ccxt.NetworkError, ccxt.ExchangeError, ValueError, Exception) as e:
        # Catch errors occurring before order placement or during setup
        logger.error(f"{Back.RED}{Fore.WHITE}{Style.BRIGHT}Place Order Ritual ({side.upper()}): Overall process failed: {type(e).__name__} - {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())
        send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] ORDER FAIL ({side.upper()}): Overall process failed: {type(e).__name__}")
    return None  # Indicate failure of the overall process


def cancel_open_orders(exchange: ccxt.Exchange, symbol: str, reason: str = "Cleanup") -> None:
    """Attempts to cancel all open orders for the specified symbol, clearing residual energies."""
    logger.info(f"{Fore.CYAN}Order Cleanup: Attempting for {symbol} (Reason: {reason})...{Style.RESET_ALL}")
    try:
        if not exchange.has.get('fetchOpenOrders'):
            logger.warning(f"{Fore.YELLOW}Order Cleanup: fetchOpenOrders spell not available.{Style.RESET_ALL}")
            return
        # Summon list of open orders
        open_orders = exchange.fetch_open_orders(symbol)
        if not open_orders:
            logger.info(f"{Fore.CYAN}Order Cleanup: No open orders found for {symbol}.{Style.RESET_ALL}")
            return

        logger.warning(f"{Fore.YELLOW}Order Cleanup: Found {len(open_orders)} open orders for {symbol}. Cancelling...{Style.RESET_ALL}")
        cancelled_count, failed_count = 0, 0
        for order in open_orders:
            order_id = order.get('id')
            order_info = f"...{format_order_id(order_id)} ({order.get('type')} {order.get('side')})"
            if order_id:
                try:
                    # Cast the cancel spell
                    exchange.cancel_order(order_id, symbol)
                    logger.info(f"{Fore.CYAN}Order Cleanup: Success for {order_info}{Style.RESET_ALL}")
                    cancelled_count += 1
                    time.sleep(0.1)  # Small delay between cancels to avoid rate limits
                except ccxt.OrderNotFound:
                    # Order might have been filled or cancelled just before this attempt
                    logger.warning(f"{Fore.YELLOW}Order Cleanup: Not found (already closed/cancelled?): {order_info}{Style.RESET_ALL}")
                    cancelled_count += 1  # Treat as cancelled if not found
                except (ccxt.NetworkError, ccxt.ExchangeError, Exception) as e:
                    logger.error(f"{Fore.RED}Order Cleanup: FAILED for {order_info}: {type(e).__name__} - {e}{Style.RESET_ALL}")
                    failed_count += 1
            else:
                logger.error(f"{Fore.RED}Order Cleanup: Found order with no ID: {order}. Cannot cancel.{Style.RESET_ALL}")
                failed_count += 1

        logger.info(f"{Fore.CYAN}Order Cleanup: Finished. Cancelled: {cancelled_count}, Failed: {failed_count}.{Style.RESET_ALL}")
        if failed_count > 0:
            send_sms_alert(f"[{symbol.split('/')[0]}/{CONFIG.strategy_name}] WARNING: Failed to cancel {failed_count} orders during {reason}.")
    except (ccxt.NetworkError, ccxt.ExchangeError, Exception) as e:
        logger.error(f"{Fore.RED}Order Cleanup: Failed fetching open orders for {symbol}: {type(e).__name__} - {e}{Style.RESET_ALL}")


# --- Strategy Signal Generation - Interpreting the Omens ---
def generate_signals(df: pd.DataFrame, strategy_name: str) -> dict[str, Any]:
    """Generates entry/exit signals based on the selected strategy's interpretation of indicators."""
    signals = {'enter_long': False, 'enter_short': False, 'exit_long': False, 'exit_short': False, 'exit_reason': "Strategy Exit"}
    if len(df) < 2: return signals  # Need previous candle for comparisons/crosses

    last = df.iloc[-1]  # Current (latest closed) candle's data
    prev = df.iloc[-2]  # Previous candle's data

    try:
        # --- Dual Supertrend Logic ---
        if strategy_name == "DUAL_SUPERTREND":
            # Enter Long: Primary ST flips long AND Confirmation ST is in uptrend
            if pd.notna(last.get('st_long')) and last['st_long'] and pd.notna(last.get('confirm_trend')) and last['confirm_trend']:
                signals['enter_long'] = True
            # Enter Short: Primary ST flips short AND Confirmation ST is in downtrend
            if pd.notna(last.get('st_short')) and last['st_short'] and pd.notna(last.get('confirm_trend')) and not last['confirm_trend']:
                signals['enter_short'] = True
            # Exit Long: Primary ST flips short
            if pd.notna(last.get('st_short')) and last['st_short']:
                signals['exit_long'] = True; signals['exit_reason'] = "Primary ST Short Flip"
            # Exit Short: Primary ST flips long
            if pd.notna(last.get('st_long')) and last['st_long']:
                signals['exit_short'] = True; signals['exit_reason'] = "Primary ST Long Flip"

        # --- StochRSI + Momentum Logic ---
        elif strategy_name == "STOCHRSI_MOMENTUM":
            k_now, d_now, mom_now = last.get('stochrsi_k'), last.get('stochrsi_d'), last.get('momentum')
            k_prev, d_prev = prev.get('stochrsi_k'), prev.get('stochrsi_d')
            # Check if all necessary indicator values are present
            if any(pd.isna(v) for v in [k_now, d_now, mom_now, k_prev, d_prev]): return signals

            # Enter Long: K crosses above D from below, K is oversold, Momentum is positive
            if k_prev <= d_prev and k_now > d_now and k_now < CONFIG.stochrsi_oversold and mom_now > CONFIG.position_qty_epsilon:
                signals['enter_long'] = True
            # Enter Short: K crosses below D from above, K is overbought, Momentum is negative
            if k_prev >= d_prev and k_now < d_now and k_now > CONFIG.stochrsi_overbought and mom_now < -CONFIG.position_qty_epsilon:
                signals['enter_short'] = True
            # Exit Long: K crosses below D
            if k_prev >= d_prev and k_now < d_now:
                signals['exit_long'] = True; signals['exit_reason'] = "StochRSI K below D"
            # Exit Short: K crosses above D
            if k_prev <= d_prev and k_now > d_now:
                signals['exit_short'] = True; signals['exit_reason'] = "StochRSI K above D"

        # --- Ehlers Fisher Logic ---
        elif strategy_name == "EHLERS_FISHER":
            fish_now, sig_now = last.get('ehlers_fisher'), last.get('ehlers_signal')
            fish_prev, sig_prev = prev.get('ehlers_fisher'), prev.get('ehlers_signal')
            if any(pd.isna(v) for v in [fish_now, sig_now, fish_prev, sig_prev]): return signals

            # Enter Long: Fisher crosses above Signal line
            if fish_prev <= sig_prev and fish_now > sig_now:
                signals['enter_long'] = True
            # Enter Short: Fisher crosses below Signal line
            if fish_prev >= sig_prev and fish_now < sig_now:
                signals['enter_short'] = True
            # Exit Long: Fisher crosses below Signal line
            if fish_prev >= sig_prev and fish_now < sig_now:
                signals['exit_long'] = True; signals['exit_reason'] = "Ehlers Fisher Short Cross"
            # Exit Short: Fisher crosses above Signal line
            if fish_prev <= sig_prev and fish_now > sig_now:
                signals['exit_short'] = True; signals['exit_reason'] = "Ehlers Fisher Long Cross"

        # --- Ehlers MA Cross Logic (Using EMA Placeholder) ---
        elif strategy_name == "EHLERS_MA_CROSS":
            fast_ma_now, slow_ma_now = last.get('fast_ema'), last.get('slow_ema')
            fast_ma_prev, slow_ma_prev = prev.get('fast_ema'), prev.get('slow_ema')
            if any(pd.isna(v) for v in [fast_ma_now, slow_ma_now, fast_ma_prev, slow_ma_prev]): return signals

            # Enter Long: Fast MA crosses above Slow MA
            if fast_ma_prev <= slow_ma_prev and fast_ma_now > slow_ma_now:
                signals['enter_long'] = True
            # Enter Short: Fast MA crosses below Slow MA
            if fast_ma_prev >= slow_ma_prev and fast_ma_now < slow_ma_now:
                signals['enter_short'] = True
            # Exit Long: Fast MA crosses below Slow MA
            if fast_ma_prev >= slow_ma_prev and fast_ma_now < slow_ma_now:
                signals['exit_long'] = True; signals['exit_reason'] = "Ehlers MA Short Cross (EMA)"
            # Exit Short: Fast MA crosses above Slow MA
            if fast_ma_prev <= slow_ma_prev and fast_ma_now > slow_ma_now:
                signals['exit_short'] = True; signals['exit_reason'] = "Ehlers MA Long Cross (EMA)"

    except KeyError as e:
        logger.error(f"{Fore.RED}Signal Generation Error: Missing expected indicator column in DataFrame: {e}. Strategy: {strategy_name}{Style.RESET_ALL}")
    except Exception as e:
        logger.error(f"{Fore.RED}Signal Generation Error: Unexpected disturbance: {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())

    # Log generated signals for debugging if any signal is active
    if signals['enter_long'] or signals['enter_short'] or signals['exit_long'] or signals['exit_short']:
        logger.debug(f"Strategy Signals ({strategy_name}): {signals}")
    return signals


# --- Trading Logic - The Core Spell Weaving ---
def trade_logic(exchange: ccxt.Exchange, symbol: str, df: pd.DataFrame) -> None:
    """Executes the main trading logic for one cycle based on selected strategy and market conditions."""
    cycle_time_str = df.index[-1].strftime('%Y-%m-%d %H:%M:%S %Z') if not df.empty else "N/A"
    logger.info(f"{Fore.BLUE}{Style.BRIGHT}========== New Weaving Cycle ({CONFIG.strategy_name}): {symbol} | Candle: {cycle_time_str} =========={Style.RESET_ALL}")

    # Determine required rows based on the longest lookback needed by any indicator used in *any* strategy + buffers
    # This ensures enough data regardless of the selected strategy.
    required_rows = max(
        CONFIG.st_atr_length, CONFIG.confirm_st_atr_length,
        CONFIG.stochrsi_rsi_length + CONFIG.stochrsi_stoch_length, CONFIG.momentum_length,  # Estimate lookback needed
        CONFIG.ehlers_fisher_length, CONFIG.ehlers_fisher_signal_length,
        CONFIG.ehlers_fast_period, CONFIG.ehlers_slow_period,
        CONFIG.atr_calculation_period, CONFIG.volume_ma_period
    ) + 10  # Add a safety buffer

    if df is None or len(df) < required_rows:
        logger.warning(f"{Fore.YELLOW}Trade Logic: Insufficient data ({len(df) if df is not None else 0}, need ~{required_rows}). Skipping cycle.{Style.RESET_ALL}")
        return

    action_taken_this_cycle: bool = False  # Track if an entry/exit order was placed
    try:
        # === 1. Calculate ALL Indicators - Scry the full spectrum ===
        # It's often simpler to calculate all potential indicators needed by any strategy
        # and let the signal generation function pick the ones it needs based on CONFIG.strategy_name.
        logger.debug("Calculating all potential indicators...")
        df = calculate_supertrend(df, CONFIG.st_atr_length, CONFIG.st_multiplier)
        df = calculate_supertrend(df, CONFIG.confirm_st_atr_length, CONFIG.confirm_st_multiplier, prefix="confirm_")
        df = calculate_stochrsi_momentum(df, CONFIG.stochrsi_rsi_length, CONFIG.stochrsi_stoch_length, CONFIG.stochrsi_k_period, CONFIG.stochrsi_d_period, CONFIG.momentum_length)
        df = calculate_ehlers_fisher(df, CONFIG.ehlers_fisher_length, CONFIG.ehlers_fisher_signal_length)
        df = calculate_ehlers_ma(df, CONFIG.ehlers_fast_period, CONFIG.ehlers_slow_period)  # Placeholder EMA
        vol_atr_data = analyze_volume_atr(df, CONFIG.atr_calculation_period, CONFIG.volume_ma_period)
        current_atr = vol_atr_data.get("atr")  # Crucial for SL calculation

        # === 2. Validate Base Requirements - Ensure stable ground ===
        last = df.iloc[-1]
        current_price = safe_decimal_conversion(last.get('close'))  # Get latest close price
        if pd.isna(current_price) or current_price <= 0:
            logger.warning(f"{Fore.YELLOW}Last candle close price is invalid ({current_price}). Skipping cycle.{Style.RESET_ALL}")
            return
        # Can we place an order? Requires valid ATR for SL calculation.
        can_place_order = current_atr is not None and current_atr > Decimal("0")
        if not can_place_order:
            logger.warning(f"{Fore.YELLOW}Invalid ATR ({current_atr}). Cannot calculate SL or place new orders this cycle.{Style.RESET_ALL}")

        # === 3. Get Position & Analyze Order Book (if configured) ===
        position = get_current_position(exchange, symbol)  # Check current market presence
        position_side = position['side']
        position_qty = position['qty']
        position_entry = position['entry_price']
        # Fetch OB data if configured for every cycle, or later if needed for confirmation
        ob_data = analyze_order_book(exchange, symbol, CONFIG.order_book_depth, CONFIG.order_book_fetch_limit) if CONFIG.fetch_order_book_per_cycle else None

        # === 4. Log Current State - The Oracle Reports ===
        vol_ratio = vol_atr_data.get("volume_ratio")
        vol_spike = vol_ratio is not None and vol_ratio > CONFIG.volume_spike_threshold
        bid_ask_ratio = ob_data.get("bid_ask_ratio") if ob_data else None
        spread = ob_data.get("spread") if ob_data else None

        # Log core state
        atr_str = f"{current_atr:.5f}" if current_atr else "N/A"
        logger.info(f"State | Price: {Fore.CYAN}{current_price:.4f}{Style.RESET_ALL}, ATR({CONFIG.atr_calculation_period}): {Fore.MAGENTA}{atr_str}{Style.RESET_ALL}")
        # Log confirmation states
        vol_ratio_str = f"{vol_ratio:.2f}" if vol_ratio else "N/A"
        vol_spike_str = f"{Fore.GREEN}YES{Style.RESET_ALL}" if vol_spike else f"{Fore.RED}NO{Style.RESET_ALL}"
        logger.info(f"State | Volume: Ratio={Fore.YELLOW}{vol_ratio_str}{Style.RESET_ALL}, Spike={vol_spike_str} (Req={CONFIG.require_volume_spike_for_entry})")
        ob_ratio_str = f"{bid_ask_ratio:.3f}" if bid_ask_ratio else "N/A"
        ob_spread_str = f"{spread:.4f}" if spread else "N/A"
        logger.info(f"State | OrderBook: Ratio={Fore.YELLOW}{ob_ratio_str}{Style.RESET_ALL}, Spread={ob_spread_str} (Fetched={ob_data is not None})")
        # Log position state
        pos_color = Fore.GREEN if position_side == CONFIG.pos_long else (Fore.RED if position_side == CONFIG.pos_short else Fore.BLUE)
        logger.info(f"State | Position: Side={pos_color}{position_side}{Style.RESET_ALL}, Qty={position_qty:.8f}, Entry={position_entry:.4f}")

        # === 5. Generate Strategy Signals - Interpret the Omens ===
        strategy_signals = generate_signals(df, CONFIG.strategy_name)
        # Log if any signal is generated
        # (Logging moved to within generate_signals for brevity here)

        # === 6. Execute Exit Actions - If the Omens Demand Retreat ===
        should_exit_long = position_side == CONFIG.pos_long and strategy_signals['exit_long']
        should_exit_short = position_side == CONFIG.pos_short and strategy_signals['exit_short']

        if should_exit_long or should_exit_short:
            exit_reason = strategy_signals['exit_reason']
            exit_side_color = Back.YELLOW
            logger.warning(f"{exit_side_color}{Fore.BLACK}{Style.BRIGHT}*** TRADE EXIT SIGNAL: Closing {position_side} due to {exit_reason} ***{Style.RESET_ALL}")
            # Cancel existing SL/TSL orders before placing market close
            cancel_open_orders(exchange, symbol, f"Pre-Exit Cleanup ({exit_reason})")
            time.sleep(0.5)  # Small pause after cancel before closing
            # Attempt to close the position
            close_result = close_position(exchange, symbol, position, reason=exit_reason)
            if close_result:
                action_taken_this_cycle = True
                # Add delay after closing before allowing new entry
                logger.info(f"Pausing for {CONFIG.post_close_delay_seconds}s after closing position...")
                time.sleep(CONFIG.post_close_delay_seconds)
            # Exit cycle immediately after attempting close, regardless of success
            # This prevents trying to enter immediately after an exit signal in the same cycle.
            return

        # === 7. Check & Execute Entry Actions (Only if Flat & Can Place Order) ===
        if position_side != CONFIG.pos_none:
             logger.info(f"Holding {pos_color}{position_side}{Style.RESET_ALL} position. Awaiting SL/TSL or Strategy Exit signal.")
             return  # Do nothing if already in a position
        if not can_place_order:
             logger.warning(f"{Fore.YELLOW}Holding Cash. Cannot enter: Invalid ATR ({current_atr}) prevents SL calculation.{Style.RESET_ALL}")
             return  # Do nothing if we can't calculate SL

        # --- Check Entry Conditions ---
        logger.debug("Position is Flat. Checking entry signals...")
        potential_entry = strategy_signals['enter_long'] or strategy_signals['enter_short']

        # Fetch OB data now if not fetched per cycle AND there's a potential entry signal AND OB confirmation is desired
        # (Assuming OB check is always desired if a signal exists, adjust logic if needed)
        ob_check_required = potential_entry  # Check OB if there's any entry signal?
        if ob_check_required and ob_data is None:
            logger.debug("Potential entry signal and OB not fetched yet, fetching OB for confirmation...")
            ob_data = analyze_order_book(exchange, symbol, CONFIG.order_book_depth, CONFIG.order_book_fetch_limit)
            bid_ask_ratio = ob_data.get("bid_ask_ratio") if ob_data else None  # Update ratio

        # Evaluate Confirmation Filters
        ob_available = ob_data is not None and bid_ask_ratio is not None
        # Long OB Confirmation: Ratio >= Threshold OR check not required
        passes_long_ob = not ob_check_required or (ob_available and bid_ask_ratio >= CONFIG.order_book_ratio_threshold_long)
        # Short OB Confirmation: Ratio <= Threshold OR check not required
        passes_short_ob = not ob_check_required or (ob_available and bid_ask_ratio <= CONFIG.order_book_ratio_threshold_short)
        ob_log_ratio = f"{bid_ask_ratio:.3f}" if bid_ask_ratio else "N/A"
        ob_log = f"OB OK? (L:{passes_long_ob}, S:{passes_short_ob}, Ratio={ob_log_ratio}, Req={ob_check_required})"

        # Volume Confirmation
        vol_check_required = CONFIG.require_volume_spike_for_entry
        passes_volume = not vol_check_required or (vol_spike)
        vol_log = f"Vol OK? (Pass:{passes_volume}, Spike={vol_spike}, Req={vol_check_required})"

        # --- Combine Strategy Signal with Confirmations ---
        enter_long = strategy_signals['enter_long'] and passes_long_ob and passes_volume
        enter_short = strategy_signals['enter_short'] and passes_short_ob and passes_volume

        # Log final entry decision logic
        if strategy_signals['enter_long'] or strategy_signals['enter_short']:  # Only log if there was a base signal
            logger.debug(f"Final Entry Check (Long): Strategy={strategy_signals['enter_long']}, {ob_log}, {vol_log} => {Fore.GREEN if enter_long else Fore.RED}Enter={enter_long}{Style.RESET_ALL}")
            logger.debug(f"Final Entry Check (Short): Strategy={strategy_signals['enter_short']}, {ob_log}, {vol_log} => {Fore.GREEN if enter_short else Fore.RED}Enter={enter_short}{Style.RESET_ALL}")

        # --- Execute Entry ---
        if enter_long:
            entry_side_color = Back.GREEN
            logger.success(f"{entry_side_color}{Fore.BLACK}{Style.BRIGHT}*** TRADE SIGNAL: CONFIRMED LONG ENTRY ({CONFIG.strategy_name}) for {symbol} ***{Style.RESET_ALL}")
            # Cancel any stray orders before entering
            cancel_open_orders(exchange, symbol, "Pre-Long Entry")
            time.sleep(0.5)  # Small pause after cancel
            # Place the risked order with SL and TSL
            place_result = place_risked_market_order(
                exchange, symbol, CONFIG.side_buy, CONFIG.risk_per_trade_percentage, current_atr, CONFIG.atr_stop_loss_multiplier,
                CONFIG.leverage, CONFIG.max_order_usdt_amount, CONFIG.required_margin_buffer,
                CONFIG.trailing_stop_percentage, CONFIG.trailing_stop_activation_offset_percent)
            if place_result: action_taken_this_cycle = True

        elif enter_short:
            entry_side_color = Back.RED
            logger.success(f"{entry_side_color}{Fore.WHITE}{Style.BRIGHT}*** TRADE SIGNAL: CONFIRMED SHORT ENTRY ({CONFIG.strategy_name}) for {symbol} ***{Style.RESET_ALL}")
            # Cancel any stray orders before entering
            cancel_open_orders(exchange, symbol, "Pre-Short Entry")
            time.sleep(0.5)  # Small pause after cancel
            # Place the risked order with SL and TSL
            place_result = place_risked_market_order(
                exchange, symbol, CONFIG.side_sell, CONFIG.risk_per_trade_percentage, current_atr, CONFIG.atr_stop_loss_multiplier,
                CONFIG.leverage, CONFIG.max_order_usdt_amount, CONFIG.required_margin_buffer,
                CONFIG.trailing_stop_percentage, CONFIG.trailing_stop_activation_offset_percent)
            if place_result: action_taken_this_cycle = True

        else:
             # Log if no entry signal met confirmations
             if potential_entry and not action_taken_this_cycle:
                 logger.info("Strategy signal present but confirmation filters not met. Holding cash.")
             elif not action_taken_this_cycle:
                 logger.info("No entry signal generated by strategy. Holding cash.")

    except Exception as e:
        # Catch-all for unexpected errors within the main logic loop
        logger.error(f"{Back.RED}{Fore.WHITE}{Style.BRIGHT}CRITICAL UNEXPECTED ERROR in trade_logic: {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())
        send_sms_alert(f"[{symbol.split('/')[0]}/{CONFIG.strategy_name}] CRITICAL ERROR in trade_logic: {type(e).__name__}. Check logs!")
    finally:
        # Mark the end of the cycle clearly
        logger.info(f"{Fore.BLUE}{Style.BRIGHT}========== Cycle Weaving End: {symbol} =========={Style.RESET_ALL}\n")


# --- Graceful Shutdown - Withdrawing the Arcane Energies ---
def graceful_shutdown(exchange: ccxt.Exchange | None, symbol: str | None) -> None:
    """Attempts to close position and cancel orders before exiting, ensuring a clean withdrawal."""
    logger.warning(f"{Fore.YELLOW}{Style.BRIGHT}Shutdown requested. Withdrawing arcane energies gracefully...{Style.RESET_ALL}")
    market_base = symbol.split('/')[0] if symbol else "Bot"
    send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] Shutdown initiated. Attempting cleanup...")

    if not exchange or not symbol:
        logger.warning(f"{Fore.YELLOW}Shutdown: Exchange portal or symbol not defined. Cannot perform cleanup.{Style.RESET_ALL}")
        return

    try:
        # 1. Cancel All Open Orders - Dispel residual intents
        logger.info("Shutdown: Cancelling all open orders...")
        cancel_open_orders(exchange, symbol, reason="Graceful Shutdown")
        time.sleep(1)  # Allow cancellations to process

        # 2. Check and Close Existing Position - Banish final presence
        logger.info("Shutdown: Checking for active position...")
        position = get_current_position(exchange, symbol)
        if position['side'] != CONFIG.pos_none:
            pos_color = Fore.GREEN if position['side'] == CONFIG.pos_long else Fore.RED
            logger.warning(f"{Fore.YELLOW}Shutdown: Active {pos_color}{position['side']}{Style.RESET_ALL} position found (Qty: {position['qty']:.8f}). Attempting banishment...{Style.RESET_ALL}")
            close_result = close_position(exchange, symbol, position, reason="Shutdown")
            if close_result:
                logger.info(f"{Fore.CYAN}Shutdown: Close order placed. Waiting {CONFIG.post_close_delay_seconds * 2}s for confirmation...{Style.RESET_ALL}")
                time.sleep(CONFIG.post_close_delay_seconds * 2)  # Wait longer to be sure
                # Final check after waiting
                final_pos = get_current_position(exchange, symbol)
                if final_pos['side'] == CONFIG.pos_none:
                    logger.success(f"{Fore.GREEN}{Style.BRIGHT}Shutdown: Position confirmed BANISHED.{Style.RESET_ALL}")
                    send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] Position confirmed CLOSED on shutdown.")
                else:
                    # This is bad - manual intervention likely needed
                    logger.error(f"{Back.RED}{Fore.WHITE}Shutdown: FAILED TO CONFIRM position closure. Final state: {final_pos['side']} Qty={final_pos['qty']:.8f}. MANUAL CHECK REQUIRED!{Style.RESET_ALL}")
                    send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] CRITICAL ERROR: Failed confirm closure! Final: {final_pos['side']} Qty={final_pos['qty']:.8f}. MANUAL CHECK!")
            else:
                # Close order placement failed
                logger.error(f"{Back.RED}{Fore.WHITE}Shutdown: Failed to place close order. MANUAL INTERVENTION REQUIRED!{Style.RESET_ALL}")
                send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] CRITICAL ERROR: Failed PLACE close order on shutdown. MANUAL CHECK!")
        else:
            logger.info(f"{Fore.GREEN}Shutdown: No active position found. Clean exit.{Style.RESET_ALL}")
            send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] No active position found on shutdown.")

    except Exception as e:
        logger.error(f"{Fore.RED}Shutdown: Error during cleanup sequence: {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())
        send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] Error during shutdown cleanup: {type(e).__name__}")

    logger.info(f"{Fore.YELLOW}{Style.BRIGHT}--- Scalping Spell Shutdown Complete ---{Style.RESET_ALL}")


# --- Main Execution - Igniting the Spell ---
def main() -> None:
    """Main function to initialize, set up, and run the trading loop."""
    start_time = time.strftime('%Y-%m-%d %H:%M:%S %Z')
    logger.info(f"{Back.BLUE}{Fore.WHITE}{Style.BRIGHT}--- Pyrmethus Bybit Scalping Spell v2.2 Initializing ({start_time}) ---{Style.RESET_ALL}")
    logger.info(f"{Fore.CYAN}--- Strategy Enchantment Selected: {CONFIG.strategy_name} ---{Style.RESET_ALL}")
    logger.info(f"{Fore.GREEN}--- Protective Wards: Initial ATR-Stop + Exchange Trailing Stop ---{Style.RESET_ALL}")
    logger.warning(f"{Back.YELLOW}{Fore.BLACK}{Style.BRIGHT}--- !!! LIVE FUTURES SCALPING MODE - EXTREME RISK - HANDLE WITH CARE !!! ---{Style.RESET_ALL}")

    exchange: ccxt.Exchange | None = None
    symbol: str | None = None  # The specific market symbol (e.g., BTC/USDT:USDT)
    run_bot: bool = True  # Controls the main loop
    cycle_count: int = 0  # Tracks the number of iterations

    try:
        # === Initialize Exchange Portal ===
        exchange = initialize_exchange()
        if not exchange:
            logger.critical("Failed to open exchange portal. Spell cannot proceed.")
            return  # Exit if connection failed

        # === Setup Symbol and Leverage - Focusing the Spell ===
        try:
            # Allow user input for symbol, falling back to config default
            sym_input = input(f"{Fore.YELLOW}Enter target symbol {Style.DIM}(Default [{CONFIG.symbol}]){Style.NORMAL}: {Style.RESET_ALL}").strip()
            symbol_to_use = sym_input or CONFIG.symbol
            # Validate and get unified symbol from CCXT
            market = exchange.market(symbol_to_use)
            symbol = market['symbol']  # Use the precise symbol recognized by CCXT
            # Ensure it's a futures/contract market
            if not market.get('contract'):
                raise ValueError(f"Market '{symbol}' is not a contract/futures market.")
            logger.info(f"{Fore.GREEN}Focusing spell on Symbol: {symbol} (Type: {market.get('type')}, Linear: {market.get('linear')}){Style.RESET_ALL}")
            # Set the desired leverage
            if not set_leverage(exchange, symbol, CONFIG.leverage):
                raise RuntimeError("Leverage conjuring failed. Cannot proceed.")
        except (ccxt.BadSymbol, KeyError, ValueError, RuntimeError) as e:
            logger.critical(f"{Back.RED}{Fore.WHITE}Symbol/Leverage setup failed: {e}{Style.RESET_ALL}")
            send_sms_alert(f"[ScalpBot/{CONFIG.strategy_name}] CRITICAL: Symbol/Leverage setup FAILED ({e}). Exiting.")
            return
        except Exception as e:
            logger.critical(f"{Back.RED}{Fore.WHITE}Unexpected error during spell focus setup: {e}{Style.RESET_ALL}")
            logger.debug(traceback.format_exc())
            send_sms_alert(f"[ScalpBot/{CONFIG.strategy_name}] CRITICAL: Unexpected setup error. Exiting.")
            return

        # === Log Configuration Summary - Reciting the Parameters ===
        logger.info(f"{Fore.MAGENTA}--- Spell Configuration Summary ---{Style.RESET_ALL}")
        logger.info(f"{Fore.WHITE}Symbol: {symbol}, Interval: {CONFIG.interval}, Leverage: {CONFIG.leverage}x")
        logger.info(f"{Fore.CYAN}Strategy Path: {CONFIG.strategy_name}")
        # Log relevant strategy parameters for clarity
        if CONFIG.strategy_name == "DUAL_SUPERTREND": logger.info(f"  Params: ST={CONFIG.st_atr_length}/{CONFIG.st_multiplier}, ConfirmST={CONFIG.confirm_st_atr_length}/{CONFIG.confirm_st_multiplier}")
        elif CONFIG.strategy_name == "STOCHRSI_MOMENTUM": logger.info(f"  Params: StochRSI={CONFIG.stochrsi_rsi_length}/{CONFIG.stochrsi_stoch_length}/{CONFIG.stochrsi_k_period}/{CONFIG.stochrsi_d_period} (OB={CONFIG.stochrsi_overbought},OS={CONFIG.stochrsi_oversold}), Mom={CONFIG.momentum_length}")
        elif CONFIG.strategy_name == "EHLERS_FISHER": logger.info(f"  Params: Fisher={CONFIG.ehlers_fisher_length}, Signal={CONFIG.ehlers_fisher_signal_length}")
        elif CONFIG.strategy_name == "EHLERS_MA_CROSS": logger.info(f"  Params: FastMA(EMA)={CONFIG.ehlers_fast_period}, SlowMA(EMA)={CONFIG.ehlers_slow_period}")
        logger.info(f"{Fore.GREEN}Risk Ward: {CONFIG.risk_per_trade_percentage:.3%}/trade, Max Pos Value: {CONFIG.max_order_usdt_amount:.4f} USDT")
        logger.info(f"{Fore.GREEN}Initial SL Ward: {CONFIG.atr_stop_loss_multiplier} * ATR({CONFIG.atr_calculation_period})")
        logger.info(f"{Fore.GREEN}Trailing SL Shield: {CONFIG.trailing_stop_percentage:.2%}, Activation Offset: {CONFIG.trailing_stop_activation_offset_percent:.2%}")
        logger.info(f"{Fore.YELLOW}Volume Filter: {CONFIG.require_volume_spike_for_entry} (MA={CONFIG.volume_ma_period}, Thr={CONFIG.volume_spike_threshold})")
        logger.info(f"{Fore.YELLOW}Order Book Filter: {CONFIG.fetch_order_book_per_cycle} (Depth={CONFIG.order_book_depth}, L>={CONFIG.order_book_ratio_threshold_long}, S<={CONFIG.order_book_ratio_threshold_short})")
        # *** THE FIX IS HERE: Ensure CONFIG.required_margin_buffer is Decimal before formatting ***
        logger.info(f"{Fore.WHITE}Timing: Sleep={CONFIG.sleep_seconds}s, Margin Buffer={CONFIG.required_margin_buffer:.1%}, SMS Alerts={CONFIG.enable_sms_alerts}{Style.RESET_ALL}")
        logger.info(f"{Fore.CYAN}Oracle Verbosity (Log Level): {logging.getLevelName(logger.level)}")
        logger.info(f"{Fore.MAGENTA}{'-' * 30}{Style.RESET_ALL}")
        market_base = symbol.split('/')[0]  # For SMS brevity
        send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] Bot Configured. SL: ATR+TSL. Starting main loop.")

        # === Main Trading Loop - The Continuous Weaving ===
        while run_bot:
            cycle_start_time = time.monotonic()
            cycle_count += 1
            logger.debug(f"{Fore.CYAN}--- Cycle {cycle_count} Weaving Start ---{Style.RESET_ALL}")
            try:
                # Determine required data length based on longest possible indicator lookback + buffer
                data_limit = max(100,  # Base minimum
                                 CONFIG.st_atr_length * 2, CONFIG.confirm_st_atr_length * 2,
                                 CONFIG.stochrsi_rsi_length + CONFIG.stochrsi_stoch_length + 5, CONFIG.momentum_length * 2,
                                 CONFIG.ehlers_fisher_length * 2, CONFIG.ehlers_fisher_signal_length * 2,
                                 CONFIG.ehlers_fast_period * 2, CONFIG.ehlers_slow_period * 2,
                                 CONFIG.atr_calculation_period * 2, CONFIG.volume_ma_period * 2
                                 ) + CONFIG.api_fetch_limit_buffer  # Add buffer for safety

                # Gather fresh market data
                df = get_market_data(exchange, symbol, CONFIG.interval, limit=data_limit)

                # Process data and execute logic if data is valid
                if df is not None and not df.empty:
                    trade_logic(exchange, symbol, df.copy())  # Pass copy to avoid modifying original df in logic
                else:
                    logger.warning(f"{Fore.YELLOW}No valid market data received for {symbol}. Skipping trade logic this cycle.{Style.RESET_ALL}")

            # --- Robust Error Handling within the Loop ---
            except ccxt.RateLimitExceeded as e:
                logger.warning(f"{Back.YELLOW}{Fore.BLACK}Rate Limit Exceeded: {e}. The exchange spirits demand patience. Sleeping longer...{Style.RESET_ALL}")
                time.sleep(CONFIG.sleep_seconds * 5)  # Sleep much longer
                send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] WARNING: Rate limit hit! Pausing.")
            except ccxt.NetworkError as e:
                # Transient network issues, retry next cycle
                logger.warning(f"{Fore.YELLOW}Network disturbance: {e}. Retrying next cycle.{Style.RESET_ALL}")
                time.sleep(CONFIG.sleep_seconds)  # Standard sleep on recoverable network errors
            except ccxt.ExchangeNotAvailable as e:
                # Exchange might be down for maintenance
                logger.error(f"{Back.RED}{Fore.WHITE}Exchange unavailable: {e}. Portal temporarily closed. Sleeping much longer...{Style.RESET_ALL}")
                time.sleep(CONFIG.sleep_seconds * 10)  # Wait a significant time
                send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] ERROR: Exchange unavailable! Long pause.")
            except ccxt.AuthenticationError as e:
                # API keys might have been revoked or expired
                logger.critical(f"{Back.RED}{Fore.WHITE}{Style.BRIGHT}Authentication Error: {e}. Spell broken! Stopping NOW.{Style.RESET_ALL}")
                run_bot = False  # Stop the bot immediately
                send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] CRITICAL: Authentication Error! Stopping NOW.")
            except ccxt.ExchangeError as e:  # Catch other specific exchange errors
                logger.error(f"{Fore.RED}Unhandled Exchange Error: {e}{Style.RESET_ALL}")
                logger.debug(traceback.format_exc())
                send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] ERROR: Unhandled Exchange error: {type(e).__name__}")
                time.sleep(CONFIG.sleep_seconds)  # Sleep before retrying after general exchange error
            except Exception as e:
                # Catch-all for truly unexpected issues
                logger.exception(f"{Back.RED}{Fore.WHITE}{Style.BRIGHT}!!! UNEXPECTED CRITICAL CHAOS: {e} !!! Stopping spell!{Style.RESET_ALL}")
                run_bot = False  # Stop the bot on unknown critical errors
                send_sms_alert(f"[{market_base}/{CONFIG.strategy_name}] CRITICAL UNEXPECTED ERROR: {type(e).__name__}! Stopping NOW.")

            # --- Loop Delay - Controlling the Rhythm ---
            if run_bot:
                elapsed = time.monotonic() - cycle_start_time
                sleep_dur = max(0, CONFIG.sleep_seconds - elapsed)
                logger.debug(f"Cycle {cycle_count} duration: {elapsed:.2f}s. Sleeping for {sleep_dur:.2f}s.")
                if sleep_dur > 0:
                    time.sleep(sleep_dur)  # Wait for the configured interval

    except KeyboardInterrupt:
        logger.warning(f"\n{Fore.YELLOW}{Style.BRIGHT}KeyboardInterrupt received. User requests withdrawal of arcane energies...{Style.RESET_ALL}")
        run_bot = False  # Signal the loop to terminate
    finally:
        # --- Graceful Shutdown Sequence ---
        # This will run whether the loop finished normally, was interrupted, or hit a critical error that set run_bot=False
        graceful_shutdown(exchange, symbol)
        symbol.split('/')[0] if symbol else "Bot"
        # Final SMS may not send if Termux process is killed abruptly, but attempt it.
        # send_sms_alert(f"[{market_base_final}] Bot process terminated.") # Optional: Alert on final termination
        logger.info(f"{Back.BLUE}{Fore.WHITE}{Style.BRIGHT}--- Pyrmethus Scalping Spell Deactivated ---{Style.RESET_ALL}")


if __name__ == "__main__":
    # Ensure the spell is cast only when invoked directly
    main()
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# ██████╗ ██╗   ██╗███████╗███╗   ███╗███████╗████████╗██╗   ██╗██║   ██║███████╗
# ██╔══██╗╚██╗ ██╔╝██╔════╝████╗ ████║██╔════╝╚══██╔══╝██║   ██║██║   ██║██╔════╝
# ██████╔╝ ╚████╔╝ ███████╗██╔████╔██║███████╗   ██║   ██║   ██║██║   ██║███████╗
# ██╔═══╝   ╚██╔╝  ╚════██║██║╚██╔╝██║╚════██║   ██║   ██║   ██║██║   ██║╚════██║
# ██║        ██║   ███████║██║ ╚═╝ ██║███████║   ██║   ╚██████╔╝╚██████╔╝███████║
# ╚═╝        ╚═╝   ╚══════╝╚═╝     ╚═╝╚══════╝   ╚═╝    ╚═════╝  ╚═════╝ ╚══════╝
# Pyrmethus - Unified Scalping Spell v10.1.0 (Reforged Config & Arcane Clarity)
# Conjures high-frequency trades on Bybit Futures with enhanced config, precision, V5 focus, and Termux integration.

"""High-Frequency Trading Bot (Scalping) for Bybit USDT Futures
Version: 10.1.0 (Reforged: Class-based Config, Enhanced Fill Confirm, Standardized SL/TP, Pyrmethus Style).

Features:
- Dual Supertrend strategy with confirmation.
- ATR for volatility measurement and SL/TP calculation.
- **CRITICAL SAFETY UPGRADE:** Implements exchange-native Stop-Loss and Take-Profit
  orders (both using `stopMarket` type) immediately after entry confirmation,
  based on actual fill price. Uses `fetch_order` primarily for faster confirmation.
- **Includes necessary 'triggerDirection' parameter for Bybit V5 API.**
- Optional Volume spike analysis for entry confirmation.
- Optional Order book pressure analysis for entry confirmation.
- **Enhanced Risk Management:**
    - Risk-based position sizing with margin checks.
    - Checks against exchange minimum order amount and cost *before* placing orders.
    - Caps position size based on `MAX_ORDER_USDT_AMOUNT`.
- **Reforged Configuration:** Uses a dedicated `Config` class for better organization and validation.
- Termux SMS alerts for critical events (with Termux:API check).
- Robust error handling and logging with vibrant Neon color support via Colorama.
- Graceful shutdown on KeyboardInterrupt with position closing attempt.
- Stricter position detection logic (targeting Bybit V5 API).
- **Decimal Precision:** Uses Decimal for critical financial calculations.

Disclaimer:
- **EXTREME RISK**: Arcane energies are volatile. Educational purposes ONLY. High-risk. Use at own absolute risk.
- **EXCHANGE-NATIVE SL/TP:** Relies on exchange-native orders. Subject to exchange performance, slippage, API reliability.
- Parameter Sensitivity: Requires significant tuning and testing in the astral plane (testnet).
- API Rate Limits: Monitor usage lest the exchange spirits grow wary.
- Slippage: Market orders are prone to slippage in turbulent ether.
- Test Thoroughly: **DO NOT RUN LIVE WITHOUT EXTENSIVE TESTNET/DEMO TESTING.**
- Termux Dependency: Requires Termux:API for SMS communication scrolls. Ensure `pkg install termux-api`.
- API Changes: Exchange APIs (like Bybit V5) can change. Ensure CCXT is updated.

**Installation:**
pip install ccxt pandas pandas_ta python-dotenv colorama # termux-api (if using Termux for SMS)
"""

# Standard Library Imports - The Foundational Runes
import contextlib
import logging
import os
import shutil  # For checking command existence
import subprocess  # For Termux API calls
import sys
import time
import traceback
from decimal import ROUND_HALF_UP, Decimal, InvalidOperation, getcontext
from typing import Any, Dict, List, Optional, Tuple, Union, Type, cast

# Third-party Libraries - Summoned Essences
try:
    import ccxt
    import pandas as pd
    import pandas_ta as ta  # type: ignore[import]
    from colorama import Back, Fore, Style
    from colorama import init as colorama_init
    from dotenv import load_dotenv
except ImportError as e:
    missing_pkg = e.name
    # Use Colorama's raw codes here as it might not be initialized yet
    print(f"\033[91m\033[1mCRITICAL ERROR: Missing required Python package: '{missing_pkg}'.\033[0m")
    print(f"\033[93mPlease install it using: pip install {missing_pkg}\033[0m")
    sys.exit(1)

# --- Initializations - Preparing the Ritual Chamber ---
colorama_init(autoreset=True)  # Activate Colorama's magic
load_dotenv()  # Load secrets from the hidden .env scroll
# Set Decimal precision high enough for crypto calculations
# Bybit USDT perps typically have price precision up to 4-6 decimals,
# and quantity precision up to 3-8 decimals. 18 should be safe.
getcontext().prec = 18

# --- Constants ---

# --- String Constants ---
# Dictionary Keys / Internal Representations
SIDE_KEY = 'side'
QTY_KEY = 'qty'
ENTRY_PRICE_KEY = 'entry_price'
INFO_KEY = 'info'
SYMBOL_KEY = 'symbol'
ID_KEY = 'id'
AVG_PRICE_KEY = 'avgPrice'  # Bybit V5 raw field preferred
CONTRACTS_KEY = 'contracts'  # CCXT unified field
FILLED_KEY = 'filled'
COST_KEY = 'cost'
AVERAGE_KEY = 'average'  # CCXT unified field for fill price
TIMESTAMP_KEY = 'timestamp'
LAST_PRICE_KEY = 'last'
BIDS_KEY = 'bids'
ASKS_KEY = 'asks'
SPREAD_KEY = 'spread'
BEST_BID_KEY = 'best_bid'
BEST_ASK_KEY = 'best_ask'
BID_ASK_RATIO_KEY = 'bid_ask_ratio'
ATR_KEY = 'atr'
VOLUME_MA_KEY = 'volume_ma'
LAST_VOLUME_KEY = 'last_volume'
VOLUME_RATIO_KEY = 'volume_ratio'
STATUS_KEY = 'status'
PRICE_KEY = 'price'  # Fallback for average price
PRECISION_KEY = 'precision'
LIMITS_KEY = 'limits'
AMOUNT_KEY = 'amount'
MIN_KEY = 'min'
MAX_KEY = 'max'
MARKET_KEY = 'market'
BASE_KEY = 'base'
CONTRACT_KEY = 'contract'
SPOT_KEY = 'spot'
TYPE_KEY = 'type'
LINEAR_KEY = 'linear'
INVERSE_KEY = 'inverse'
TOTAL_KEY = 'total'
FREE_KEY = 'free'

# Order Sides / Position Sides
SIDE_BUY = 'buy'
SIDE_SELL = 'sell'
POSITION_SIDE_LONG = 'Long'    # Internal representation for long position
POSITION_SIDE_SHORT = 'Short'  # Internal representation for short position
POSITION_SIDE_NONE = 'None'    # Internal representation for no position / Bybit V5 side 'None'
BYBIT_SIDE_BUY = 'Buy'         # Bybit V5 API side
BYBIT_SIDE_SELL = 'Sell'       # Bybit V5 API side

# Order Types / Statuses / Params
ORDER_TYPE_MARKET = 'market'
ORDER_TYPE_STOP_MARKET = 'stopMarket'  # Used for both SL and TP conditional market orders
ORDER_STATUS_OPEN = 'open'
ORDER_STATUS_CLOSED = 'closed'
ORDER_STATUS_CANCELED = 'canceled'  # Note: CCXT might use 'cancelled' or 'canceled'
ORDER_STATUS_REJECTED = 'rejected'
ORDER_STATUS_EXPIRED = 'expired'
PARAM_REDUCE_ONLY = 'reduce_only'  # CCXT standard param name
PARAM_STOP_PRICE = 'stopPrice'  # CCXT standard param name for trigger price
PARAM_TRIGGER_DIRECTION = 'triggerDirection'  # Bybit V5 specific for conditional orders (1=above, 2=below)
PARAM_CATEGORY = 'category'  # Bybit V5 specific for linear/inverse
PARAM_SETTLE_COIN = 'settleCoin' # Bybit V5 param for balance/position filtering
PARAM_POSITION_IDX = 'positionIdx' # Bybit V5 raw field for hedge/one-way mode
PARAM_SIZE = 'size' # Bybit V5 raw field for position size

# Currencies
USDT_SYMBOL = "USDT"

# --- Logger Setup - The Oracle's Voice ---
LOGGING_LEVEL_STR = os.getenv("LOGGING_LEVEL", "INFO").upper()
LOGGING_LEVEL = getattr(logging, LOGGING_LEVEL_STR, logging.INFO)

# Custom Log Level for Success
SUCCESS_LEVEL = 25  # Between INFO and WARNING
logging.addLevelName(SUCCESS_LEVEL, "SUCCESS")


def log_success(self: logging.Logger, message: str, *args: Any, **kwargs: Any) -> None:
    """Adds a 'success' log level method."""
    if self.isEnabledFor(SUCCESS_LEVEL):
        # pylint: disable=protected-access
        self._log(SUCCESS_LEVEL, message, args, **kwargs)


# Bind the new method to the Logger class
logging.Logger.success = log_success # type: ignore[attr-defined]

# Basic configuration first
logging.basicConfig(
    level=LOGGING_LEVEL,
    format="%(asctime)s [%(levelname)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
    handlers=[
        # logging.FileHandler("scalp_bot_v10.1.log"), # Optional: Log to file
        logging.StreamHandler(sys.stdout)  # Log to console
    ]
)
logger: logging.Logger = logging.getLogger(__name__)

# Apply colors if outputting to a TTY (like Termux)
if hasattr(sys.stdout, 'isatty') and sys.stdout.isatty():
    # Apply Pyrmethus colors
    logging.addLevelName(logging.DEBUG, f"{Fore.CYAN}{Style.DIM}{logging.getLevelName(logging.DEBUG)}{Style.RESET_ALL}")  # Dim Cyan for Debug
    logging.addLevelName(logging.INFO, f"{Fore.BLUE}{logging.getLevelName(logging.INFO)}{Style.RESET_ALL}")  # Blue for Info
    logging.addLevelName(SUCCESS_LEVEL, f"{Fore.MAGENTA}{Style.BRIGHT}{logging.getLevelName(SUCCESS_LEVEL)}{Style.RESET_ALL}")  # Bright Magenta for Success
    logging.addLevelName(logging.WARNING, f"{Fore.YELLOW}{Style.BRIGHT}{logging.getLevelName(logging.WARNING)}{Style.RESET_ALL}")  # Bright Yellow for Warning
    logging.addLevelName(logging.ERROR, f"{Fore.RED}{Style.BRIGHT}{logging.getLevelName(logging.ERROR)}{Style.RESET_ALL}")  # Bright Red for Error
    logging.addLevelName(logging.CRITICAL, f"{Back.RED}{Fore.WHITE}{Style.BRIGHT}{logging.getLevelName(logging.CRITICAL)}{Style.RESET_ALL}")  # White on Red for Critical
else:
    # Avoid color codes if not a TTY
    logging.addLevelName(SUCCESS_LEVEL, "SUCCESS")  # Ensure level name exists without color


# --- Configuration Class - Defining the Spell's Parameters ---
class Config:
    """Loads, validates, and stores configuration parameters with arcane precision."""
    def __init__(self) -> None:
        logger.info(f"{Fore.MAGENTA}--- Summoning Configuration Runes ---{Style.RESET_ALL}")
        valid = True  # Track overall validity

        # --- API Credentials (Required) ---
        self.api_key: Optional[str] = self._get_env("BYBIT_API_KEY", None, str, required=True, color=Fore.RED)
        self.api_secret: Optional[str] = self._get_env("BYBIT_API_SECRET", None, str, required=True, color=Fore.RED)
        if not self.api_key or not self.api_secret: valid = False

        # --- Trading Parameters ---
        self.symbol: str = self._get_env("SYMBOL", "BTC/USDT:USDT", str, color=Fore.YELLOW)
        self.interval: str = self._get_env("INTERVAL", "1m", str, color=Fore.YELLOW)
        self.leverage: int = self._get_env("LEVERAGE", 10, int, color=Fore.YELLOW)
        self.sleep_seconds: int = self._get_env("SLEEP_SECONDS", 10, int, color=Fore.YELLOW)
        if self.leverage <= 0:
            logger.critical(f"CRITICAL CONFIG: LEVERAGE must be positive, got: {self.leverage}")
            valid = False
        if self.sleep_seconds <= 0:
            logger.warning(f"CONFIG WARNING: SLEEP_SECONDS ({self.sleep_seconds}) invalid. Setting to 1.")
            self.sleep_seconds = 1

        # --- Risk Management (CRITICAL) ---
        self.risk_per_trade_percentage: Decimal = self._get_env("RISK_PER_TRADE_PERCENTAGE", Decimal("0.005"), Decimal, color=Fore.GREEN)
        self.atr_stop_loss_multiplier: Decimal = self._get_env("ATR_STOP_LOSS_MULTIPLIER", Decimal("1.5"), Decimal, color=Fore.GREEN)
        self.atr_take_profit_multiplier: Decimal = self._get_env("ATR_TAKE_PROFIT_MULTIPLIER", Decimal("2.0"), Decimal, color=Fore.GREEN)
        self.max_order_usdt_amount: Decimal = self._get_env("MAX_ORDER_USDT_AMOUNT", Decimal("500.0"), Decimal, color=Fore.GREEN)
        self.required_margin_buffer: Decimal = self._get_env("REQUIRED_MARGIN_BUFFER", Decimal("1.05"), Decimal, color=Fore.GREEN)
        if not (Decimal(0) < self.risk_per_trade_percentage < Decimal(1)):
            logger.critical(f"CRITICAL CONFIG: RISK_PER_TRADE_PERCENTAGE must be between 0 and 1 (exclusive), got: {self.risk_per_trade_percentage}")
            valid = False
        if self.atr_stop_loss_multiplier <= 0:
            logger.warning(f"CONFIG WARNING: ATR_STOP_LOSS_MULTIPLIER ({self.atr_stop_loss_multiplier}) should be positive.")
        if self.atr_take_profit_multiplier <= 0:
            logger.warning(f"CONFIG WARNING: ATR_TAKE_PROFIT_MULTIPLIER ({self.atr_take_profit_multiplier}) should be positive.")
        if self.max_order_usdt_amount <= 0:
            logger.warning(f"CONFIG WARNING: MAX_ORDER_USDT_AMOUNT ({self.max_order_usdt_amount}) should be positive.")
        if self.required_margin_buffer < 1:
            logger.warning(f"CONFIG WARNING: REQUIRED_MARGIN_BUFFER ({self.required_margin_buffer}) is less than 1. Margin checks might be ineffective.")

        # --- Supertrend Indicator Parameters ---
        self.st_atr_length: int = self._get_env("ST_ATR_LENGTH", 7, int, color=Fore.CYAN)
        self.st_multiplier: float = float(self._get_env("ST_MULTIPLIER", Decimal("2.5"), Decimal, color=Fore.CYAN))  # pandas_ta needs float
        self.confirm_st_atr_length: int = self._get_env("CONFIRM_ST_ATR_LENGTH", 5, int, color=Fore.CYAN)
        self.confirm_st_multiplier: float = float(self._get_env("CONFIRM_ST_MULTIPLIER", Decimal("2.0"), Decimal, color=Fore.CYAN))  # pandas_ta needs float
        if self.st_atr_length <= 0 or self.confirm_st_atr_length <= 0:
            logger.warning("CONFIG WARNING: Supertrend ATR length(s) are zero or negative.")
        if self.st_multiplier <= 0 or self.confirm_st_multiplier <= 0:
            logger.warning("CONFIG WARNING: Supertrend multiplier(s) are zero or negative.")

        # --- Volume Analysis Parameters ---
        self.volume_ma_period: int = self._get_env("VOLUME_MA_PERIOD", 20, int, color=Fore.YELLOW)
        self.volume_spike_threshold: Decimal = self._get_env("VOLUME_SPIKE_THRESHOLD", Decimal("1.5"), Decimal, color=Fore.YELLOW)
        self.require_volume_spike_for_entry: bool = self._get_env("REQUIRE_VOLUME_SPIKE_FOR_ENTRY", True, bool, color=Fore.YELLOW)
        if self.volume_ma_period <= 0:
            logger.warning("CONFIG WARNING: VOLUME_MA_PERIOD is zero or negative.")
        if self.volume_spike_threshold <= 0:
            logger.warning("CONFIG WARNING: VOLUME_SPIKE_THRESHOLD should be positive.")

        # --- Order Book Analysis Parameters ---
        self.order_book_depth: int = self._get_env("ORDER_BOOK_DEPTH", 10, int, color=Fore.YELLOW)
        self.order_book_ratio_threshold_long: Decimal = self._get_env("ORDER_BOOK_RATIO_THRESHOLD_LONG", Decimal("1.2"), Decimal, color=Fore.YELLOW)
        self.order_book_ratio_threshold_short: Decimal = self._get_env("ORDER_BOOK_RATIO_THRESHOLD_SHORT", Decimal("0.8"), Decimal, color=Fore.YELLOW)
        self.fetch_order_book_per_cycle: bool = self._get_env("FETCH_ORDER_BOOK_PER_CYCLE", False, bool, color=Fore.YELLOW)
        self.use_ob_confirm: bool = self._get_env("USE_OB_CONFIRM", True, bool, color=Fore.YELLOW)  # Added explicit OB confirmation flag
        if self.order_book_depth <= 0:
            logger.warning("CONFIG WARNING: ORDER_BOOK_DEPTH should be positive.")

        # --- ATR Calculation Parameter (for SL/TP) ---
        self.atr_calculation_period: int = self._get_env("ATR_CALCULATION_PERIOD", 14, int, color=Fore.GREEN)
        if self.atr_calculation_period <= 0:
            logger.warning("CONFIG WARNING: ATR_CALCULATION_PERIOD is zero or negative.")

        # --- Termux SMS Alert Configuration ---
        self.enable_sms_alerts: bool = self._get_env("ENABLE_SMS_ALERTS", False, bool, color=Fore.MAGENTA)
        self.sms_recipient_number: Optional[str] = self._get_env("SMS_RECIPIENT_NUMBER", None, str, color=Fore.MAGENTA)
        self.sms_timeout_seconds: int = self._get_env("SMS_TIMEOUT_SECONDS", 30, int, color=Fore.MAGENTA)
        if self.enable_sms_alerts and not self.sms_recipient_number:
            logger.warning("CONFIG WARNING: SMS alerts enabled, but SMS_RECIPIENT_NUMBER not set.")
        if self.sms_timeout_seconds <= 0:
            logger.warning(f"CONFIG WARNING: SMS_TIMEOUT_SECONDS ({self.sms_timeout_seconds}) invalid. Setting to 10.")
            self.sms_timeout_seconds = 10

        # --- CCXT / API Parameters ---
        self.default_recv_window: int = self._get_env("RECV_WINDOW", 10000, int, color=Fore.WHITE)
        # Bybit V5 L2 OB limit can be 1, 50, 200. Fetch 50 if depth <= 50, else 200.
        self.order_book_fetch_limit: int = 50 if self.order_book_depth <= 50 else 200
        self.shallow_ob_fetch_depth: int = self._get_env("SHALLOW_OB_FETCH_DEPTH", 5, int, color=Fore.WHITE) # Not currently used, but kept for potential future use

        # --- Internal Constants & Behavior ---
        self.retry_count: int = self._get_env("RETRY_COUNT", 3, int, color=Fore.WHITE)
        self.retry_delay_seconds: int = self._get_env("RETRY_DELAY_SECONDS", 1, int, color=Fore.WHITE)
        self.api_fetch_limit_buffer: int = self._get_env("API_FETCH_LIMIT_BUFFER", 5, int, color=Fore.WHITE)
        self.position_qty_epsilon: Decimal = self._get_env("POSITION_QTY_EPSILON", Decimal("1e-9"), Decimal, color=Fore.WHITE)
        self.post_close_delay_seconds: int = self._get_env("POST_CLOSE_DELAY_SECONDS", 2, int, color=Fore.WHITE)
        self.post_entry_delay_seconds: float = float(self._get_env("POST_ENTRY_DELAY_SECONDS", Decimal("1.0"), Decimal, color=Fore.WHITE))
        self.fetch_order_status_retries: int = self._get_env("FETCH_ORDER_STATUS_RETRIES", 5, int, color=Fore.WHITE)
        self.fetch_order_status_delay: float = float(self._get_env("FETCH_ORDER_STATUS_DELAY", Decimal("0.5"), Decimal, color=Fore.WHITE))
        self.confirm_fill_lookback_seconds: int = self._get_env("CONFIRM_FILL_LOOKBACK_SECONDS", 600, int, color=Fore.WHITE) # Lookback for fetch_closed_orders fallback
        self.emergency_close_on_sl_fail: bool = self._get_env("EMERGENCY_CLOSE_ON_SL_FAIL", True, bool, color=Fore.RED) # Attempt emergency close if SL order fails

        # --- Final Validation Check ---
        if not valid:
            logger.critical(f"{Back.RED}{Fore.WHITE}--- Configuration validation FAILED. Cannot proceed. ---{Style.RESET_ALL}")
            raise ValueError("Critical configuration validation failed.")
        else:
            logger.success(f"{Fore.GREEN}{Style.BRIGHT}--- Configuration Runes Summoned and Verified ---{Style.RESET_ALL}")

    def _get_env(self, var_name: str, default: Any, expected_type: Type, required: bool = False, color: str = Fore.WHITE) -> Any:
        """Gets an environment variable, casts type (incl. defaults), logs, handles errors.
        Handles str, int, float, bool, and Decimal types.
        """
        value_str = os.getenv(var_name)
        source = "environment" if value_str is not None else "default"
        value_to_process: Any = value_str if value_str is not None else default

        log_val_str = f"'{value_str}'" if source == "environment" else f"(Default: '{default}')"
        logger.debug(f"{color}Summoning {var_name}: {log_val_str}{Style.RESET_ALL}")

        if value_to_process is None:
            if required:
                logger.critical(f"{Back.RED}{Fore.WHITE}CRITICAL: Required config '{var_name}' is missing and has no default.{Style.RESET_ALL}")
                # Raise error immediately if required and no value/default
                raise ValueError(f"Required environment variable '{var_name}' not set and no default provided.")
            return None  # Return None if not required and no value/default

        try:
            if expected_type == bool:
                # Explicitly check for string representations of True/False
                if isinstance(value_to_process, str):
                    return value_to_process.lower() in ('true', '1', 't', 'yes', 'y')
                # If not a string, try standard Python truthiness
                return bool(value_to_process)
            elif expected_type == Decimal:
                # Ensure input is string for Decimal constructor for reliable conversion
                return Decimal(str(value_to_process))
            else:
                # Handle int, float, str directly
                return expected_type(value_to_process)
        except (ValueError, TypeError, InvalidOperation) as e:
            env_val_disp = f"'{value_str}'" if value_str is not None else "(Not Set)"
            logger.error(
                f"{Fore.RED}Config Error: Invalid type/value for {var_name}={env_val_disp} (Source: {source}). "
                f"Expected {expected_type.__name__}. Error: {e}. Trying default '{default}'...{Style.RESET_ALL}"
            )
            # Try casting the default again if the primary value failed
            if default is None:
                if required:  # Should have been caught above, but defensive check
                     raise ValueError(f"Required env var '{var_name}' failed casting and has no valid default.")
                return None
            try:
                if expected_type == bool:
                    if isinstance(default, str): return default.lower() in ('true', '1', 't', 'yes', 'y')
                    return bool(default)
                elif expected_type == Decimal: return Decimal(str(default))
                else: return expected_type(default)
            except (ValueError, TypeError, InvalidOperation) as e_default:
                logger.critical(
                    f"{Back.RED}{Fore.WHITE}CRITICAL CONFIG: Default '{default}' for {var_name} is also incompatible "
                    f"with type {expected_type.__name__}. Error: {e_default}. Cannot proceed.{Style.RESET_ALL}"
                )
                raise ValueError(f"Configuration error: Cannot cast value or default for key '{var_name}' to {expected_type.__name__}.")


# --- Global Objects - Instantiated Arcana ---
try:
    CONFIG = Config()  # Forge the configuration object
except ValueError as config_err:
    # Error already logged within Config init or _get_env
    # Attempt to send SMS even if config partially failed (if SMS settings were read)
    # Check if CONFIG object exists and has necessary attributes before trying to send SMS
    config_exists = 'CONFIG' in globals() and hasattr(CONFIG, 'enable_sms_alerts') and hasattr(CONFIG, 'sms_recipient_number')
    if config_exists and CONFIG.enable_sms_alerts and CONFIG.sms_recipient_number:
         # Import send_sms_alert here or define it earlier if needed for this edge case
         # For simplicity, assume send_sms_alert is defined before this point
         try:
             # Define send_sms_alert minimally if it's not available yet
             if 'send_sms_alert' not in globals():
                 def send_sms_alert(message: str) -> bool:
                     logger.warning(f"Attempted emergency SMS, but function not fully loaded: {message}")
                     return False
             send_sms_alert(f"[ScalpBot] CRITICAL: Config validation FAILED: {config_err}. Bot stopped.")
         except Exception as sms_err: # Catch errors during the emergency SMS itself
             logger.error(f"Failed to send critical config failure SMS: {sms_err}")
    sys.exit(1)

# --- Termux SMS Alert Function - Sending Whispers ---
_termux_sms_command_exists: Optional[bool] = None  # Cache check result


def send_sms_alert(message: str) -> bool:
    """Sends an SMS alert using Termux API, a whisper through the digital veil."""
    global _termux_sms_command_exists

    if not CONFIG.enable_sms_alerts:
        logger.debug("SMS alerts disabled by configuration.")
        return False

    # Check for command existence only once
    if _termux_sms_command_exists is None:
        _termux_sms_command_exists = shutil.which('termux-sms-send') is not None
        if not _termux_sms_command_exists:
             logger.warning(f"{Fore.YELLOW}SMS failed: 'termux-sms-send' command not found. Ensure Termux:API is installed (`pkg install termux-api`) and configured.{Style.RESET_ALL}")

    if not _termux_sms_command_exists:
        return False  # Don't proceed if command is missing

    if not CONFIG.sms_recipient_number:
        logger.warning(f"{Fore.YELLOW}SMS alerts enabled, but SMS_RECIPIENT_NUMBER rune is missing.{Style.RESET_ALL}")
        return False

    try:
        # Prepare the command spell
        command: List[str] = ['termux-sms-send', '-n', CONFIG.sms_recipient_number, message]
        logger.info(f"{Fore.MAGENTA}Dispatching SMS whisper to {CONFIG.sms_recipient_number} (Timeout: {CONFIG.sms_timeout_seconds}s)...{Style.RESET_ALL}")
        # Execute the spell via subprocess
        result = subprocess.run(command, capture_output=True, text=True, check=False, timeout=CONFIG.sms_timeout_seconds)
        if result.returncode == 0:
            logger.success(f"{Fore.MAGENTA}SMS whisper dispatched successfully.{Style.RESET_ALL}")
            return True
        else:
            logger.error(f"{Fore.RED}SMS whisper failed. RC: {result.returncode}, Stderr: {result.stderr.strip()}{Style.RESET_ALL}")
            return False
    except FileNotFoundError:
        # This shouldn't happen due to the check above, but handle defensively
        logger.error(f"{Fore.RED}SMS failed: 'termux-sms-send' vanished unexpectedly?{Style.RESET_ALL}")
        _termux_sms_command_exists = False  # Update cache
        return False
    except subprocess.TimeoutExpired:
        logger.error(f"{Fore.RED}SMS failed: Command timed out after {CONFIG.sms_timeout_seconds}s.{Style.RESET_ALL}")
        return False
    except Exception as e:
        logger.error(f"{Fore.RED}SMS failed: Unexpected disturbance: {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())
        return False


# --- Exchange Initialization - Opening the Portal ---
def initialize_exchange() -> Optional[ccxt.Exchange]:
    """Initializes and returns the CCXT Bybit exchange instance, opening a portal."""
    logger.info(f"{Fore.BLUE}Opening portal to Bybit via CCXT...{Style.RESET_ALL}")
    # API keys already checked in Config, but double-check instance variables
    if not CONFIG.api_key or not CONFIG.api_secret:
         logger.critical(f"{Back.RED}{Fore.WHITE}CRITICAL: API keys check failed during initialization.{Style.RESET_ALL}")
         return None

    try:
        exchange = ccxt.bybit(
            {
                'apiKey': CONFIG.api_key,
                'secret': CONFIG.api_secret,
                'enableRateLimit': True,  # Built-in rate limiting
                'options': {
                    'adjustForTimeDifference': True,  # Adjust for clock skew
                    'recvWindow': CONFIG.default_recv_window,  # Increase if timestamp errors occur
                    'defaultType': 'swap',  # Explicitly default to swap markets (linear/inverse determined by symbol)
                    'warnOnFetchOpenOrdersWithoutSymbol': False,  # Suppress common warning
                    'brokerId': 'Pyrmethus_Scalp_v10.1',  # Optional: Identify the bot
                    'defaultMarginMode': 'isolated', # Explicitly set default margin mode if desired, though leverage setting might override
                    'createMarketBuyOrderRequiresPrice': False # Bybit V5 doesn't require price for market buy
                }
            }
        )
        # Explicitly set API version to v5 if CCXT doesn't default correctly (usually not needed)
        # exchange.set_sandbox_mode(False) # Ensure not in sandbox unless intended

    except Exception as e:
        logger.critical(f"{Back.RED}{Fore.WHITE}CRITICAL: Failed to instantiate CCXT Bybit object: {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())
        send_sms_alert(f"[ScalpBot] CRITICAL: CCXT Instantiation Error: {type(e).__name__}. Bot stopped.")
        return None

    try:
        # Test connection and authentication by fetching markets and balance
        logger.debug("Loading market structures...")
        exchange.load_markets()
        logger.debug("Fetching balance (tests authentication)...")
        # Specify params for V5 balance fetch if needed (e.g., account type)
        # For USDT perpetual, accountType='CONTRACT' is typical for V5 unified margin,
        # but CCXT might handle this based on the market type. Let's try without first.
        # Bybit V5 requires accountType for fetchBalance
        # For USDT Perpetual, it's 'CONTRACT'. For USDC Perpetual, it's 'UNIFIED'.
        # Determine based on symbol quote currency? Or assume USDT for now.
        # Let's assume USDT perpetual -> 'CONTRACT'
        balance_params = {'accountType': 'CONTRACT'} # Adjust if using USDC or other account types
        balance = exchange.fetch_balance(params=balance_params)
        total_usdt = balance.get(TOTAL_KEY, {}).get(USDT_SYMBOL, 'N/A')
        logger.debug(f"Initial balance fetched: {total_usdt} {USDT_SYMBOL}")
        logger.success(f"{Fore.GREEN}{Style.BRIGHT}Portal to Bybit Opened (LIVE SCALPING MODE - EXTREME CAUTION!).{Style.RESET_ALL}")
        send_sms_alert("[ScalpBot] Initialized successfully and authenticated.")
        return exchange

    except ccxt.AuthenticationError as e:
        logger.critical(f"{Back.RED}{Fore.WHITE}Authentication failed: {e}. Check API key/secret and ensure IP whitelist (if used) is correct and API permissions are sufficient.{Style.RESET_ALL}")
        send_sms_alert(f"[ScalpBot] CRITICAL: Authentication FAILED: {e}. Bot stopped.")
        return None
    except ccxt.NetworkError as e:
        logger.critical(f"{Back.RED}{Fore.WHITE}Network error during initialization: {e}. Check internet connection and Bybit status.{Style.RESET_ALL}")
        send_sms_alert(f"[ScalpBot] CRITICAL: Network Error on Init: {e}. Bot stopped.")
        return None
    except ccxt.ExchangeError as e:
        logger.critical(f"{Back.RED}{Fore.WHITE}Exchange error during initialization: {e}. Check Bybit status page or API documentation for details.{Style.RESET_ALL}")
        send_sms_alert(f"[ScalpBot] CRITICAL: Exchange Error on Init: {e}. Bot stopped.")
        return None
    except Exception as e:
        logger.critical(f"{Back.RED}{Fore.WHITE}Unexpected error initializing exchange: {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())
        send_sms_alert(f"[ScalpBot] CRITICAL: Unexpected Init Error: {type(e).__name__}. Bot stopped.")
        return None


# --- Indicator Calculation Functions - Scrying the Market ---
def calculate_supertrend(
    df: pd.DataFrame, length: int, multiplier: float, prefix: str = ""
) -> pd.DataFrame:
     """Calculates the Supertrend indicator using the pandas_ta library."""
     required_input_cols = ['high', 'low', 'close']
     col_prefix = f"{prefix}" if prefix else ""
     # Define target column names clearly
     target_st_val_col = f"{col_prefix}st_value"
     target_st_trend_col = f"{col_prefix}trend"
     target_st_long_flip_col = f"{col_prefix}st_long_flip"
     target_st_short_flip_col = f"{col_prefix}st_short_flip"
     target_cols = [target_st_val_col, target_st_trend_col, target_st_long_flip_col, target_st_short_flip_col]

     # Define expected pandas_ta column names (adjust if pandas_ta version changes output)
     pta_st_col_name = f"SUPERT_{length}_{multiplier}"
     pta_st_trend_col = f"SUPERTd_{length}_{multiplier}"
     pta_st_long_col = f"SUPERTl_{length}_{multiplier}" # pandas_ta uses 'l' for long band
     pta_st_short_col = f"SUPERTs_{length}_{multiplier}" # pandas_ta uses 's' for short band
     expected_pta_cols = [pta_st_col_name, pta_st_trend_col, pta_st_long_col, pta_st_short_col]

     if df is None or df.empty or not all(c in df.columns for c in required_input_cols):
         logger.warning(f"{Fore.YELLOW}Scrying ({col_prefix}Supertrend): Input DataFrame is missing required columns {required_input_cols} or is empty.{Style.RESET_ALL}")
         # Ensure target columns exist with NA if input is invalid but not None
         if df is not None:
             for col in target_cols: df[col] = pd.NA
         return df if df is not None else pd.DataFrame()

     if len(df) < length:
         logger.warning(f"{Fore.YELLOW}Scrying ({col_prefix}Supertrend): DataFrame length ({len(df)}) is less than ST period ({length}). Filling with NA.{Style.RESET_ALL}")
         for col in target_cols: df[col] = pd.NA
         return df

     try:
         logger.debug(f"Scrying ({col_prefix}ST): Calculating with length={length}, multiplier={multiplier}")
         # Ensure input columns are numeric
         for col in required_input_cols:
             df[col] = pd.to_numeric(df[col], errors='coerce')
         if df[required_input_cols].isnull().values.any():
              logger.warning(f"{Fore.YELLOW}Scrying ({col_prefix}ST): NaNs found in input data before calculation. Results may be affected.{Style.RESET_ALL}")
              # Optionally fill NaNs here if appropriate (e.g., df.ffill(inplace=True))

         # Calculate Supertrend using pandas_ta
         df.ta.supertrend(length=length, multiplier=multiplier, append=True)

         # Check if pandas_ta created the expected columns
         missing_pta_cols = [col for col in expected_pta_cols if col not in df.columns]
         if missing_pta_cols:
              raise KeyError(f"pandas_ta failed to create expected raw columns: {', '.join(missing_pta_cols)}")

         # Convert potentially generated columns to numeric, coercing errors
         for col in expected_pta_cols:
             if col in df.columns:
                 df[col] = pd.to_numeric(df[col], errors='coerce')

         # Rename and process
         # Check if target columns already exist before renaming (e.g., from previous runs)
         # Use errors='ignore' in case columns don't exist yet
         df.drop(columns=[target_st_val_col, target_st_trend_col], inplace=True, errors='ignore')
         df.rename(columns={pta_st_col_name: target_st_val_col}, inplace=True)  # Supertrend value
         df.rename(columns={pta_st_trend_col: target_st_trend_col}, inplace=True)  # Trend direction (-1, 1)

         # Calculate flip signals based on trend change
         prev_trend_direction = df[target_st_trend_col].shift(1)
         # Long flip: Previous was Down (-1) and Current is Up (1)
         df[target_st_long_flip_col] = (prev_trend_direction == -1) & (df[target_st_trend_col] == 1)
         # Short flip: Previous was Up (1) and Current is Down (-1)
         df[target_st_short_flip_col] = (prev_trend_direction == 1) & (df[target_st_trend_col] == -1)
         # Ensure boolean type and fill NA (especially first row) with False
         df[[target_st_long_flip_col, target_st_short_flip_col]] = df[[target_st_long_flip_col, target_st_short_flip_col]].fillna(False).astype(bool)

         # Clean up intermediate columns generated by pandas_ta
         # Drop the original long/short band columns and any other potential intermediates
         cols_to_drop = [pta_st_long_col, pta_st_short_col] + [c for c in df.columns if c.startswith("SUPERT_") and c not in target_cols]
         # Ensure we don't try to drop columns that weren't created or already dropped
         cols_to_drop_existing = [col for col in cols_to_drop if col in df.columns]
         if cols_to_drop_existing:
             df.drop(columns=list(set(cols_to_drop_existing)), errors='ignore', inplace=True)

         # Log last candle result
         if not df.empty:
             last_trend_val = df[target_st_trend_col].iloc[-1] if pd.notna(df[target_st_trend_col].iloc[-1]) else None
             last_st_val = df[target_st_val_col].iloc[-1] if pd.notna(df[target_st_val_col].iloc[-1]) else float('nan')
             last_trend_str = 'Up' if last_trend_val == 1 else 'Down' if last_trend_val == -1 else 'N/A'
             trend_color = Fore.GREEN if last_trend_str == 'Up' else Fore.RED if last_trend_str == 'Down' else Fore.WHITE
             logger.debug(f"Scrying ({col_prefix}ST({length}, {multiplier})): Last Trend={trend_color}{last_trend_str}{Style.RESET_ALL}, Last Value={last_st_val:.4f}")
         else:
             logger.debug(f"Scrying ({col_prefix}ST): DataFrame became empty during processing.")

     except (KeyError, AttributeError, Exception) as e:
         logger.error(f"{Fore.RED}Scrying ({col_prefix}Supertrend): Error during calculation: {e}{Style.RESET_ALL}")
         logger.debug(traceback.format_exc())
         # Ensure target columns exist with NA on error
         for col in target_cols: df[col] = pd.NA
     return df


def analyze_volume_atr(
     df: pd.DataFrame, atr_len: int, vol_ma_len: int
) -> Dict[str, Optional[Decimal]]:
     """Calculates ATR, Volume MA, and checks for volume spikes."""
     results: Dict[str, Optional[Decimal]] = {ATR_KEY: None, VOLUME_MA_KEY: None, LAST_VOLUME_KEY: None, VOLUME_RATIO_KEY: None}
     required_cols = ['high', 'low', 'close', 'volume']

     if df is None or df.empty or not all(c in df.columns for c in required_cols):
         logger.warning(f"{Fore.YELLOW}Scrying (Vol/ATR): Input DataFrame is missing required columns {required_cols} or is empty.{Style.RESET_ALL}")
         return results
     min_len = max(atr_len, vol_ma_len, 1) # Need at least 1 row for volume, more for indicators
     if len(df) < min_len:
           logger.warning(f"{Fore.YELLOW}Scrying (Vol/ATR): DataFrame length ({len(df)}) < required ({min_len}) for ATR({atr_len})/VolMA({vol_ma_len}).{Style.RESET_ALL}")
           return results

     try:
         # Ensure numeric types, coercing errors to NaN
         for col in required_cols: df[col] = pd.to_numeric(df[col], errors='coerce')
         if df[required_cols].isnull().values.any(): logger.warning(f"{Fore.YELLOW}Scrying (Vol/ATR): NaNs found in input data after coercion. Results may be inaccurate.{Style.RESET_ALL}")

         # Calculate ATR using pandas_ta
         atr_col = f"ATRr_{atr_len}" # Default ATR column name from pandas_ta
         df.ta.atr(length=atr_len, append=True)
         if atr_col in df.columns and pd.notna(df[atr_col].iloc[-1]):
            with contextlib.suppress(InvalidOperation, ValueError, TypeError):
                # Convert to string first for Decimal robustness
                results[ATR_KEY] = Decimal(str(df[atr_col].iloc[-1]))
            if results[ATR_KEY] is None:
                logger.warning(f"Scrying (ATR): Invalid Decimal value for ATR: {df[atr_col].iloc[-1]}.")
         else:
             logger.warning(f"Scrying: Failed to calculate valid ATR({atr_len}). Column '{atr_col}' missing or last value is NaN.")
         # Clean up ATR column if it exists
         if atr_col in df.columns: df.drop(columns=[atr_col], errors='ignore', inplace=True)

         # Calculate Volume MA
         volume_ma_col = f"volume_ma_{vol_ma_len}"
         # Use min_periods=1 to get a value even if window isn't full, but be aware of implications
         df[volume_ma_col] = df['volume'].rolling(window=vol_ma_len, min_periods=max(1, vol_ma_len // 2)).mean()

         if pd.notna(df[volume_ma_col].iloc[-1]) and pd.notna(df['volume'].iloc[-1]):
            with contextlib.suppress(InvalidOperation, ValueError, TypeError):
                # Convert to string first for Decimal robustness
                results[VOLUME_MA_KEY] = Decimal(str(df[volume_ma_col].iloc[-1]))
                results[LAST_VOLUME_KEY] = Decimal(str(df['volume'].iloc[-1]))
            if results[VOLUME_MA_KEY] is None or results[LAST_VOLUME_KEY] is None:
                 logger.warning(f"Scrying (Vol): Invalid Decimal value for Volume/MA. Vol: {df['volume'].iloc[-1]}, MA: {df[volume_ma_col].iloc[-1]}.")

            # Calculate Volume Ratio
            # Ensure both values are valid Decimals and MA is not effectively zero
            if results[VOLUME_MA_KEY] is not None and results[VOLUME_MA_KEY] > CONFIG.position_qty_epsilon and results[LAST_VOLUME_KEY] is not None:
                with contextlib.suppress(InvalidOperation, ZeroDivisionError): # Catch division by zero explicitly
                    results[VOLUME_RATIO_KEY] = (results[LAST_VOLUME_KEY] / results[VOLUME_MA_KEY]).quantize(Decimal("0.01"))
                if results[VOLUME_RATIO_KEY] is None:
                    logger.warning(f"Scrying (Vol): Invalid Decimal operation for ratio. LastVol={results[LAST_VOLUME_KEY]}, VolMA={results[VOLUME_MA_KEY]}.")
            else:
                results[VOLUME_RATIO_KEY] = None
                logger.debug(f"Scrying (Vol): Ratio calc skipped (LastVol={results.get(LAST_VOLUME_KEY)}, MA={results.get(VOLUME_MA_KEY)})")
         else:
             logger.warning(f"Scrying (Vol): Failed calc VolMA({vol_ma_len}) or get last vol. LastVol: {df['volume'].iloc[-1]}, LastMA: {df[volume_ma_col].iloc[-1]}")
         # Clean up volume MA column if it exists
         if volume_ma_col in df.columns: df.drop(columns=[volume_ma_col], errors='ignore', inplace=True)

         # Log results
         atr_str = f"{results[ATR_KEY]:.4f}" if results[ATR_KEY] is not None else 'N/A'
         last_vol_val = results.get(LAST_VOLUME_KEY)
         vol_ma_val = results.get(VOLUME_MA_KEY)
         vol_ratio_val = results.get(VOLUME_RATIO_KEY)
         last_vol_str = f"{last_vol_val:.2f}" if last_vol_val is not None else 'N/A'
         vol_ma_str = f"{vol_ma_val:.2f}" if vol_ma_val is not None else 'N/A'
         vol_ratio_str = f"{vol_ratio_val:.2f}" if vol_ratio_val is not None else 'N/A'

         logger.debug(f"Scrying Results: ATR({atr_len}) = {Fore.CYAN}{atr_str}{Style.RESET_ALL}")
         logger.debug(f"Scrying Results: Volume: Last={last_vol_str}, MA({vol_ma_len})={vol_ma_str}, Ratio={Fore.YELLOW}{vol_ratio_str}{Style.RESET_ALL}")

     except Exception as e:
         logger.error(f"{Fore.RED}Scrying (Vol/ATR): Error during calculation: {e}{Style.RESET_ALL}")
         logger.debug(traceback.format_exc())
         results = {key: None for key in results} # Reset results on error
     return results


def analyze_order_book(
     exchange: ccxt.Exchange, symbol: str, depth: int, fetch_limit: int, market_info: Optional[Dict] = None
) -> Dict[str, Optional[Decimal]]:
     """Fetches L2 order book and analyzes bid/ask pressure and spread."""
     results: Dict[str, Optional[Decimal]] = {BID_ASK_RATIO_KEY: None, SPREAD_KEY: None, BEST_BID_KEY: None, BEST_ASK_KEY: None}
     logger.debug(f"Order Book Scrying: Fetching L2 for {symbol} (Analyze Depth: {depth}, API Fetch Limit: {fetch_limit})...")

     try:
         order_book = exchange.fetch_l2_order_book(symbol, limit=fetch_limit)

         if not order_book or not isinstance(order_book.get(BIDS_KEY), list) or not isinstance(order_book.get(ASKS_KEY), list):
             logger.warning(f"{Fore.YELLOW}Order Book Scrying: Incomplete or invalid data structure received for {symbol}.{Style.RESET_ALL}")
             return results

         bids: List[List[Union[float, str]]] = order_book[BIDS_KEY]
         asks: List[List[Union[float, str]]] = order_book[ASKS_KEY]

         if not bids or not asks:
             logger.warning(f"{Fore.YELLOW}Order Book Scrying: Bids or asks list is empty for {symbol}. Bids: {len(bids)}, Asks: {len(asks)}{Style.RESET_ALL}")
             return results

         # Get best bid/ask and calculate spread
         try:
             # Ensure there's data at index 0 and the inner list has at least one element (price)
             if len(bids) > 0 and len(bids[0]) > 0 and len(asks) > 0 and len(asks[0]) > 0:
                 best_bid_raw = bids[0][0]
                 best_ask_raw = asks[0][0]
                 # Convert to string first for Decimal robustness
                 results[BEST_BID_KEY] = Decimal(str(best_bid_raw))
                 results[BEST_ASK_KEY] = Decimal(str(best_ask_raw))

                 if results[BEST_BID_KEY] > 0 and results[BEST_ASK_KEY] > 0:
                      spread = results[BEST_ASK_KEY] - results[BEST_BID_KEY]
                      # Determine price precision dynamically if possible
                      price_precision = Decimal('0.0001') # Default precision
                      try:
                          # Use passed market_info if available
                          local_market_info = market_info or exchange.market(symbol)
                          price_prec_str = local_market_info.get(PRECISION_KEY, {}).get(PRICE_KEY)
                          if price_prec_str: price_precision = Decimal(str(price_prec_str))
                      except Exception as market_err:
                          logger.debug(f"OB Scrying: Could not get market precision for spread calc: {market_err}. Using default.")
                      results[SPREAD_KEY] = spread.quantize(price_precision)
                      logger.debug(f"OB Scrying: Best Bid={Fore.GREEN}{results[BEST_BID_KEY]}{Style.RESET_ALL}, Best Ask={Fore.RED}{results[BEST_ASK_KEY]}{Style.RESET_ALL}, Spread={Fore.YELLOW}{results[SPREAD_KEY]}{Style.RESET_ALL}")
                 else:
                      logger.debug("OB Scrying: Could not calculate spread (Best Bid/Ask zero or invalid).")
             else:
                 logger.warning(f"{Fore.YELLOW}OB Scrying: Best bid/ask data missing or incomplete.{Style.RESET_ALL}")

         except (IndexError, InvalidOperation, ValueError, TypeError) as e:
              logger.warning(f"{Fore.YELLOW}OB Scrying: Error processing best bid/ask/spread for {symbol}: {e}{Style.RESET_ALL}")
              results[BEST_BID_KEY] = None; results[BEST_ASK_KEY] = None; results[SPREAD_KEY] = None

         # Calculate cumulative volume within depth
         try:
             # Ensure inner lists have at least two elements (price, volume)
             # Convert to string first for Decimal robustness
             bid_volume_sum_raw = sum(Decimal(str(bid[1])) for bid in bids[:depth] if len(bid) > 1)
             ask_volume_sum_raw = sum(Decimal(str(ask[1])) for ask in asks[:depth] if len(ask) > 1)
             # Use a reasonable precision for volume sums
             vol_precision = Decimal("0.0001")
             bid_volume_sum = bid_volume_sum_raw.quantize(vol_precision)
             ask_volume_sum = ask_volume_sum_raw.quantize(vol_precision)
             logger.debug(f"OB Scrying (Depth {depth}): Cum Bid={Fore.GREEN}{bid_volume_sum}{Style.RESET_ALL}, Cum Ask={Fore.RED}{ask_volume_sum}{Style.RESET_ALL}")

             # Calculate Bid/Ask Ratio
             if ask_volume_sum > CONFIG.position_qty_epsilon:
                  with contextlib.suppress(InvalidOperation, ZeroDivisionError):
                      bid_ask_ratio = (bid_volume_sum / ask_volume_sum).quantize(Decimal("0.01"))
                      results[BID_ASK_RATIO_KEY] = bid_ask_ratio
                  if results[BID_ASK_RATIO_KEY] is not None:
                      ratio_color = Fore.GREEN if results[BID_ASK_RATIO_KEY] >= CONFIG.order_book_ratio_threshold_long else (Fore.RED if results[BID_ASK_RATIO_KEY] <= CONFIG.order_book_ratio_threshold_short else Fore.YELLOW)
                      logger.debug(f"OB Scrying Ratio (Depth {depth}) = {ratio_color}{results[BID_ASK_RATIO_KEY]:.3f}{Style.RESET_ALL}")
                  else:
                      logger.warning(f"OB Scrying Ratio calculation failed (InvalidOp/ZeroDiv). BidSum={bid_volume_sum}, AskSum={ask_volume_sum}")
             else:
                  logger.debug(f"OB Scrying Ratio calculation skipped (Ask volume at depth {depth} is zero or negligible)")

         except (IndexError, InvalidOperation, ValueError, TypeError) as e:
              logger.warning(f"{Fore.YELLOW}OB Scrying: Error calculating cumulative volume or ratio for {symbol}: {e}{Style.RESET_ALL}")
              results[BID_ASK_RATIO_KEY] = None

     except (ccxt.NetworkError, ccxt.ExchangeError) as e:
         logger.warning(f"{Fore.YELLOW}OB Scrying: API error fetching order book for {symbol}: {e}{Style.RESET_ALL}")
     except (IndexError, InvalidOperation, ValueError, TypeError) as e:
         # Catch potential errors from processing the raw OB data structure
         logger.warning(f"{Fore.YELLOW}OB Scrying: Error processing OB data structure for {symbol}: {e}{Style.RESET_ALL}")
     except Exception as e:
         logger.error(f"{Fore.RED}OB Scrying: Unexpected error analyzing order book for {symbol}: {e}{Style.RESET_ALL}")
         logger.debug(traceback.format_exc())
         return {key: None for key in results}  # Return None dict on error

     return results


# --- Data Fetching - Gathering Etheric Data Streams ---
def fetch_ohlcv(exchange: ccxt.Exchange, symbol: str, timeframe: str, limit: int) -> Optional[pd.DataFrame]:
    """Fetches OHLCV data with retries and basic validation."""
    logger.info(f"Data Fetch: Gathering {limit} {timeframe} candles for {symbol}...")
    for attempt in range(CONFIG.retry_count):
        try:
            # Fetch OHLCV data
            ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit=limit)

            if not ohlcv:
                logger.warning(f"{Fore.YELLOW}Data Fetch: Received empty OHLCV data for {symbol} on attempt {attempt + 1}.{Style.RESET_ALL}")
                if attempt < CONFIG.retry_count - 1:
                    time.sleep(CONFIG.retry_delay_seconds)
                    continue
                else: return None  # Return None after final retry

            # Convert to DataFrame
            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            # Convert timestamp to UTC datetime objects
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms', utc=True)
            df.set_index('timestamp', inplace=True)

            # --- Basic Data Validation ---
            if df.empty:
                logger.warning(f"{Fore.YELLOW}Data Fetch: DataFrame is empty after conversion for {symbol}.{Style.RESET_ALL}")
                return None  # Cannot proceed with empty DataFrame

            # Ensure correct data types before NaN checks
            # Convert OHLCV columns to numeric, coercing errors to NaN
            for col in ['open', 'high', 'low', 'close', 'volume']:
                df[col] = pd.to_numeric(df[col], errors='coerce')

            # Check for NaNs introduced by conversion or present in original data
            if df.isnull().values.any():
                nan_counts = df.isnull().sum()
                logger.warning(f"{Fore.YELLOW}Data Fetch: Fetched OHLCV data contains NaN values after numeric conversion. Counts:\n{nan_counts[nan_counts > 0]}\nAttempting forward fill...{Style.RESET_ALL}")
                # Simple imputation: Forward fill NaNs. More sophisticated methods could be used.
                df.ffill(inplace=True)
                # Check again after filling - if NaNs remain (e.g., at the very beginning), data is unusable
                if df.isnull().values.any():
                    logger.error(f"{Fore.RED}Data Fetch: NaN values remain after forward fill. Cannot proceed with this data batch.{Style.RESET_ALL}")
                    return None

            logger.debug(f"Data Fetch: Successfully woven {len(df)} OHLCV candles for {symbol}.")
            return df

        except (ccxt.NetworkError, ccxt.ExchangeError) as e:
            logger.warning(f"{Fore.YELLOW}Data Fetch: API error fetching OHLCV for {symbol} (Attempt {attempt + 1}/{CONFIG.retry_count}): {e}{Style.RESET_ALL}")
            if attempt < CONFIG.retry_count - 1:
                time.sleep(CONFIG.retry_delay_seconds)
            else:
                logger.error(f"{Fore.RED}Data Fetch: Failed to fetch OHLCV for {symbol} after {CONFIG.retry_count} attempts.{Style.RESET_ALL}")
                return None
        except Exception as e:
            logger.error(f"{Fore.RED}Data Fetch: Unexpected error fetching market data for {symbol}: {e}{Style.RESET_ALL}")
            logger.debug(traceback.format_exc())
            return None  # Return None on unexpected errors

    return None  # Should not be reached if loop completes, but included for safety


# --- Position & Order Management - Manipulating Market Presence ---
def get_current_position(exchange: ccxt.Exchange, symbol: str) -> Dict[str, Any]:
     """Fetches current position details for Bybit V5 via CCXT. Returns Decimal for qty/price."""
     # Default: no active position, using Decimal for precision
     default_pos: Dict[str, Any] = {SIDE_KEY: POSITION_SIDE_NONE, QTY_KEY: Decimal('0.0'), ENTRY_PRICE_KEY: Decimal('0.0')}
     ccxt_unified_symbol = symbol
     market_id = None
     market = None

     # Get Market Info
     try:
         market = exchange.market(ccxt_unified_symbol)
         if not market: raise KeyError(f"Market info not found for {ccxt_unified_symbol}")
         market_id = market.get(ID_KEY) # The exchange-specific market ID (e.g., 'BTCUSDT')
         if not market_id: raise KeyError(f"Market ID not found in market info for {ccxt_unified_symbol}")
         logger.debug(f"Position Check: Fetching position for CCXT symbol '{ccxt_unified_symbol}' (Target Exchange Market ID: '{market_id}')...")
     except (ccxt.BadSymbol, KeyError) as e:
          logger.error(f"{Fore.RED}Position Check: Failed get market info/ID for '{ccxt_unified_symbol}': {e}{Style.RESET_ALL}")
          return default_pos
     except Exception as e:
          logger.error(f"{Fore.RED}Position Check: Unexpected error getting market info for '{ccxt_unified_symbol}': {e}{Style.RESET_ALL}")
          logger.debug(traceback.format_exc())
          return default_pos

     # Fetch Positions
     try:
         if not exchange.has.get('fetchPositions'):
             logger.warning(f"{Fore.YELLOW}Position Check: Exchange '{exchange.id}' may not support fetchPositions.{Style.RESET_ALL}")
             return default_pos

         # Determine category for V5 API call based on market info (linear/inverse)
         params = {}
         if market and market.get(LINEAR_KEY, False): params = {PARAM_CATEGORY: LINEAR_KEY}
         elif market and market.get(INVERSE_KEY, False): params = {PARAM_CATEGORY: INVERSE_KEY}
         else:
             # If market type unknown, try linear as a default (most common for USDT perps)
             logger.warning(f"{Fore.YELLOW}Position Check: Market type for {symbol} unclear, defaulting category to 'linear'.{Style.RESET_ALL}")
             params = {PARAM_CATEGORY: LINEAR_KEY}

         # Fetch positions for the specific symbol
         # Setting settle coin might also be needed for V5 depending on account type (e.g., USDT for linear)
         # params[PARAM_SETTLE_COIN] = USDT_SYMBOL # Add if needed, depends on account type and CCXT handling
         positions = exchange.fetch_positions(symbols=[ccxt_unified_symbol], params=params)
         logger.debug(f"Fetched positions data (raw count: {len(positions)}) for symbol {ccxt_unified_symbol}")

         # Filter positions: Bybit V5 fetchPositions returns multiple entries even for one symbol/mode.
         # We need the one for the correct market_id AND One-Way mode (positionIdx=0).
         active_position_found = None
         for pos in positions:
             pos_info = pos.get(INFO_KEY, {})
             pos_symbol_raw = pos_info.get(SYMBOL_KEY) # Raw symbol from exchange ('BTCUSDT')

             # 1. Match the raw symbol from the position data with the market ID we expect
             if pos_symbol_raw != market_id:
                 # logger.debug(f"Skipping position entry, symbol mismatch: '{pos_symbol_raw}' != '{market_id}'")
                 continue

             # 2. Check for One-Way Mode (positionIdx=0) - V5 returns as string
             position_idx_str = pos_info.get(PARAM_POSITION_IDX, '-1')
             try:
                 position_idx = int(position_idx_str)
             except (ValueError, TypeError):
                 logger.warning(f"Could not parse positionIdx '{position_idx_str}' for {market_id}. Skipping.")
                 continue
             if position_idx != 0:
                 # logger.debug(f"Skipping position entry for {market_id}, not One-Way mode (positionIdx={position_idx}).")
                 continue # Skip hedge mode positions

             # If we found the entry for our symbol and One-Way mode, this is the one.
             active_position_found = pos
             logger.debug(f"Position Check: Found matching One-Way mode entry for {market_id}.")
             break # Stop searching once the correct entry is found

         # Process the found position (if any)
         if active_position_found:
             pos_info = active_position_found.get(INFO_KEY, {})
             # Check Side (V5: 'Buy', 'Sell', 'None')
             pos_side_v5 = pos_info.get(SIDE_KEY, POSITION_SIDE_NONE) # Raw side from exchange
             determined_side = POSITION_SIDE_NONE
             if pos_side_v5 == BYBIT_SIDE_BUY: determined_side = POSITION_SIDE_LONG
             elif pos_side_v5 == BYBIT_SIDE_SELL: determined_side = POSITION_SIDE_SHORT
             # If side is 'None', it implies no position or a flat state for this entry

             # Check Position Size (V5: 'size') - this is the key indicator of an active position
             size_str = pos_info.get(PARAM_SIZE)
             if size_str is None or size_str == "":
                 logger.debug(f"Position Check: Size field missing for {market_id}. Assuming flat.")
                 return default_pos # Treat as flat if size is missing

             try:
                 # Convert size string to Decimal
                 size = Decimal(str(size_str))
                 # Check if size is significantly different from zero using epsilon
                 if abs(size) > CONFIG.position_qty_epsilon:
                     # Found active position! Get entry price.
                     # Prefer raw V5 avgPrice, fallback to CCXT unified entryPrice (less reliable for V5?)
                     entry_price_str = pos_info.get(AVG_PRICE_KEY) # Prioritize V5 raw field
                     if entry_price_str is None or entry_price_str == "":
                         # Fallback to unified field if V5 raw field is missing
                         entry_price_str = active_position_found.get(ENTRY_PRICE_KEY)
                         logger.debug(f"Position Check: Using fallback CCXT unified entryPrice field for {market_id}.")

                     entry_price = Decimal('0.0')
                     if entry_price_str is not None and entry_price_str != "":
                         with contextlib.suppress(InvalidOperation, ValueError, TypeError):
                             # Convert entry price string to Decimal
                             entry_price = Decimal(str(entry_price_str))
                         if entry_price == Decimal('0.0'):
                              logger.warning(f"Could not parse entry price string: '{entry_price_str}'. Defaulting to 0.0.")
                     else:
                         logger.warning(f"Position Check: Entry price field (avgPrice/entryPrice) missing or empty for active position {market_id}. Defaulting to 0.0.")

                     qty_abs = abs(size)
                     pos_color = Fore.GREEN if determined_side == POSITION_SIDE_LONG else Fore.RED
                     logger.info(f"{pos_color}Position Check: FOUND Active Position for {market_id}: Side={determined_side}, Qty={qty_abs}, Entry={entry_price:.4f}{Style.RESET_ALL}")
                     return {SIDE_KEY: determined_side, QTY_KEY: qty_abs, ENTRY_PRICE_KEY: entry_price}
                 else:
                     # Size is zero or negligible, treat as flat
                     logger.info(f"{Fore.BLUE}Position Check: Position size for {market_id} is zero/negligible ({size_str}). Treating as flat.{Style.RESET_ALL}")
                     return default_pos

             except (ValueError, TypeError, InvalidOperation) as e:
                  logger.warning(f"{Fore.YELLOW}Position Check: Error parsing size '{size_str}' for {market_id}: {e}{Style.RESET_ALL}")
                  return default_pos # Treat as flat on parsing error
         else:
             # No position entry matched the symbol and One-Way mode criteria
             logger.info(f"{Fore.BLUE}Position Check: No active One-Way Mode position found for {market_id}.{Style.RESET_ALL}")
             return default_pos

     except (ccxt.NetworkError, ccxt.ExchangeError) as e:
         logger.warning(f"{Fore.YELLOW}Position Check: API error during fetch_positions for {symbol}: {e}{Style.RESET_ALL}")
     except Exception as e:
         logger.error(f"{Fore.RED}Position Check: Unexpected error during position check for {symbol}: {e}{Style.RESET_ALL}")
         logger.debug(traceback.format_exc())

     logger.warning(f"{Fore.YELLOW}Position Check: Returning default (No Position) due to error or no active position found for {symbol}.{Style.RESET_ALL}")
     return default_pos


def set_leverage(exchange: ccxt.Exchange, symbol: str, leverage: int) -> bool:
    """Sets leverage for Bybit V5, checks market type, retries."""
    logger.info(f"{Fore.CYAN}Leverage Conjuring: Attempting to set {leverage}x for {symbol}...{Style.RESET_ALL}")
    market_base = "N/A"
    market = None
    try:
        market = exchange.market(symbol)
        if not market: raise KeyError(f"Market info not found for {symbol}")
        market_base = market.get(BASE_KEY, 'N/A')
        # Check if it's a contract market (swap, futures)
        if not market.get(CONTRACT_KEY, False) or market.get(SPOT_KEY, False):
            logger.error(f"{Fore.RED}Leverage Conjuring: Cannot set leverage for non-contract market: {symbol}. Market type: {market.get(TYPE_KEY)}{Style.RESET_ALL}")
            return False
    except (ccxt.BadSymbol, KeyError) as e:
          logger.error(f"{Fore.RED}Leverage Conjuring: Failed to get market info for symbol '{symbol}': {e}{Style.RESET_ALL}")
          return False
    except Exception as e:
          logger.error(f"{Fore.RED}Leverage Conjuring: Unexpected error getting market info for {symbol}: {e}{Style.RESET_ALL}")
          logger.debug(traceback.format_exc())
          return False

    for attempt in range(CONFIG.retry_count):
        try:
            # Bybit V5 requires setting buy and sell leverage separately via set_leverage call in CCXT
            # CCXT handles mapping this to the correct API call structure for Bybit V5
            # The unified method `set_leverage` should handle this abstraction.
            # Bybit V5 also requires specifying margin mode (isolated/cross) when setting leverage.
            # We set 'defaultMarginMode': 'isolated' in initialize_exchange, CCXT should use this.
            logger.debug(f"Leverage Conjuring: Calling exchange.set_leverage({leverage}, '{symbol}') (Attempt {attempt + 1}/{CONFIG.retry_count})")
            # Params might be needed if CCXT abstraction fails:
            # params = {'buyLeverage': str(leverage), 'sellLeverage': str(leverage), 'marginMode': 0} # 0 for isolated, 1 for cross
            response = exchange.set_leverage(leverage=leverage, symbol=symbol) # Rely on CCXT abstraction
            logger.success(f"{Fore.GREEN}Leverage Conjuring: Successfully set leverage to {leverage}x for {symbol}. Response: {response}{Style.RESET_ALL}")
            return True

        except ccxt.ExchangeError as e:
            error_msg_lower = str(e).lower()
            # Bybit V5 specific error codes or messages for "leverage not modified"
            # 110044: "Set leverage not modified" (from Bybit docs)
            # Check for common phrases as well
            if "110044" in str(e) or any(p in error_msg_lower for p in ["leverage not modified", "same leverage", "no need to modify leverage", "leverage is same as requested"]):
                logger.info(f"{Fore.CYAN}Leverage Conjuring: Leverage for {symbol} already set to {leverage}x (Confirmed by exchange message).{Style.RESET_ALL}")
                return True
            logger.warning(f"{Fore.YELLOW}Leverage Conjuring: Exchange resistance on attempt {attempt + 1}/{CONFIG.retry_count} for {symbol}: {e}{Style.RESET_ALL}")
            if attempt < CONFIG.retry_count - 1:
                time.sleep(CONFIG.retry_delay_seconds)
            else:
                logger.error(f"{Fore.RED}Leverage Conjuring: FAILED after {CONFIG.retry_count} attempts due to exchange error: {e}{Style.RESET_ALL}")
                send_sms_alert(f"[{market_base}] CRITICAL: Leverage set FAILED {symbol}.")
                return False
        except ccxt.NetworkError as e:
             logger.warning(f"{Fore.YELLOW}Leverage Conjuring: Network error on attempt {attempt + 1}/{CONFIG.retry_count} for {symbol}: {e}{Style.RESET_ALL}")
             if attempt < CONFIG.retry_count - 1:
                 time.sleep(CONFIG.retry_delay_seconds)
             else:
                 logger.error(f"{Fore.RED}Leverage Conjuring: FAILED after {CONFIG.retry_count} attempts due to network error.{Style.RESET_ALL}")
                 send_sms_alert(f"[{market_base}] CRITICAL: Leverage set FAILED (Network) {symbol}.")
                 return False
        except Exception as e:
             logger.error(f"{Fore.RED}Leverage Conjuring: Unexpected error setting leverage for {symbol} on attempt {attempt + 1}: {e}{Style.RESET_ALL}")
             logger.debug(traceback.format_exc())
             # Fail fast on unexpected errors
             send_sms_alert(f"[{market_base}] CRITICAL: Leverage set FAILED (Unexpected: {type(e).__name__}) {symbol}.")
             return False
    return False


def close_position(
    exchange: ccxt.Exchange, symbol: str, position_to_close: Dict[str, Any], reason: str = "Signal"
) -> Optional[Dict[str, Any]]:
    """Closes active position via market order with reduce_only, validates first."""
    initial_side = position_to_close.get(SIDE_KEY, POSITION_SIDE_NONE)
    initial_qty = position_to_close.get(QTY_KEY, Decimal('0.0'))
    market_base = symbol.split('/')[0] if '/' in symbol else symbol

    logger.info(f"{Fore.YELLOW}Banish Position: Initiated for {symbol}. Reason: {reason}. Initial state: {initial_side} Qty={initial_qty:.8f}{Style.RESET_ALL}")

    # Re-validate Position Before Closing
    logger.debug("Banish Position: Re-validating live position status...")
    live_position = get_current_position(exchange, symbol)
    live_position_side = live_position.get(SIDE_KEY, POSITION_SIDE_NONE)
    live_amount_to_close = live_position.get(QTY_KEY, Decimal('0.0'))  # Absolute value from get_current_position

    if live_position_side == POSITION_SIDE_NONE or live_amount_to_close <= CONFIG.position_qty_epsilon:
        logger.warning(f"{Fore.YELLOW}Banish Position: Discrepancy detected or position already closed. Initial check showed {initial_side}, but live check shows none or negligible qty ({live_amount_to_close:.8f}). Assuming closed.{Style.RESET_ALL}")
        return None # Treat as already closed, no action needed

    # Determine the side of the market order needed to close
    side_to_execute_close = SIDE_SELL if live_position_side == POSITION_SIDE_LONG else SIDE_BUY

    # Place Reduce-Only Market Order
    params = {PARAM_REDUCE_ONLY: True}

    try:
        # Convert the Decimal amount to float for CCXT, applying precision first
        # Use amount_to_precision which returns a string, then convert to float
        amount_str = exchange.amount_to_precision(symbol, float(live_amount_to_close))
        amount_float_prec = float(amount_str)

        if amount_float_prec <= float(CONFIG.position_qty_epsilon): # Check precision-adjusted amount
            logger.error(f"{Fore.RED}Banish Pos: Closing amount {amount_str} ({live_amount_to_close}) negligible after precision. Abort.{Style.RESET_ALL}")
            return None

        logger.warning(f"{Back.YELLOW}{Fore.BLACK}Banish Position: Attempting to CLOSE {live_position_side} position ({reason}): Executing {side_to_execute_close.upper()} MARKET order for {amount_str} {symbol} (Reduce-Only){Style.RESET_ALL}")

        order = exchange.create_market_order(
            symbol=symbol, side=side_to_execute_close, amount=amount_float_prec, params=params
        )

        # Log details immediately using data from the returned order object
        fill_price_str = "?"
        filled_qty_str = "?"
        cost_str = "?"
        order_id_short = str(order.get(ID_KEY, 'N/A'))[-6:]

        # Prefer 'average' for fill price, fallback to 'price'
        avg_price_raw = order.get(AVERAGE_KEY) or order.get(PRICE_KEY)
        if avg_price_raw is not None:
            with contextlib.suppress(InvalidOperation, ValueError, TypeError):
                fill_price_str = f"{Decimal(str(avg_price_raw)):.4f}"

        if order.get(FILLED_KEY) is not None:
            with contextlib.suppress(InvalidOperation, ValueError, TypeError):
                filled_qty_str = f"{Decimal(str(order.get(FILLED_KEY))):.8f}"

        if order.get(COST_KEY) is not None:
            with contextlib.suppress(InvalidOperation, ValueError, TypeError):
                cost_str = f"{Decimal(str(order.get(COST_KEY))):.2f}"

        logger.success(f"{Fore.GREEN}{Style.BRIGHT}Banish Position: CLOSE Order ({reason}) placed successfully for {symbol}. Qty Filled: {filled_qty_str}/{amount_str}, Avg Fill ~{fill_price_str}, Cost: {cost_str} USDT. ID:...{order_id_short}{Style.RESET_ALL}")

        # Send SMS Alert
        sms_msg = (f"[{market_base}] BANISHED {live_position_side} {amount_str} @ ~{fill_price_str} ({reason}). ID:...{order_id_short}")
        send_sms_alert(sms_msg)
        return order # Return the order dictionary

    except ccxt.InsufficientFunds as e:
        logger.error(f"{Fore.RED}Banish Position ({reason}): Insufficient funds error during close attempt: {e}{Style.RESET_ALL}")
        send_sms_alert(f"[{market_base}] ERROR Closing ({reason}): Insuff funds! Check margin.")
    except ccxt.NetworkError as e:
        logger.error(f"{Fore.RED}Banish Position ({reason}): Network error placing close order: {e}{Style.RESET_ALL}")
        send_sms_alert(f"[{market_base}] ERROR Closing ({reason}): Network error! Check connection.")
    except ccxt.ExchangeError as e:
        err_str_lower = str(e).lower()
        # Check for specific errors indicating already closed/closing or order would not reduce
        # Bybit V5 error codes: 110025 ("Position size is zero"), 110043 ("Order would not reduce position size")
        # Also check for common phrases
        if "110025" in str(e) or "110043" in str(e) or any(phrase in err_str_lower for phrase in ["order would not reduce position size", "position is zero", "position size is zero", "cannot be less than", "position has been closed"]):
             logger.warning(f"{Fore.YELLOW}Banish Position ({reason}): Exchange indicates order would not reduce size or position is zero/closed. Assuming already closed. Error: {e}{Style.RESET_ALL}")
             return None  # Treat as success/non-actionable
        logger.error(f"{Fore.RED}Banish Position ({reason}): Exchange error placing close order: {e}{Style.RESET_ALL}")
        send_sms_alert(f"[{market_base}] ERROR Closing ({reason}): API error ({type(e).__name__}).")
    except (ValueError, TypeError, InvalidOperation) as e:
         logger.error(f"{Fore.RED}Banish Position ({reason}): Value error during amount processing (Qty: {live_amount_to_close}): {e}{Style.RESET_ALL}")
         send_sms_alert(f"[{market_base}] ERROR Closing ({reason}): Value error ({type(e).__name__}).")
    except Exception as e:
        logger.error(f"{Fore.RED}Banish Position ({reason}): Unexpected error placing close order: {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())
        send_sms_alert(f"[{market_base}] ERROR Closing ({reason}): Unexpected error ({type(e).__name__}). Check logs!")

    return None # Return None if closing failed


def calculate_position_size(
    equity: Decimal,
    risk_per_trade_pct: Decimal,
    entry_price: Decimal,
    stop_loss_price: Decimal,
    leverage: int,
    symbol: str,
    exchange: ccxt.Exchange,
    market_info: Dict # Pass market info to avoid redundant fetch
) -> Tuple[Optional[Decimal], Optional[Decimal]]:
     """Calculates position size based on risk, checks limits. Returns Decimals."""
     logger.debug(f"Risk Calc Input: Equity={equity:.2f}, Risk%={risk_per_trade_pct:.3%}, Entry={entry_price:.4f}, SL={stop_loss_price:.4f}, Lev={leverage}x, Symbol={symbol}")

     # Input Validation
     if not (entry_price > 0 and stop_loss_price > 0):
         logger.error(f"{Fore.RED}Risk Calc: Invalid entry/SL price (must be > 0). Entry={entry_price}, SL={stop_loss_price}{Style.RESET_ALL}")
         return None, None
     price_difference_per_unit = abs(entry_price - stop_loss_price)
     if price_difference_per_unit <= CONFIG.position_qty_epsilon:
         logger.error(f"{Fore.RED}Risk Calc: Entry/SL prices are identical or too close to calculate risk ({price_difference_per_unit}). Entry={entry_price}, SL={stop_loss_price}{Style.RESET_ALL}")
         return None, None
     if not 0 < risk_per_trade_pct < 1:
         logger.error(f"{Fore.RED}Risk Calc: Invalid risk percentage: {risk_per_trade_pct:.3%}. Must be between 0 and 1.{Style.RESET_ALL}")
         return None, None
     if equity <= 0:
         logger.error(f"{Fore.RED}Risk Calc: Invalid equity: {equity:.2f}. Must be positive.{Style.RESET_ALL}")
         return None, None
     if leverage <= 0:
         logger.error(f"{Fore.RED}Risk Calc: Invalid leverage: {leverage}. Must be positive.{Style.RESET_ALL}")
         return None, None

     # Calculation
     risk_amount_usdt: Decimal = equity * risk_per_trade_pct
     quantity: Decimal = risk_amount_usdt / price_difference_per_unit

     # Apply exchange precision to quantity
     try:
         # Use amount_to_precision which returns a string, then convert back to Decimal
         quantity_precise_str = exchange.amount_to_precision(symbol, float(quantity))
         quantity_precise = Decimal(quantity_precise_str)
         logger.debug(f"Risk Calc: Raw Qty={quantity:.18f}, Precise Qty={quantity_precise_str}")
         quantity = quantity_precise # Use the precision-adjusted Decimal value for further checks
     except (ccxt.ExchangeError, ValueError, TypeError, InvalidOperation) as e:
          logger.warning(f"{Fore.YELLOW}Risk Calc: Could not apply exchange precision to quantity {quantity:.8f} for {symbol}. Using raw value. Error: {e}{Style.RESET_ALL}")
     except Exception as e: # Catch any other unexpected error during precision adjustment
          logger.error(f"{Fore.RED}Risk Calc: Unexpected error applying precision to quantity {quantity:.8f} for {symbol}: {e}{Style.RESET_ALL}")
          logger.debug(traceback.format_exc())
          return None, None # Fail calculation if precision fails unexpectedly

     if quantity <= CONFIG.position_qty_epsilon:
         logger.error(f"{Fore.RED}Risk Calc: Calculated quantity ({quantity}) is zero or negligible after precision adjustment.{Style.RESET_ALL}")
         return None, None

     # Estimate Value and Margin using the precise quantity
     position_value_usdt: Decimal = quantity * entry_price
     required_margin_estimate: Decimal = position_value_usdt / Decimal(leverage)
     logger.debug(f"Risk Calc Output: RiskAmt={risk_amount_usdt:.2f}, PriceDiff={price_difference_per_unit:.4f} => PreciseQty={quantity:.8f}, EstVal={position_value_usdt:.2f}, EstMargin={required_margin_estimate:.2f}")

     # Exchange Limit Checks (using precise quantity and estimated value)
     try:
         # Use passed market_info
         limits = market_info.get(LIMITS_KEY, {})
         amount_limits = limits.get(AMOUNT_KEY, {})
         cost_limits = limits.get(COST_KEY, {})

         # Safely get min/max limits, converting to Decimal
         def get_limit_decimal(limit_dict: Optional[dict], key: str, default: str) -> Decimal:
             if limit_dict is None: return Decimal(default)
             val = limit_dict.get(key)
             if val is not None:
                 with contextlib.suppress(InvalidOperation, ValueError, TypeError):
                     return Decimal(str(val))
             return Decimal(default)

         min_amount = get_limit_decimal(amount_limits, MIN_KEY, '0')
         max_amount = get_limit_decimal(amount_limits, MAX_KEY, 'inf')
         min_cost = get_limit_decimal(cost_limits, MIN_KEY, '0')
         max_cost = get_limit_decimal(cost_limits, MAX_KEY, 'inf')

         logger.debug(f"Market Limits for {symbol}: MinAmt={min_amount}, MaxAmt={max_amount}, MinCost={min_cost}, MaxCost={max_cost}")

         # Check against limits
         if quantity < min_amount:
             logger.error(f"{Fore.RED}Risk Calc: Calculated Qty {quantity:.8f} is less than Min Amount limit {min_amount:.8f}.{Style.RESET_ALL}")
             return None, None
         if position_value_usdt < min_cost:
             logger.error(f"{Fore.RED}Risk Calc: Estimated Value {position_value_usdt:.2f} is less than Min Cost limit {min_cost:.2f}.{Style.RESET_ALL}")
             return None, None
         if quantity > max_amount:
             logger.warning(f"{Fore.YELLOW}Risk Calc: Calculated Qty {quantity:.8f} exceeds Max Amount limit {max_amount:.8f}. Capping quantity to limit.{Style.RESET_ALL}")
             # Apply precision to the max_amount limit itself before assigning
             max_amount_str = exchange.amount_to_precision(symbol, float(max_amount))
             quantity = Decimal(max_amount_str) # Cap quantity to the precision-adjusted max limit
             # Recalculate estimated value and margin based on capped quantity
             position_value_usdt = quantity * entry_price
             required_margin_estimate = position_value_usdt / Decimal(leverage)
             logger.info(f"Risk Calc: Capped Qty={quantity:.8f}, New EstVal={position_value_usdt:.2f}, New EstMargin={required_margin_estimate:.2f}")
         if position_value_usdt > max_cost:
             # If even the capped quantity's value exceeds max cost, it's an issue
             logger.error(f"{Fore.RED}Risk Calc: Estimated Value {position_value_usdt:.2f} (potentially capped) exceeds Max Cost limit {max_cost:.2f}.{Style.RESET_ALL}")
             return None, None

     except (KeyError, InvalidOperation, ValueError, TypeError) as e:
         logger.warning(f"{Fore.YELLOW}Risk Calc: Error parsing market limits for {symbol}: {e}. Skipping limit checks.{Style.RESET_ALL}")
     except Exception as e:
         logger.warning(f"{Fore.YELLOW}Risk Calc: Unexpected error checking market limits: {e}. Skipping limit checks.{Style.RESET_ALL}")
         logger.debug(traceback.format_exc())

     # Return Decimal values for quantity and margin estimate
     return quantity, required_margin_estimate


def confirm_order_fill(exchange: ccxt.Exchange, order_id: str, symbol: str) -> Optional[Dict[str, Any]]:
    """Confirms if an order is filled using fetch_order primarily, falling back to fetch_closed_orders.

    Args:
        exchange: Initialized CCXT exchange object.
        order_id: The ID of the order to confirm.
        symbol: Unified CCXT symbol.

    Returns:
        Optional[Dict[str, Any]]: The filled order details, or None if not confirmed filled/failed.
    """
    log_prefix = f"Fill Confirm (ID:...{order_id[-6:]})"
    logger.debug(f"{log_prefix}: Attempting to confirm fill...")
    start_time = time.time()
    confirmed_order = None

    # --- Primary Method: fetch_order ---
    for attempt in range(CONFIG.fetch_order_status_retries):
        try:
            order = exchange.fetch_order(order_id, symbol)
            status = order.get(STATUS_KEY)
            logger.debug(f"{log_prefix}: Attempt {attempt + 1}, fetch_order status: {status}")

            if status == ORDER_STATUS_CLOSED:
                logger.success(f"{log_prefix}: Confirmed FILLED via fetch_order.")
                confirmed_order = order
                break  # Exit loop on success
            elif status in [ORDER_STATUS_CANCELED, ORDER_STATUS_REJECTED, ORDER_STATUS_EXPIRED]:
                logger.error(f"{Fore.RED}{log_prefix}: Order FAILED with status '{status}' via fetch_order.{Style.RESET_ALL}")
                return None  # Order definitively failed

            # If status is 'open' or None/unknown, continue retrying

        except ccxt.OrderNotFound:
            logger.warning(f"{Fore.YELLOW}{log_prefix}: Order not found via fetch_order (Attempt {attempt + 1}). Might be processing or already closed/canceled.{Style.RESET_ALL}")
            # Continue to next attempt, will try fallback later
        except (ccxt.NetworkError, ccxt.ExchangeError) as e:
            logger.warning(f"{Fore.YELLOW}{log_prefix}: API error during fetch_order (Attempt {attempt + 1}): {e}{Style.RESET_ALL}")
            # Continue retrying
        except Exception as e:
            logger.error(f"{Fore.RED}{log_prefix}: Unexpected error during fetch_order: {e}{Style.RESET_ALL}")
            logger.debug(traceback.format_exc())
            # Break on unexpected error? Or continue retrying? Let's continue for robustness.

        # Wait before retrying fetch_order
        if attempt < CONFIG.fetch_order_status_retries - 1:
            time.sleep(CONFIG.fetch_order_status_delay)

    # --- Fallback Method: fetch_closed_orders (if fetch_order didn't confirm 'closed') ---
    if not confirmed_order:
        logger.debug(f"{log_prefix}: fetch_order did not confirm 'closed'. Trying fallback: fetch_closed_orders...")
        try:
            # Fetch recent closed orders (increase limit slightly for safety)
            # Add timestamp filter to limit results
            since_timestamp = int((time.time() - CONFIG.confirm_fill_lookback_seconds) * 1000) # Look back N seconds
            closed_orders = exchange.fetch_closed_orders(symbol, limit=20, since=since_timestamp)
            logger.debug(f"{log_prefix}: Fallback fetched {len(closed_orders)} recent closed orders since {since_timestamp}.")
            for order in closed_orders:
                if order.get(ID_KEY) == order_id:
                    status = order.get(STATUS_KEY)
                    # We only care if it's 'closed' in the fallback, as 'canceled' etc. should have been caught by fetch_order
                    if status == ORDER_STATUS_CLOSED:
                         logger.success(f"{log_prefix}: Confirmed FILLED via fetch_closed_orders fallback.")
                         confirmed_order = order
                         break
                    else:
                         # Found the order but it wasn't closed (e.g., canceled and fetch_order missed it?)
                         logger.warning(f"{Fore.YELLOW}{log_prefix}: Found order in fallback, but status is '{status}'. Assuming failed/not filled.{Style.RESET_ALL}")
                         return None # Treat as failed if found in closed but not 'closed' status
            if not confirmed_order:
                 logger.warning(f"{Fore.YELLOW}{log_prefix}: Order not found in recent closed orders via fallback.{Style.RESET_ALL}")

        except (ccxt.NetworkError, ccxt.ExchangeError) as e:
            logger.warning(f"{Fore.YELLOW}{log_prefix}: API error during fetch_closed_orders fallback: {e}{Style.RESET_ALL}")
        except Exception as e:
            logger.error(f"{Fore.RED}{log_prefix}: Unexpected error during fetch_closed_orders fallback: {e}{Style.RESET_ALL}")
            logger.debug(traceback.format_exc())

    # --- Final Verdict ---
    if confirmed_order:
        # Final check: Ensure filled amount is positive
        try:
            filled_qty_str = confirmed_order.get(FILLED_KEY, '0')
            filled_qty = Decimal(str(filled_qty_str))
            if filled_qty <= CONFIG.position_qty_epsilon:
                logger.error(f"{Fore.RED}{log_prefix}: Order {order_id} confirmed '{ORDER_STATUS_CLOSED}' but filled quantity is zero/negligible ({filled_qty}). Treating as FAILED.{Style.RESET_ALL}")
                return None
        except (InvalidOperation, ValueError, TypeError):
            logger.error(f"{Fore.RED}{log_prefix}: Could not parse filled quantity '{confirmed_order.get(FILLED_KEY)}' from confirmed order {order_id}. Treating as FAILED.{Style.RESET_ALL}")
            return None
        return confirmed_order
    else:
        elapsed = time.time() - start_time
        logger.error(f"{Fore.RED}{log_prefix}: FAILED to confirm fill for order {order_id} using both methods within timeout ({elapsed:.1f}s). Assume failure.{Style.RESET_ALL}")
        return None


def place_risked_market_order(
    exchange: ccxt.Exchange,
    symbol: str,
    side: str,
    quantity_decimal: Decimal, # Receive Decimal from calculation
    required_margin_decimal: Decimal, # Receive Decimal from calculation
    stop_loss_price: Decimal,
    take_profit_price: Decimal,
    market_info: Dict # Pass market info (including precision, limits)
) -> Optional[Dict[str, Any]]:
    """Places market entry, confirms fill, then places SL/TP orders based on actual fill."""
    market_base = symbol.split('/')[0] if '/' in symbol else symbol
    log_prefix = f"Entry Order ({side.upper()})"
    order_id: Optional[str] = None
    entry_order: Optional[Dict[str, Any]] = None
    confirmed_order: Optional[Dict[str, Any]] = None # To store the confirmed filled order

    try:
        # Fetch Balance & Ticker (needed for capping and final checks)
        logger.debug(f"{log_prefix}: Gathering resources (Balance, Ticker)...")
        balance_info = exchange.fetch_balance(params={'accountType': 'CONTRACT'}) # Assume CONTRACT account type
        # Use 'free' balance for margin check (ensure it's USDT)
        free_balance_raw = balance_info.get(FREE_KEY, {}).get(USDT_SYMBOL)
        if free_balance_raw is None: raise ValueError("Could not fetch free USDT balance.")
        free_balance = Decimal(str(free_balance_raw))

        ticker = exchange.fetch_ticker(symbol)
        last_price_raw = ticker.get(LAST_PRICE_KEY)
        if last_price_raw is None: raise ValueError("Could not fetch last price for estimates.")
        entry_price_estimate = Decimal(str(last_price_raw))
        if entry_price_estimate <= 0: raise ValueError(f"Fetched invalid last price: {entry_price_estimate}")

        # --- Pre-flight Checks ---
        # Quantity and margin are already Decimals

        # Cap Quantity based on MAX_ORDER_USDT_AMOUNT
        estimated_value = quantity_decimal * entry_price_estimate
        if estimated_value > CONFIG.max_order_usdt_amount:
            original_quantity_str = f"{quantity_decimal:.8f}"
            # Calculate capped quantity as Decimal first for precision
            capped_qty_decimal_raw = (CONFIG.max_order_usdt_amount / entry_price_estimate)
            # Apply exchange precision using float conversion temporarily
            quantity_str = exchange.amount_to_precision(symbol, float(capped_qty_decimal_raw))
            quantity_decimal = Decimal(quantity_str) # Update Decimal quantity
            # Recalculate estimated margin based on capped Decimal quantity
            required_margin_decimal = (quantity_decimal * entry_price_estimate) / Decimal(CONFIG.leverage)
            logger.warning(f"{Fore.YELLOW}{log_prefix}: Qty {original_quantity_str} (Val ~{estimated_value:.2f}) > Max {CONFIG.max_order_usdt_amount:.2f}. Capping to {quantity_str} (New Est. Margin ~{required_margin_decimal:.2f}).{Style.RESET_ALL}")

        # Final Limit Checks (Amount & Cost) using potentially capped quantity and market_info
        limits = market_info.get(LIMITS_KEY, {})
        amount_limits = limits.get(AMOUNT_KEY, {})
        cost_limits = limits.get(COST_KEY, {})
        min_amount = Decimal(str(amount_limits.get(MIN_KEY, '0'))) if amount_limits.get(MIN_KEY) is not None else Decimal('0')
        min_cost = Decimal(str(cost_limits.get(MIN_KEY, '0'))) if cost_limits.get(MIN_KEY) is not None else Decimal('0')

        if quantity_decimal < min_amount:
            logger.error(f"{Fore.RED}{log_prefix}: Final quantity {quantity_decimal:.8f} < Min Amount limit {min_amount:.8f}. Abort.{Style.RESET_ALL}")
            return None
        estimated_cost_final = quantity_decimal * entry_price_estimate
        if estimated_cost_final < min_cost:
            logger.error(f"{Fore.RED}{log_prefix}: Final estimated cost {estimated_cost_final:.2f} < Min Cost limit {min_cost:.2f}. Abort.{Style.RESET_ALL}")
            return None

        # Margin Check using potentially recalculated margin estimate
        required_margin_with_buffer = required_margin_decimal * CONFIG.required_margin_buffer
        logger.debug(f"{log_prefix}: Free Balance={free_balance:.2f}, Est. Margin Required (incl. buffer)={required_margin_with_buffer:.2f}")
        if free_balance < required_margin_with_buffer:
            logger.error(f"{Fore.RED}{log_prefix}: Insufficient free balance ({free_balance:.2f}) for required margin ({required_margin_with_buffer:.2f}). Abort.{Style.RESET_ALL}")
            send_sms_alert(f"[{market_base}] Order REJECTED ({side.upper()}): Insuff. free balance. Need ~{required_margin_with_buffer:.2f}")
            return None

        # --- Place Market Order ---
        entry_side_color = Back.GREEN if side == SIDE_BUY else Back.RED
        text_color = Fore.BLACK if side == SIDE_BUY else Fore.WHITE
        # Convert final Decimal quantity to float for create_market_order
        quantity_float = float(quantity_decimal)
        logger.warning(f"{entry_side_color}{text_color}{Style.BRIGHT}*** Placing {side.upper()} MARKET ENTRY: {quantity_float:.8f} {symbol} ***{Style.RESET_ALL}")
        entry_order = exchange.create_market_order(symbol, side, quantity_float)
        order_id = entry_order.get(ID_KEY)
        if not order_id: raise ValueError("Market order placed but no ID returned.")
        logger.success(f"{log_prefix}: Market order submitted. ID: ...{order_id[-6:]}. Waiting for fill confirmation...")
        time.sleep(CONFIG.post_entry_delay_seconds)  # Allow time for order processing

        # --- Confirm Order Fill ---
        confirmed_order = confirm_order_fill(exchange, order_id, symbol)
        if not confirmed_order:
            logger.error(f"{Fore.RED}{log_prefix}: FAILED to confirm fill for entry order {order_id}. Aborting SL/TP placement.{Style.RESET_ALL}")
            send_sms_alert(f"[{market_base}] CRITICAL: Entry fill confirm FAILED: {order_id}. Manual check needed!")
            # Position state is unknown, do not proceed.
            return None

        # --- Extract Actual Fill Details ---
        actual_filled_qty = Decimal('0.0')
        actual_avg_price = Decimal('0.0')
        try:
            # Use Decimal for accuracy when reading fill details
            actual_filled_qty_str = confirmed_order.get(FILLED_KEY)
            # Prefer 'average' price from CCXT unified response, fallback to raw 'avgPrice' or 'price'
            actual_avg_price_str = confirmed_order.get(AVERAGE_KEY) or confirmed_order.get(INFO_KEY, {}).get(AVG_PRICE_KEY) or confirmed_order.get(PRICE_KEY)

            if actual_filled_qty_str is None or actual_avg_price_str is None:
                 raise ValueError("Missing filled quantity or average price in confirmed order.")

            actual_filled_qty = Decimal(str(actual_filled_qty_str))
            actual_avg_price = Decimal(str(actual_avg_price_str))

            if actual_filled_qty <= CONFIG.position_qty_epsilon or actual_avg_price <= 0:
                 raise ValueError(f"Invalid fill data: Qty={actual_filled_qty}, Price={actual_avg_price}")
            logger.success(f"{log_prefix}: Fill Confirmed: Order ID ...{order_id[-6:]}, Filled Qty={actual_filled_qty:.8f}, Avg Price={actual_avg_price:.4f}")
        except (InvalidOperation, ValueError, TypeError, KeyError) as e:
            logger.error(f"{Fore.RED}{log_prefix}: Error parsing confirmed fill details for order {order_id}: {e}. Data: {confirmed_order}{Style.RESET_ALL}")
            send_sms_alert(f"[{market_base}] CRITICAL ERROR parsing fill data: {order_id}. Manual check needed!")
            # We have a filled position but can't parse details. Attempt emergency close? Risky. Alerting is primary.
            # Let's return None here, indicating failure to setup SL/TP.
            return None

        # --- Place SL/TP Orders ---
        logger.info(f"{log_prefix}: Placing SL ({stop_loss_price}) and TP ({take_profit_price}) orders for filled qty {actual_filled_qty:.8f}...")
        sl_tp_success = True
        close_side = SIDE_SELL if side == SIDE_BUY else SIDE_BUY
        # Use the actual filled quantity (as float for create_order) for SL/TP orders
        sl_tp_amount_float = float(actual_filled_qty)

        # Apply precision to SL/TP prices before sending
        try:
            sl_price_str = exchange.price_to_precision(symbol, float(stop_loss_price))
            tp_price_str = exchange.price_to_precision(symbol, float(take_profit_price))
        except Exception as e:
            logger.error(f"{Fore.RED}{log_prefix}: Failed to apply precision to SL/TP prices: {e}. Aborting SL/TP placement.{Style.RESET_ALL}")
            send_sms_alert(f"[{market_base}] CRITICAL: SL/TP price precision FAILED for {order_id}. Manual check needed!")
            # Attempt emergency close if SL/TP cannot be placed due to precision error?
            if CONFIG.emergency_close_on_sl_fail:
                logger.warning(f"{log_prefix}: Attempting emergency close due to SL/TP price precision failure.")
                # Construct a temporary position dict based on confirmed fill
                pos_to_close = {SIDE_KEY: side, QTY_KEY: actual_filled_qty, ENTRY_PRICE_KEY: actual_avg_price}
                close_position(exchange, symbol, pos_to_close, reason="SL_TP_Precision_Fail")
            return None # Cannot place SL/TP without correct price format

        # SL Order Params (stopMarket)
        sl_trigger_direction = 2 if side == SIDE_BUY else 1 # Trigger when price goes BELOW for LONG SL, ABOVE for SHORT SL
        sl_params = {
            PARAM_STOP_PRICE: sl_price_str,
            PARAM_REDUCE_ONLY: True,
            PARAM_TRIGGER_DIRECTION: sl_trigger_direction, # 1: Mark price > trigger price, 2: Mark price < trigger price
            'tpslMode': 'Full', # Bybit V5: 'Full' or 'Partial'. Assume full position SL/TP.
            'slOrderType': 'Market', # Explicitly state market execution for SL trigger
        }
        # TP Order Params (stopMarket)
        tp_trigger_direction = 1 if side == SIDE_BUY else 2 # Trigger when price goes ABOVE for LONG TP, BELOW for SHORT TP
        tp_params = {
            PARAM_STOP_PRICE: tp_price_str,
            PARAM_REDUCE_ONLY: True,
            PARAM_TRIGGER_DIRECTION: tp_trigger_direction, # 1: Mark price > trigger price, 2: Mark price < trigger price
            'tpslMode': 'Full', # As above
            'tpOrderType': 'Market', # Explicitly state market execution for TP trigger
        }

        sl_order_id_short, tp_order_id_short = "N/A", "N/A"
        sl_order_info, tp_order_info = None, None

        # Place Stop-Loss Order
        try:
            logger.debug(f"Placing SL order: symbol={symbol}, type={ORDER_TYPE_STOP_MARKET}, side={close_side}, amount={sl_tp_amount_float}, params={sl_params}")
            sl_order_info = exchange.create_order(symbol, ORDER_TYPE_STOP_MARKET, close_side, sl_tp_amount_float, params=sl_params)
            sl_order_id_short = str(sl_order_info.get(ID_KEY, 'N/A'))[-6:]
            logger.success(f"{Fore.GREEN}{log_prefix}: Stop-Loss order placed. ID: ...{sl_order_id_short}{Style.RESET_ALL}")
            time.sleep(0.1)  # Small delay between orders
        except Exception as e:
            sl_tp_success = False
            logger.error(f"{Back.RED}{Fore.WHITE}{log_prefix}: FAILED to place Stop-Loss order: {e}{Style.RESET_ALL}")
            logger.debug(traceback.format_exc())
            send_sms_alert(f"[{market_base}] CRITICAL: SL order FAILED for {symbol} ({side}) after entry {order_id[-6:]}: {e}")
            # Attempt to close position immediately if SL fails and config allows
            if CONFIG.emergency_close_on_sl_fail:
                logger.warning(f"{log_prefix}: Attempting emergency close due to SL placement failure.")
                # Construct a temporary position dict based on confirmed fill
                pos_to_close = {SIDE_KEY: side, QTY_KEY: actual_filled_qty, ENTRY_PRICE_KEY: actual_avg_price}
                close_result = close_position(exchange, symbol, pos_to_close, reason="SL_Placement_Fail")
                if close_result:
                    logger.warning(f"{log_prefix}: Emergency close successful after SL failure.")
                else:
                    logger.error(f"{log_prefix}: Emergency close FAILED after SL placement failure. MANUAL INTERVENTION URGENT!")
                    send_sms_alert(f"[{market_base}] URGENT: Emergency CLOSE FAILED after SL fail for {symbol}. MANUAL ACTION!")
            # Even if emergency close fails, we cannot proceed with TP as the state is compromised. Return None.
            return None

        # Place Take-Profit Order (only if SL succeeded)
        try:
            logger.debug(f"Placing TP order: symbol={symbol}, type={ORDER_TYPE_STOP_MARKET}, side={close_side}, amount={sl_tp_amount_float}, params={tp_params}")
            tp_order_info = exchange.create_order(symbol, ORDER_TYPE_STOP_MARKET, close_side, sl_tp_amount_float, params=tp_params)
            tp_order_id_short = str(tp_order_info.get(ID_KEY, 'N/A'))[-6:]
            logger.success(f"{Fore.GREEN}{log_prefix}: Take-Profit order placed. ID: ...{tp_order_id_short}{Style.RESET_ALL}")
        except Exception as e:
            # TP failure is less critical than SL, but still log as error and mark overall failure
            sl_tp_success = False
            logger.error(f"{Back.YELLOW}{Fore.BLACK}{log_prefix}: FAILED to place Take-Profit order: {e}{Style.RESET_ALL}")
            logger.debug(traceback.format_exc())
            send_sms_alert(f"[{market_base}] WARNING: TP order FAILED for {symbol} ({side}) after entry {order_id[-6:]}: {e}")
            # If TP fails, the position is still protected by SL. Should we cancel the SL and close?
            # Or leave the SL active? Leaving SL active seems safer.
            # Mark sl_tp_success as False, so the function returns None, indicating incomplete setup.
            # The main loop won't see a successful entry and won't try to manage it further, relying on the existing SL.

        # Final outcome
        if sl_tp_success:
            logger.info(f"{Fore.GREEN}{log_prefix}: Entry order filled and SL/TP orders placed successfully.{Style.RESET_ALL}")
            send_sms_alert(f"[{market_base}] Entered {side.upper()} {actual_filled_qty:.4f} @ {actual_avg_price:.2f}. SL=...{sl_order_id_short}, TP=...{tp_order_id_short}")
            # Return the confirmed *entry* order details
            return confirmed_order
        else:
            logger.error(f"{Back.RED}{Fore.WHITE}{log_prefix}: Entry filled (ID:...{order_id[-6:]}), but FAILED to place one/both SL/TP orders. Position might be partially protected (SL only) or unprotected. MANUAL INTERVENTION RECOMMENDED!{Style.RESET_ALL}")
            # Return None to indicate the overall process including SL/TP setup failed or was incomplete.
            return None

    except (ccxt.InsufficientFunds, ccxt.ExchangeError, ccxt.NetworkError, ValueError) as e:
        logger.error(f"{Fore.RED}{log_prefix}: Failed during order placement/check: {e}{Style.RESET_ALL}")
        if entry_order: logger.error(f"Entry order details (if placed): {entry_order}")
        send_sms_alert(f"[{market_base}] Entry order FAILED ({side.upper()}): {type(e).__name__}")
        return None
    except Exception as e:
        logger.error(f"{Fore.RED}{log_prefix}: Unexpected error during order ritual: {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())
        send_sms_alert(f"[{market_base}] UNEXPECTED error during entry ({side.upper()}): {type(e).__name__}")
        return None


# --- Core Trading Logic - The Spell Weaving Cycle ---
def trade_logic(exchange: ccxt.Exchange, symbol: str, timeframe: str) -> None:
    """Main trading logic loop."""
    cycle_time_str = time.strftime('%Y-%m-%d %H:%M:%S %Z')
    logger.info(f"{Fore.BLUE}{Style.BRIGHT}========== New Weaving Cycle: {symbol} ({timeframe}) | {cycle_time_str} =========={Style.RESET_ALL}")

    # --- 0. Get Market Info (once per cycle) ---
    try:
        market_info = exchange.market(symbol)
        if not market_info:
            logger.error(f"{Fore.RED}Trade Logic: Skipping cycle - unable to fetch market info for {symbol}.{Style.RESET_ALL}")
            return
    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.BadSymbol) as e:
        logger.warning(f"{Fore.YELLOW}Trade Logic: Skipping cycle - API error fetching market info for {symbol}: {e}{Style.RESET_ALL}")
        return
    except Exception as e:
        logger.error(f"{Fore.RED}Trade Logic: Skipping cycle - Unexpected error fetching market info for {symbol}: {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())
        return

    # --- 1. Get Data ---
    # Determine required length based on longest indicator period + buffer
    required_ohlcv_len = max(CONFIG.st_atr_length, CONFIG.confirm_st_atr_length, CONFIG.volume_ma_period, CONFIG.atr_calculation_period) + CONFIG.api_fetch_limit_buffer
    df = fetch_ohlcv(exchange, symbol, timeframe, limit=required_ohlcv_len)
    if df is None or df.empty:
        logger.warning(f"{Fore.YELLOW}Trade Logic: Skipping cycle - unable to fetch valid OHLCV data.{Style.RESET_ALL}")
        return

    order_book_data: Optional[Dict[str, Optional[Decimal]]] = None
    # Fetch OB if always required OR if confirmation is enabled (fetch only when needed later)
    if CONFIG.fetch_order_book_per_cycle:
        order_book_data = analyze_order_book(exchange, symbol, CONFIG.order_book_depth, CONFIG.order_book_fetch_limit, market_info)
        # If OB analysis is mandatory for entry and it failed, skip cycle
        if order_book_data is None and CONFIG.use_ob_confirm:
             logger.warning(f"{Fore.YELLOW}Trade Logic: Skipping cycle - failed to get required OB data (fetch_order_book_per_cycle=True).{Style.RESET_ALL}")
             return

    # --- 2. Calculate Indicators ---
    logger.debug("Calculating indicators...")
    df = calculate_supertrend(df, CONFIG.st_atr_length, CONFIG.st_multiplier)
    df = calculate_supertrend(df, CONFIG.confirm_st_atr_length, CONFIG.confirm_st_multiplier, prefix="confirm_")
    vol_atr_results = analyze_volume_atr(df, CONFIG.atr_calculation_period, CONFIG.volume_ma_period)

    # Check for critical indicator calculation failures
    # Check if columns exist and the last value is not NaN/NA
    # Use the renamed column names from calculate_supertrend
    if 'trend' not in df.columns or pd.isna(df['trend'].iloc[-1]):
        logger.warning(f"{Fore.YELLOW}Trade Logic: Skipping cycle - primary Supertrend trend calculation failed or resulted in NaN.{Style.RESET_ALL}")
        return
    if 'confirm_trend' not in df.columns or pd.isna(df['confirm_trend'].iloc[-1]):
        logger.warning(f"{Fore.YELLOW}Trade Logic: Skipping cycle - confirmation Supertrend trend calculation failed or resulted in NaN.{Style.RESET_ALL}")
        return
    if vol_atr_results is None or vol_atr_results.get(ATR_KEY) is None:
        logger.warning(f"{Fore.YELLOW}Trade Logic: Skipping cycle - Volume/ATR calculation failed or ATR is None.{Style.RESET_ALL}")
        return

    # --- 3. Extract Latest Indicator Values ---
    try:
        last_candle = df.iloc[-1]
        # Primary Supertrend (using renamed columns)
        st_trend = last_candle['trend']                 # Current trend direction (-1 or 1)
        st_long_signal = last_candle['st_long_flip']    # True only on the candle where trend flipped to long
        st_short_signal = last_candle['st_short_flip']  # True only on the candle where trend flipped to short
        # Confirmation Supertrend (using renamed columns)
        confirm_st_trend = last_candle['confirm_trend'] # Current trend direction (-1 or 1)
        # Volume/ATR
        current_atr: Optional[Decimal] = vol_atr_results.get(ATR_KEY) # Decimal or None
        volume_ratio: Optional[Decimal] = vol_atr_results.get(VOLUME_RATIO_KEY) # Decimal or None
        # Current Price (use last close)
        current_price = Decimal(str(last_candle['close']))

        # Validate essential values extracted
        if current_atr is None or pd.isna(st_trend) or pd.isna(confirm_st_trend) or current_price <= 0:
             raise ValueError("Essential indicator values (ATR, ST trends, Price) are None/NaN/invalid after extraction.")
        # Flip signals should be boolean due to .astype(bool) in calculate_supertrend
        if not isinstance(st_long_signal, bool):
             raise ValueError(f"Supertrend long flip signal (st_long_flip) is not boolean, type: {type(st_long_signal)}")
        if not isinstance(st_short_signal, bool):
             raise ValueError(f"Supertrend short flip signal (st_short_flip) is not boolean, type: {type(st_short_signal)}")

    except (IndexError, KeyError, ValueError, InvalidOperation) as e:
        logger.error(f"{Fore.RED}Trade Logic: Error accessing or validating indicator/price data from last candle: {e}{Style.RESET_ALL}")
        logger.debug(f"DataFrame tail:\n{df.tail()}")
        logger.debug(f"Vol/ATR Results: {vol_atr_results}")
        return

    # --- 4. Check Current Position ---
    current_position = get_current_position(exchange, symbol)
    position_side = current_position[SIDE_KEY]
    position_qty = current_position[QTY_KEY]
    position_entry_price = current_position[ENTRY_PRICE_KEY]
    pos_color = Fore.GREEN if position_side == POSITION_SIDE_LONG else (Fore.RED if position_side == POSITION_SIDE_SHORT else Fore.BLUE)
    logger.info(f"State | Position: Side={pos_color}{position_side}{Style.RESET_ALL}, Qty={position_qty:.8f}, Entry={position_entry_price:.4f}")
    vol_ratio_str = f"{volume_ratio:.2f}" if volume_ratio is not None else 'N/A'
    logger.info(f"State | Indicators: Price={current_price:.4f}, ATR={current_atr:.4f}, ST Trend={st_trend}, Confirm ST Trend={confirm_st_trend}, VolRatio={vol_ratio_str}")

    # --- 5. Determine Signals ---
    # Entry signal: ST flip occurred on this candle AND confirmation ST agrees with the new direction
    long_entry_signal = st_long_signal and confirm_st_trend == 1
    short_entry_signal = st_short_signal and confirm_st_trend == -1
    # Exit signal: Primary ST trend flips against the current position
    close_long_signal = position_side == POSITION_SIDE_LONG and st_trend == -1
    close_short_signal = position_side == POSITION_SIDE_SHORT and st_trend == 1
    logger.debug(f"Signals: EntryLong={long_entry_signal}, EntryShort={short_entry_signal}, CloseLong={close_long_signal}, CloseShort={close_short_signal}")

    # --- 6. Decision Making ---

    # **Exit Logic:** Prioritize closing existing positions based on primary ST flip
    exit_reason = None
    if close_long_signal: exit_reason = "ST Exit Long"
    elif close_short_signal: exit_reason = "ST Exit Short"

    if exit_reason:
        exit_side_color = Back.YELLOW
        logger.warning(f"{exit_side_color}{Fore.BLACK}{Style.BRIGHT}*** TRADE EXIT SIGNAL: Closing {position_side} due to {exit_reason} ***{Style.RESET_ALL}")
        close_position(exchange, symbol, current_position, reason=exit_reason)
        time.sleep(CONFIG.post_close_delay_seconds)  # Pause after closing attempt
        return  # End cycle after attempting exit

    # **Entry Logic:** Only consider entry if currently flat
    if position_side == POSITION_SIDE_NONE:
        selected_side = None
        if long_entry_signal: selected_side = SIDE_BUY
        elif short_entry_signal: selected_side = SIDE_SELL

        if selected_side:
            logger.info(f"{Fore.CYAN}Entry Signal: Potential {selected_side.upper()} entry detected by Supertrend flip and confirmation.{Style.RESET_ALL}")

            # --- Entry Confirmations ---
            volume_confirmed = True
            if CONFIG.require_volume_spike_for_entry:
                if volume_ratio is None or volume_ratio <= CONFIG.volume_spike_threshold:
                    volume_confirmed = False
                    vol_ratio_str = f"{volume_ratio:.2f}" if volume_ratio is not None else 'N/A'
                    logger.info(f"Entry REJECTED ({selected_side.upper()}): Volume spike confirmation FAILED (Ratio: {vol_ratio_str} <= Threshold: {CONFIG.volume_spike_threshold}).")
                else:
                    logger.info(f"{Fore.GREEN}Entry Check ({selected_side.upper()}): Volume spike OK (Ratio: {volume_ratio:.2f}).{Style.RESET_ALL}")

            ob_confirmed = True
            # Only check OB if volume passed (or volume check disabled) AND OB check is enabled
            if volume_confirmed and CONFIG.use_ob_confirm:
                # Fetch OB data now if not fetched per cycle
                if order_book_data is None:
                     logger.debug("Fetching OB data for confirmation...")
                     order_book_data = analyze_order_book(exchange, symbol, CONFIG.order_book_depth, CONFIG.order_book_fetch_limit, market_info)

                # Check OB results
                if order_book_data is None or order_book_data.get(BID_ASK_RATIO_KEY) is None:
                    ob_confirmed = False
                    logger.warning(f"{Fore.YELLOW}Entry REJECTED ({selected_side.upper()}): OB confirmation FAILED (Could not get valid OB data/ratio).{Style.RESET_ALL}")
                else:
                    # Type hint for clarity after check
                    ob_ratio = cast(Decimal, order_book_data[BID_ASK_RATIO_KEY])
                    ob_ratio_str = f"{ob_ratio:.3f}"
                    if selected_side == SIDE_BUY and ob_ratio < CONFIG.order_book_ratio_threshold_long:
                        ob_confirmed = False
                        logger.info(f"Entry REJECTED ({selected_side.upper()}): OB confirmation FAILED (Ratio: {ob_ratio_str} < Threshold: {CONFIG.order_book_ratio_threshold_long}).")
                    elif selected_side == SIDE_SELL and ob_ratio > CONFIG.order_book_ratio_threshold_short:
                        ob_confirmed = False
                        logger.info(f"Entry REJECTED ({selected_side.upper()}): OB confirmation FAILED (Ratio: {ob_ratio_str} > Threshold: {CONFIG.order_book_ratio_threshold_short}).")
                    else:
                         ob_color = Fore.GREEN if selected_side == SIDE_BUY else Fore.RED
                         logger.info(f"{ob_color}Entry Check ({selected_side.upper()}): OB pressure OK (Ratio: {ob_ratio_str}).{Style.RESET_ALL}")

            # --- Proceed with Entry Calculation if All Confirmations Pass ---
            if volume_confirmed and ob_confirmed:
                logger.success(f"{Fore.GREEN}{Style.BRIGHT}Entry CONFIRMED ({selected_side.upper()}): All checks passed. Calculating parameters...{Style.RESET_ALL}")

                # Calculate SL/TP Prices using current ATR
                try:
                    # Get market price precision for rounding SL/TP from market_info
                    price_precision_str = market_info.get(PRECISION_KEY, {}).get(PRICE_KEY)
                    if price_precision_str is None: raise ValueError("Could not determine price precision from market info.")
                    price_precision = Decimal(str(price_precision_str)) # Ensure Decimal

                    # Ensure current_atr is Decimal before multiplication
                    if not isinstance(current_atr, Decimal):
                        raise TypeError(f"current_atr is not a Decimal: {type(current_atr)}")

                    sl_distance = current_atr * CONFIG.atr_stop_loss_multiplier
                    tp_distance = current_atr * CONFIG.atr_take_profit_multiplier
                    entry_price_est = current_price  # Use last close price as entry estimate for calculations

                    if selected_side == SIDE_BUY:
                        sl_price_raw = entry_price_est - sl_distance
                        tp_price_raw = entry_price_est + tp_distance
                    else:  # SIDE_SELL
                        sl_price_raw = entry_price_est + sl_distance
                        tp_price_raw = entry_price_est - tp_distance

                    # Ensure SL/TP are not zero or negative
                    if sl_price_raw <= 0 or tp_price_raw <= 0:
                        raise ValueError(f"Calculated SL/TP price is zero or negative (SL={sl_price_raw}, TP={tp_price_raw}).")

                    # Quantize SL/TP using market precision (rounding away from entry for SL, towards for TP?)
                    # Let's use standard rounding (ROUND_HALF_UP) for simplicity first.
                    sl_price = sl_price_raw.quantize(price_precision, rounding=ROUND_HALF_UP)
                    tp_price = tp_price_raw.quantize(price_precision, rounding=ROUND_HALF_UP)

                    # Final check: Ensure SL/TP didn't round to the same value as entry estimate or cross each other
                    # Use price_precision for comparison threshold
                    if abs(sl_price - entry_price_est) < price_precision:
                        logger.warning(f"SL price {sl_price} too close to entry estimate {entry_price_est} after rounding. Adjusting slightly.")
                        # Adjust SL slightly further away based on side
                        sl_price = sl_price - price_precision if selected_side == SIDE_BUY else sl_price + price_precision
                        # Re-check after adjustment
                        if abs(sl_price - entry_price_est) < price_precision:
                             raise ValueError(f"SL price {sl_price} still too close to entry estimate {entry_price_est} after adjustment.")

                    if abs(tp_price - entry_price_est) < price_precision:
                         logger.warning(f"TP price {tp_price} too close to entry estimate {entry_price_est} after rounding. Cannot proceed with zero TP distance.")
                         raise ValueError("TP price rounded too close to entry price estimate.")
                    if (selected_side == SIDE_BUY and sl_price >= tp_price) or \
                       (selected_side == SIDE_SELL and sl_price <= tp_price):
                        raise ValueError(f"SL price ({sl_price}) crossed TP price ({tp_price}) after calculation/rounding.")

                    logger.info(f"Calculated SL={sl_price}, TP={tp_price} based on EntryEst={entry_price_est}, ATR={current_atr:.4f}")

                except (ValueError, InvalidOperation, KeyError, TypeError) as e:
                    logger.error(f"{Fore.RED}Entry REJECTED ({selected_side.upper()}): Error calculating SL/TP prices: {e}{Style.RESET_ALL}")
                    return # Stop processing this entry signal

                # Calculate Position Size
                try:
                    balance_info = exchange.fetch_balance(params={'accountType': 'CONTRACT'}) # Assume CONTRACT account type
                    # Use 'total' equity for risk calculation
                    equity_str = balance_info.get(TOTAL_KEY, {}).get(USDT_SYMBOL)
                    if equity_str is None: raise ValueError("Could not fetch USDT total equity from balance.")
                    equity = Decimal(str(equity_str))
                    if equity <= 0: raise ValueError(f"Zero or negative equity ({equity}).")
                except (ccxt.NetworkError, ccxt.ExchangeError, ValueError, InvalidOperation) as e:
                     logger.error(f"{Fore.RED}Entry REJECTED ({selected_side.upper()}): Failed to fetch valid equity: {e}{Style.RESET_ALL}")
                     return # Stop processing this entry signal

                # Calculate position size returns Decimals
                quantity_decimal, margin_est_decimal = calculate_position_size(
                    equity, CONFIG.risk_per_trade_percentage, entry_price_est, sl_price,
                    CONFIG.leverage, symbol, exchange, market_info # Pass market_info
                )

                if quantity_decimal is not None and margin_est_decimal is not None:
                    # Place the risked market order (which includes SL/TP placement)
                    # Pass Decimal values and market_info to the function
                    place_risked_market_order(
                        exchange, symbol, selected_side, quantity_decimal, margin_est_decimal, sl_price, tp_price, market_info
                    )
                    # The place_risked_market_order function handles logging success/failure internally.
                    # No return needed here, let the cycle finish.
                else:
                    logger.error(f"{Fore.RED}Entry REJECTED ({selected_side.upper()}): Failed to calculate valid position size or margin estimate.{Style.RESET_ALL}")
                    # Stop processing this entry signal

    elif position_side != POSITION_SIDE_NONE:
        logger.info(f"Holding {pos_color}{position_side}{Style.RESET_ALL} position. No exit signal this cycle. Awaiting exchange SL/TP or next signal.")
        # No redundant monitoring needed as we rely on exchange-native SL/TP

    logger.info(f"{Fore.BLUE}{Style.BRIGHT}========== Cycle Weaving End: {symbol} =========={Style.RESET_ALL}\n")


# --- Main Execution - Igniting the Spell ---
def main() -> None:
    """Main function to run the bot."""
    start_time_str = time.strftime('%Y-%m-%d %H:%M:%S %Z')
    logger.info(f"{Back.BLUE}{Fore.WHITE}{Style.BRIGHT}--- Pyrmethus Bybit Scalping Spell v10.1.0 Initializing ({start_time_str}) ---{Style.RESET_ALL}")
    logger.info(f"{Fore.CYAN}--- Strategy Enchantment: Dual Supertrend ---{Style.RESET_ALL}")
    logger.info(f"{Fore.GREEN}--- Protective Wards: Exchange Native SL/TP (stopMarket) ---{Style.RESET_ALL}")

    # Config object already instantiated and validated globally (CONFIG)
    logger.warning(f"{Back.YELLOW}{Fore.BLACK}{Style.BRIGHT}--- !!! LIVE FUTURES SCALPING MODE - EXTREME RISK - HANDLE WITH CARE !!! ---{Style.RESET_ALL}")

    # Initialize Exchange
    exchange = initialize_exchange()
    if not exchange:
        logger.critical("Failed to initialize exchange. Spell fizzles.")
        sys.exit(1) # Exit if exchange init fails

    # Set Leverage
    if not set_leverage(exchange, CONFIG.symbol, CONFIG.leverage):
         logger.critical(f"Failed to set leverage to {CONFIG.leverage}x for {CONFIG.symbol}. Spell cannot bind.")
         # Attempt to send SMS even if leverage fails
         send_sms_alert(f"[ScalpBot] CRITICAL: Leverage set FAILED for {CONFIG.symbol}. Bot stopped.")
         sys.exit(1) # Exit if leverage set fails

    # Log Final Config Summary (using CONFIG object)
    logger.info(f"{Fore.MAGENTA}--- Final Spell Configuration ---{Style.RESET_ALL}")
    logger.info(f"{Fore.WHITE}Symbol: {CONFIG.symbol}, Interval: {CONFIG.interval}, Leverage: {CONFIG.leverage}x")
    logger.info(f"  Supertrend Params: ST={CONFIG.st_atr_length}/{CONFIG.st_multiplier}, ConfirmST={CONFIG.confirm_st_atr_length}/{CONFIG.confirm_st_multiplier}")
    logger.info(f"{Fore.GREEN}Risk Ward: {CONFIG.risk_per_trade_percentage:.3%}/trade, Max Pos Value: {CONFIG.max_order_usdt_amount:.4f} USDT")
    logger.info(f"{Fore.GREEN}SL/TP Wards: SL Mult={CONFIG.atr_stop_loss_multiplier}, TP Mult={CONFIG.atr_take_profit_multiplier} (ATR Period: {CONFIG.atr_calculation_period})")
    logger.info(f"{Fore.YELLOW}Volume Filter: {CONFIG.require_volume_spike_for_entry} (MA={CONFIG.volume_ma_period}, Thr={CONFIG.volume_spike_threshold})")
    logger.info(f"{Fore.YELLOW}Order Book Filter: Use Confirm={CONFIG.use_ob_confirm}, Fetch Each Cycle={CONFIG.fetch_order_book_per_cycle} (Depth={CONFIG.order_book_depth}, L>={CONFIG.order_book_ratio_threshold_long}, S<={CONFIG.order_book_ratio_threshold_short})")
    logger.info(f"{Fore.WHITE}Timing: Sleep={CONFIG.sleep_seconds}s, Margin Buffer={CONFIG.required_margin_buffer:.1%}, SMS Alerts={CONFIG.enable_sms_alerts}")
    logger.info(f"{Fore.RED}Safety: Emergency Close on SL Fail = {CONFIG.emergency_close_on_sl_fail}")
    logger.info(f"{Fore.CYAN}Oracle Verbosity (Log Level): {logging.getLevelName(logger.level)}")
    logger.info(f"{Fore.MAGENTA}{'-' * 30}{Style.RESET_ALL}")

    # --- Main Loop ---
    run_bot = True
    cycle_count = 0
    while run_bot:
        cycle_count += 1
        logger.debug(f"{Fore.CYAN}--- Cycle {cycle_count} Weaving Start ---{Style.RESET_ALL}")
        try:
            trade_logic(exchange, CONFIG.symbol, CONFIG.interval)
            logger.debug(f"Cycle {cycle_count} complete. Sleeping for {CONFIG.sleep_seconds} seconds...")
            time.sleep(CONFIG.sleep_seconds)

        except KeyboardInterrupt:
            logger.warning(f"\n{Fore.YELLOW}{Style.BRIGHT}KeyboardInterrupt detected. Requesting graceful withdrawal...{Style.RESET_ALL}")
            send_sms_alert(f"[ScalpBot] Shutdown initiated for {CONFIG.symbol} (KeyboardInterrupt).")
            run_bot = False  # Signal loop termination

        except ccxt.AuthenticationError as e:
             logger.critical(f"{Back.RED}{Fore.WHITE}CRITICAL: Authentication Error during main loop: {e}. API keys invalid/revoked? Shutting down NOW.{Style.RESET_ALL}")
             send_sms_alert("[ScalpBot] CRITICAL: Auth Error - SHUTDOWN. Check Keys/Permissions.")
             run_bot = False # Stop immediately
        except ccxt.NetworkError as e:
            # Log as error but continue running, assuming temporary network issue
            logger.error(f"{Fore.RED}ERROR: Network error in main loop: {e}. Retrying after delay...{Style.RESET_ALL}")
            time.sleep(CONFIG.sleep_seconds * 2)  # Longer delay for network issues
        except ccxt.RateLimitExceeded as e:
            logger.warning(f"{Fore.YELLOW}WARNING: Rate limit exceeded: {e}. Increasing sleep duration...{Style.RESET_ALL}")
            time.sleep(CONFIG.sleep_seconds * 3) # Longer sleep after rate limit
        except ccxt.ExchangeNotAvailable as e:
            logger.error(f"{Fore.RED}ERROR: Exchange not available: {e}. Retrying after longer delay...{Style.RESET_ALL}")
            send_sms_alert(f"[ScalpBot] WARNING: Exchange Not Available {CONFIG.symbol}. Retrying.")
            time.sleep(CONFIG.sleep_seconds * 5) # Much longer delay
        except ccxt.ExchangeError as e:
             # Log as error but continue running, assuming temporary exchange issue
             logger.error(f"{Fore.RED}ERROR: Exchange error in main loop: {e}. Retrying after delay...{Style.RESET_ALL}")
             logger.debug(traceback.format_exc()) # Log full traceback for exchange errors
             time.sleep(CONFIG.sleep_seconds)
        except Exception as e:
            # Catch any other unexpected error, log critically, and stop the bot
            logger.critical(f"{Back.RED}{Fore.WHITE}FATAL: An unexpected error occurred in the main loop: {e}{Style.RESET_ALL}")
            logger.critical(traceback.format_exc())
            send_sms_alert(f"[ScalpBot] FATAL ERROR: {type(e).__name__}. Bot stopped. Check logs!")
            run_bot = False  # Stop on fatal unexpected errors

    # --- Graceful Shutdown ---
    logger.warning(f"{Fore.YELLOW}{Style.BRIGHT}Initiating graceful shutdown sequence...{Style.RESET_ALL}")
    try:
        logger.info("Checking for open position to close on exit...")
        # Ensure exchange object is valid and usable before attempting actions
        if exchange and exchange.check_required_credentials(): # Basic check if usable
             current_pos = get_current_position(exchange, CONFIG.symbol)
             if current_pos[SIDE_KEY] != POSITION_SIDE_NONE:
                 logger.warning(f"Attempting to close {current_pos[SIDE_KEY]} position ({current_pos[QTY_KEY]:.8f}) before exiting...")
                 # Attempt to close, log result but don't prevent shutdown if it fails
                 close_result = close_position(exchange, symbol=CONFIG.symbol, position_to_close=current_pos, reason="Shutdown")
                 if close_result:
                     logger.info("Position closed successfully during shutdown.")
                 else:
                     logger.error(f"{Fore.RED}Failed to close position during shutdown. Manual check required.{Style.RESET_ALL}")
                     send_sms_alert(f"[ScalpBot] Error closing position {CONFIG.symbol} on shutdown. MANUAL CHECK!")
             else:
                 logger.info("No open position found to close.")
        else:
             logger.warning("Exchange object not available or authenticated for final position check.")
    except Exception as close_err:
         # Catch errors during the shutdown close attempt itself
         logger.error(f"{Fore.RED}Failed to check/close position during final shutdown sequence: {close_err}{Style.RESET_ALL}")
         logger.debug(traceback.format_exc())
         send_sms_alert("[ScalpBot] Error during final position close check on shutdown.")

    logger.info(f"{Back.BLUE}{Fore.WHITE}{Style.BRIGHT}--- Pyrmethus Scalping Spell Deactivated ---{Style.RESET_ALL}")


if __name__ == "__main__":
    main()
#!/usr/bin/env python

# ██████╗ ██╗   ██╗███████╗███╗   ███╗███████╗████████╗██╗   ██╗██╗   ██╗███████╗
# ██╔══██╗╚██╗ ██╔╝██╔════╝████╗ ████║██╔════╝╚══██╔══╝██║   ██║██║   ██║██╔════╝
# ██████╔╝ ╚████╔╝ ███████╗██╔████╔██║███████╗   ██║   ██║   ██║██║   ██║███████╗
# ██╔═══╝   ╚██╔╝  ╚════██║██║╚██╔╝██║╚════██║   ██║   ██║   ██║██║   ██║╚════██║
# ██║        ██║   ███████║██║ ╚═╝ ██║███████║   ██║   ╚██████╔╝╚██████╔╝███████║
# ╚═╝        ╚═╝   ╚══════╝╚═╝     ╚═╝╚══════╝   ╚═╝    ╚═════╝  ╚═════╝ ╚══════╝
# Pyrmethus - Unified Scalping Spell v10.1.0 (Reforged Config & Arcane Clarity)
# Conjures high-frequency trades on Bybit Futures with enhanced config, precision, V5 focus, and Termux integration.

"""High-Frequency Trading Bot (Scalping) for Bybit USDT Futures
Version: 10.1.0 (Reforged: Class-based Config, Enhanced Fill Confirm, Standardized SL/TP, Pyrmethus Style).

Features:
- Dual Supertrend strategy with confirmation.
- ATR for volatility measurement and SL/TP calculation.
- **CRITICAL SAFETY UPGRADE:** Implements exchange-native Stop-Loss and Take-Profit
  orders (both using `stopMarket` type) immediately after entry confirmation,
  based on actual fill price. Uses `fetch_order` primarily for faster confirmation.
- **Includes necessary 'triggerDirection' parameter for Bybit V5 API.**
- Optional Volume spike analysis for entry confirmation.
- Optional Order book pressure analysis for entry confirmation.
- **Enhanced Risk Management:**
    - Risk-based position sizing with margin checks.
    - Checks against exchange minimum order amount and cost *before* placing orders.
    - Caps position size based on `MAX_ORDER_USDT_AMOUNT`.
- **Reforged Configuration:** Uses a dedicated `Config` class for better organization and validation.
- Termux SMS alerts for critical events (with Termux:API check).
- Robust error handling and logging with vibrant Neon color support via Colorama.
- Graceful shutdown on KeyboardInterrupt with position closing attempt.
- Stricter position detection logic (targeting Bybit V5 API).
- **Decimal Precision:** Uses Decimal for critical financial calculations.

Disclaimer:
- **EXTREME RISK**: Arcane energies are volatile. Educational purposes ONLY. High-risk. Use at own absolute risk.
- **EXCHANGE-NATIVE SL/TP:** Relies on exchange-native orders. Subject to exchange performance, slippage, API reliability.
- Parameter Sensitivity: Requires significant tuning and testing in the astral plane (testnet).
- API Rate Limits: Monitor usage lest the exchange spirits grow wary.
- Slippage: Market orders are prone to slippage in turbulent ether.
- Test Thoroughly: **DO NOT RUN LIVE WITHOUT EXTENSIVE TESTNET/DEMO TESTING.**
- Termux Dependency: Requires Termux:API for SMS communication scrolls. Ensure `pkg install termux-api`.
- API Changes: Exchange APIs (like Bybit V5) can change. Ensure CCXT is updated.

**Installation:**
pip install ccxt pandas pandas_ta python-dotenv colorama # termux-api (if using Termux for SMS)
"""

# Standard Library Imports - The Foundational Runes
import contextlib
import logging
import os
import shutil  # For checking command existence
import subprocess  # For Termux API calls
import sys
import time
import traceback
from decimal import ROUND_HALF_UP, Decimal, InvalidOperation, getcontext
from typing import Any

# Third-party Libraries - Summoned Essences
try:
    import ccxt
    import pandas as pd
    import pandas_ta as ta  # type: ignore[import]
    from colorama import Back, Fore, Style
    from colorama import init as colorama_init
    from dotenv import load_dotenv
except ImportError as e:
    missing_pkg = e.name
    # Use Colorama's raw codes here as it might not be initialized yet
    sys.exit(1)

# --- Initializations - Preparing the Ritual Chamber ---
colorama_init(autoreset=True)  # Activate Colorama's magic
load_dotenv()  # Load secrets from the hidden .env scroll
getcontext().prec = 18  # Set Decimal precision for financial exactitude

# --- Constants ---

# --- String Constants ---
# Dictionary Keys / Internal Representations
SIDE_KEY = 'side'
QTY_KEY = 'qty'
ENTRY_PRICE_KEY = 'entry_price'
INFO_KEY = 'info'
SYMBOL_KEY = 'symbol'
ID_KEY = 'id'
AVG_PRICE_KEY = 'avgPrice'  # Bybit V5 raw field preferred
CONTRACTS_KEY = 'contracts'  # CCXT unified field
FILLED_KEY = 'filled'
COST_KEY = 'cost'
AVERAGE_KEY = 'average'  # CCXT unified field for fill price
TIMESTAMP_KEY = 'timestamp'
LAST_PRICE_KEY = 'last'
BIDS_KEY = 'bids'
ASKS_KEY = 'asks'
SPREAD_KEY = 'spread'
BEST_BID_KEY = 'best_bid'
BEST_ASK_KEY = 'best_ask'
BID_ASK_RATIO_KEY = 'bid_ask_ratio'
ATR_KEY = 'atr'
VOLUME_MA_KEY = 'volume_ma'
LAST_VOLUME_KEY = 'last_volume'
VOLUME_RATIO_KEY = 'volume_ratio'
STATUS_KEY = 'status'
PRICE_KEY = 'price'  # Fallback for average price

# Order Sides / Position Sides
SIDE_BUY = 'buy'
SIDE_SELL = 'sell'
POSITION_SIDE_LONG = 'Long'    # Internal representation for long position
POSITION_SIDE_SHORT = 'Short'  # Internal representation for short position
POSITION_SIDE_NONE = 'None'    # Internal representation for no position / Bybit V5 side 'None'
BYBIT_SIDE_BUY = 'Buy'         # Bybit V5 API side
BYBIT_SIDE_SELL = 'Sell'       # Bybit V5 API side

# Order Types / Statuses / Params
ORDER_TYPE_MARKET = 'market'
ORDER_TYPE_STOP_MARKET = 'stopMarket'  # Used for both SL and TP conditional market orders
# ORDER_TYPE_TAKE_PROFIT_MARKET = 'takeProfitMarket' # Deprecated in favor of stopMarket with triggerDirection
ORDER_STATUS_OPEN = 'open'
ORDER_STATUS_CLOSED = 'closed'
ORDER_STATUS_CANCELED = 'canceled'  # Note: CCXT might use 'cancelled' or 'canceled'
ORDER_STATUS_REJECTED = 'rejected'
ORDER_STATUS_EXPIRED = 'expired'
PARAM_REDUCE_ONLY = 'reduce_only'  # CCXT standard param name
PARAM_STOP_PRICE = 'stopPrice'  # CCXT standard param name for trigger price
# PARAM_TRIGGER_PRICE = 'triggerPrice' # Often interchangeable with stopPrice in CCXT, prefer stopPrice
PARAM_TRIGGER_DIRECTION = 'triggerDirection'  # Bybit V5 specific for conditional orders (1=above, 2=below)
PARAM_CATEGORY = 'category'  # Bybit V5 specific for linear/inverse

# Currencies
USDT_SYMBOL = "USDT"

# --- Logger Setup - The Oracle's Voice ---
LOGGING_LEVEL_STR = os.getenv("LOGGING_LEVEL", "INFO").upper()
LOGGING_LEVEL = getattr(logging, LOGGING_LEVEL_STR, logging.INFO)

# Custom Log Level for Success
SUCCESS_LEVEL = 25  # Between INFO and WARNING
logging.addLevelName(SUCCESS_LEVEL, "SUCCESS")


def log_success(self, message, *args, **kwargs) -> None:  # type: ignore
    """Adds a 'success' log level method."""
    if self.isEnabledFor(SUCCESS_LEVEL):
        # pylint: disable=protected-access
        self._log(SUCCESS_LEVEL, message, args, **kwargs)


# Bind the new method to the Logger class
logging.Logger.success = log_success  # type: ignore

# Basic configuration first
logging.basicConfig(
    level=LOGGING_LEVEL,
    format="%(asctime)s [%(levelname)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
    handlers=[
        # logging.FileHandler("scalp_bot_v10.1.log"), # Optional: Log to file
        logging.StreamHandler(sys.stdout)  # Log to console
    ]
)
logger: logging.Logger = logging.getLogger(__name__)

# Apply colors if outputting to a TTY (like Termux)
if hasattr(sys.stdout, 'isatty') and sys.stdout.isatty():
    # Apply Pyrmethus colors
    logging.addLevelName(logging.DEBUG, f"{Fore.CYAN}{Style.DIM}{logging.getLevelName(logging.DEBUG)}{Style.RESET_ALL}")  # Dim Cyan for Debug
    logging.addLevelName(logging.INFO, f"{Fore.BLUE}{logging.getLevelName(logging.INFO)}{Style.RESET_ALL}")  # Blue for Info
    logging.addLevelName(SUCCESS_LEVEL, f"{Fore.MAGENTA}{Style.BRIGHT}{logging.getLevelName(SUCCESS_LEVEL)}{Style.RESET_ALL}")  # Bright Magenta for Success
    logging.addLevelName(logging.WARNING, f"{Fore.YELLOW}{Style.BRIGHT}{logging.getLevelName(logging.WARNING)}{Style.RESET_ALL}")  # Bright Yellow for Warning
    logging.addLevelName(logging.ERROR, f"{Fore.RED}{Style.BRIGHT}{logging.getLevelName(logging.ERROR)}{Style.RESET_ALL}")  # Bright Red for Error
    logging.addLevelName(logging.CRITICAL, f"{Back.RED}{Fore.WHITE}{Style.BRIGHT}{logging.getLevelName(logging.CRITICAL)}{Style.RESET_ALL}")  # White on Red for Critical
else:
    # Avoid color codes if not a TTY
    logging.addLevelName(SUCCESS_LEVEL, "SUCCESS")  # Ensure level name exists without color


# --- Configuration Class - Defining the Spell's Parameters ---
class Config:
    """Loads, validates, and stores configuration parameters with arcane precision."""
    def __init__(self) -> None:
        logger.info(f"{Fore.MAGENTA}--- Summoning Configuration Runes ---{Style.RESET_ALL}")
        valid = True  # Track overall validity

        # --- API Credentials (Required) ---
        self.api_key: str | None = self._get_env("BYBIT_API_KEY", None, str, required=True, color=Fore.RED)
        self.api_secret: str | None = self._get_env("BYBIT_API_SECRET", None, str, required=True, color=Fore.RED)
        if not self.api_key or not self.api_secret: valid = False

        # --- Trading Parameters ---
        self.symbol: str = self._get_env("SYMBOL", "BTC/USDT:USDT", str, color=Fore.YELLOW)
        self.interval: str = self._get_env("INTERVAL", "1m", str, color=Fore.YELLOW)
        self.leverage: int = self._get_env("LEVERAGE", 10, int, color=Fore.YELLOW)
        self.sleep_seconds: int = self._get_env("SLEEP_SECONDS", 10, int, color=Fore.YELLOW)
        if self.leverage <= 0: logger.critical(f"CRITICAL CONFIG: LEVERAGE invalid: {self.leverage}"); valid = False
        if self.sleep_seconds <= 0: logger.warning(f"CONFIG WARNING: SLEEP_SECONDS ({self.sleep_seconds}) invalid. Setting to 1."); self.sleep_seconds = 1

        # --- Risk Management (CRITICAL) ---
        self.risk_per_trade_percentage: Decimal = self._get_env("RISK_PER_TRADE_PERCENTAGE", Decimal("0.005"), Decimal, color=Fore.GREEN)
        self.atr_stop_loss_multiplier: Decimal = self._get_env("ATR_STOP_LOSS_MULTIPLIER", Decimal("1.5"), Decimal, color=Fore.GREEN)
        self.atr_take_profit_multiplier: Decimal = self._get_env("ATR_TAKE_PROFIT_MULTIPLIER", Decimal("2.0"), Decimal, color=Fore.GREEN)
        self.max_order_usdt_amount: Decimal = self._get_env("MAX_ORDER_USDT_AMOUNT", Decimal("500.0"), Decimal, color=Fore.GREEN)
        self.required_margin_buffer: Decimal = self._get_env("REQUIRED_MARGIN_BUFFER", Decimal("1.05"), Decimal, color=Fore.GREEN)
        if not (Decimal(0) < self.risk_per_trade_percentage < Decimal(1)): logger.critical(f"CRITICAL CONFIG: RISK_PER_TRADE_PERCENTAGE invalid: {self.risk_per_trade_percentage}"); valid = False
        if self.atr_stop_loss_multiplier <= 0: logger.warning(f"CONFIG WARNING: ATR_STOP_LOSS_MULTIPLIER ({self.atr_stop_loss_multiplier}) not positive.")
        if self.atr_take_profit_multiplier <= 0: logger.warning(f"CONFIG WARNING: ATR_TAKE_PROFIT_MULTIPLIER ({self.atr_take_profit_multiplier}) not positive.")
        if self.max_order_usdt_amount <= 0: logger.warning(f"CONFIG WARNING: MAX_ORDER_USDT_AMOUNT ({self.max_order_usdt_amount}) not positive.")
        if self.required_margin_buffer < 1: logger.warning(f"CONFIG WARNING: REQUIRED_MARGIN_BUFFER ({self.required_margin_buffer}) is less than 1. Margin checks might be ineffective.")

        # --- Supertrend Indicator Parameters ---
        self.st_atr_length: int = self._get_env("ST_ATR_LENGTH", 7, int, color=Fore.CYAN)
        self.st_multiplier: float = float(self._get_env("ST_MULTIPLIER", Decimal("2.5"), Decimal, color=Fore.CYAN))  # pandas_ta needs float
        self.confirm_st_atr_length: int = self._get_env("CONFIRM_ST_ATR_LENGTH", 5, int, color=Fore.CYAN)
        self.confirm_st_multiplier: float = float(self._get_env("CONFIRM_ST_MULTIPLIER", Decimal("2.0"), Decimal, color=Fore.CYAN))  # pandas_ta needs float
        if self.st_atr_length <= 0 or self.confirm_st_atr_length <= 0: logger.warning("CONFIG WARNING: Supertrend ATR length(s) are zero or negative.")

        # --- Volume Analysis Parameters ---
        self.volume_ma_period: int = self._get_env("VOLUME_MA_PERIOD", 20, int, color=Fore.YELLOW)
        self.volume_spike_threshold: Decimal = self._get_env("VOLUME_SPIKE_THRESHOLD", Decimal("1.5"), Decimal, color=Fore.YELLOW)
        self.require_volume_spike_for_entry: bool = self._get_env("REQUIRE_VOLUME_SPIKE_FOR_ENTRY", True, bool, color=Fore.YELLOW)
        if self.volume_ma_period <= 0: logger.warning("CONFIG WARNING: VOLUME_MA_PERIOD is zero or negative.")

        # --- Order Book Analysis Parameters ---
        self.order_book_depth: int = self._get_env("ORDER_BOOK_DEPTH", 10, int, color=Fore.YELLOW)
        self.order_book_ratio_threshold_long: Decimal = self._get_env("ORDER_BOOK_RATIO_THRESHOLD_LONG", Decimal("1.2"), Decimal, color=Fore.YELLOW)
        self.order_book_ratio_threshold_short: Decimal = self._get_env("ORDER_BOOK_RATIO_THRESHOLD_SHORT", Decimal("0.8"), Decimal, color=Fore.YELLOW)
        self.fetch_order_book_per_cycle: bool = self._get_env("FETCH_ORDER_BOOK_PER_CYCLE", False, bool, color=Fore.YELLOW)
        self.use_ob_confirm: bool = self._get_env("USE_OB_CONFIRM", True, bool, color=Fore.YELLOW)  # Added explicit OB confirmation flag

        # --- ATR Calculation Parameter (for SL/TP) ---
        self.atr_calculation_period: int = self._get_env("ATR_CALCULATION_PERIOD", 14, int, color=Fore.GREEN)
        if self.atr_calculation_period <= 0: logger.warning("CONFIG WARNING: ATR_CALCULATION_PERIOD is zero or negative.")

        # --- Termux SMS Alert Configuration ---
        self.enable_sms_alerts: bool = self._get_env("ENABLE_SMS_ALERTS", False, bool, color=Fore.MAGENTA)
        self.sms_recipient_number: str | None = self._get_env("SMS_RECIPIENT_NUMBER", None, str, color=Fore.MAGENTA)
        self.sms_timeout_seconds: int = self._get_env("SMS_TIMEOUT_SECONDS", 30, int, color=Fore.MAGENTA)
        if self.enable_sms_alerts and not self.sms_recipient_number: logger.warning("CONFIG WARNING: SMS alerts enabled, but SMS_RECIPIENT_NUMBER not set.")

        # --- CCXT / API Parameters ---
        self.default_recv_window: int = self._get_env("RECV_WINDOW", 10000, int, color=Fore.WHITE)
        self.order_book_fetch_limit: int = max(25, self.order_book_depth)  # Ensure sufficient depth fetched
        self.shallow_ob_fetch_depth: int = self._get_env("SHALLOW_OB_FETCH_DEPTH", 5, int, color=Fore.WHITE)

        # --- Internal Constants & Behavior ---
        self.retry_count: int = self._get_env("RETRY_COUNT", 3, int, color=Fore.WHITE)
        self.retry_delay_seconds: int = self._get_env("RETRY_DELAY_SECONDS", 1, int, color=Fore.WHITE)
        self.api_fetch_limit_buffer: int = self._get_env("API_FETCH_LIMIT_BUFFER", 5, int, color=Fore.WHITE)
        self.position_qty_epsilon: Decimal = self._get_env("POSITION_QTY_EPSILON", Decimal("1e-9"), Decimal, color=Fore.WHITE)
        self.post_close_delay_seconds: int = self._get_env("POST_CLOSE_DELAY_SECONDS", 2, int, color=Fore.WHITE)
        self.post_entry_delay_seconds: float = float(self._get_env("POST_ENTRY_DELAY_SECONDS", Decimal("1.0"), Decimal, color=Fore.WHITE))
        self.fetch_order_status_retries: int = self._get_env("FETCH_ORDER_STATUS_RETRIES", 5, int, color=Fore.WHITE)
        self.fetch_order_status_delay: float = float(self._get_env("FETCH_ORDER_STATUS_DELAY", Decimal("0.5"), Decimal, color=Fore.WHITE))
        self.enable_monitor_sltp: bool = self._get_env("ENABLE_MONITOR_SLTP", False, bool, color=Fore.YELLOW)  # Redundant check flag

        # --- Final Validation Check ---
        if not valid:
            logger.critical(f"{Back.RED}{Fore.WHITE}--- Configuration validation FAILED. Cannot proceed. ---{Style.RESET_ALL}")
            raise ValueError("Critical configuration validation failed.")
        else:
            logger.success(f"{Fore.GREEN}{Style.BRIGHT}--- Configuration Runes Summoned and Verified ---{Style.RESET_ALL}")

    def _get_env(self, var_name: str, default: Any, expected_type: type, required: bool = False, color: str = Fore.WHITE) -> Any:
        """Gets an environment variable, casts type (incl. defaults), logs, handles errors.
        Handles str, int, float, bool, and Decimal types.
        """
        value_str = os.getenv(var_name)
        source = "environment" if value_str is not None else "default"
        value_to_process = value_str if value_str is not None else default

        log_val_str = f"'{value_str}'" if source == "environment" else f"(Default: '{default}')"
        logger.debug(f"{color}Summoning {var_name}: {log_val_str}{Style.RESET_ALL}")

        if value_to_process is None:
            if required:
                logger.critical(f"{Back.RED}{Fore.WHITE}CRITICAL: Required config '{var_name}' is missing and has no default.{Style.RESET_ALL}")
                # Raise error immediately if required and no value/default
                raise ValueError(f"Required environment variable '{var_name}' not set and no default provided.")
            return None  # Return None if not required and no value/default

        try:
            if expected_type == bool:
                return str(value_to_process).lower() in ('true', '1', 't', 'yes', 'y')
            elif expected_type == Decimal:
                return Decimal(str(value_to_process))
            else:
                # Handle int, float, str directly
                return expected_type(value_to_process)
        except (ValueError, TypeError, InvalidOperation) as e:
            env_val_disp = f"'{value_str}'" if value_str is not None else "(Not Set)"
            logger.error(
                f"{Fore.RED}Config Error: Invalid type/value for {var_name}={env_val_disp} (Source: {source}). "
                f"Expected {expected_type.__name__}. Error: {e}. Trying default '{default}'...{Style.RESET_ALL}"
            )
            # Try casting the default again if the primary value failed
            if default is None:
                if required:  # Should have been caught above, but defensive check
                     raise ValueError(f"Required env var '{var_name}' failed casting and has no valid default.")
                return None
            try:
                if expected_type == bool: return str(default).lower() in ('true', '1', 't', 'yes', 'y')
                elif expected_type == Decimal: return Decimal(str(default))
                else: return expected_type(default)
            except (ValueError, TypeError, InvalidOperation) as e_default:
                logger.critical(
                    f"{Back.RED}{Fore.WHITE}CRITICAL CONFIG: Default '{default}' for {var_name} is also incompatible "
                    f"with type {expected_type.__name__}. Error: {e_default}. Cannot proceed.{Style.RESET_ALL}"
                )
                raise ValueError(f"Configuration error: Cannot cast value or default for key '{var_name}' to {expected_type.__name__}.")


# --- Global Objects - Instantiated Arcana ---
try:
    CONFIG = Config()  # Forge the configuration object
except ValueError:
    # Error already logged within Config init or _get_env
    send_sms_alert("[ScalpBot] CRITICAL: Config validation FAILED. Bot stopped.")  # Send SMS on critical config fail
    sys.exit(1)

# --- Termux SMS Alert Function - Sending Whispers ---
_termux_sms_command_exists: bool | None = None  # Cache check result


def send_sms_alert(message: str) -> bool:
    """Sends an SMS alert using Termux API, a whisper through the digital veil."""
    global _termux_sms_command_exists

    if not CONFIG.enable_sms_alerts:
        logger.debug("SMS alerts disabled by configuration.")
        return False

    # Check for command existence only once
    if _termux_sms_command_exists is None:
        _termux_sms_command_exists = shutil.which('termux-sms-send') is not None
        if not _termux_sms_command_exists:
             logger.warning(f"{Fore.YELLOW}SMS failed: 'termux-sms-send' command not found. Ensure Termux:API is installed (`pkg install termux-api`) and configured.{Style.RESET_ALL}")

    if not _termux_sms_command_exists:
        return False  # Don't proceed if command is missing

    if not CONFIG.sms_recipient_number:
        logger.warning(f"{Fore.YELLOW}SMS alerts enabled, but SMS_RECIPIENT_NUMBER rune is missing.{Style.RESET_ALL}")
        return False

    try:
        # Prepare the command spell
        command: list[str] = ['termux-sms-send', '-n', CONFIG.sms_recipient_number, message]
        logger.info(f"{Fore.MAGENTA}Dispatching SMS whisper to {CONFIG.sms_recipient_number} (Timeout: {CONFIG.sms_timeout_seconds}s)...{Style.RESET_ALL}")
        # Execute the spell via subprocess
        result = subprocess.run(command, capture_output=True, text=True, check=False, timeout=CONFIG.sms_timeout_seconds)
        if result.returncode == 0:
            logger.success(f"{Fore.MAGENTA}SMS whisper dispatched successfully.{Style.RESET_ALL}")
            return True
        else:
            logger.error(f"{Fore.RED}SMS whisper failed. RC: {result.returncode}, Stderr: {result.stderr.strip()}{Style.RESET_ALL}")
            return False
    except FileNotFoundError:
        # This shouldn't happen due to the check above, but handle defensively
        logger.error(f"{Fore.RED}SMS failed: 'termux-sms-send' vanished unexpectedly?{Style.RESET_ALL}")
        _termux_sms_command_exists = False  # Update cache
        return False
    except subprocess.TimeoutExpired:
        logger.error(f"{Fore.RED}SMS failed: Command timed out after {CONFIG.sms_timeout_seconds}s.{Style.RESET_ALL}")
        return False
    except Exception as e:
        logger.error(f"{Fore.RED}SMS failed: Unexpected disturbance: {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())
        return False


# --- Exchange Initialization - Opening the Portal ---
def initialize_exchange() -> ccxt.Exchange | None:
    """Initializes and returns the CCXT Bybit exchange instance, opening a portal."""
    logger.info(f"{Fore.BLUE}Opening portal to Bybit via CCXT...{Style.RESET_ALL}")
    # API keys already checked in Config, but double-check instance variables
    if not CONFIG.api_key or not CONFIG.api_secret:
         logger.critical(f"{Back.RED}{Fore.WHITE}CRITICAL: API keys check failed during initialization.{Style.RESET_ALL}")
         return None

    exchange = ccxt.bybit(
        {
            'apiKey': CONFIG.api_key,
            'secret': CONFIG.api_secret,
            'enableRateLimit': True,  # Built-in rate limiting
            'options': {
                'adjustForTimeDifference': True,  # Adjust for clock skew
                'recvWindow': CONFIG.default_recv_window,  # Increase if timestamp errors occur
                'defaultType': 'swap',  # Explicitly default to swap markets
                'warnOnFetchOpenOrdersWithoutSymbol': False,  # Suppress common warning
                'brokerId': 'Pyrmethus_Scalp_v10.1'  # Optional: Identify the bot
            }
        }
    )
    try:
        # Test connection and authentication by fetching markets and balance
        logger.debug("Loading market structures...")
        exchange.load_markets()
        logger.debug("Fetching balance (tests authentication)...")
        balance = exchange.fetch_balance()  # Throws AuthenticationError on bad keys
        total_usdt = balance.get('total', {}).get(USDT_SYMBOL, 'N/A')
        logger.debug(f"Initial balance fetched: {total_usdt} {USDT_SYMBOL}")
        logger.success(f"{Fore.GREEN}{Style.BRIGHT}Portal to Bybit Opened (LIVE SCALPING MODE - EXTREME CAUTION!).{Style.RESET_ALL}")
        send_sms_alert("[ScalpBot] Initialized successfully and authenticated.")
        return exchange

    except ccxt.AuthenticationError as e:
        logger.critical(f"{Back.RED}{Fore.WHITE}Authentication failed: {e}. Check API key/secret and ensure IP whitelist (if used) is correct and API permissions are sufficient.{Style.RESET_ALL}")
        send_sms_alert(f"[ScalpBot] CRITICAL: Authentication FAILED: {e}. Bot stopped.")
        return None
    except ccxt.NetworkError as e:
        logger.critical(f"{Back.RED}{Fore.WHITE}Network error during initialization: {e}. Check internet connection and Bybit status.{Style.RESET_ALL}")
        send_sms_alert(f"[ScalpBot] CRITICAL: Network Error on Init: {e}. Bot stopped.")
        return None
    except ccxt.ExchangeError as e:
        logger.critical(f"{Back.RED}{Fore.WHITE}Exchange error during initialization: {e}. Check Bybit status page or API documentation for details.{Style.RESET_ALL}")
        send_sms_alert(f"[ScalpBot] CRITICAL: Exchange Error on Init: {e}. Bot stopped.")
        return None
    except Exception as e:
        logger.critical(f"{Back.RED}{Fore.WHITE}Unexpected error initializing exchange: {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())
        send_sms_alert(f"[ScalpBot] CRITICAL: Unexpected Init Error: {type(e).__name__}. Bot stopped.")
        return None


# --- Indicator Calculation Functions - Scrying the Market ---
# (Indicator functions remain largely the same as v10.0, focusing on clarity and Decimal usage)
# Added Pyrmethus logging style.
def calculate_supertrend(
    df: pd.DataFrame, length: int, multiplier: float, prefix: str = ""
) -> pd.DataFrame:  # Uses float multiplier internally for pandas_ta
     """Calculates the Supertrend indicator using the pandas_ta library."""
     required_input_cols = ['high', 'low', 'close']
     col_prefix = f"{prefix}" if prefix else ""
     target_cols = [f"{col_prefix}supertrend", f"{col_prefix}trend", f"{col_prefix}st_long", f"{col_prefix}st_short", ]
     st_col_name = f"SUPERT_{length}_{multiplier}"; st_trend_col = f"SUPERTd_{length}_{multiplier}"
     st_long_col = f"SUPERTl_{length}_{multiplier}"; st_short_col = f"SUPERTs_{length}_{multiplier}"

     if df is None or df.empty or not all(c in df.columns for c in required_input_cols):
         logger.warning(f"{Fore.YELLOW}Scrying ({col_prefix}Supertrend): Input DataFrame is missing required columns {required_input_cols} or is empty.{Style.RESET_ALL}")
         if df is not None:
             for col in target_cols: df[col] = pd.NA
         return df if df is not None else pd.DataFrame()

     if len(df) < length:
         logger.warning(f"{Fore.YELLOW}Scrying ({col_prefix}Supertrend): DataFrame length ({len(df)}) is less than ST period ({length}).{Style.RESET_ALL}")
         for col in target_cols: df[col] = pd.NA
         return df

     try:
         logger.debug(f"Scrying ({col_prefix}ST): Calculating with length={length}, multiplier={multiplier}")
         df.ta.supertrend(length=length, multiplier=multiplier, append=True)

         if st_col_name not in df.columns or st_trend_col not in df.columns:
              raise KeyError(f"pandas_ta failed to create expected raw columns: {st_col_name}, {st_trend_col}")

         cols_to_convert = required_input_cols + [st_col_name, st_trend_col, st_long_col, st_short_col]
         for col in cols_to_convert:
             if col in df.columns:
                 df[col] = pd.to_numeric(df[col], errors='coerce')
         if df[required_input_cols].isnull().values.any():
              logger.warning(f"{Fore.YELLOW}Scrying ({col_prefix}ST): NaNs found in input data after coercion.{Style.RESET_ALL}")

         # Rename and process
         df.rename(columns={st_col_name: target_cols[0]}, inplace=True)  # Supertrend value
         df.rename(columns={st_trend_col: target_cols[1]}, inplace=True)  # Trend direction (-1, 1)

         # Calculate flip signals
         prev_trend_direction = df[target_cols[1]].shift(1)
         df[target_cols[2]] = (prev_trend_direction == -1) & (df[target_cols[1]] == 1)  # Long flip
         df[target_cols[3]] = (prev_trend_direction == 1) & (df[target_cols[1]] == -1)  # Short flip
         df[[target_cols[2], target_cols[3]]] = df[[target_cols[2], target_cols[3]]].fillna(False).astype(bool)  # type: ignore

         # Clean up intermediate columns
         cols_to_drop = [c for c in df.columns if c.startswith("SUPERT_") and c not in target_cols]
         df.drop(columns=list(set(cols_to_drop)), errors='ignore', inplace=True)

         # Log last candle result
         last_trend_val = df[target_cols[1]].iloc[-1] if not df.empty and pd.notna(df[target_cols[1]].iloc[-1]) else None
         last_trend_str = 'Up' if last_trend_val == 1 else 'Down' if last_trend_val == -1 else 'N/A'
         last_st_val = df[target_cols[0]].iloc[-1] if not df.empty and pd.notna(df[target_cols[0]].iloc[-1]) else float('nan')
         trend_color = Fore.GREEN if last_trend_str == 'Up' else Fore.RED if last_trend_str == 'Down' else Fore.WHITE
         logger.debug(f"Scrying ({col_prefix}ST({length}, {multiplier})): Last Trend={trend_color}{last_trend_str}{Style.RESET_ALL}, Last Value={last_st_val:.4f}")

     except (KeyError, AttributeError, Exception) as e:
         logger.error(f"{Fore.RED}Scrying ({col_prefix}Supertrend): Error during calculation: {e}{Style.RESET_ALL}")
         logger.debug(traceback.format_exc())
         for col in target_cols: df[col] = pd.NA
     return df if df is not None else pd.DataFrame()


def analyze_volume_atr(
     df: pd.DataFrame, atr_len: int, vol_ma_len: int
) -> dict[str, Decimal | None]:
     """Calculates ATR, Volume MA, and checks for volume spikes."""
     results: dict[str, Decimal | None] = {ATR_KEY: None, VOLUME_MA_KEY: None, LAST_VOLUME_KEY: None, VOLUME_RATIO_KEY: None}
     required_cols = ['high', 'low', 'close', 'volume']

     if df is None or df.empty or not all(c in df.columns for c in required_cols):
         logger.warning(f"{Fore.YELLOW}Scrying (Vol/ATR): Input DataFrame is missing required columns {required_cols} or is empty.{Style.RESET_ALL}")
         return results
     min_len = max(atr_len, vol_ma_len, 1)
     if len(df) < min_len:
           logger.warning(f"{Fore.YELLOW}Scrying (Vol/ATR): DataFrame length ({len(df)}) < required ({min_len}) for ATR({atr_len})/VolMA({vol_ma_len}).{Style.RESET_ALL}")
           return results

     try:
         for col in required_cols: df[col] = pd.to_numeric(df[col], errors='coerce')
         if df[required_cols].isnull().values.any(): logger.warning(f"{Fore.YELLOW}Scrying (Vol/ATR): NaNs found in input data after coercion.{Style.RESET_ALL}")

         # Calculate ATR
         atr_col = f"ATRr_{atr_len}"
         df.ta.atr(length=atr_len, append=True)
         if atr_col in df.columns and pd.notna(df[atr_col].iloc[-1]):
            try: results[ATR_KEY] = Decimal(str(df[atr_col].iloc[-1]))
            except InvalidOperation: logger.warning(f"Scrying (ATR): Invalid Decimal value for ATR: {df[atr_col].iloc[-1]}")
         else: logger.warning(f"Scrying: Failed to calculate valid ATR({atr_len}).")
         df.drop(columns=[atr_col], errors='ignore', inplace=True)

         # Calculate Volume MA
         volume_ma_col = f"volume_ma_{vol_ma_len}"
         df[volume_ma_col] = df['volume'].rolling(window=vol_ma_len, min_periods=max(1, vol_ma_len // 2)).mean()

         if pd.notna(df[volume_ma_col].iloc[-1]) and pd.notna(df['volume'].iloc[-1]):
            try:
                results[VOLUME_MA_KEY] = Decimal(str(df[volume_ma_col].iloc[-1]))
                results[LAST_VOLUME_KEY] = Decimal(str(df['volume'].iloc[-1]))
            except InvalidOperation: logger.warning("Scrying (Vol): Invalid Decimal value for Volume/MA.")

            # Calculate Volume Ratio
            if results[VOLUME_MA_KEY] and results[VOLUME_MA_KEY] > CONFIG.position_qty_epsilon and results[LAST_VOLUME_KEY]:
                try: results[VOLUME_RATIO_KEY] = (results[LAST_VOLUME_KEY] / results[VOLUME_MA_KEY]).quantize(Decimal("0.01"))
                except InvalidOperation: logger.warning("Scrying (Vol): Invalid Decimal operation for ratio."); results[VOLUME_RATIO_KEY] = None
            else: results[VOLUME_RATIO_KEY] = None; logger.debug(f"Scrying (Vol): Ratio calc skipped (Vol={results[LAST_VOLUME_KEY]}, MA={results[VOLUME_MA_KEY]})")
         else: logger.warning(f"Scrying (Vol): Failed calc VolMA({vol_ma_len}) or get last vol.")
         df.drop(columns=[volume_ma_col], errors='ignore', inplace=True)

         # Log results
         atr_str = f"{results[ATR_KEY]:.4f}" if results[ATR_KEY] else 'N/A'
         last_vol_val = results.get(LAST_VOLUME_KEY)
         vol_ma_val = results.get(VOLUME_MA_KEY)
         vol_ratio_val = results.get(VOLUME_RATIO_KEY)
         last_vol_str = f"{last_vol_val:.2f}" if last_vol_val else 'N/A'
         vol_ma_str = f"{vol_ma_val:.2f}" if vol_ma_val else 'N/A'
         vol_ratio_str = f"{vol_ratio_val:.2f}" if vol_ratio_val else 'N/A'

         logger.debug(f"Scrying Results: ATR({atr_len}) = {Fore.CYAN}{atr_str}{Style.RESET_ALL}")
         logger.debug(f"Scrying Results: Volume: Last={last_vol_str}, MA({vol_ma_len})={vol_ma_str}, Ratio={Fore.YELLOW}{vol_ratio_str}{Style.RESET_ALL}")

     except Exception as e:
         logger.error(f"{Fore.RED}Scrying (Vol/ATR): Error during calculation: {e}{Style.RESET_ALL}")
         logger.debug(traceback.format_exc())
         results = dict.fromkeys(results)
     return results


def analyze_order_book(
     exchange: ccxt.Exchange, symbol: str, depth: int, fetch_limit: int
) -> dict[str, Decimal | None]:  # Returns Decimal or None
     """Fetches L2 order book and analyzes bid/ask pressure and spread."""
     results: dict[str, Decimal | None] = {BID_ASK_RATIO_KEY: None, SPREAD_KEY: None, BEST_BID_KEY: None, BEST_ASK_KEY: None}
     logger.debug(f"Order Book Scrying: Fetching L2 for {symbol} (Analyze Depth: {depth}, API Fetch Limit: {fetch_limit})...")

     try:
         order_book = exchange.fetch_l2_order_book(symbol, limit=fetch_limit)

         if not order_book or not isinstance(order_book.get(BIDS_KEY), list) or not isinstance(order_book.get(ASKS_KEY), list):
             logger.warning(f"{Fore.YELLOW}Order Book Scrying: Incomplete or invalid data structure received for {symbol}.{Style.RESET_ALL}")
             return results

         bids: list[list[float | str]] = order_book[BIDS_KEY]
         asks: list[list[float | str]] = order_book[ASKS_KEY]

         if not bids or not asks:
             logger.warning(f"{Fore.YELLOW}Order Book Scrying: Bids or asks list is empty for {symbol}. Bids: {len(bids)}, Asks: {len(asks)}{Style.RESET_ALL}")
             return results

         # Get best bid/ask and calculate spread
         try:
             best_bid_raw = bids[0][0] if len(bids[0]) > 0 else '0.0'
             best_ask_raw = asks[0][0] if len(asks[0]) > 0 else '0.0'
             results[BEST_BID_KEY] = Decimal(str(best_bid_raw))
             results[BEST_ASK_KEY] = Decimal(str(best_ask_raw))

             if results[BEST_BID_KEY] > 0 and results[BEST_ASK_KEY] > 0:
                  spread = results[BEST_ASK_KEY] - results[BEST_BID_KEY]
                  results[SPREAD_KEY] = spread.quantize(Decimal("0.0001"))  # Adjust precision as needed
                  logger.debug(f"OB Scrying: Best Bid={Fore.GREEN}{results[BEST_BID_KEY]:.4f}{Style.RESET_ALL}, Best Ask={Fore.RED}{results[BEST_ASK_KEY]:.4f}{Style.RESET_ALL}, Spread={Fore.YELLOW}{results[SPREAD_KEY]:.4f}{Style.RESET_ALL}")
             else:
                  logger.debug("OB Scrying: Could not calculate spread (Bid/Ask zero or invalid).")

         except (IndexError, InvalidOperation, ValueError, TypeError) as e:
              logger.warning(f"{Fore.YELLOW}OB Scrying: Error processing best bid/ask/spread for {symbol}: {e}{Style.RESET_ALL}")
              results[BEST_BID_KEY] = None; results[BEST_ASK_KEY] = None; results[SPREAD_KEY] = None

         # Calculate cumulative volume within depth
         try:
             bid_volume_sum_raw = sum(Decimal(str(bid[1])) for bid in bids[:depth] if len(bid) > 1)
             ask_volume_sum_raw = sum(Decimal(str(ask[1])) for ask in asks[:depth] if len(ask) > 1)
             bid_volume_sum = bid_volume_sum_raw.quantize(Decimal("0.0001"))
             ask_volume_sum = ask_volume_sum_raw.quantize(Decimal("0.0001"))
             logger.debug(f"OB Scrying (Depth {depth}): Cum Bid={Fore.GREEN}{bid_volume_sum:.4f}{Style.RESET_ALL}, Cum Ask={Fore.RED}{ask_volume_sum:.4f}{Style.RESET_ALL}")

             # Calculate Bid/Ask Ratio
             if ask_volume_sum > CONFIG.position_qty_epsilon:
                  bid_ask_ratio = (bid_volume_sum / ask_volume_sum).quantize(Decimal("0.01"))
                  results[BID_ASK_RATIO_KEY] = bid_ask_ratio
                  ratio_color = Fore.GREEN if bid_ask_ratio >= CONFIG.order_book_ratio_threshold_long else (Fore.RED if bid_ask_ratio <= CONFIG.order_book_ratio_threshold_short else Fore.YELLOW)
                  logger.debug(f"OB Scrying Ratio (Depth {depth}) = {ratio_color}{bid_ask_ratio:.3f}{Style.RESET_ALL}")
             else:
                  logger.debug(f"OB Scrying Ratio calculation skipped (Ask volume at depth {depth} is zero or negligible)")

         except (IndexError, InvalidOperation, ValueError, TypeError) as e:
              logger.warning(f"{Fore.YELLOW}OB Scrying: Error calculating cumulative volume or ratio for {symbol}: {e}{Style.RESET_ALL}")
              results[BID_ASK_RATIO_KEY] = None

     except (ccxt.NetworkError, ccxt.ExchangeError) as e:
         logger.warning(f"{Fore.YELLOW}OB Scrying: API error fetching order book for {symbol}: {e}{Style.RESET_ALL}")
     except (IndexError, InvalidOperation, ValueError, TypeError) as e:
         logger.warning(f"{Fore.YELLOW}OB Scrying: Error processing OB data for {symbol}: {e}{Style.RESET_ALL}")
     except Exception as e:
         logger.error(f"{Fore.RED}OB Scrying: Unexpected error analyzing order book for {symbol}: {e}{Style.RESET_ALL}")
         logger.debug(traceback.format_exc())
         return dict.fromkeys(results)  # Return None dict on error

     return results


# --- Data Fetching - Gathering Etheric Data Streams ---
def fetch_ohlcv(exchange: ccxt.Exchange, symbol: str, timeframe: str, limit: int) -> pd.DataFrame | None:
    """Fetches OHLCV data with retries and basic validation."""
    logger.info(f"Data Fetch: Gathering {limit} {timeframe} candles for {symbol}...")
    for attempt in range(CONFIG.retry_count):
        try:
            # Fetch OHLCV data
            ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit=limit)

            if not ohlcv:
                logger.warning(f"{Fore.YELLOW}Data Fetch: Received empty OHLCV data for {symbol} on attempt {attempt + 1}.{Style.RESET_ALL}")
                if attempt < CONFIG.retry_count - 1: time.sleep(CONFIG.retry_delay_seconds); continue
                else: return None  # Return None after final retry

            # Convert to DataFrame
            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms', utc=True)  # Time magic
            df.set_index('timestamp', inplace=True)

            # --- Basic Data Validation ---
            if df.empty:
                logger.warning(f"{Fore.YELLOW}Data Fetch: DataFrame is empty after conversion for {symbol}.{Style.RESET_ALL}")
                return None  # Cannot proceed with empty DataFrame

            # Check for NaNs
            if df.isnull().values.any():
                nan_counts = df.isnull().sum()
                logger.warning(f"{Fore.YELLOW}Data Fetch: Fetched OHLCV data contains NaN values. Counts:\n{nan_counts[nan_counts > 0]}\nAttempting forward fill...{Style.RESET_ALL}")
                # Simple imputation: Forward fill NaNs. More sophisticated methods could be used.
                df.ffill(inplace=True)  # type: ignore
                # Check again after filling - if NaNs remain (e.g., at the very beginning), data is unusable
                if df.isnull().values.any():
                    logger.error(f"{Fore.RED}Data Fetch: NaN values remain after forward fill. Cannot proceed with this data batch.{Style.RESET_ALL}")
                    return None

            logger.debug(f"Data Fetch: Successfully woven {len(df)} OHLCV candles for {symbol}.")
            return df

        except (ccxt.NetworkError, ccxt.ExchangeError) as e:
            logger.warning(f"{Fore.YELLOW}Data Fetch: API error fetching OHLCV for {symbol} (Attempt {attempt + 1}/{CONFIG.retry_count}): {e}{Style.RESET_ALL}")
            if attempt < CONFIG.retry_count - 1: time.sleep(CONFIG.retry_delay_seconds)
            else: logger.error(f"{Fore.RED}Data Fetch: Failed to fetch OHLCV for {symbol} after {CONFIG.retry_count} attempts.{Style.RESET_ALL}"); return None
        except Exception as e:
            logger.error(f"{Fore.RED}Data Fetch: Unexpected error fetching market data for {symbol}: {e}{Style.RESET_ALL}")
            logger.debug(traceback.format_exc())
            return None  # Return None on unexpected errors

    return None  # Should not be reached if loop completes, but included for safety


# --- Position & Order Management - Manipulating Market Presence ---
def get_current_position(exchange: ccxt.Exchange, symbol: str) -> dict[str, Any]:  # Returns Decimal for qty/price
     """Fetches current position details for Bybit V5 via CCXT."""
     # Default: no active position, using Decimal for precision
     default_pos: dict[str, Any] = {SIDE_KEY: POSITION_SIDE_NONE, QTY_KEY: Decimal('0.0'), ENTRY_PRICE_KEY: Decimal('0.0')}
     ccxt_unified_symbol = symbol
     market_id = None
     market = None

     # Get Market Info
     try:
         market = exchange.market(ccxt_unified_symbol)
         if not market: raise KeyError(f"Market info not found for {ccxt_unified_symbol}")
         market_id = market.get(ID_KEY)
         if not market_id: raise KeyError(f"Market ID not found in market info for {ccxt_unified_symbol}")
         logger.debug(f"Position Check: Fetching position for CCXT symbol '{ccxt_unified_symbol}' (Target Exchange Market ID: '{market_id}')...")
     except (ccxt.BadSymbol, KeyError) as e:
          logger.error(f"{Fore.RED}Position Check: Failed get market info/ID for '{ccxt_unified_symbol}': {e}{Style.RESET_ALL}")
          return default_pos
     except Exception as e:
          logger.error(f"{Fore.RED}Position Check: Unexpected error getting market info for '{ccxt_unified_symbol}': {e}{Style.RESET_ALL}")
          logger.debug(traceback.format_exc())
          return default_pos

     # Fetch Positions
     try:
         if not exchange.has.get('fetchPositions'):  # type: ignore
             logger.warning(f"{Fore.YELLOW}Position Check: Exchange '{exchange.id}' may not support fetchPositions.{Style.RESET_ALL}")
             return default_pos

         # Determine category for V5 API call
         params = {}
         if market and market.get('linear', False): params = {PARAM_CATEGORY: 'linear'}
         elif market and market.get('inverse', False): params = {PARAM_CATEGORY: 'inverse'}

         positions = exchange.fetch_positions(symbols=[ccxt_unified_symbol], params=params)
         logger.debug(f"Fetched positions data (raw count: {len(positions)})")

         # Filter positions
         for pos in positions:
             pos_info = pos.get(INFO_KEY, {})
             pos_symbol_raw = pos_info.get(SYMBOL_KEY)

             if pos_symbol_raw != market_id: continue  # Skip if not the target symbol

             # Check for One-Way Mode (positionIdx=0)
             position_idx = pos_info.get('positionIdx', -1)
             try: position_idx = int(position_idx)
             except (ValueError, TypeError): position_idx = -1
             if position_idx != 0: continue  # Skip hedge mode positions

             # Check Side (V5: 'Buy', 'Sell', 'None')
             pos_side_v5 = pos_info.get(SIDE_KEY, POSITION_SIDE_NONE)
             determined_side = POSITION_SIDE_NONE
             if pos_side_v5 == BYBIT_SIDE_BUY: determined_side = POSITION_SIDE_LONG
             elif pos_side_v5 == BYBIT_SIDE_SELL: determined_side = POSITION_SIDE_SHORT
             else: continue  # Skip if side is 'None' or unexpected

             # Check Position Size (V5: 'size')
             size_str = pos_info.get('size')
             if size_str is None or size_str == "": continue  # Skip if size field missing

             try:
                 size = Decimal(str(size_str))
                 if abs(size) > CONFIG.position_qty_epsilon:
                     # Found active position! Get entry price.
                     entry_price_str = pos_info.get(AVG_PRICE_KEY) or pos.get(ENTRY_PRICE_KEY)  # Prefer raw V5 avgPrice
                     entry_price = Decimal('0.0')
                     if entry_price_str is not None and entry_price_str != "":
                         try: entry_price = Decimal(str(entry_price_str))
                         except (InvalidOperation, ValueError, TypeError) as price_err:
                              logger.warning(f"Could not parse entry price string: '{entry_price_str}'. Defaulting to 0.0. Error: {price_err}")
                     qty_abs = abs(size)
                     pos_color = Fore.GREEN if determined_side == POSITION_SIDE_LONG else Fore.RED
                     logger.info(f"{pos_color}Position Check: FOUND Active Position for {market_id}: Side={determined_side}, Qty={qty_abs}, Entry={entry_price:.4f}{Style.RESET_ALL}")
                     return {SIDE_KEY: determined_side, QTY_KEY: qty_abs, ENTRY_PRICE_KEY: entry_price}
                 else: continue  # Size negligible, treat as flat

             except (ValueError, TypeError, InvalidOperation) as e:
                  logger.warning(f"{Fore.YELLOW}Position Check: Error parsing size '{size_str}': {e}{Style.RESET_ALL}")
                  continue
         # End of loop

         logger.info(f"{Fore.BLUE}Position Check: No active position found for {market_id} (One-Way Mode).{Style.RESET_ALL}")
         return default_pos

     except (ccxt.NetworkError, ccxt.ExchangeError) as e:
         logger.warning(f"{Fore.YELLOW}Position Check: API error during fetch_positions for {symbol}: {e}{Style.RESET_ALL}")
     except Exception as e:
         logger.error(f"{Fore.RED}Position Check: Unexpected error during position check for {symbol}: {e}{Style.RESET_ALL}")
         logger.debug(traceback.format_exc())

     logger.warning(f"{Fore.YELLOW}Position Check: Returning default (No Position) due to error or no active position found for {symbol}.{Style.RESET_ALL}")
     return default_pos


def set_leverage(exchange: ccxt.Exchange, symbol: str, leverage: int) -> bool:
    """Sets leverage, checks market type, retries."""
    logger.info(f"{Fore.CYAN}Leverage Conjuring: Attempting to set {leverage}x for {symbol}...{Style.RESET_ALL}")
    market_base = "N/A"
    try:
        market = exchange.market(symbol)
        market_base = market.get('base', 'N/A')
        if not market.get('contract', False) or market.get('spot', False):
            logger.error(f"{Fore.RED}Leverage Conjuring: Cannot set leverage for non-contract market: {symbol}. Market type: {market.get('type')}{Style.RESET_ALL}")
            return False
    except (ccxt.BadSymbol, KeyError) as e:
          logger.error(f"{Fore.RED}Leverage Conjuring: Failed to get market info for symbol '{symbol}': {e}{Style.RESET_ALL}")
          return False
    except Exception as e:
          logger.error(f"{Fore.RED}Leverage Conjuring: Unexpected error getting market info for {symbol}: {e}{Style.RESET_ALL}")
          logger.debug(traceback.format_exc())
          return False

    for attempt in range(CONFIG.retry_count):
        try:
            # Bybit V5 requires setting buy and sell leverage separately for set_leverage call via CCXT
            params = {'buyLeverage': str(leverage), 'sellLeverage': str(leverage)}
            logger.debug(f"Leverage Conjuring: Calling exchange.set_leverage({leverage}, '{symbol}', params={params}) (Attempt {attempt + 1}/{CONFIG.retry_count})")
            response = exchange.set_leverage(leverage=leverage, symbol=symbol, params=params)
            logger.success(f"{Fore.GREEN}Leverage Conjuring: Successfully set leverage to {leverage}x for {symbol}. Response: {response}{Style.RESET_ALL}")
            return True

        except ccxt.ExchangeError as e:
            error_msg_lower = str(e).lower()
            if any(p in error_msg_lower for p in ["leverage not modified", "same leverage", "no need to modify leverage", "leverage is same as requested"]):
                logger.info(f"{Fore.CYAN}Leverage Conjuring: Leverage for {symbol} already set to {leverage}x (Confirmed by exchange message).{Style.RESET_ALL}")
                return True
            logger.warning(f"{Fore.YELLOW}Leverage Conjuring: Exchange resistance on attempt {attempt + 1}/{CONFIG.retry_count} for {symbol}: {e}{Style.RESET_ALL}")
            if attempt < CONFIG.retry_count - 1: time.sleep(CONFIG.retry_delay_seconds)
            else: logger.error(f"{Fore.RED}Leverage Conjuring: FAILED after {CONFIG.retry_count} attempts due to exchange error: {e}{Style.RESET_ALL}"); send_sms_alert(f"[{market_base}] CRITICAL: Leverage set FAILED {symbol}."); return False
        except ccxt.NetworkError as e:
             logger.warning(f"{Fore.YELLOW}Leverage Conjuring: Network error on attempt {attempt + 1}/{CONFIG.retry_count} for {symbol}: {e}{Style.RESET_ALL}")
             if attempt < CONFIG.retry_count - 1: time.sleep(CONFIG.retry_delay_seconds)
             else: logger.error(f"{Fore.RED}Leverage Conjuring: FAILED after {CONFIG.retry_count} attempts due to network error.{Style.RESET_ALL}"); send_sms_alert(f"[{market_base}] CRITICAL: Leverage set FAILED (Network) {symbol}."); return False
        except Exception as e:
             logger.error(f"{Fore.RED}Leverage Conjuring: Unexpected error setting leverage for {symbol} on attempt {attempt + 1}: {e}{Style.RESET_ALL}")
             logger.debug(traceback.format_exc())
             return False  # Exit immediately on unexpected errors
    return False


def close_position(
    exchange: ccxt.Exchange, symbol: str, position_to_close: dict[str, Any], reason: str = "Signal"
) -> dict[str, Any] | None:
    """Closes active position via market order with reduce_only, validates first."""
    initial_side = position_to_close.get(SIDE_KEY, POSITION_SIDE_NONE)
    initial_qty = position_to_close.get(QTY_KEY, Decimal('0.0'))
    market_base = symbol.split('/')[0]

    logger.info(f"{Fore.YELLOW}Banish Position: Initiated for {symbol}. Reason: {reason}. Initial state: {initial_side} Qty={initial_qty:.8f}{Style.RESET_ALL}")

    # Re-validate Position Before Closing
    logger.debug("Banish Position: Re-validating live position status...")
    live_position = get_current_position(exchange, symbol)
    live_position_side = live_position.get(SIDE_KEY, POSITION_SIDE_NONE)
    live_amount_to_close = live_position.get(QTY_KEY, Decimal('0.0'))  # Absolute value

    if live_position_side == POSITION_SIDE_NONE or live_amount_to_close <= CONFIG.position_qty_epsilon:
        logger.warning(f"{Fore.YELLOW}Banish Position: Discrepancy detected. Initial check showed {initial_side}, but live check shows none or negligible qty ({live_amount_to_close:.8f}). Assuming already closed.{Style.RESET_ALL}")
        return None

    # Determine the side of the market order needed to close
    side_to_execute_close = SIDE_SELL if live_position_side == POSITION_SIDE_LONG else SIDE_BUY

    # Place Reduce-Only Market Order
    params = {PARAM_REDUCE_ONLY: True}

    try:
        amount_float = float(live_amount_to_close)
        amount_str = exchange.amount_to_precision(symbol, amount_float)
        amount_float_prec = float(amount_str)

        if amount_float_prec <= float(CONFIG.position_qty_epsilon):
            logger.error(f"{Fore.RED}Banish Pos: Closing amount {amount_str} negligible. Abort.{Style.RESET_ALL}")
            return None

        logger.warning(f"{Back.YELLOW}{Fore.BLACK}Banish Position: Attempting to CLOSE {live_position_side} position ({reason}): Executing {side_to_execute_close.upper()} MARKET order for {amount_str} {symbol} (Reduce-Only){Style.RESET_ALL}")

        order = exchange.create_market_order(
            symbol=symbol, side=side_to_execute_close, amount=amount_float_prec, params=params
        )

        # Log details immediately
        fill_price_str = "?"
        if order.get(AVERAGE_KEY) is not None:
            with contextlib.suppress(Exception): fill_price_str = f"{Decimal(str(order.get(AVERAGE_KEY))):.4f}"
        elif order.get(PRICE_KEY) is not None:
             with contextlib.suppress(Exception): fill_price_str = f"{Decimal(str(order.get(PRICE_KEY))):.4f}"
        filled_qty_str = "?"
        if order.get(FILLED_KEY) is not None:
            with contextlib.suppress(Exception): filled_qty_str = f"{Decimal(str(order.get(FILLED_KEY))):.8f}"
        order_id_short = str(order.get(ID_KEY, 'N/A'))[-6:]
        cost_str = "?"
        if order.get(COST_KEY) is not None:
            with contextlib.suppress(Exception): cost_str = f"{Decimal(str(order.get(COST_KEY))):.2f}"

        logger.success(f"{Fore.GREEN}{Style.BRIGHT}Banish Position: CLOSE Order ({reason}) placed successfully for {symbol}. Qty Filled: {filled_qty_str}/{amount_str}, Avg Fill ~{fill_price_str}, Cost: {cost_str} USDT. ID:...{order_id_short}{Style.RESET_ALL}")

        # Send SMS Alert
        sms_msg = (f"[{market_base}] BANISHED {live_position_side} {amount_str} @ ~{fill_price_str} ({reason}). ID:...{order_id_short}")
        send_sms_alert(sms_msg)
        return order

    except ccxt.InsufficientFunds as e:
        logger.error(f"{Fore.RED}Banish Position ({reason}): Insufficient funds error during close attempt: {e}{Style.RESET_ALL}")
        send_sms_alert(f"[{market_base}] ERROR Closing ({reason}): Insuff funds! Check margin.")
    except ccxt.NetworkError as e:
        logger.error(f"{Fore.RED}Banish Position ({reason}): Network error placing close order: {e}{Style.RESET_ALL}")
        send_sms_alert(f"[{market_base}] ERROR Closing ({reason}): Network error! Check connection.")
    except ccxt.ExchangeError as e:
        err_str_lower = str(e).lower()
        # Check for specific errors indicating already closed/closing
        if any(phrase in err_str_lower for phrase in ["order would not reduce position size", "position is zero", "position size is zero", "cannot be less than"]):
             logger.warning(f"{Fore.YELLOW}Banish Position ({reason}): Exchange indicates order would not reduce size or position is zero. Assuming already closed.{Style.RESET_ALL}")
             return None  # Treat as success/non-actionable
        logger.error(f"{Fore.RED}Banish Position ({reason}): Exchange error placing close order: {e}{Style.RESET_ALL}")
        send_sms_alert(f"[{market_base}] ERROR Closing ({reason}): API error ({type(e).__name__}).")
    except (ValueError, TypeError, InvalidOperation) as e:
         logger.error(f"{Fore.RED}Banish Position ({reason}): Value error during amount processing (Qty: {live_amount_to_close}): {e}{Style.RESET_ALL}")
         send_sms_alert(f"[{market_base}] ERROR Closing ({reason}): Value error ({type(e).__name__}).")
    except Exception as e:
        logger.error(f"{Fore.RED}Banish Position ({reason}): Unexpected error placing close order: {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())
        send_sms_alert(f"[{market_base}] ERROR Closing ({reason}): Unexpected error ({type(e).__name__}). Check logs!")

    return None


def calculate_position_size(
    equity: Decimal, risk_per_trade_pct: Decimal, entry_price: Decimal, stop_loss_price: Decimal,
    leverage: int, symbol: str, exchange: ccxt.Exchange
) -> tuple[float | None, float | None]:  # Returns float for create_order
     """Calculates position size based on risk, checks limits."""
     logger.debug(f"Risk Calc Input: Equity={equity:.2f}, Risk%={risk_per_trade_pct:.3%}, Entry={entry_price:.4f}, SL={stop_loss_price:.4f}, Lev={leverage}x, Symbol={symbol}")

     # Input Validation
     if not (entry_price > 0 and stop_loss_price > 0): logger.error(f"{Fore.RED}Risk Calc: Invalid entry/SL price (> 0).{Style.RESET_ALL}"); return None, None
     price_difference_per_unit = abs(entry_price - stop_loss_price)
     if price_difference_per_unit <= CONFIG.position_qty_epsilon: logger.error(f"{Fore.RED}Risk Calc: Entry/SL prices too close.{Style.RESET_ALL}"); return None, None
     if not 0 < risk_per_trade_pct < 1: logger.error(f"{Fore.RED}Risk Calc: Invalid risk %: {risk_per_trade_pct}.{Style.RESET_ALL}"); return None, None
     if equity <= 0: logger.error(f"{Fore.RED}Risk Calc: Invalid equity: {equity:.2f}{Style.RESET_ALL}"); return None, None
     if leverage <= 0: logger.error(f"{Fore.RED}Risk Calc: Invalid leverage: {leverage}{Style.RESET_ALL}"); return None, None

     # Calculation
     risk_amount_usdt: Decimal = equity * risk_per_trade_pct
     quantity: Decimal = risk_amount_usdt / price_difference_per_unit

     # Apply exchange precision
     try:
         quantity_precise_str = exchange.amount_to_precision(symbol, float(quantity))
         quantity_precise = Decimal(quantity_precise_str)
         logger.debug(f"Risk Calc: Raw Qty={quantity:.18f}, Precise Qty={quantity_precise_str}")
         quantity = quantity_precise
     except Exception as e:
          logger.warning(f"{Fore.YELLOW}Risk Calc: Could not apply precision to qty {quantity:.8f} for {symbol}. Using raw. Err: {e}{Style.RESET_ALL}")

     if quantity <= CONFIG.position_qty_epsilon: logger.error(f"{Fore.RED}Risk Calc: Calculated quantity ({quantity}) zero/negligible.{Style.RESET_ALL}"); return None, None

     # Estimate Value and Margin
     position_value_usdt: Decimal = quantity * entry_price
     required_margin_estimate: Decimal = position_value_usdt / Decimal(leverage)
     logger.debug(f"Risk Calc Output: RiskAmt={risk_amount_usdt:.2f}, PriceDiff={price_difference_per_unit:.4f} => PreciseQty={quantity:.8f}, EstVal={position_value_usdt:.2f}, EstMargin={required_margin_estimate:.2f}")

     # Exchange Limit Checks
     try:
         market = exchange.market(symbol)
         limits = market.get('limits', {})
         amount_limits = limits.get('amount', {})
         cost_limits = limits.get('cost', {})
         min_amount = Decimal(str(amount_limits.get('min', '0'))) if amount_limits.get('min') is not None else Decimal('0')
         max_amount = Decimal(str(amount_limits.get('max', 'inf'))) if amount_limits.get('max') is not None else Decimal('inf')
         min_cost = Decimal(str(cost_limits.get('min', '0'))) if cost_limits.get('min') is not None else Decimal('0')
         max_cost = Decimal(str(cost_limits.get('max', 'inf'))) if cost_limits.get('max') is not None else Decimal('inf')
         logger.debug(f"Market Limits for {symbol}: MinAmt={min_amount}, MaxAmt={max_amount}, MinCost={min_cost}, MaxCost={max_cost}")

         if quantity < min_amount: logger.error(f"{Fore.RED}Risk Calc: Qty {quantity:.8f} < MinAmt {min_amount:.8f}.{Style.RESET_ALL}"); return None, None
         if position_value_usdt < min_cost: logger.error(f"{Fore.RED}Risk Calc: EstVal {position_value_usdt:.2f} < MinCost {min_cost:.2f}.{Style.RESET_ALL}"); return None, None
         if quantity > max_amount:
             logger.warning(f"{Fore.YELLOW}Risk Calc: Qty {quantity:.8f} > MaxAmt {max_amount:.8f}. Capping.{Style.RESET_ALL}")
             quantity = max_amount
             position_value_usdt = quantity * entry_price
             required_margin_estimate = position_value_usdt / Decimal(leverage)
             logger.info(f"Risk Calc: Capped Qty={quantity:.8f}, New EstVal={position_value_usdt:.2f}, New EstMargin={required_margin_estimate:.2f}")
         if position_value_usdt > max_cost: logger.error(f"{Fore.RED}Risk Calc: EstVal {position_value_usdt:.2f} > MaxCost {max_cost:.2f}.{Style.RESET_ALL}"); return None, None

     except (ccxt.BadSymbol, KeyError) as e: logger.warning(f"{Fore.YELLOW}Risk Calc: Could not fetch market limits for {symbol}: {e}. Skipping checks.{Style.RESET_ALL}")
     except (InvalidOperation, ValueError, TypeError) as e: logger.warning(f"{Fore.YELLOW}Risk Calc: Error parsing market limits for {symbol}: {e}. Skipping checks.{Style.RESET_ALL}")
     except Exception as e: logger.warning(f"{Fore.YELLOW}Risk Calc: Unexpected error checking market limits: {e}. Skipping checks.{Style.RESET_ALL}"); logger.debug(traceback.format_exc())

     # Return float for CCXT compatibility
     return float(quantity), float(required_margin_estimate)


def confirm_order_fill(exchange: ccxt.Exchange, order_id: str, symbol: str) -> dict[str, Any] | None:
    """Confirms if an order is filled using fetch_order primarily, falling back to fetch_closed_orders.

    Args:
        exchange: Initialized CCXT exchange object.
        order_id: The ID of the order to confirm.
        symbol: Unified CCXT symbol.

    Returns:
        Optional[Dict[str, Any]]: The filled order details, or None if not confirmed filled/failed.
    """
    log_prefix = f"Fill Confirm (ID:...{order_id[-6:]})"
    logger.debug(f"{log_prefix}: Attempting to confirm fill...")
    start_time = time.time()
    confirmed_order = None

    # --- Primary Method: fetch_order ---
    for attempt in range(CONFIG.fetch_order_status_retries):
        try:
            order = exchange.fetch_order(order_id, symbol)
            status = order.get(STATUS_KEY)
            logger.debug(f"{log_prefix}: Attempt {attempt + 1}, fetch_order status: {status}")

            if status == ORDER_STATUS_CLOSED:
                logger.success(f"{log_prefix}: Confirmed FILLED via fetch_order.")
                confirmed_order = order
                break  # Exit loop on success
            elif status in [ORDER_STATUS_CANCELED, ORDER_STATUS_REJECTED, ORDER_STATUS_EXPIRED]:
                logger.error(f"{Fore.RED}{log_prefix}: Order FAILED with status '{status}' via fetch_order.{Style.RESET_ALL}")
                return None  # Order definitively failed

            # If status is 'open' or None, continue retrying

        except ccxt.OrderNotFound:
            logger.warning(f"{Fore.YELLOW}{log_prefix}: Order not found via fetch_order (Attempt {attempt + 1}). Might be processing or already closed.{Style.RESET_ALL}")
            # Continue to next attempt, will try fallback later
        except (ccxt.NetworkError, ccxt.ExchangeError) as e:
            logger.warning(f"{Fore.YELLOW}{log_prefix}: API error during fetch_order (Attempt {attempt + 1}): {e}{Style.RESET_ALL}")
            # Continue retrying
        except Exception as e:
            logger.error(f"{Fore.RED}{log_prefix}: Unexpected error during fetch_order: {e}{Style.RESET_ALL}")
            logger.debug(traceback.format_exc())
            # Break on unexpected error? Or continue retrying? Let's continue for now.

        # Wait before retrying fetch_order
        if attempt < CONFIG.fetch_order_status_retries - 1:
            time.sleep(CONFIG.fetch_order_status_delay)

    # --- Fallback Method: fetch_closed_orders (if fetch_order didn't confirm) ---
    if not confirmed_order:
        logger.debug(f"{log_prefix}: fetch_order did not confirm 'closed'. Trying fallback: fetch_closed_orders...")
        try:
            # Fetch recent closed orders
            closed_orders = exchange.fetch_closed_orders(symbol, limit=10)  # Fetch a few recent ones
            logger.debug(f"{log_prefix}: Fallback fetched recent closed orders: {[o.get('id') for o in closed_orders]}")
            for order in closed_orders:
                if order.get(ID_KEY) == order_id:
                    status = order.get(STATUS_KEY)
                    if status == ORDER_STATUS_CLOSED:
                         logger.success(f"{log_prefix}: Confirmed FILLED via fetch_closed_orders fallback.")
                         confirmed_order = order
                         break
                    else:
                         # Found the order but it wasn't closed (e.g., canceled)
                         logger.error(f"{Fore.RED}{log_prefix}: Found order in fallback, but status is '{status}'. Order failed.{Style.RESET_ALL}")
                         return None
            if not confirmed_order:
                 logger.warning(f"{Fore.YELLOW}{log_prefix}: Order not found in recent closed orders via fallback.{Style.RESET_ALL}")

        except (ccxt.NetworkError, ccxt.ExchangeError) as e:
            logger.warning(f"{Fore.YELLOW}{log_prefix}: API error during fetch_closed_orders fallback: {e}{Style.RESET_ALL}")
        except Exception as e:
            logger.error(f"{Fore.RED}{log_prefix}: Unexpected error during fetch_closed_orders fallback: {e}{Style.RESET_ALL}")
            logger.debug(traceback.format_exc())

    # --- Final Verdict ---
    if confirmed_order:
        return confirmed_order
    else:
        elapsed = time.time() - start_time
        logger.error(f"{Fore.RED}{log_prefix}: FAILED to confirm fill for order {order_id} using both methods within timeout ({elapsed:.1f}s).{Style.RESET_ALL}")
        return None


def place_risked_market_order(
    exchange: ccxt.Exchange, symbol: str, side: str,
    quantity: float, required_margin: float,  # Floats received from calculate_position_size
    stop_loss_price: Decimal, take_profit_price: Decimal
) -> dict[str, Any] | None:
    """Places market entry, confirms fill, then places SL/TP orders based on actual fill."""
    market_base = symbol.split('/')[0]
    log_prefix = f"Entry Order ({side.upper()})"
    order_id = None
    entry_order = None
    confirmed_order = None  # To store the confirmed filled order

    try:
        # Fetch Balance & Market Info
        logger.debug(f"{log_prefix}: Gathering resources...")
        balance_info = exchange.fetch_balance()
        free_balance = Decimal(str(balance_info.get('free', {}).get(USDT_SYMBOL, '0')))
        market = exchange.market(symbol)
        if not market: raise ValueError(f"Market info not found for {symbol}")
        entry_price_estimate = Decimal(str(exchange.fetch_ticker(symbol).get(LAST_PRICE_KEY, '0')))
        if entry_price_estimate <= 0: raise ValueError("Could not fetch valid last price for estimate.")

        # Cap Quantity based on MAX_ORDER_USDT_AMOUNT
        estimated_value = Decimal(str(quantity)) * entry_price_estimate
        if estimated_value > CONFIG.max_order_usdt_amount:
            original_quantity = quantity
            # Calculate capped quantity as Decimal first for precision
            capped_qty_decimal = (CONFIG.max_order_usdt_amount / entry_price_estimate)
            # Apply exchange precision using float conversion temporarily
            quantity_str = exchange.amount_to_precision(symbol, float(capped_qty_decimal))
            quantity = float(quantity_str)  # Final quantity as float for create_order
            # Recalculate estimated margin
            required_margin = float((Decimal(quantity_str) * entry_price_estimate) / Decimal(CONFIG.leverage))
            logger.warning(f"{Fore.YELLOW}{log_prefix}: Qty {original_quantity:.8f} (Val ~{estimated_value:.2f}) > Max {CONFIG.max_order_usdt_amount:.2f}. Capping to {quantity_str} (New Est. Margin ~{required_margin:.2f}).{Style.RESET_ALL}")

        # Final Limit Checks (Amount & Cost)
        limits = market.get('limits', {})
        amount_limits = limits.get('amount', {})
        cost_limits = limits.get('cost', {})
        min_amount = float(amount_limits.get('min', 0)) if amount_limits.get('min') is not None else 0.0
        min_cost = float(cost_limits.get('min', 0)) if cost_limits.get('min') is not None else 0.0
        if quantity < min_amount: logger.error(f"{Fore.RED}{log_prefix}: Capped qty {quantity:.8f} < MinAmt {min_amount:.8f}. Abort.{Style.RESET_ALL}"); return None
        estimated_cost_final = quantity * float(entry_price_estimate)
        if estimated_cost_final < min_cost: logger.error(f"{Fore.RED}{log_prefix}: EstCost {estimated_cost_final:.2f} < MinCost {min_cost:.2f}. Abort.{Style.RESET_ALL}"); return None

        # Margin Check
        required_margin_with_buffer = Decimal(str(required_margin)) * CONFIG.required_margin_buffer
        logger.debug(f"{log_prefix}: Free Balance={free_balance:.2f}, Est. Margin Required (incl. buffer)={required_margin_with_buffer:.2f}")
        if free_balance < required_margin_with_buffer:
            logger.error(f"{Fore.RED}{log_prefix}: Insufficient free balance ({free_balance:.2f}) for margin ({required_margin_with_buffer:.2f}). Abort.{Style.RESET_ALL}")
            send_sms_alert(f"[{market_base}] Order REJECTED ({side.upper()}): Insuff. free balance. Need ~{required_margin_with_buffer:.2f}")
            return None

        # Place Market Order
        entry_side_color = Back.GREEN if side == SIDE_BUY else Back.RED
        text_color = Fore.BLACK if side == SIDE_BUY else Fore.WHITE
        logger.warning(f"{entry_side_color}{text_color}{Style.BRIGHT}*** Placing {side.upper()} MARKET ENTRY: {quantity:.8f} {symbol} ***{Style.RESET_ALL}")
        entry_order = exchange.create_market_order(symbol, side, quantity)
        order_id = entry_order.get(ID_KEY)
        if not order_id: raise ValueError("Market order placed but no ID returned.")
        logger.success(f"{log_prefix}: Market order submitted. ID: ...{order_id[-6:]}. Waiting for fill confirmation...")
        time.sleep(CONFIG.post_entry_delay_seconds)  # Allow time for order processing

        # Confirm Order Fill (using improved function)
        confirmed_order = confirm_order_fill(exchange, order_id, symbol)
        if not confirmed_order:
            logger.error(f"{Fore.RED}{log_prefix}: FAILED to confirm fill for order {order_id}. Aborting SL/TP placement.{Style.RESET_ALL}")
            send_sms_alert(f"[{market_base}] Entry fill confirm FAILED: {order_id}")
            # Consider emergency close here if needed
            return None

        # Extract Actual Fill Details
        try:
            actual_filled_qty = Decimal(str(confirmed_order.get(FILLED_KEY, '0')))
            actual_avg_price = Decimal(str(confirmed_order.get(AVERAGE_KEY, '0')))
            if actual_avg_price <= 0 and confirmed_order.get(PRICE_KEY) is not None:
                actual_avg_price = Decimal(str(confirmed_order.get(PRICE_KEY)))
            if actual_filled_qty <= CONFIG.position_qty_epsilon or actual_avg_price <= 0:
                 raise ValueError(f"Invalid fill data: Qty={actual_filled_qty}, Price={actual_avg_price}")
            logger.success(f"{log_prefix}: Fill Confirmed: Order ID ...{order_id[-6:]}, Filled Qty={actual_filled_qty:.8f}, Avg Price={actual_avg_price:.4f}")
        except (InvalidOperation, ValueError, TypeError, KeyError) as e:
            logger.error(f"{Fore.RED}{log_prefix}: Error parsing confirmed fill details for order {order_id}: {e}. Data: {confirmed_order}{Style.RESET_ALL}")
            send_sms_alert(f"[{market_base}] ERROR parsing fill data: {order_id}")
            return None  # Cannot proceed

        # Place SL/TP Orders
        logger.info(f"{log_prefix}: Placing SL ({stop_loss_price}) and TP ({take_profit_price}) orders for filled qty {actual_filled_qty:.8f}...")
        sl_tp_success = True
        close_side = SIDE_SELL if side == SIDE_BUY else SIDE_BUY
        sl_tp_amount_float = float(actual_filled_qty)  # Use actual filled quantity

        # SL Order Params
        sl_trigger_direction = 2 if side == SIDE_BUY else 1
        sl_params = {
            PARAM_STOP_PRICE: exchange.price_to_precision(symbol, float(stop_loss_price)),
            PARAM_REDUCE_ONLY: True,
            PARAM_TRIGGER_DIRECTION: sl_trigger_direction
        }
        # TP Order Params (Using stopMarket type)
        tp_trigger_direction = 1 if side == SIDE_BUY else 2
        tp_params = {
            PARAM_STOP_PRICE: exchange.price_to_precision(symbol, float(take_profit_price)),
            PARAM_REDUCE_ONLY: True,
            PARAM_TRIGGER_DIRECTION: tp_trigger_direction
        }

        sl_order_id_short, tp_order_id_short = "N/A", "N/A"
        try:
            logger.debug(f"Placing SL order: side={close_side}, amount={sl_tp_amount_float}, params={sl_params}")
            sl_order = exchange.create_order(symbol, ORDER_TYPE_STOP_MARKET, close_side, sl_tp_amount_float, params=sl_params)
            sl_order_id_short = str(sl_order.get(ID_KEY, 'N/A'))[-6:]
            logger.success(f"{Fore.GREEN}{log_prefix}: Stop-Loss order placed. ID: ...{sl_order_id_short}{Style.RESET_ALL}")
            time.sleep(0.1)  # Small delay
        except Exception as e:
            sl_tp_success = False
            logger.error(f"{Back.RED}{Fore.WHITE}{log_prefix}: FAILED to place Stop-Loss order: {e}{Style.RESET_ALL}")
            send_sms_alert(f"[{market_base}] CRITICAL: SL order FAILED for {symbol} ({side}): {e}")

        try:
            logger.debug(f"Placing TP order: side={close_side}, amount={sl_tp_amount_float}, params={tp_params}")
            # Use stopMarket for TP as well
            tp_order = exchange.create_order(symbol, ORDER_TYPE_STOP_MARKET, close_side, sl_tp_amount_float, params=tp_params)
            tp_order_id_short = str(tp_order.get(ID_KEY, 'N/A'))[-6:]
            logger.success(f"{Fore.GREEN}{log_prefix}: Take-Profit order placed. ID: ...{tp_order_id_short}{Style.RESET_ALL}")
        except Exception as e:
            # TP failure is less critical than SL, but still log as error
            sl_tp_success = False  # Mark overall success as false if TP fails
            logger.error(f"{Back.YELLOW}{Fore.BLACK}{log_prefix}: FAILED to place Take-Profit order: {e}{Style.RESET_ALL}")
            send_sms_alert(f"[{market_base}] WARNING: TP order FAILED for {symbol} ({side}): {e}")

        if sl_tp_success:
            logger.info(f"{Fore.GREEN}{log_prefix}: Entry order filled and SL/TP orders placed successfully.{Style.RESET_ALL}")
            send_sms_alert(f"[{market_base}] Entered {side.upper()} {actual_filled_qty:.4f} @ {actual_avg_price:.2f}. SL=...{sl_order_id_short}, TP=...{tp_order_id_short}")
            return confirmed_order
        else:
            logger.error(f"{Back.RED}{Fore.WHITE}{log_prefix}: Entry filled, but FAILED to place one/both SL/TP orders. MANUAL CHECK REQUIRED!{Style.RESET_ALL}")
            return None  # Indicate failure if SL/TP placement wasn't fully successful

    except (ccxt.InsufficientFunds, ccxt.ExchangeError, ccxt.NetworkError, ValueError) as e:
        logger.error(f"{Fore.RED}{log_prefix}: Failed during order placement/check: {e}{Style.RESET_ALL}")
        if entry_order: logger.error(f"Entry order details (if placed): {entry_order}")
        send_sms_alert(f"[{market_base}] Entry order FAILED ({side.upper()}): {type(e).__name__}")
        return None
    except Exception as e:
        logger.error(f"{Fore.RED}{log_prefix}: Unexpected error during order ritual: {e}{Style.RESET_ALL}")
        logger.debug(traceback.format_exc())
        send_sms_alert(f"[{market_base}] UNEXPECTED error during entry ({side.upper()}): {type(e).__name__}")
        return None


# --- Core Trading Logic - The Spell Weaving Cycle ---
def trade_logic(exchange: ccxt.Exchange, symbol: str, timeframe: str) -> None:
    """Main trading logic loop."""
    cycle_time_str = time.strftime('%Y-%m-%d %H:%M:%S %Z')
    logger.info(f"{Fore.BLUE}{Style.BRIGHT}========== New Weaving Cycle: {symbol} ({timeframe}) | {cycle_time_str} =========={Style.RESET_ALL}")

    # --- 1. Get Data ---
    required_ohlcv_len = max(CONFIG.st_atr_length, CONFIG.confirm_st_atr_length, CONFIG.volume_ma_period, CONFIG.atr_calculation_period) + CONFIG.api_fetch_limit_buffer
    df = fetch_ohlcv(exchange, symbol, timeframe, limit=required_ohlcv_len)
    if df is None or df.empty:
        logger.warning(f"{Fore.YELLOW}Trade Logic: Skipping cycle - unable to fetch valid OHLCV data.{Style.RESET_ALL}")
        return

    order_book_data = None
    # Fetch OB if always required OR if confirmation is enabled (fetch only when needed later)
    if CONFIG.fetch_order_book_per_cycle:
        order_book_data = analyze_order_book(exchange, symbol, CONFIG.order_book_depth, CONFIG.order_book_fetch_limit)
        if order_book_data is None and CONFIG.use_ob_confirm:  # If mandatory and failed
             logger.warning(f"{Fore.YELLOW}Trade Logic: Skipping cycle - failed to get required OB data.{Style.RESET_ALL}")
             return

    # --- 2. Calculate Indicators ---
    logger.debug("Calculating indicators...")
    df = calculate_supertrend(df, CONFIG.st_atr_length, CONFIG.st_multiplier)
    df = calculate_supertrend(df, CONFIG.confirm_st_atr_length, CONFIG.confirm_st_multiplier, prefix="confirm_")
    vol_atr_results = analyze_volume_atr(df, CONFIG.atr_calculation_period, CONFIG.volume_ma_period)

    # Check for critical indicator failures
    if 'supertrend' not in df.columns or df['supertrend'].isnull().all(): logger.warning(f"{Fore.YELLOW}Trade Logic: Skipping cycle - primary Supertrend calc failed.{Style.RESET_ALL}"); return
    if 'confirm_supertrend' not in df.columns or df['confirm_supertrend'].isnull().all(): logger.warning(f"{Fore.YELLOW}Trade Logic: Skipping cycle - confirmation Supertrend calc failed.{Style.RESET_ALL}"); return
    if vol_atr_results is None or vol_atr_results.get(ATR_KEY) is None: logger.warning(f"{Fore.YELLOW}Trade Logic: Skipping cycle - Volume/ATR calc failed.{Style.RESET_ALL}"); return

    # --- 3. Extract Latest Indicator Values ---
    try:
        last_candle = df.iloc[-1]
        # Primary Supertrend
        st_trend = last_candle['trend']  # Current trend direction (-1 or 1)
        st_long_signal = last_candle['st_long']  # True only on flip candle
        st_short_signal = last_candle['st_short']  # True only on flip candle
        # Confirmation Supertrend
        confirm_st_trend = last_candle['confirm_trend']  # Current trend direction (-1 or 1)
        # Volume/ATR
        current_atr = vol_atr_results.get(ATR_KEY)  # Decimal or None
        volume_ratio = vol_atr_results.get(VOLUME_RATIO_KEY)  # Decimal or None
        # Current Price
        current_price = Decimal(str(last_candle['close']))

        if current_atr is None or pd.isna(st_trend) or pd.isna(confirm_st_trend) or current_price <= 0:
             raise ValueError("Essential indicator values (ATR, ST trends, Price) are None/NaN/invalid.")

    except (IndexError, KeyError, ValueError, InvalidOperation) as e:
        logger.error(f"{Fore.RED}Trade Logic: Error accessing indicator/price data: {e}{Style.RESET_ALL}")
        logger.debug(f"DataFrame tail:\n{df.tail()}")
        return

    # --- 4. Check Current Position ---
    current_position = get_current_position(exchange, symbol)
    position_side = current_position[SIDE_KEY]
    position_qty = current_position[QTY_KEY]
    position_entry_price = current_position[ENTRY_PRICE_KEY]
    pos_color = Fore.GREEN if position_side == POSITION_SIDE_LONG else (Fore.RED if position_side == POSITION_SIDE_SHORT else Fore.BLUE)
    logger.info(f"State | Position: Side={pos_color}{position_side}{Style.RESET_ALL}, Qty={position_qty:.8f}, Entry={position_entry_price:.4f}")
    logger.info(f"State | Indicators: Price={current_price:.4f}, ATR={current_atr:.4f}, ST Trend={st_trend}, Confirm ST Trend={confirm_st_trend}, VolRatio={volume_ratio if volume_ratio else 'N/A'}")

    # --- 5. Determine Signals ---
    long_entry_signal = st_long_signal and confirm_st_trend == 1
    short_entry_signal = st_short_signal and confirm_st_trend == -1
    close_long_signal = position_side == POSITION_SIDE_LONG and st_trend == -1
    close_short_signal = position_side == POSITION_SIDE_SHORT and st_trend == 1
    logger.debug(f"Signals: EntryLong={long_entry_signal}, EntryShort={short_entry_signal}, CloseLong={close_long_signal}, CloseShort={close_short_signal}")

    # --- 6. Decision Making ---

    # **Exit Logic:** Prioritize closing
    exit_reason = None
    if close_long_signal: exit_reason = "ST Exit Long"
    elif close_short_signal: exit_reason = "ST Exit Short"

    if exit_reason:
        exit_side_color = Back.YELLOW
        logger.warning(f"{exit_side_color}{Fore.BLACK}{Style.BRIGHT}*** TRADE EXIT SIGNAL: Closing {position_side} due to {exit_reason} ***{Style.RESET_ALL}")
        close_position(exchange, symbol, current_position, reason=exit_reason)
        time.sleep(CONFIG.post_close_delay_seconds)  # Pause after closing
        return  # End cycle

    # **Entry Logic:** Only if flat
    if position_side == POSITION_SIDE_NONE:
        selected_side = None
        if long_entry_signal: selected_side = SIDE_BUY
        elif short_entry_signal: selected_side = SIDE_SELL

        if selected_side:
            logger.info(f"{Fore.CYAN}Entry Signal: Potential {selected_side.upper()} entry detected by Supertrend.{Style.RESET_ALL}")

            # Volume Confirmation
            volume_confirmed = True
            if CONFIG.require_volume_spike_for_entry:
                if volume_ratio is None or volume_ratio <= CONFIG.volume_spike_threshold:
                    volume_confirmed = False
                    logger.info(f"Entry REJECTED ({selected_side.upper()}): Volume spike confirmation FAILED (Ratio: {volume_ratio if volume_ratio else 'N/A'} <= Threshold: {CONFIG.volume_spike_threshold}).")
                else:
                    logger.info(f"{Fore.GREEN}Entry Check ({selected_side.upper()}): Volume spike OK (Ratio: {volume_ratio:.2f}).{Style.RESET_ALL}")

            # Order Book Confirmation
            ob_confirmed = True
            if volume_confirmed and CONFIG.use_ob_confirm:
                if order_book_data is None:  # Fetch only if needed now
                     logger.debug("Fetching OB data for confirmation...")
                     order_book_data = analyze_order_book(exchange, symbol, CONFIG.order_book_depth, CONFIG.order_book_fetch_limit)

                if order_book_data is None or order_book_data.get(BID_ASK_RATIO_KEY) is None:
                    ob_confirmed = False
                    logger.warning(f"{Fore.YELLOW}Entry SKIPPED ({selected_side.upper()}): OB confirmation FAILED (Could not get valid OB data/ratio).{Style.RESET_ALL}")
                else:
                    ob_ratio = order_book_data[BID_ASK_RATIO_KEY]
                    ob_ratio_str = f"{ob_ratio:.3f}"
                    if selected_side == SIDE_BUY and ob_ratio < CONFIG.order_book_ratio_threshold_long:
                        ob_confirmed = False
                        logger.info(f"Entry REJECTED ({selected_side.upper()}): OB confirmation FAILED (Ratio: {ob_ratio_str} < Threshold: {CONFIG.order_book_ratio_threshold_long}).")
                    elif selected_side == SIDE_SELL and ob_ratio > CONFIG.order_book_ratio_threshold_short:
                        ob_confirmed = False
                        logger.info(f"Entry REJECTED ({selected_side.upper()}): OB confirmation FAILED (Ratio: {ob_ratio_str} > Threshold: {CONFIG.order_book_ratio_threshold_short}).")
                    else:
                         ob_color = Fore.GREEN if selected_side == SIDE_BUY else Fore.RED
                         logger.info(f"{ob_color}Entry Check ({selected_side.upper()}): OB pressure OK (Ratio: {ob_ratio_str}).{Style.RESET_ALL}")

            # Proceed if all confirmations pass
            if volume_confirmed and ob_confirmed:
                logger.success(f"{Fore.GREEN}{Style.BRIGHT}Entry CONFIRMED ({selected_side.upper()}): All checks passed. Calculating parameters...{Style.RESET_ALL}")

                # Calculate SL/TP Prices
                try:
                    price_precision_str = exchange.markets[symbol]['precision']['price']
                    price_precision = Decimal(price_precision_str) if price_precision_str else Decimal('0.0001')  # Fallback precision
                    sl_distance = current_atr * CONFIG.atr_stop_loss_multiplier
                    tp_distance = current_atr * CONFIG.atr_take_profit_multiplier
                    entry_price_est = current_price  # Use last close price as estimate

                    if selected_side == SIDE_BUY:
                        sl_price = entry_price_est - sl_distance
                        tp_price = entry_price_est + tp_distance
                    else:  # SIDE_SELL
                        sl_price = entry_price_est + sl_distance
                        tp_price = entry_price_est - tp_distance

                    if sl_price <= 0 or tp_price <= 0: raise ValueError("SL/TP price zero or negative.")

                    # Quantize SL/TP using market precision
                    sl_price = sl_price.quantize(price_precision, rounding=ROUND_HALF_UP)
                    tp_price = tp_price.quantize(price_precision, rounding=ROUND_HALF_UP)
                    logger.info(f"Calculated SL={sl_price}, TP={tp_price} based on EntryEst={entry_price_est}, ATR={current_atr:.4f}")

                except Exception as e:
                    logger.error(f"{Fore.RED}Entry REJECTED ({selected_side.upper()}): Error calculating SL/TP prices: {e}{Style.RESET_ALL}")
                    return

                # Calculate Position Size
                try:
                    equity = Decimal(str(exchange.fetch_balance().get('total', {}).get(USDT_SYMBOL, '0')))
                    if equity <= 0: raise ValueError("Zero or negative equity.")
                except Exception as e:
                     logger.error(f"{Fore.RED}Entry REJECTED ({selected_side.upper()}): Failed to fetch valid equity: {e}{Style.RESET_ALL}")
                     return

                quantity_float, margin_est_float = calculate_position_size(
                    equity, CONFIG.risk_per_trade_percentage, entry_price_est, sl_price,
                    CONFIG.leverage, symbol, exchange
                )

                if quantity_float is not None and margin_est_float is not None:
                    # Place the order
                    place_risked_market_order(
                        exchange, symbol, selected_side, quantity_float, margin_est_float, sl_price, tp_price
                    )
                    return  # End cycle after attempting entry
                else:
                    logger.error(f"{Fore.RED}Entry REJECTED ({selected_side.upper()}): Failed to calculate valid position size or margin.{Style.RESET_ALL}")

    elif position_side != POSITION_SIDE_NONE:
        logger.info(f"Holding {pos_color}{position_side}{Style.RESET_ALL} position. No exit signal. Awaiting SL/TP or next signal.")
        # Optional: Implement redundant SL/TP monitoring here if needed
        # if CONFIG.enable_monitor_sltp: monitor_and_close_if_needed(...)

    logger.info(f"{Fore.BLUE}{Style.BRIGHT}========== Cycle Weaving End: {symbol} =========={Style.RESET_ALL}\n")


# --- Main Execution - Igniting the Spell ---
def main() -> None:
    """Main function to run the bot."""
    start_time_str = time.strftime('%Y-%m-%d %H:%M:%S %Z')
    logger.info(f"{Back.BLUE}{Fore.WHITE}{Style.BRIGHT}--- Pyrmethus Bybit Scalping Spell v10.1.0 Initializing ({start_time_str}) ---{Style.RESET_ALL}")
    logger.info(f"{Fore.CYAN}--- Strategy Enchantment: Dual Supertrend ---{Style.RESET_ALL}")  # Strategy is hardcoded in this version
    logger.info(f"{Fore.GREEN}--- Protective Wards: Exchange Native SL/TP ---{Style.RESET_ALL}")

    # Config object already instantiated and validated globally
    logger.warning(f"{Back.YELLOW}{Fore.BLACK}{Style.BRIGHT}--- !!! LIVE FUTURES SCALPING MODE - EXTREME RISK - HANDLE WITH CARE !!! ---{Style.RESET_ALL}")

    # Initialize Exchange
    exchange = initialize_exchange()
    if not exchange:
        logger.critical("Failed to initialize exchange. Spell fizzles.")
        sys.exit(1)

    # Set Leverage
    if not set_leverage(exchange, CONFIG.symbol, CONFIG.leverage):
         logger.critical(f"Failed to set leverage to {CONFIG.leverage}x for {CONFIG.symbol}. Spell cannot bind.")
         sys.exit(1)

    # Log Final Config Summary (using CONFIG object)
    logger.info(f"{Fore.MAGENTA}--- Final Spell Configuration ---{Style.RESET_ALL}")
    logger.info(f"{Fore.WHITE}Symbol: {CONFIG.symbol}, Interval: {CONFIG.interval}, Leverage: {CONFIG.leverage}x")
    logger.info(f"  Supertrend Params: ST={CONFIG.st_atr_length}/{CONFIG.st_multiplier}, ConfirmST={CONFIG.confirm_st_atr_length}/{CONFIG.confirm_st_multiplier}")
    logger.info(f"{Fore.GREEN}Risk Ward: {CONFIG.risk_per_trade_percentage:.3%}/trade, Max Pos Value: {CONFIG.max_order_usdt_amount:.4f} USDT")
    logger.info(f"{Fore.GREEN}SL/TP Wards: SL Mult={CONFIG.atr_stop_loss_multiplier}, TP Mult={CONFIG.atr_take_profit_multiplier} (ATR Period: {CONFIG.atr_calculation_period})")
    logger.info(f"{Fore.YELLOW}Volume Filter: {CONFIG.require_volume_spike_for_entry} (MA={CONFIG.volume_ma_period}, Thr={CONFIG.volume_spike_threshold})")
    logger.info(f"{Fore.YELLOW}Order Book Filter: Use Confirm={CONFIG.use_ob_confirm}, Fetch Each Cycle={CONFIG.fetch_order_book_per_cycle} (Depth={CONFIG.order_book_depth}, L>={CONFIG.order_book_ratio_threshold_long}, S<={CONFIG.order_book_ratio_threshold_short})")
    logger.info(f"{Fore.WHITE}Timing: Sleep={CONFIG.sleep_seconds}s, Margin Buffer={CONFIG.required_margin_buffer:.1%}, SMS Alerts={CONFIG.enable_sms_alerts}")
    logger.info(f"{Fore.CYAN}Oracle Verbosity (Log Level): {logging.getLevelName(logger.level)}")
    logger.info(f"{Fore.MAGENTA}{'-' * 30}{Style.RESET_ALL}")

    # --- Main Loop ---
    run_bot = True
    cycle_count = 0
    while run_bot:
        cycle_count += 1
        logger.debug(f"{Fore.CYAN}--- Cycle {cycle_count} Weaving Start ---{Style.RESET_ALL}")
        try:
            trade_logic(exchange, CONFIG.symbol, CONFIG.interval)  # Pass necessary args
            logger.debug(f"Cycle {cycle_count} complete. Sleeping for {CONFIG.sleep_seconds} seconds...")
            time.sleep(CONFIG.sleep_seconds)

        except KeyboardInterrupt:
            logger.warning(f"\n{Fore.YELLOW}{Style.BRIGHT}KeyboardInterrupt detected. Requesting graceful withdrawal...{Style.RESET_ALL}")
            send_sms_alert(f"[ScalpBot] Shutdown initiated for {CONFIG.symbol} (KeyboardInterrupt).")
            run_bot = False  # Signal loop termination

        except ccxt.AuthenticationError as e:
             logger.critical(f"{Back.RED}{Fore.WHITE}CRITICAL: Authentication Error during main loop: {e}. API keys invalid/revoked? Shutting down NOW.{Style.RESET_ALL}")
             send_sms_alert("[ScalpBot] CRITICAL: Auth Error - SHUTDOWN. Check Keys/Permissions.")
             run_bot = False
        except ccxt.NetworkError as e:
            logger.error(f"{Fore.RED}ERROR: Network error in main loop: {e}. Retrying after delay...{Style.RESET_ALL}")
            time.sleep(CONFIG.sleep_seconds * 2)  # Longer delay
        except ccxt.ExchangeError as e:
             logger.error(f"{Fore.RED}ERROR: Exchange error in main loop: {e}. Retrying after delay...{Style.RESET_ALL}")
             logger.debug(traceback.format_exc())
             time.sleep(CONFIG.sleep_seconds)
        except Exception as e:
            logger.error(f"{Back.RED}{Fore.WHITE}FATAL: An unexpected error occurred in the main loop: {e}{Style.RESET_ALL}")
            logger.error(traceback.format_exc())
            send_sms_alert(f"[ScalpBot] FATAL ERROR: {type(e).__name__}. Bot stopped. Check logs!")
            run_bot = False  # Stop on fatal errors

    # --- Graceful Shutdown ---
    logger.warning(f"{Fore.YELLOW}{Style.BRIGHT}Initiating graceful shutdown sequence...{Style.RESET_ALL}")
    try:
        logger.info("Checking for open position to close on exit...")
        # Ensure exchange object is valid before using
        if exchange:
             current_pos = get_current_position(exchange, CONFIG.symbol)
             if current_pos[SIDE_KEY] != POSITION_SIDE_NONE:
                 logger.warning(f"Attempting to close {current_pos[SIDE_KEY]} position before exiting...")
                 close_position(exchange, symbol=CONFIG.symbol, position_to_close=current_pos, reason="Shutdown")
             else:
                 logger.info("No open position found to close.")
        else:
             logger.warning("Exchange object not available for final position check.")
    except Exception as close_err:
         logger.error(f"{Fore.RED}Failed to check/close position during final shutdown: {close_err}{Style.RESET_ALL}")
         send_sms_alert("[ScalpBot] Error during final position close check on shutdown.")

    logger.info(f"{Back.BLUE}{Fore.WHITE}{Style.BRIGHT}--- Pyrmethus Scalping Spell Deactivated ---{Style.RESET_ALL}")


if __name__ == "__main__":
    main()
