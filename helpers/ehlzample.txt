Hark, Seeker! You ask Pyrmethus to refine the potent `ehlers_volumetric_strategy.py` spell. I shall imbue it with greater clarity, resilience, and the vibrant glow of Colorama, transforming it into an even more formidable enchantment for the Termux realm.

First, ensure your Termux environment is attuned to the necessary energies:

```bash
# Awaken the core Termux spirits
pkg update && pkg upgrade -y

# Summon the Pythonic essence and builders
pkg install python clang make libzmq fftw libjpeg-turbo -y # Add FFTW/JPEG for potential SciPy/NumPy needs

# Invoke the required Python spirits via pip
pip install --upgrade pip
pip install pandas ccxt colorama requests pydantic # Pydantic for structured config runes
# Ensure your custom helpers' dependencies are also installed!
# e.g., pip install numpy scipy ta-lib # If indicators.py needs them

# Grant access to Termux device features if SMS alerts are used
# pkg install termux-api # Uncomment if send_sms_alert uses termux-api
```

Remember the incantations for stability: `termux-wake-lock` to keep the device vigilant, and `tmux` or `screen` to shield the spell from disconnection.

Now, behold the enhanced grimoire page:

```python
# -*- coding: utf-8 -*-
# --- Enhanced Ehlers Volumetric Strategy Spell ---
# Woven by Pyrmethus for the Termux Sanctuary

import asyncio
import logging
import time
from decimal import ROUND_DOWN, Decimal, InvalidOperation
from typing import Any, Dict, List, Optional, Tuple

import pandas as pd
from pydantic import BaseModel, Field, validator, ValidationError # For structured config runes

# --- Import Custom Modules & Helpers ---
# Assume these scrolls are present in the same directory or Python path
try:
    import bybit_helpers as bybit
    from bybit_helpers import (
        Category,
        Config as HelperConfig, # Keep separate if needed
        OrderFilter,
        PositionIdx,
        Side,
        TimeInForce,
        TriggerBy,
        TriggerDirection,
    )
    import indicators as ind # Contains the sacred calculation rites
    from bybit_utils import (
        format_amount,
        format_order_id,
        format_price,
        safe_decimal_conversion,
        send_sms_alert, # Must be async-safe or run in executor
    )
except ImportError as e:
    # Use basic printing here as Colorama/logging might not be ready
    print(f"\033[91m\033[1mStrategy FATAL: Failed to import helper modules: {e}\033[0m")
    print("\033[93mEnsure neon_logger.py, bybit_helpers.py, indicators.py, bybit_utils.py are present.\033[0m")
    exit(1)

# --- Colorama Enchantment ---
try:
    from colorama import init, Fore, Style, Back
    init(autoreset=True) # Let the colors fade gracefully
    COLORAMA_AVAILABLE = True
    # Define standard color runes
    C_INFO = Fore.CYAN
    C_SUCCESS = Fore.GREEN
    C_WARN = Fore.YELLOW
    C_ERROR = Fore.RED + Style.BRIGHT
    C_CRIT = Back.RED + Fore.WHITE + Style.BRIGHT
    C_DEBUG = Fore.MAGENTA
    C_BOLD = Style.BRIGHT
    C_RESET = Style.RESET_ALL
except ImportError:
    # Create dummy color objects if Colorama is missing
    class DummyColor:
        def __getattr__(self, name: str) -> str: return ""
    Fore = Style = Back = DummyColor() # type: ignore
    COLORAMA_AVAILABLE = False
    C_INFO = C_SUCCESS = C_WARN = C_ERROR = C_CRIT = C_DEBUG = C_BOLD = C_RESET = ""
    print("\033[93mWarning: Colorama module not found. Outputs will lack mystical hues.\033[0m")
    print("\033[93mInstall it with: pip install colorama\033[0m")


# --- Configuration Runes (Pydantic Models) ---
# These runes define the expected structure and types for our spell's parameters

class APIConfig(BaseModel):
    """Runes for Exchange API Connection"""
    API_KEY: str
    API_SECRET: str
    SYMBOL: str
    TESTNET_MODE: bool = True
    # Define position constants clearly
    POS_NONE: str = "NONE" # Custom identifier for no position
    POS_LONG: str = "Buy"  # Bybit V5 uses "Buy" for long side
    POS_SHORT: str = "Sell" # Bybit V5 uses "Sell" for short side
    POSITION_QTY_EPSILON: Decimal = Field(default=Decimal("0.000001"), ge=0)
    USDT_SYMBOL: str = "USDT" # For logging balance

    @validator('POSITION_QTY_EPSILON', pre=True, always=True)
    def validate_decimal_epsilon(cls, v):
        try:
            d = Decimal(v)
            if d < 0:
                raise ValueError("POSITION_QTY_EPSILON cannot be negative")
            return d
        except (InvalidOperation, TypeError, ValueError) as e:
            raise ValueError(f"Invalid Decimal for POSITION_QTY_EPSILON: {v} ({e})")

class IndicatorSettings(BaseModel):
    """Runes for Indicator Parameters"""
    min_data_periods: int = Field(default=100, gt=10) # Need sufficient data
    evt_length: int = Field(default=7, gt=1)
    atr_period: int = Field(default=14, gt=1)
    # Add other indicator params here if needed by indicators.py

class AnalysisFlags(BaseModel):
    """Runes to Enable/Disable Specific Analyses"""
    use_evt: bool = True
    use_atr: bool = True
    # Add other flags as needed

class StrategyConfig(BaseModel):
    """Runes for Strategy Behavior"""
    name: str = "EhlersVolumetric"
    timeframe: str = "15m"
    leverage: int = Field(default=5, ge=1, le=100) # Sensible leverage bounds
    indicator_settings: IndicatorSettings
    analysis_flags: AnalysisFlags
    risk_per_trade: Decimal = Field(default=Decimal("0.01"), gt=0, le=0.1) # Risk 0-10%
    stop_loss_atr_multiplier: Decimal = Field(default=Decimal("2.0"), gt=0)
    position_idx: PositionIdx = PositionIdx.ONE_WAY # Default to one-way
    polling_interval_seconds: int = Field(default=60, ge=5) # Min 5s polling
    EVT_ENABLED: bool = True # Explicit flag for this strategy
    STOP_LOSS_ATR_PERIOD: int # Re-declared for clarity, must match atr_period
    strategy_params: Dict[str, Any] = {} # For generic pass-through if needed

    @validator('risk_per_trade', 'stop_loss_atr_multiplier', pre=True, always=True)
    def validate_decimal_positive(cls, v, field):
        try:
            d = Decimal(v)
            if d <= 0:
                raise ValueError(f"{field.name} must be positive")
            return d
        except (InvalidOperation, TypeError, ValueError) as e:
            raise ValueError(f"Invalid Decimal for {field.name}: {v} ({e})")

    @validator('position_idx', pre=True, always=True)
    def validate_position_idx(cls, v):
        if isinstance(v, PositionIdx):
            return v
        try:
            return PositionIdx(int(v))
        except (ValueError, TypeError):
            # Log warning later in __init__ if needed, return default here
            return PositionIdx.ONE_WAY

    @validator('STOP_LOSS_ATR_PERIOD', always=True)
    def check_atr_period_match(cls, v, values):
        if 'indicator_settings' in values and v != values['indicator_settings'].atr_period:
            raise ValueError("STOP_LOSS_ATR_PERIOD must match indicator_settings.atr_period")
        return v

class SMSConfig(BaseModel):
    """Runes for SMS Alerting"""
    ENABLE_SMS_ALERTS: bool = False
    TWILIO_ACCOUNT_SID: Optional[str] = None
    TWILIO_AUTH_TOKEN: Optional[str] = None
    TWILIO_PHONE_NUMBER: Optional[str] = None
    RECIPIENT_PHONE_NUMBER: Optional[str] = None
    # Add fields for Termux API method if used

class AppConfig(BaseModel):
    """The Master Rune holding all configurations"""
    API_CONFIG: APIConfig
    STRATEGY_CONFIG: StrategyConfig
    SMS_CONFIG: SMSConfig
    LOGGING_CONFIG: Dict[str, Any] # Keep flexible for now


# --- The Enhanced Strategy Spell ---

class EhlersVolumetricStrategyEnhanced:
    """
    An enhanced trading strategy using the Ehlers Volumetric Trend (EVT) indicator,
    imbued with Pyrmethus's refinements for clarity, robustness, and Termux.
    """

    def __init__(self, config: Dict[str, Any], logger: logging.Logger):
        """
        Initializes the strategy instance with validated configuration.

        Args:
            config: A dictionary containing all configuration sections.
            logger: An initialized logging.Logger instance.
        """
        self.logger = logger
        self.logger.info(f"{C_INFO}{C_BOLD}Conjuring the Ehlers Volumetric Strategy...")

        # --- Validate and Bind Configuration Runes ---
        try:
            self.app_config = AppConfig(**config)
            self.api_config = self.app_config.API_CONFIG
            self.strategy_config = self.app_config.STRATEGY_CONFIG
            self.sms_config = self.app_config.SMS_CONFIG
            self.logger.info(f"{C_SUCCESS}Configuration runes validated successfully.")
        except ValidationError as e:
            self.logger.critical(f"{C_CRIT}FATAL: Invalid configuration runes! {e}{C_RESET}")
            raise ValueError("Invalid configuration provided.") from e

        # --- Essential Strategy Logic Validation ---
        if not self.strategy_config.EVT_ENABLED or not self.strategy_config.analysis_flags.use_evt:
             self.logger.critical(f"{C_CRIT}Ehlers Volumetric strategy requires 'EVT_ENABLED' and 'analysis_flags.use_evt' to be True.{C_RESET}")
             raise ValueError("EVT indicator not enabled correctly in configuration.")
        if self.strategy_config.analysis_flags.use_atr and not self.strategy_config.STOP_LOSS_ATR_PERIOD > 0:
             self.logger.critical(f"{C_CRIT}ATR-based stop loss requires 'use_atr' flag and a valid 'STOP_LOSS_ATR_PERIOD'.{C_RESET}")
             raise ValueError("ATR required for SL but not configured correctly.")

        # --- Assign Core Parameters ---
        self.symbol = self.api_config.SYMBOL
        self.timeframe = self.strategy_config.timeframe
        self.leverage = self.strategy_config.leverage
        self.position_idx = self.strategy_config.position_idx
        if self.strategy_config.position_idx == PositionIdx.ONE_WAY and config.get("STRATEGY_CONFIG", {}).get("position_idx") != 0:
             self.logger.warning(f"{C_WARN}Configuration specified an invalid 'position_idx', defaulting to ONE_WAY (0).{C_RESET}")

        # --- Exchange and Market Info (Initialized Async) ---
        self.exchange: Optional[bybit.ccxt.bybit] = None
        self.market_info: Optional[Dict[str, Any]] = None
        self.min_qty = Decimal("0.000001") # Smallest possible default
        self.qty_step = Decimal("0.000001")
        self.price_tick = Decimal("0.000001")

        # --- Strategy State ---
        self.current_position: Optional[Dict[str, Any]] = None
        self.open_orders: Dict[str, Dict[str, Any]] = {}
        self.last_known_price = Decimal("0")
        self.available_balance = Decimal("0")
        self.is_running = False
        self.stop_loss_order_id: Optional[str] = None
        self.loop: Optional[asyncio.AbstractEventLoop] = None # To run sync code

        # --- Indicator Config & Column Names ---
        # These names are derived from the config and indicator calculation logic
        self.evt_length = self.strategy_config.indicator_settings.evt_length
        self.atr_period = self.strategy_config.indicator_settings.atr_period

        self.evt_trend_col = f"evt_trend_{self.evt_length}"
        self.evt_buy_col = f"evt_buy_{self.evt_length}"
        self.evt_sell_col = f"evt_sell_{self.evt_length}"
        self.atr_col = f"ATRr_{self.atr_period}"

        self.required_indicators: List[str] = []
        if self.strategy_config.analysis_flags.use_evt:
             self.required_indicators.extend([self.evt_trend_col, self.evt_buy_col, self.evt_sell_col])
        if self.strategy_config.analysis_flags.use_atr:
             self.required_indicators.append(self.atr_col)

        self.logger.info(f"{C_INFO}Strategy '{self.strategy_config.name}' initialized for {C_BOLD}{self.symbol}{C_RESET}{C_INFO} on {self.timeframe} timeframe.")
        self.logger.debug(f"{C_DEBUG}Required indicators: {self.required_indicators}")
        self.logger.debug(f"{C_DEBUG}Position Mode: {self.position_idx.name}")

    async def _initialize(self) -> bool:
        """
        Asynchronously awakens the connection, gathers market lore, attunes leverage,
        fetches initial state, and performs pre-run cleansing rituals.

        Returns:
            bool: True if initialization spell succeeded, False otherwise.
        """
        self.logger.info(f"{C_INFO}{C_BOLD}--- Strategy Initialization Ritual ---{C_RESET}")
        self.loop = asyncio.get_running_loop() # Store the loop

        try:
            # 1. Awaken Exchange Connection (Async)
            self.logger.info(f"{C_DEBUG}Summoning connection to Bybit...")
            self.exchange = await bybit.initialize_bybit(self.api_config.dict()) # Pass config as dict
            if not self.exchange:
                self.logger.critical(f"{C_CRIT}Failed to summon Bybit exchange connection. Halting the ritual.{C_RESET}")
                return False
            self.logger.info(f"{C_SUCCESS}Bybit connection established.")

            # 2. Gather Market Lore (Uses cache populated by initialize_bybit)
            self.logger.info(f"{C_DEBUG}Gathering market lore for {self.symbol}...")
            self.market_info = bybit.market_cache.get_market(self.symbol)
            if not self.market_info:
                self.logger.critical(f"{C_CRIT}Market lore not found for {self.symbol}. Was it loaded? Halting.{C_RESET}")
                await self._safe_exchange_close()
                return False
            self._extract_market_details() # Set precision, limits etc.

            # 3. Attune Leverage (Async)
            if self.leverage > 0:
                self.logger.info(f"{C_INFO}Attuning leverage for {self.symbol} to {self.leverage}x...")
                leverage_set = await bybit.set_leverage(
                    self.exchange, self.symbol, self.leverage, self.api_config.dict()
                )
                if not leverage_set:
                    self.logger.warning(
                        f"{C_WARN}Failed to attune leverage to {self.leverage}x. Check API permissions or existing state. Proceeding with current setting.{C_RESET}"
                    )
                else:
                     self.logger.success(f"{C_SUCCESS}Leverage attunement confirmed.{C_RESET}")

            # 4. Fetch Initial State (Async)
            self.logger.info(f"{C_INFO}Scrying initial account state (position, orders, balance)...")
            await self._update_state() # Handles internal errors
            pos_side = self.current_position.get("side", self.api_config.POS_NONE) if self.current_position else self.api_config.POS_NONE
            pos_qty_str = format_amount(self.exchange, self.symbol, self.current_position.get("qty", Decimal(0))) if self.current_position else "0"
            self.logger.info(f"{C_INFO}Initial Position: Side={pos_side}, Qty={pos_qty_str}")
            self.logger.info(f"{C_INFO}Initial Open Orders: {len(self.open_orders)}")
            self.logger.info(f"{C_INFO}Initial Available Balance: {self.available_balance:.4f} {self.api_config.USDT_SYMBOL}")

            # 5. Initial Cleansing Ritual (Cancel Orders)
            self.logger.info(f"{C_INFO}Performing initial cleansing: cancelling existing orders...")
            category = bybit.market_cache.get_category(self.symbol)
            if category and self.exchange:
                cancelled_count = await bybit.cancel_all_orders(
                    self.exchange, symbol=self.symbol, category=category, config=self.api_config.dict(), reason="Init Cleanup"
                )
                if cancelled_count is not None:
                    self.logger.info(f"{C_SUCCESS}Cleansed {cancelled_count} existing orders for {self.symbol}.")
                    await asyncio.sleep(1) # Brief pause for the ether to settle
                    await self._update_state() # Refresh state after cleansing
                else:
                    self.logger.warning(f"{C_WARN}Cleansing ritual (cancel_all_orders) failed to execute fully. Check logs.{C_RESET}")
            else:
                self.logger.error(f"{C_ERROR}Cannot perform cleansing ritual: Category unknown or exchange not ready for {self.symbol}.")

            self.logger.success(f"{C_SUCCESS}{C_BOLD}--- Strategy Initialization Ritual Complete ---{C_RESET}")
            return True

        except Exception as e:
            self.logger.critical(f"{C_CRIT}Critical failure during initialization ritual: {e}{C_RESET}", exc_info=True)
            await self._safe_exchange_close()
            return False

    def _extract_market_details(self):
        """Extracts and sets precision and limit runes from market lore."""
        if not self.market_info or not self.exchange:
            self.logger.error(f"{C_ERROR}Cannot extract market details: market_info or exchange is missing.{C_RESET}")
            return

        self.logger.debug(f"{C_DEBUG}Extracting market runes (precision, limits)...")
        try:
            limits = self.market_info.get("limits", {})
            amount_limits = limits.get("amount", {})
            precision = self.market_info.get("precision", {})

            min_qty_str = amount_limits.get("min")
            qty_step_str = precision.get("amount") # V5: This is the step size
            price_tick_str = precision.get("price") # V5: This is the tick size

            # Use safe conversion with defaults, ensuring they are positive
            self.min_qty = max(Decimal("1E-8"), safe_decimal_conversion(min_qty_str, Decimal("0.000001")))
            self.qty_step = max(Decimal("1E-8"), safe_decimal_conversion(qty_step_str, Decimal("0.000001")))
            self.price_tick = max(Decimal("1E-8"), safe_decimal_conversion(price_tick_str, Decimal("0.01")))

            if self.qty_step <= 0 or self.price_tick <= 0:
                 raise ValueError(f"Parsed invalid step/tick size (QtyStep: {self.qty_step}, PriceTick: {self.price_tick})")

            self.logger.info(f"{C_SUCCESS}Market Runes Set: Min Qty={format_amount(self.exchange, self.symbol, self.min_qty)}, "
                             f"Qty Step={format_amount(self.exchange, self.symbol, self.qty_step)}, "
                             f"Price Tick={format_price(self.exchange, self.symbol, self.price_tick)}")

        except Exception as e:
             self.logger.error(f"{C_ERROR}Failed to parse market runes for {self.symbol}: {e}{C_RESET}", exc_info=True)
             self.logger.warning(f"{C_WARN}Using default market details, order sizing/pricing may be imprecise.{C_RESET}")
             # Keep the small defaults set earlier

    async def _update_state(self):
        """Gathers current state from the exchange: position, orders, balance, ticker."""
        self.logger.debug(f"{C_DEBUG}Updating strategy state...")
        if not self.exchange or not self.loop: # Safety check
             self.logger.error(f"{C_ERROR}Cannot update state: Exchange or event loop not initialized.{C_RESET}")
             return
        try:
            # Use asyncio.gather for concurrent fetching
            tasks = {
                "position": bybit.get_current_position_bybit_v5(self.exchange, self.symbol, self.api_config.dict()),
                "orders": self._fetch_all_open_orders(),
                "balance": bybit.fetch_usdt_balance(self.exchange, self.api_config.dict()),
                "ticker": bybit.fetch_ticker_validated(self.exchange, self.symbol, self.api_config.dict()),
            }
            results = await asyncio.gather(*tasks.values(), return_exceptions=True)
            results_dict = dict(zip(tasks.keys(), results)) # Map results back to keys

            # --- Process results, handling potential exceptions ---
            state_update_summary = []

            # Position
            pos_data = results_dict.get("position")
            if isinstance(pos_data, Exception):
                 self.logger.error(f"{C_ERROR}Failed to fetch position state: {pos_data}{C_RESET}")
                 state_update_summary.append("Pos:Error")
            elif isinstance(pos_data, list): # Hedge mode
                self.logger.debug(f"{C_DEBUG}Hedge mode detected by position fetch.")
                found_pos = next((p for p in pos_data if p.get('misc', {}).get('positionIdx') == self.position_idx.value), None)
                self.current_position = found_pos # Assign found pos or None
                state_update_summary.append(f"Pos:{self.current_position['side'] if self.current_position else 'None'}")
            else: # One-way mode or None returned
                 self.current_position = pos_data
                 state_update_summary.append(f"Pos:{self.current_position['side'] if self.current_position else 'None'}")

            # Open Orders
            open_orders_list = results_dict.get("orders")
            if isinstance(open_orders_list, Exception):
                 self.logger.error(f"{C_ERROR}Failed to fetch open orders: {open_orders_list}{C_RESET}")
                 state_update_summary.append("Orders:Error")
            else:
                 self.open_orders = {o['id']: o for o in open_orders_list}
                 state_update_summary.append(f"Orders:{len(self.open_orders)}")
                 # Prune tracked SL order ID if it's no longer open
                 if self.stop_loss_order_id and self.stop_loss_order_id not in self.open_orders:
                     self.logger.info(f"{C_INFO}Tracked SL order ...{format_order_id(self.stop_loss_order_id)} vanished from open orders (filled/cancelled).")
                     self.stop_loss_order_id = None

            # Balance
            balance_tuple = results_dict.get("balance")
            if isinstance(balance_tuple, Exception):
                 self.logger.error(f"{C_ERROR}Failed to fetch balance: {balance_tuple}{C_RESET}")
                 state_update_summary.append("Bal:Error")
            elif balance_tuple is not None and len(balance_tuple) == 2:
                 _, fetched_available = balance_tuple # (total, available)
                 self.available_balance = fetched_available if fetched_available is not None else Decimal(0)
                 state_update_summary.append(f"Bal:{self.available_balance:.2f}")
            else:
                 self.logger.error(f"{C_ERROR}Failed to fetch balance (unexpected return: {balance_tuple}).{C_RESET}")
                 state_update_summary.append("Bal:Error")

            # Ticker
            ticker = results_dict.get("ticker")
            if isinstance(ticker, Exception):
                 self.logger.warning(f"{C_WARN}Failed to fetch ticker: {ticker}{C_RESET}")
                 state_update_summary.append("Px:Error")
            elif ticker and ticker.get('last'):
                 new_price = safe_decimal_conversion(ticker['last'])
                 if new_price and new_price > 0: # Ensure price is valid
                      self.last_known_price = new_price
                      state_update_summary.append(f"Px:{self.last_known_price:.4f}")
                 else:
                      self.logger.warning(f"{C_WARN}Fetched ticker price '{ticker['last']}' is invalid. Keeping previous: {self.last_known_price}{C_RESET}")
                      state_update_summary.append(f"Px:{self.last_known_price:.4f}(Stale)")
            else:
                state_update_summary.append(f"Px:{self.last_known_price:.4f}(Stale)")


            # Log summary of state
            pos_side = self.current_position.get('side', self.api_config.POS_NONE) if self.current_position else self.api_config.POS_NONE
            pos_qty = self.current_position.get('qty', Decimal(0)) if self.current_position else Decimal(0)
            pos_qty_str = format_amount(self.exchange, self.symbol, pos_qty) if self.exchange else str(pos_qty)
            self.logger.debug(f"{C_DEBUG}State Update: {', '.join(state_update_summary)} | Current Pos: {pos_side} Qty: {pos_qty_str}")

        except Exception as e:
            self.logger.error(f"{C_ERROR}Unexpected error during state update ritual: {e}{C_RESET}", exc_info=True)


    async def _fetch_all_open_orders(self) -> List[Dict[str, Any]]:
        """Fetches all types of open orders (Regular, Stop) concurrently."""
        if not self.exchange: return []
        category = bybit.market_cache.get_category(self.symbol)
        if not category:
            self.logger.error(f"{C_ERROR}Cannot fetch orders: Category unknown for {self.symbol}{C_RESET}")
            return []

        self.logger.debug(f"{C_DEBUG}Fetching all open order types...")
        tasks = []
        # Define filters based on Bybit V5 types needed for strategy logic
        order_filters_to_check = [
             OrderFilter.ORDER,      # Regular limit/market orders
             OrderFilter.STOP_ORDER, # Conditional orders (includes SL/TP placed this way)
        ]

        for order_filter in order_filters_to_check:
            tasks.append(
                 bybit.fetch_open_orders_filtered(
                      self.exchange, self.symbol, category=category, order_filter=order_filter, config=self.api_config.dict()
                 )
            )

        results = await asyncio.gather(*tasks, return_exceptions=True)

        all_orders: List[Dict[str, Any]] = []
        filter_names = [f.value for f in order_filters_to_check]
        for i, res in enumerate(results):
            if isinstance(res, Exception):
                self.logger.warning(f"{C_WARN}Failed to fetch open orders with filter '{filter_names[i]}': {res}{C_RESET}")
            elif isinstance(res, list):
                all_orders.extend(res)
                self.logger.debug(f"{C_DEBUG}Fetched {len(res)} open orders with filter '{filter_names[i]}'.")

        # Deduplicate based on order ID
        unique_orders = {o['id']: o for o in all_orders}
        self.logger.debug(f"{C_DEBUG}Total unique open orders found: {len(unique_orders)}")
        return list(unique_orders.values())


    async def _fetch_and_calculate_indicators(self) -> Optional[pd.DataFrame]:
        """Fetches OHLCV data and invokes the indicator calculation rites."""
        self.logger.debug(f"{C_DEBUG}Fetching OHLCV data ({self.timeframe})...")
        if not self.exchange or not self.loop: return None
        try:
            # Fetch enough data for indicators + warm-up buffer
            min_periods = self.strategy_config.indicator_settings.min_data_periods
            limit = min_periods + 50 # Add buffer
            ohlcv_data = await bybit.fetch_ohlcv_paginated(
                self.exchange,
                self.symbol,
                self.timeframe,
                limit=limit,
                config=self.api_config.dict(),
            )

            if ohlcv_data is None or ohlcv_data.empty or len(ohlcv_data) < min_periods:
                self.logger.warning(f"{C_WARN}Insufficient OHLCV data ({len(ohlcv_data) if ohlcv_data is not None else 0} candles < {min_periods}). Cannot divine indicators.{C_RESET}")
                return None

            # Ensure DataFrame format (handle list return from helper if necessary)
            if not isinstance(ohlcv_data, pd.DataFrame):
                try:
                     ohlcv_data = pd.DataFrame(ohlcv_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
                     ohlcv_data['datetime'] = pd.to_datetime(ohlcv_data['timestamp'], unit='ms', utc=True)
                     ohlcv_data.set_index('datetime', inplace=True)
                     for col in ['open', 'high', 'low', 'close', 'volume']:
                          ohlcv_data[col] = pd.to_numeric(ohlcv_data[col], errors='coerce')
                     self.logger.debug(f"{C_DEBUG}Converted OHLCV list to DataFrame.")
                except Exception as conv_err:
                     self.logger.error(f"{C_ERROR}Failed to convert OHLCV list to DataFrame: {conv_err}{C_RESET}")
                     return None

            # Prepare config for the indicator calculation rites
            indicator_config = {
                "indicator_settings": self.strategy_config.indicator_settings.dict(),
                "analysis_flags": self.strategy_config.analysis_flags.dict(),
                "strategy_params": self.strategy_config.strategy_params,
                # Pass any other context indicators.py might need
            }
            self.logger.debug(f"{C_DEBUG}Invoking indicator calculation rites...")

            # Run synchronous calculation in executor to avoid blocking async loop
            df_with_indicators = await self.loop.run_in_executor(
                 None, ind.calculate_all_indicators, ohlcv_data.copy(), indicator_config
            )

            # Validate results and required columns
            if df_with_indicators is None:
                 self.logger.error(f"{C_ERROR}Indicator calculation rite returned None.{C_RESET}")
                 return None
            missing_cols = [col for col in self.required_indicators if col not in df_with_indicators.columns]
            if missing_cols:
                 self.logger.error(f"{C_ERROR}Required indicator columns missing after calculation: {missing_cols}{C_RESET}")
                 return None

            self.logger.debug(f"{C_DEBUG}Indicator calculation rites complete. DataFrame shape: {df_with_indicators.shape}")
            return df_with_indicators

        except Exception as e:
            self.logger.error(
                f"{C_ERROR}Error during indicator divination: {e}{C_RESET}", exc_info=True
            )
            return None


    def _check_signals(self, df: pd.DataFrame) -> Tuple[Optional[Side], bool]:
        """
        Interprets the omens from the indicator data (EVT signals).

        Returns:
            tuple: (entry_side, should_exit)
                   entry_side: Side.BUY, Side.SELL, or None
                   should_exit: True if current position should be closed, False otherwise
        """
        if df is None or df.empty or len(df) < 2: # Need current and previous row
            self.logger.debug(f"{C_DEBUG}Indicator DataFrame too short or empty for signal interpretation.")
            return None, False
        if not self.strategy_config.analysis_flags.use_evt:
             self.logger.debug(f"{C_DEBUG}EVT analysis disabled, no EVT signals generated.")
             return None, False

        try:
            latest = df.iloc[-1]
            previous = df.iloc[-2]
        except IndexError:
            self.logger.warning(f"{C_WARN}Could not access latest/previous rows in indicator DataFrame.{C_RESET}")
            return None, False

        # --- Safely read the omens (indicator values) ---
        trend_latest_raw = latest.get(self.evt_trend_col)
        trend_prev_raw = previous.get(self.evt_trend_col)
        buy_signal_latest_raw = latest.get(self.evt_buy_col)
        sell_signal_latest_raw = latest.get(self.evt_sell_col)

        # Check if essential EVT indicators are available and not NaN/None
        if pd.isna(trend_latest_raw) or pd.isna(trend_prev_raw) or \
           pd.isna(buy_signal_latest_raw) or pd.isna(sell_signal_latest_raw):
             self.logger.debug(f"{C_DEBUG}EVT omens unclear (NaN/None found). Trend:{trend_latest_raw}, Buy:{buy_signal_latest_raw}, Sell:{sell_signal_latest_raw}. No signal.")
             return None, False

        # Convert to expected types
        try:
            current_trend = int(trend_latest_raw)
            previous_trend = int(trend_prev_raw)
            is_buy_signal = bool(buy_signal_latest_raw)
            is_sell_signal = bool(sell_signal_latest_raw)
        except (ValueError, TypeError) as e:
            self.logger.error(f"{C_ERROR}Failed to interpret EVT omen types: {e}. Raw values: Trend={trend_latest_raw}, Buy={buy_signal_latest_raw}, Sell={sell_signal_latest_raw}{C_RESET}")
            return None, False

        self.logger.debug(f"{C_DEBUG}Signal Check - Omens: Trend={current_trend} (Prev:{previous_trend}), BuySig={is_buy_signal}, SellSig={is_sell_signal}")

        # --- Define Entry/Exit Logic based on Omens ---
        entry_side: Optional[Side] = None
        should_exit: bool = False
        current_pos_side = self.current_position.get("side") if self.current_position else self.api_config.POS_NONE
        is_flat = current_pos_side == self.api_config.POS_NONE

        # **Entry Omens (Only if currently flat)**
        if is_flat:
            if is_buy_signal:
                 entry_side = Side.BUY
                 self.logger.info(f"{C_SUCCESS}{C_BOLD}ENTRY OMEN: BUY signal sighted (EVT Buy flag)!{C_RESET}")
            elif is_sell_signal:
                 entry_side = Side.SELL
                 self.logger.info(f"{C_ERROR}{C_BOLD}ENTRY OMEN: SELL signal sighted (EVT Sell flag)!{C_RESET}")

        # **Exit Omens (Only if in position)**
        elif not is_flat:
            is_long = current_pos_side == self.api_config.POS_LONG
            is_short = current_pos_side == self.api_config.POS_SHORT

            # Exit Long: Trend flips from non-negative (1 or 0) to negative (-1)
            if is_long and current_trend == -1 and previous_trend != -1:
                should_exit = True
                self.logger.info(f"{C_WARN}{C_BOLD}EXIT OMEN: Close LONG position (EVT Trend flipped bearish: {previous_trend} -> {current_trend}){C_RESET}")

            # Exit Short: Trend flips from non-positive (-1 or 0) to positive (1)
            elif is_short and current_trend == 1 and previous_trend != 1:
                should_exit = True
                self.logger.info(f"{C_WARN}{C_BOLD}EXIT OMEN: Close SHORT position (EVT Trend flipped bullish: {previous_trend} -> {current_trend}){C_RESET}")

        return entry_side, should_exit


    def _calculate_position_size(self, entry_price: Decimal, stop_loss_price: Decimal) -> Optional[Decimal]:
        """
        Calculates position size based on risk runes, stop-loss distance, and available balance.
        """
        self.logger.debug(f"{C_DEBUG}Calculating position size...")
        risk_pct = self.strategy_config.risk_per_trade
        balance = self.available_balance

        if balance <= 0:
            self.logger.error(f"{C_ERROR}Cannot calculate position size: Available balance ({balance}) is zero or negative.{C_RESET}")
            return None
        if entry_price <= 0 or stop_loss_price <= 0:
            self.logger.error(f"{C_ERROR}Cannot calculate position size: Entry ({entry_price}) or SL ({stop_loss_price}) price is invalid.{C_RESET}")
            return None
        if not self.exchange:
            self.logger.error(f"{C_ERROR}Cannot calculate position size: Exchange object missing.{C_RESET}")
            return None

        risk_amount_usd = balance * risk_pct
        price_diff = abs(entry_price - stop_loss_price)

        # Ensure price difference is meaningful relative to tick size
        if price_diff < self.price_tick:
            self.logger.error(
                f"{C_ERROR}Cannot calculate position size: Price difference ({price_diff:.8f}) "
                f"between entry ({entry_price:.4f}) and SL ({stop_loss_price:.4f}) "
                f"is smaller than tick size ({self.price_tick:.8f}). SL too tight or invalid prices.{C_RESET}"
            )
            return None

        # Calculate ideal size based on risk (assuming linear contract)
        position_size_base = risk_amount_usd / price_diff

        # Adjust for Step Size (quantize down)
        if self.qty_step <= 0: # Safety check
             self.logger.error(f"{C_ERROR}Invalid quantity step size ({self.qty_step}). Cannot adjust position size.{C_RESET}")
             return None
        position_size_adjusted = (position_size_base // self.qty_step) * self.qty_step

        if position_size_adjusted <= Decimal(0):
            self.logger.warning(
                f"{C_WARN}Calculated position size is zero after adjusting for step size {self.qty_step}. "
                f"Risk Amount: {risk_amount_usd:.4f} {self.api_config.USDT_SYMBOL}, Price Diff: {price_diff:.4f}. Cannot trade.{C_RESET}"
            )
            return None

        # Check against minimum order size
        if position_size_adjusted < self.min_qty:
            self.logger.warning(
                f"{C_WARN}Calculated size ({format_amount(self.exchange, self.symbol, position_size_adjusted)}) is below minimum ({format_amount(self.exchange, self.symbol, self.min_qty)}).{C_RESET}"
            )
            min_qty_risk_usd = self.min_qty * price_diff
            # Allow slightly exceeding risk budget ONLY if using min qty is necessary
            if min_qty_risk_usd <= risk_amount_usd * Decimal("1.10"): # Allow 10% over budget for min qty
                 self.logger.info(f"{C_INFO}Using minimum order size ({format_amount(self.exchange, self.symbol, self.min_qty)}) as its risk ({min_qty_risk_usd:.4f}) is acceptable.")
                 position_size_adjusted = self.min_qty
            else:
                 self.logger.error(f"{C_ERROR}Minimum order size risk ({min_qty_risk_usd:.4f}) significantly exceeds budget ({risk_amount_usd:.4f}). Cannot place trade.{C_RESET}")
                 return None

        # Basic Margin Check (Estimate)
        leverage_decimal = Decimal(str(self.leverage)) if self.leverage > 0 else Decimal('1')
        cost_estimate = (position_size_adjusted * entry_price) / leverage_decimal
        # Leave a small buffer (e.g., 2-5%)
        margin_buffer_factor = Decimal('0.95')
        if cost_estimate > balance * margin_buffer_factor:
            self.logger.error(
                f"{C_ERROR}Estimated cost ({cost_estimate:.4f} {self.api_config.USDT_SYMBOL}) exceeds {margin_buffer_factor*100:.0f}% of "
                f"available balance ({balance:.4f}) with {self.leverage}x leverage. Cannot place trade.{C_RESET}"
            )
            return None

        pos_size_fmt = format_amount(self.exchange, self.symbol, position_size_adjusted)
        self.logger.info(
            f"{C_SUCCESS}Calculated Position Size: {C_BOLD}{pos_size_fmt}{C_RESET}{C_SUCCESS} "
            f"(Risk: {risk_amount_usd:.4f} {self.api_config.USDT_SYMBOL}, Balance: {balance:.4f}, Price Diff: {price_diff:.4f})"
        )
        return position_size_adjusted


    def _calculate_stop_loss_price(self, df: pd.DataFrame, side: Side, entry_price: Decimal) -> Optional[Decimal]:
        """Calculates ATR based stop loss price."""
        self.logger.debug(f"{C_DEBUG}Calculating Stop Loss price...")
        if not self.strategy_config.analysis_flags.use_atr:
            self.logger.debug(f"{C_DEBUG}ATR analysis disabled, cannot calculate ATR-based SL.")
            return None
        if df is None or df.empty:
            self.logger.warning(f"{C_WARN}Indicator data missing, cannot calculate SL.{C_RESET}")
            return None
        if not self.exchange:
            self.logger.error(f"{C_ERROR}Cannot calculate SL price: Exchange object missing.{C_RESET}")
            return None
        if entry_price <= 0:
            self.logger.error(f"{C_ERROR}Cannot calculate SL price: Invalid entry price ({entry_price}).{C_RESET}")
            return None

        try:
            latest_atr_raw = df.iloc[-1].get(self.atr_col)
            if pd.isna(latest_atr_raw):
                self.logger.warning(f"{C_WARN}Latest ATR value is NaN. Cannot calculate SL.{C_RESET}")
                return None

            latest_atr = safe_decimal_conversion(latest_atr_raw)
            if latest_atr is None or latest_atr <= 0:
                self.logger.warning(f"{C_WARN}Invalid ATR value ({latest_atr}) for SL calculation.{C_RESET}")
                return None

            multiplier = self.strategy_config.stop_loss_atr_multiplier
            stop_offset = latest_atr * multiplier

            if side == Side.BUY:
                sl_price_raw = entry_price - stop_offset
            elif side == Side.SELL:
                sl_price_raw = entry_price + stop_offset
            else: # Should not happen if called correctly
                self.logger.error(f"{C_ERROR}Invalid side '{side}' provided for SL calculation.{C_RESET}")
                return None

            # Format according to market precision
            sl_price_fmt = format_price(self.exchange, self.symbol, sl_price_raw)
            sl_price = safe_decimal_conversion(sl_price_fmt)

            if sl_price is None or sl_price <= 0:
                 self.logger.error(f"{C_ERROR}Formatted SL price is invalid: Raw={sl_price_raw}, Fmt={sl_price_fmt}{C_RESET}")
                 return None

            # Sanity check: SL must be below entry for LONG, above for SHORT
            # Adjust by one tick if calculation lands exactly on or beyond entry
            if side == Side.BUY and sl_price >= entry_price:
                self.logger.warning(f"{C_WARN}Calculated Buy SL {sl_price_fmt} >= Entry {entry_price}. Adjusting down by one tick.{C_RESET}")
                sl_price = entry_price - self.price_tick
            elif side == Side.SELL and sl_price <= entry_price:
                 self.logger.warning(f"{C_WARN}Calculated Sell SL {sl_price_fmt} <= Entry {entry_price}. Adjusting up by one tick.{C_RESET}")
                 sl_price = entry_price + self.price_tick

            # Re-format after potential adjustment and final check
            sl_price_final_fmt = format_price(self.exchange, self.symbol, sl_price)
            sl_price_final = safe_decimal_conversion(sl_price_final_fmt)

            if sl_price_final and sl_price_final > 0:
                 atr_fmt = format_price(self.exchange, self.symbol, latest_atr) # Format ATR for logging
                 self.logger.info(f"{C_SUCCESS}Calculated SL Price: {C_BOLD}{sl_price_final_fmt}{C_RESET}{C_SUCCESS} "
                                  f"(Entry: {entry_price:.4f}, ATR: {atr_fmt}, Mult: {multiplier})")
                 return sl_price_final
            else:
                 self.logger.error(f"{C_ERROR}Final SL price after adjustment is invalid: {sl_price_final_fmt}. Raw adjusted: {sl_price}{C_RESET}")
                 return None

        except Exception as e:
            self.logger.error(f"{C_ERROR}Error calculating stop loss price: {e}{C_RESET}", exc_info=True)
            return None

    async def _place_stop_loss(self, entry_side: Side, qty: Decimal, sl_price: Decimal):
        """Places the native stop loss order using the exchange's magic."""
        if not self.exchange:
            self.logger.error(f"{C_ERROR}Cannot place SL: Exchange object missing.{C_RESET}")
            return
        if not sl_price or sl_price <= 0:
            self.logger.error(f"{C_ERROR}Invalid SL price ({sl_price}) provided. Cannot place SL.{C_RESET}")
            return
        if qty <= 0:
             self.logger.error(f"{C_ERROR}Invalid quantity ({qty}) provided. Cannot place SL.{C_RESET}")
             return

        sl_order_side = Side.SELL if entry_side == Side.BUY else Side.BUY
        trigger_direction = TriggerDirection.FALLING if sl_order_side == Side.SELL else TriggerDirection.RISING # V5 uses FALLING/RISING

        qty_fmt = format_amount(self.exchange, self.symbol, qty)
        sl_price_fmt = format_price(self.exchange, self.symbol, sl_price)
        self.logger.info(f"{C_INFO}Placing {sl_order_side.value.upper()} native Stop Loss for {qty_fmt} at trigger price {sl_price_fmt}...")

        # Use the helper function, ensuring basePrice is provided if needed (V5 often requires it)
        # Use last known price as a reasonable base price estimate
        base_price_for_sl = self.last_known_price
        if base_price_for_sl <= 0:
             self.logger.error(f"{C_ERROR}Last known price ({base_price_for_sl}) is invalid for SL basePrice. Cannot place SL.{C_RESET}")
             # Trigger emergency? Position is unprotected.
             await self._trigger_alert(f"URGENT: Invalid basePrice ({base_price_for_sl}) for SL placement! Position UNPROTECTED.", critical=True)
             # Consider emergency exit here if configuration allows
             # await self._emergency_close("Invalid basePrice for SL")
             return

        try:
            sl_order = await bybit.place_native_stop_loss(
                exchange=self.exchange,
                symbol=self.symbol,
                side=sl_order_side, # Side of the SL order itself
                amount=qty,
                stop_price=sl_price,
                base_price=base_price_for_sl, # Required by V5 for conditional orders
                config=self.api_config.dict(),
                trigger_direction=trigger_direction,
                is_reduce_only=True,
                order_type="Market", # SL triggers a market order
                position_idx=self.position_idx,
                trigger_by=TriggerBy.LAST_PRICE # Or MARK_PRICE, depends on preference/testing
            )

            if sl_order and sl_order.get('id'):
                self.stop_loss_order_id = sl_order['id']
                sl_id_short = format_order_id(self.stop_loss_order_id)
                self.logger.success(f"{C_SUCCESS}{C_BOLD}Native Stop Loss placed successfully! Order ID: ...{sl_id_short}{C_RESET}")
            else:
                self.logger.error(f"{C_CRIT}Failed to place native Stop Loss order! Position is UNPROTECTED.{C_RESET}")
                self.stop_loss_order_id = None # Ensure it's cleared
                await self._trigger_alert(f"URGENT: Failed SL placement after {entry_side.value} entry! Pos UNPROTECTED.", critical=True)
                # Consider emergency exit
                # await self._emergency_close("Failed SL Placement")

        except Exception as e:
             self.logger.error(f"{C_CRIT}Exception during Stop Loss placement: {e}{C_RESET}", exc_info=True)
             self.stop_loss_order_id = None
             await self._trigger_alert(f"EXCEPTION during SL placement! Pos UNPROTECTED. Check Logs!", critical=True)
             # Consider emergency exit
             # await self._emergency_close("Exception during SL Placement")


    async def _cancel_stop_loss(self):
        """Banishes the tracked stop loss order if it exists."""
        if not self.exchange:
             self.logger.error(f"{C_ERROR}Cannot cancel SL: Exchange object missing.{C_RESET}")
             return False # Indicate failure
        if self.stop_loss_order_id:
            sl_id_short = format_order_id(self.stop_loss_order_id)
            self.logger.info(f"{C_INFO}Attempting to banish existing Stop Loss order: ...{sl_id_short}")
            try:
                category = bybit.market_cache.get_category(self.symbol)
                if not category:
                    self.logger.error(f"{C_ERROR}Cannot cancel SL {sl_id_short}: Category unknown for {self.symbol}{C_RESET}")
                    return False # Indicate failure, don't clear ID

                # Use the specific helper for cancelling conditional orders
                success = await bybit.cancel_conditional_order(
                    exchange=self.exchange,
                    symbol=self.symbol,
                    order_id=self.stop_loss_order_id,
                    config=self.api_config.dict(),
                    category=category # Pass category explicitly
                )

                if success:
                    self.logger.info(f"{C_SUCCESS}Stop Loss ...{sl_id_short} banished successfully (or was already gone).{C_RESET}")
                    self.stop_loss_order_id = None # Clear ID on success
                    return True
                else:
                    # If cancel returns False, it might mean the order wasn't found (already filled/cancelled)
                    # Or it could be an API error. Re-check state to be sure.
                    self.logger.warning(f"{C_WARN}Attempt to banish Stop Loss order ...{sl_id_short} returned false. Re-checking state...{C_RESET}")
                    await self._update_state() # Update orders
                    if self.stop_loss_order_id and self.stop_loss_order_id not in self.open_orders:
                         self.logger.info(f"{C_INFO}Re-checked state: SL order ...{sl_id_short} is confirmed gone.")
                         self.stop_loss_order_id = None
                         return True # Confirmed gone
                    else:
                         self.logger.error(f"{C_ERROR}Failed to banish Stop Loss order ...{sl_id_short} and it still appears in open orders.{C_RESET}")
                         return False # Indicate persistent failure

            except Exception as e:
                 self.logger.error(f"{C_ERROR}Error banishing Stop Loss ...{sl_id_short}: {e}{C_RESET}", exc_info=True)
                 # Don't clear self.stop_loss_order_id here, might need retry or manual check
                 return False # Indicate failure
        else:
            self.logger.debug(f"{C_DEBUG}No active Stop Loss order ID tracked to banish.")
            return True # No SL to cancel is considered success in this context


    async def _manage_position(self, entry_side: Optional[Side], should_exit: bool, df_indicators: pd.DataFrame):
        """Orchestrates the entry and exit rituals based on signals."""
        current_pos_side = self.current_position.get("side") if self.current_position else self.api_config.POS_NONE
        current_qty = self.current_position.get("qty", Decimal(0)) if self.current_position else Decimal(0)
        is_flat = current_pos_side == self.api_config.POS_NONE

        # --- Exit Ritual ---
        if should_exit and not is_flat:
            pos_side_str = self.current_position.get("side", "Unknown") if self.current_position else "Unknown"
            qty_fmt = format_amount(self.exchange, self.symbol, current_qty) if self.exchange else str(current_qty)
            self.logger.warning(f"{C_WARN}{C_BOLD}Exit signal received for {pos_side_str} position of {qty_fmt}. Initiating closing ritual...{C_RESET}")

            # 1. Banish existing SL order FIRST
            sl_cancelled = await self._cancel_stop_loss()
            if not sl_cancelled:
                 self.logger.error(f"{C_ERROR}Failed to cancel SL before closing position. Attempting close anyway, but SL might interfere.{C_RESET}")
                 # Decide: Proceed with close? Or halt? Proceeding is often better.
            await asyncio.sleep(0.5) # Short pause after cancel request

            # 2. Close the position with reduce-only market order
            self.logger.info(f"{C_INFO}Submitting market order to close {pos_side_str} position of {qty_fmt}...")
            close_order = await bybit.close_position_reduce_only(
                 self.exchange, self.symbol, self.api_config.dict(), position_to_close=self.current_position, reason="Strategy Exit Signal"
            )

            if close_order and close_order.get('id'):
                 close_id_short = format_order_id(close_order['id'])
                 self.logger.success(f"{C_SUCCESS}Position close order ...{close_id_short} submitted successfully.{C_RESET}")
                 await self._trigger_alert(f"Closed {pos_side_str} Pos ({qty_fmt}). Reason: EVT Exit")
            else:
                 self.logger.error(f"{C_CRIT}Failed to submit position close order! Manual intervention likely needed.{C_RESET}")
                 await self._trigger_alert(f"URGENT: Failed CLOSE order for {pos_side_str} ({qty_fmt})!", critical=True)

            # Update state after attempting closure to confirm
            await asyncio.sleep(5) # Allow time for order processing/state update
            await self._update_state()
            return # Prevent entry on the same tick

        # --- Entry Ritual ---
        if entry_side is not None and is_flat:
            self.logger.info(f"{C_BOLD}{C_INFO}Entry signal: {entry_side.value.upper()}. Preparing entry ritual...{C_RESET}")

            # 1. Optional: Cleanse any lingering non-SL orders (defensive)
            if self.open_orders:
                 non_sl_orders = {oid: o for oid, o in self.open_orders.items() if oid != self.stop_loss_order_id}
                 if non_sl_orders:
                     self.logger.warning(f"{C_WARN}Found {len(non_sl_orders)} non-SL open orders before entry. Banishing them...{C_RESET}")
                     category = bybit.market_cache.get_category(self.symbol)
                     if category and self.exchange:
                         # Cancel only regular orders (OrderFilter.ORDER)
                         await bybit.cancel_all_orders(self.exchange, self.symbol, category=category, order_filter=OrderFilter.ORDER, config=self.api_config.dict(), reason="Pre-Entry Cleanup")
                         await asyncio.sleep(1) # Pause after cancellation
                         await self._update_state() # Refresh orders state
                     else:
                          self.logger.error(f"{C_ERROR}Cannot cleanse orders: Category or exchange missing.{C_RESET}")


            # 2. Calculate SL Price (using current price as estimate for initial sizing)
            entry_price_estimate = self.last_known_price
            if entry_price_estimate <= 0:
                self.logger.error(f"{C_ERROR}Cannot calculate SL for entry: Invalid estimated entry price ({entry_price_estimate}).{C_RESET}")
                return

            sl_price_initial = self._calculate_stop_loss_price(df_indicators, entry_side, entry_price_estimate)
            if sl_price_initial is None:
                self.logger.error(f"{C_ERROR}Failed to calculate valid initial SL price. Cannot divine entry size.{C_RESET}")
                return

            # 3. Calculate Position Size (based on estimated entry and initial SL)
            qty_to_order = self._calculate_position_size(entry_price_estimate, sl_price_initial)
            if qty_to_order is None or qty_to_order <= 0:
                self.logger.error(f"{C_ERROR}Failed to calculate valid order quantity ({qty_to_order}). Aborting entry ritual.{C_RESET}")
                return

            # 4. Place Market Entry Order
            entry_order_side_str = entry_side.value # Convert Enum to string for helper
            qty_fmt = format_amount(self.exchange, self.symbol, qty_to_order) if self.exchange else str(qty_to_order)
            self.logger.info(f"{C_INFO}Placing {entry_order_side_str.upper()} market entry order for {qty_fmt}...")
            entry_order = await bybit.place_market_order_slippage_check(
                exchange=self.exchange,
                symbol=self.symbol,
                side=entry_order_side_str,
                amount=qty_to_order,
                config=self.api_config.dict(),
                is_reduce_only=False,
                time_in_force=TimeInForce.IOC, # ImmediateOrCancel is safer for market orders
                position_idx=self.position_idx
            )

            # 5. Handle Entry Order Result & Place SL
            if entry_order and entry_order.get('status') in ['closed', 'filled']:
                 # Order filled - Confirm details and place SL
                 entry_id_short = format_order_id(entry_order.get('id', 'N/A'))
                 self.logger.success(f"{C_SUCCESS}Entry order ...{entry_id_short} reported filled/closed.{C_RESET}")

                 # Try to get actual fill details from receipt, otherwise re-fetch state
                 filled_price_entry = safe_decimal_conversion(entry_order.get('average'))
                 filled_qty_entry = safe_decimal_conversion(entry_order.get('filled'))

                 # If receipt lacks details, wait and fetch position state
                 if not filled_price_entry or not filled_qty_entry or filled_qty_entry <= 0:
                      self.logger.warning(f"{C_WARN}Entry order receipt lacks fill details, re-fetching position state after delay...{C_RESET}")
                      await asyncio.sleep(5) # Wait longer for state update propagation
                      await self._update_state()
                      # Check if position actually opened with the correct side
                      if self.current_position and self.current_position.get('side') == self.api_config.POS_LONG if entry_side == Side.BUY else self.api_config.POS_SHORT:
                           self.logger.info(f"{C_INFO}Position state confirmed after entry.")
                           # Use position data, fallback to estimates/ordered qty if needed
                           filled_price_entry = safe_decimal_conversion(self.current_position.get('avgPrice')) or entry_price_estimate
                           filled_qty_entry = self.current_position.get('qty', qty_to_order) # Use actual position qty
                      else:
                           self.logger.error(f"{C_ERROR}Failed to confirm position opening after entry order ({entry_id_short}). Aborting SL placement.{C_RESET}")
                           await self._trigger_alert(f"Failed Entry Confirmation! Order: ...{entry_id_short}", critical=True)
                           return # Cannot proceed without confirmed entry

                 # Final check on filled quantity
                 if filled_qty_entry <= 0:
                     self.logger.error(f"{C_ERROR}Confirmed filled quantity is zero or invalid ({filled_qty_entry}). Cannot place SL.{C_RESET}")
                     return

                 filled_qty_fmt = format_amount(self.exchange, self.symbol, filled_qty_entry) if self.exchange else str(filled_qty_entry)
                 filled_price_fmt = format_price(self.exchange, self.symbol, filled_price_entry) if self.exchange else str(filled_price_entry)
                 self.logger.success(f"{C_SUCCESS}{C_BOLD}Entry Confirmed: Side={entry_side.value}, Qty={filled_qty_fmt}, AvgPx={filled_price_fmt}{C_RESET}")
                 await self._trigger_alert(f"Entered {entry_side.value} {filled_qty_fmt} @ {filled_price_fmt}")


                 # --- CRITICAL: Recalculate SL price based on ACTUAL fill price ---
                 self.logger.info(f"{C_INFO}Recalculating SL based on actual fill price {filled_price_fmt}...")
                 sl_price_actual = self._calculate_stop_loss_price(df_indicators, entry_side, filled_price_entry)

                 if sl_price_actual is None:
                     self.logger.error(f"{C_CRIT}Failed to recalculate SL price based on actual fill price ({filled_price_fmt}). POSITION UNPROTECTED.{C_RESET}")
                     await self._trigger_alert(f"URGENT: Failed SL RECALC after {entry_side.value} entry! Pos UNPROTECTED.", critical=True)
                     # Trigger emergency close immediately as position is open and unprotected
                     await self._emergency_close("Failed SL Recalculation after Entry")
                     return # Stop further processing for this tick

                 await asyncio.sleep(0.5) # Brief pause before placing SL

                 # Place the SL using actual filled quantity and recalculated SL price
                 await self._place_stop_loss(entry_side, filled_qty_entry, sl_price_actual)

                 # Final state update after entry and SL placement attempt
                 await asyncio.sleep(2)
                 await self._update_state()

            elif entry_order: # Order placed but status is not confirmed filled (e.g., 'open', 'new', 'rejected')
                 status = entry_order.get('status', 'unknown')
                 order_id = entry_order.get('id', 'N/A')
                 order_id_short = format_order_id(order_id)
                 self.logger.warning(f"{C_WARN}Entry market order (...{order_id_short}) status is '{status}'. Position may not have opened as expected.{C_RESET}")
                 # Update state to see if position opened despite unclear status
                 await asyncio.sleep(3)
                 await self._update_state()
            else: # place_market_order returned None or error
                 self.logger.error(f"{C_ERROR}Failed to place entry market order. Check helper logs. Aborting entry.{C_RESET}")


    async def run_loop(self):
        """The main enchantment loop, observing the market and acting on omens."""
        if not await self._initialize():
            self.logger.critical(f"{C_CRIT}Strategy initialization failed. Shutting down the spell.{C_RESET}")
            return

        self.is_running = True
        self.logger.info(f"{C_SUCCESS}{C_BOLD}=== Starting Ehlers Volumetric Strategy Loop ===")
        self.logger.info(f"{C_INFO}Observing {self.symbol} on {self.timeframe} timeframe. Polling every {self.strategy_config.polling_interval_seconds}s.")

        while self.is_running:
            try:
                loop_start_time = time.monotonic()
                current_time_utc = pd.Timestamp.now(tz='UTC').strftime('%Y-%m-%d %H:%M:%S %Z')
                self.logger.info(f"{C_INFO}{'-'*25} Tick Start ({current_time_utc}) {'-'*25}{C_RESET}")

                # 1. Update current state (position, orders, balance, price)
                await self._update_state()
                if self.exchange is None: # Check if connection lost/closed
                     self.logger.critical(f"{C_CRIT}Exchange connection lost or closed unexpectedly. Stopping loop.{C_RESET}")
                     self.is_running = False; continue

                # 2. Fetch data and calculate indicators (divine the omens)
                df_indicators = await self._fetch_and_calculate_indicators()
                if df_indicators is None:
                     self.logger.warning(f"{C_WARN}Failed to divine indicators for this tick. Waiting for next cycle.{C_RESET}")
                     # Use calculated sleep time below, don't continue here
                else:
                    # 3. Check for entry/exit signals (interpret the omens)
                    entry_side, should_exit = self._check_signals(df_indicators)

                    # 4. Manage position based on signals (perform rituals)
                    await self._manage_position(entry_side, should_exit, df_indicators)

                # --- Loop Timing & Sleep ---
                loop_end_time = time.monotonic()
                elapsed = loop_end_time - loop_start_time
                poll_interval = self.strategy_config.polling_interval_seconds
                sleep_time = max(0.1, poll_interval - elapsed) # Ensure minimum sleep
                self.logger.info(f"{C_INFO}Tick processed in {elapsed:.2f}s. Sleeping for {sleep_time:.2f}s.")
                await asyncio.sleep(sleep_time)

            except asyncio.CancelledError:
                self.logger.info(f"{C_WARN}Strategy loop cancellation requested. Beginning shutdown ritual...{C_RESET}")
                self.is_running = False # Ensure loop terminates cleanly

            except Exception as e:
                # Log critical errors, send alert, pause, and continue loop
                self.logger.critical(f"{C_CRIT}CRITICAL UNHANDLED ERROR in strategy loop: {e}{C_RESET}", exc_info=True)
                await self._trigger_alert(f"CRITICAL LOOP ERROR: {type(e).__name__}. Check Logs!", critical=True)
                self.logger.info(f"{C_WARN}Pausing for 60 seconds after critical loop error...{C_RESET}")
                await asyncio.sleep(60) # Pause longer after unexpected error

        self.logger.info(f"{C_INFO}{C_BOLD}--- Strategy Loop Finished ---{C_RESET}")
        await self._cleanup()


    async def stop(self):
        """Signals the strategy loop to stop gracefully after the current tick."""
        if self.is_running:
             self.logger.warning(f"{C_WARN}{C_BOLD}Stop signal received. Strategy loop will terminate after current cycle.{C_RESET}")
             self.is_running = False # Set flag to break loop
        else:
             self.logger.info(f"{C_INFO}Stop signal received, but loop wasn't running.")


    async def _cleanup(self):
        """Performs cleanup rituals upon spell termination."""
        self.logger.info(f"{C_INFO}{C_BOLD}--- Initiating Strategy Cleanup Ritual ---{C_RESET}")
        if self.exchange:
             # Cancel all remaining open orders (including any lingering SL)
             self.logger.info(f"{C_INFO}Banishing all remaining open orders for {self.symbol}...")
             category = bybit.market_cache.get_category(self.symbol)
             if category:
                 try:
                     cancelled_count = await bybit.cancel_all_orders(
                          self.exchange, symbol=self.symbol, category=category, config=self.api_config.dict(), reason="Shutdown Cleanup"
                     )
                     if cancelled_count is not None:
                          self.logger.info(f"{C_SUCCESS}Banished {cancelled_count} orders during cleanup.{C_RESET}")
                     else:
                          self.logger.warning(f"{C_WARN}Order banishment ritual (cancel_all) failed during cleanup.{C_RESET}")
                 except Exception as cancel_err:
                      self.logger.error(f"{C_ERROR}Error during cleanup order cancellation: {cancel_err}{C_RESET}", exc_info=True)
             else:
                  self.logger.error(f"{C_ERROR}Cannot perform cleanup order cancellation: Category unknown.{C_RESET}")

             # Close the exchange connection safely
             await self._safe_exchange_close()
        else:
            self.logger.info(f"{C_INFO}Exchange connection already closed or never established.")

        self.logger.info(f"{C_SUCCESS}{C_BOLD}--- Strategy Cleanup Ritual Complete ---{C_RESET}")

    async def _safe_exchange_close(self):
        """Safely closes the exchange connection if it's open."""
        if self.exchange and hasattr(self.exchange, 'close') and getattr(self.exchange, 'closed', True) is False:
            self.logger.info(f"{C_INFO}Closing connection to the exchange...")
            try:
                await self.exchange.close()
                self.logger.info(f"{C_SUCCESS}Exchange connection closed.")
            except Exception as e:
                self.logger.error(f"{C_ERROR}Error closing exchange connection: {e}{C_RESET}", exc_info=True)
        self.exchange = None # Ensure it's None after closing attempt


    async def _trigger_alert(self, message: str, critical: bool = False):
        """Sends an SMS alert if configured, handling potential blocking."""
        prefix = f"[{self.symbol}] "
        full_message = prefix + message
        log_level = logging.CRITICAL if critical else logging.WARNING
        log_color = C_CRIT if critical else C_WARN

        self.logger.log(log_level, f"{log_color}{C_BOLD}ALERT: {message}{C_RESET}")

        if self.sms_config.ENABLE_SMS_ALERTS and self.loop:
            self.logger.debug(f"{C_DEBUG}Attempting to send SMS alert...")
            try:
                # Run the potentially blocking SMS function in an executor thread
                await self.loop.run_in_executor(
                    None, # Use default executor
                    send_sms_alert,
                    full_message,
                    self.app_config.dict() # Pass the whole validated config dict
                )
                self.logger.info(f"{C_SUCCESS}SMS alert dispatched successfully.{C_RESET}")
            except Exception as e:
                self.logger.error(f"{C_ERROR}Failed to send SMS alert: {e}{C_RESET}", exc_info=True)
        elif self.sms_config.ENABLE_SMS_ALERTS:
             self.logger.warning(f"{C_WARN}Cannot send SMS alert: Event loop not available.{C_RESET}")


    async def _emergency_close(self, reason: str):
         """Attempts to immediately close the current position in an emergency."""
         self.logger.critical(f"{C_CRIT}EMERGENCY CLOSE triggered! Reason: {reason}{C_RESET}")
         await self._trigger_alert(f"EMERGENCY Closing Position! Reason: {reason}", critical=True)

         # Ensure state is fresh before acting
         await self._update_state()

         if self.current_position and self.current_position.get('side') != self.api_config.POS_NONE:
              pos_side = self.current_position['side']
              pos_qty = self.current_position.get('qty', Decimal(0))
              qty_fmt = format_amount(self.exchange, self.symbol, pos_qty) if self.exchange else str(pos_qty)

              self.logger.warning(f"{C_WARN}Attempting emergency close of {pos_side} position of {qty_fmt}...{C_RESET}")

              # 1. Cancel SL first (best effort)
              await self._cancel_stop_loss()
              await asyncio.sleep(0.5)

              # 2. Submit close order
              close_order = await bybit.close_position_reduce_only(
                   self.exchange, self.symbol, self.api_config.dict(), position_to_close=self.current_position, reason=f"Emergency Close: {reason}"
              )

              if close_order and close_order.get('id'):
                   close_id_short = format_order_id(close_order['id'])
                   self.logger.warning(f"{C_WARN}{C_BOLD}Emergency close order submitted: ...{close_id_short}{C_RESET}")
                   # Alert already sent at the start of the function
              else:
                   self.logger.critical(f"{C_CRIT}FAILED to submit emergency close order! MANUAL INTERVENTION REQUIRED!{C_RESET}")
                   # Send another, more urgent alert
                   await self._trigger_alert(f"!!! CRITICAL: FAILED EMERGENCY CLOSE for {pos_side} ({qty_fmt}) !!!", critical=True)
         else:
              self.logger.info(f"{C_INFO}Emergency close triggered, but no open position found to close.")


# --- Example Usage (Requires a main async execution context) ---
# This part would typically be in your main script (e.g., main.py)

async def main():
    # 1. Configure Logging (using your neon_logger or basic config)
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    logger = logging.getLogger("EhlersStrategy")
    logger.info(f"{C_INFO}Logger initialized.")

    # 2. Load Configuration (from file, env vars, etc.)
    # Replace with your actual config loading mechanism
    config = {
        "API_CONFIG": {
            "API_KEY": "YOUR_API_KEY",
            "API_SECRET": "YOUR_API_SECRET",
            "SYMBOL": "BTCUSDT", # Example
            "TESTNET_MODE": True,
            # POS_NONE, POS_LONG, POS_SHORT use defaults from Pydantic model
        },
        "STRATEGY_CONFIG": {
            "name": "EhlersVolumetricEnhanced",
            "timeframe": "15m",
            "leverage": 5,
            "indicator_settings": {
                "min_data_periods": 100,
                "evt_length": 7,
                "atr_period": 14,
            },
            "analysis_flags": {
                "use_evt": True,
                "use_atr": True,
            },
            "risk_per_trade": "0.01", # 1% risk
            "stop_loss_atr_multiplier": "2.0",
            "position_idx": 0, # 0 for One-Way, 1 for Hedge Long, 2 for Hedge Short
            "polling_interval_seconds": 60,
            "EVT_ENABLED": True,
            "STOP_LOSS_ATR_PERIOD": 14, # Must match atr_period above
        },
        "SMS_CONFIG": {
            "ENABLE_SMS_ALERTS": False, # Set to True to enable
            # Add Twilio or Termux API details if enabled
        },
        "LOGGING_CONFIG": {
             "level": "INFO" # Example logging config item
        }
    }

    # 3. Instantiate the Strategy
    try:
        strategy = EhlersVolumetricStrategyEnhanced(config, logger)
    except ValueError as e:
         logger.critical(f"{C_CRIT}Failed to instantiate strategy due to config errors: {e}{C_RESET}")
         return # Exit if config is invalid

    # 4. Run the Strategy Loop
    try:
        await strategy.run_loop()
    except KeyboardInterrupt:
        logger.warning(f"{C_WARN}Manual interruption detected. Stopping strategy...{C_RESET}")
        await strategy.stop()
        # Allow loop to finish current cycle and cleanup
        await asyncio.sleep(2) # Give a moment for stop signal processing
    except Exception as e:
        logger.critical(f"{C_CRIT}Unhandled exception in main execution: {e}{C_RESET}", exc_info=True)
        await strategy.stop() # Attempt graceful stop on other errors
        await asyncio.sleep(2)
    finally:
        # Ensure cleanup runs even if loop crashes hard (though stop() should handle it)
        if strategy and strategy.is_running:
             logger.warning(f"{C_WARN}Performing final cleanup check...{C_RESET}")
             await strategy._cleanup() # Call cleanup directly if needed

if __name__ == "__main__":
    print(f"{C_INFO}Initiating strategy spell... Run with 'python {__file__}'{C_RESET}")
    # Ensure Termux keeps running
    print(f"{C_WARN}Consider running within 'tmux' and using 'termux-wake-lock' for stability.{C_RESET}")
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print(f"\n{C_WARN}Spell interrupted manually.{C_RESET}")
    except Exception as e:
         print(f"\n{C_CRIT}A critical error disrupted the spell: {e}{C_RESET}")

```

**Summary of Enhancements Woven by Pyrmethus:**

1.  **Pydantic Configuration Runes:** Introduced `pydantic` models (`APIConfig`, `StrategyConfig`, etc.) for strict validation, type safety, and clearer definition of required parameters. This prevents runtime errors due to misconfiguration.
2.  **Enhanced Colorama Integration:** Defined standard color constants (`C_INFO`, `C_SUCCESS`, etc.) and applied them consistently throughout logging messages for improved readability and mystical flair. Added `Style.BRIGHT` for emphasis.
3.  **Robust Initialization:** Improved logging during initialization, clearer error messages, and ensured safe closure of the exchange connection on failure.
4.  **Refined State Updates (`_update_state`):** Logs results for each concurrent task (position, orders, balance, ticker) individually, making it easier to pinpoint failures. Provides a concise summary log.
5.  **Clearer Order Fetching (`_fetch_all_open_orders`):** Explicitly logs the number of orders fetched per filter type.
6.  **Safer Indicator Calculation:** Ensured OHLCV data is explicitly converted to a DataFrame if needed. Improved logging around the calculation process.
7.  **Precise Calculations:** Added safety checks for zero/negative prices/ATR/steps in `_calculate_position_size` and `_calculate_stop_loss_price`. Improved logging formats for calculated values using exchange precision. Added sanity checks and adjustments for SL prices relative to entry.
8.  **Improved Order Management (`_manage_position`):**
    *   More robust handling of entry order confirmation, including re-fetching state if the initial receipt is unclear.
    *   **Crucially:** Added an immediate `_emergency_close` trigger if SL recalculation *after* a confirmed entry fails, preventing an unprotected position.
    *   Clearer logging of order statuses and actions.
9.  **Asynchronous Safety (`_trigger_alert`):** Explicitly runs the potentially blocking `send_sms_alert` function within `loop.run_in_executor` to prevent stalling the main async event loop.
10. **Enhanced Stop Loss Handling:** Uses the correct V5 `cancel_conditional_order` helper. Re-checks state if cancellation returns `False` to confirm if the order is truly gone. Triggers alerts and considers emergency close if SL placement fails.
11. **Graceful Shutdown & Cleanup:** Improved `stop()` and `_cleanup()` logic, ensuring orders are cancelled and the connection is closed safely, even on errors. Added `_safe_exchange_close` helper.
12. **Type Hinting:** Added more specific type hints throughout the code for better static analysis and developer understanding.
13. **Mystical Flair:** Infused comments and logging messages with Pyrmethus's characteristic tone.
14. **Termux Guidance:** Included setup instructions (`pkg`, `pip`) and reminders about `tmux` and `termux-wake-lock` at the beginning.

This enhanced spell is now more resilient, easier to debug, and speaks with the clarity and power befitting a Termux Coding Wizard. Remember to replace placeholder API keys and adjust configuration runes to match your specific needs. Test it thoroughly in the `TESTNET_MODE` crucible before unleashing it upon live markets! May the digital currents flow in your favor!