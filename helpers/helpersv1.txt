#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Bybit V5 CCXT Helper Functions (v3.2 - Merged & Enhanced)

A robust, modular, and enhanced collection of helper functions for interacting with
the Bybit V5 API (Unified Trading Account) using the CCXT library. This version
merges the functionalities of previous v2.x versions into the enhanced v3.x async
structure, making it self-contained.

Key Features:
- Fully asynchronous operations (`async`/`await`).
- Logically grouped functions (can be split into submodules).
- Enhanced type safety with TypedDict, Enums, and precise hints.
- Performance optimizations via integrated MarketCache.
- Centralized asynchronous error handling and retry logic via decorator.
- Structured logging with conditional color support.
- Implemented features: Batch orders, WebSocket streaming, comprehensive order types.
- Increased robustness and handling of Bybit V5 specifics (category, filters, UTA).
- Self-contained: Includes necessary utility functions and decorators.

Version: 3.2
"""

# Standard Library Imports
import logging
import os
import sys
import time
import random
import json
from decimal import Decimal, ROUND_HALF_UP, getcontext, InvalidOperation, DivisionByZero
from typing import (Optional, Dict, List, Tuple, Any, Literal, Union,
                    TypedDict, Callable, Coroutine, TypeVar)
from enum import Enum
import asyncio
import math

# Third-party Libraries
try:
    import ccxt.async_support as ccxt
    from ccxt.base.errors import (
        ExchangeError, NetworkError, RateLimitExceeded, AuthenticationError,
        OrderNotFound, InvalidOrder, InsufficientFunds, ExchangeNotAvailable,
        NotSupported, OrderImmediatelyFillable, BadSymbol, ArgumentsRequired,
        RequestTimeout
    )
except ImportError:
    print("FATAL ERROR: CCXT library not found.")
    print("Please install it: pip install ccxt>=4.0.0") # Recommend recent async version
    sys.exit(1)
try:
    import pandas as pd
except ImportError:
    print("Warning: pandas library not found. OHLCV functions will return lists, not DataFrames.")
    print("Install for DataFrame support: pip install pandas>=2.0.0")
    pd = None
try:
    from colorama import Fore, Style, Back, init
    if os.name == 'nt': init() # Initialize colorama on Windows
except ImportError:
    print("Warning: colorama not found. Logs will be uncolored.")
    class DummyColor:
        def __getattr__(self, name: str) -> str: return ""
    Fore = Style = Back = DummyColor()
try:
    import websockets
    from websockets.exceptions import WebSocketException, ConnectionClosed, ConnectionClosedOK, ConnectionClosedError, InvalidURI
except ImportError:
    print("Warning: websockets library not found. WebSocket features disabled.")
    websockets = None
    class DummyWebSocketException(Exception): pass
    WebSocketException = ConnectionClosed = ConnectionClosedOK = ConnectionClosedError = InvalidURI = DummyWebSocketException

# --- Configuration & Constants ---
getcontext().prec = 28 # Decimal precision

# Config Structure
class Config(TypedDict):
    EXCHANGE_ID: Literal['bybit']
    API_KEY: str
    API_SECRET: str
    TESTNET_MODE: bool
    SYMBOL: str
    USDT_SYMBOL: str
    DEFAULT_MARGIN_MODE: Literal['isolated', 'cross']
    DEFAULT_RECV_WINDOW: int
    DEFAULT_SLIPPAGE_PCT: Decimal
    POSITION_QTY_EPSILON: Decimal
    SHALLOW_OB_FETCH_DEPTH: int
    ORDER_BOOK_FETCH_LIMIT: int
    EXPECTED_MARKET_TYPE: Literal['swap', 'spot', 'option', 'future']
    EXPECTED_MARKET_LOGIC: Literal['linear', 'inverse']
    RETRY_COUNT: int
    RETRY_DELAY_SECONDS: float # Added for OHLCV retry
    POS_NONE: Literal['NONE'] # Define constants for position side clarity
    POS_LONG: Literal['LONG']
    POS_SHORT: Literal['SHORT']
    SIDE_BUY: Literal['buy']
    SIDE_SELL: Literal['sell']
    MAKER_FEE_RATE: Decimal # Needed for margin calculation
    TAKER_FEE_RATE: Decimal # Needed for margin calculation

# Enums
class Side(str, Enum):
    BUY = "buy"
    SELL = "sell"

class Category(str, Enum):
    LINEAR = "linear"; INVERSE = "inverse"; SPOT = "spot"; OPTION = "option"

class OrderFilter(str, Enum):
    ORDER = "Order"; STOP_ORDER = "StopOrder"; TPSL_ORDER = "tpslOrder"

class TimeInForce(str, Enum):
    GTC = "GTC"; IOC = "IOC"; FOK = "FOK"; POST_ONLY = "PostOnly"

class TriggerDirection(int, Enum):
    RISE = 1; FALL = 2

class PositionIdx(int, Enum):
    ONE_WAY = 0; BUY_SIDE = 1; SELL_SIDE = 2

class TriggerBy(str, Enum):
    LAST = "LastPrice"; MARK = "MarkPrice"; INDEX = "IndexPrice"

# --- Logger Setup ---
logger = logging.getLogger(__name__)
if not logger.hasHandlers():
    logger.setLevel(logging.DEBUG); handler = logging.StreamHandler(sys.stdout)
    formatter = logging.Formatter("%(asctime)s [%(levelname)s] {%(name)s:%(lineno)d} - %(message)s", datefmt="%Y-%m-%d %H:%M:%S")
    handler.setFormatter(formatter); logger.addHandler(handler)

# --- Market Cache ---
class MarketCache:
    """ Caches market data fetched from the exchange to reduce API calls. """
    def __init__(self): self._markets: Dict[str, Dict[str, Any]] = {}; self._categories: Dict[str, Optional[Category]] = {}; self._lock = asyncio.Lock()
    async def load_markets(self, exchange: ccxt.bybit, reload: bool = False):
        async with self._lock:
            if not self._markets or reload:
                logger.info(f"{Fore.BLUE}[MarketCache] {'Reloading' if reload else 'Loading'} markets...{Style.RESET_ALL}")
                try:
                    all_markets = await exchange.load_markets(reload=reload)
                    if not all_markets: logger.critical(f"{Back.RED}[MarketCache] Failed load markets - empty data.{Style.RESET_ALL}"); self._markets={}; self._categories={}; return
                    self._markets = all_markets; self._categories.clear(); logger.success(f"{Fore.GREEN}[MarketCache] Loaded {len(self._markets)} markets.{Style.RESET_ALL}")
                except (NetworkError, ExchangeNotAvailable) as e: logger.error(f"{Fore.RED}[MarketCache] Network/Avail error loading: {e}{Style.RESET_ALL}")
                except ExchangeError as e: logger.error(f"{Fore.RED}[MarketCache] Exchange error loading: {e}{Style.RESET_ALL}", exc_info=True)
                except Exception as e: logger.critical(f"{Back.RED}[MarketCache] Unexpected error loading: {e}{Style.RESET_ALL}", exc_info=True); self._markets={}; self._categories={}
    def get_market(self, symbol: str) -> Optional[Dict[str, Any]]: return self._markets.get(symbol)
    def get_category(self, symbol: str) -> Optional[Category]:
        if symbol not in self._categories:
            market = self.get_market(symbol)
            if market: category_str = _get_v5_category(market); try: self._categories[symbol] = Category(category_str) if category_str else None; except ValueError: logger.error(f"[MarketCache] Invalid category '{category_str}' for '{symbol}'."); self._categories[symbol] = None
            else: self._categories[symbol] = None
        return self._categories[symbol]
    def get_all_symbols(self) -> List[str]: return list(self._markets.keys())
market_cache = MarketCache()

# --- Utility Functions (Integrated) ---
def safe_decimal_conversion(value: Any, default: Optional[Decimal] = None) -> Optional[Decimal]:
    if value is None or value == '': return default
    try: d = Decimal(str(value)); return default if d.is_nan() or d.is_infinite() else d; except (ValueError, TypeError, InvalidOperation): return default
def format_price(exchange: ccxt.bybit, symbol: str, price: Optional[Union[Decimal, float, str]]) -> Optional[str]:
    if price is None: return None; market = market_cache.get_market(symbol)
    if not market: logger.warning(f"[format_price] No market cache for {symbol}."); return str(price)
    price_decimal = safe_decimal_conversion(price);
    if price_decimal is None: logger.error(f"[format_price] Invalid price '{price}' for {symbol}."); return None
    try: return exchange.price_to_precision(symbol, float(price_decimal))
    except Exception as e: logger.error(f"[format_price] Format error {price_decimal} for {symbol}: {e}", exc_info=True); prec = market.get('precision', {}).get('price', 8); try: return f"{price_decimal:.{prec}f}"; except Exception: return str(price_decimal)
def format_amount(exchange: ccxt.bybit, symbol: str, amount: Optional[Union[Decimal, float, str]]) -> Optional[str]:
    if amount is None: return None; market = market_cache.get_market(symbol)
    if not market: logger.warning(f"[format_amount] No market cache for {symbol}."); return str(amount)
    amount_decimal = safe_decimal_conversion(amount);
    if amount_decimal is None: logger.error(f"[format_amount] Invalid amount '{amount}' for {symbol}."); return None
    try: return exchange.amount_to_precision(symbol, float(amount_decimal))
    except Exception as e: logger.error(f"[format_amount] Format error {amount_decimal} for {symbol}: {e}", exc_info=True); prec = market.get('precision', {}).get('amount', 8); try: return f"{amount_decimal:.{prec}f}"; except Exception: return str(amount_decimal)
def format_order_id(order_id: Optional[str]) -> str: return order_id[-8:] if order_id and len(order_id) > 8 else (order_id or "N/A")
def send_sms_alert(message: str, config: Optional[Config] = None) -> None: logger.warning(f"{Back.YELLOW}{Fore.BLACK}[SMS Alert Placeholder]{Style.RESET_ALL} >> {message}")
def _get_v5_category(market: Dict[str, Any]) -> Optional[str]:
    if not market: return None
    if market.get('spot', False): return Category.SPOT.value; if market.get('option', False): return Category.OPTION.value; if market.get('linear', False): return Category.LINEAR.value; if market.get('inverse', False): return Category.INVERSE.value
    market_type = market.get('type'); symbol = market.get('symbol', 'N/A')
    if market_type == 'spot': return Category.SPOT.value
    if market_type == 'option': return Category.OPTION.value if market.get('settle', '').upper() == 'USDC' else None
    if market_type in ['swap', 'future']:
        settle=market.get('settle','').upper(); base=market.get('base','').upper(); quote=market.get('quote','').upper(); info=market.get('info',{}); contract_type=str(info.get('contractType','')).lower()
        if contract_type == 'linear': return Category.LINEAR.value; if contract_type == 'inverse': return Category.INVERSE.value
        if settle in ['USDT', 'USDC'] or info.get('settleCoin') in ['USDT', 'USDC']: return Category.LINEAR.value
        if settle == base and settle: return Category.INVERSE.value; if 'USD' in quote: return Category.LINEAR.value
        logger.warning(f"[_get_v5_category] Cannot reliably determine cat for {symbol}."); return None
    logger.warning(f"[_get_v5_category] Unknown market type '{market_type}' for {symbol}."); return None
T = TypeVar('T'); FuncT = Callable[..., Coroutine[Any, Any, T]]
def retry_api_call(max_retries: int = 3, initial_delay: float = 1.0, backoff_factor: float = 2.0, jitter: float = 0.1, retry_on_exceptions: Tuple[type[Exception], ...] = (NetworkError, RateLimitExceeded, ExchangeNotAvailable, RequestTimeout)):
    """ Async retry decorator with exponential backoff and jitter. """
    def decorator(func: FuncT) -> FuncT:
        async def async_wrapper(*args, **kwargs):
            retries = kwargs.pop('retries', max_retries); current_delay = initial_delay; last_exception: Optional[Exception] = None
            for attempt in range(retries + 1):
                try: return await func(*args, **kwargs)
                except retry_on_exceptions as e:
                    last_exception = e
                    if attempt == retries: logger.error(f"{Fore.RED}[{func.__name__}] Max retries ({retries}) reached. Last error: {type(e).__name__}: {e}{Style.RESET_ALL}"); raise
                    else: wait_time = current_delay + (current_delay * random.uniform(-jitter, jitter)); logger.warning(f"{Fore.YELLOW}[{func.__name__}] Attempt {attempt+1}/{retries+1} fail: {type(e).__name__}. Retry in {wait_time:.2f}s...{Style.RESET_ALL}"); await asyncio.sleep(wait_time); current_delay *= backoff_factor
                except Exception as e: logger.error(f"{Fore.RED}[{func.__name__}] Unhandled exception attempt {attempt+1}: {type(e).__name__}: {e}{Style.RESET_ALL}", exc_info=True); raise
            if last_exception: raise last_exception; return None # Should not be reached if retries > 0
        async_wrapper.__name__ = func.__name__; async_wrapper.__doc__ = func.__doc__; return async_wrapper
    return decorator

# --- Exchange Initialization & Configuration ---
@retry_api_call(max_retries=2, initial_delay=3.0, retry_on_exceptions=(NetworkError, ExchangeNotAvailable))
async def initialize_bybit(config: Config) -> Optional[ccxt.bybit]:
    """ Initializes the Bybit CCXT exchange instance for V5 API. """
    func_name="initialize_bybit"; logger.info(f"{Fore.BLUE}[{func_name}] Initializing Bybit V5 ({'Testnet' if config['TESTNET_MODE'] else 'Mainnet'})...{Style.RESET_ALL}"); exchange:Optional[ccxt.bybit]=None
    try:
        if not config.get('API_KEY') or not config.get('API_SECRET'): logger.warning(f"{Fore.YELLOW}[{func_name}] API Keys missing. Public mode.{Style.RESET_ALL}")
        exchange_options={'apiKey': config.get('API_KEY'), 'secret': config.get('API_SECRET'), 'enableRateLimit': True, 'options': {'defaultType': config['EXPECTED_MARKET_TYPE'], 'adjustForTimeDifference': True, 'recvWindow': config['DEFAULT_RECV_WINDOW'], 'brokerId': 'PB_PyrmethusV3.2'}}
        exchange=ccxt.bybit(exchange_options);
        if config['TESTNET_MODE']: exchange.set_sandbox_mode(True); logger.info(f"[{func_name}] Sandbox enabled (API: {exchange.urls['api']}).")
        else: logger.info(f"[{func_name}] Mainnet enabled (API: {exchange.urls['api']}).")
        await market_cache.load_markets(exchange, reload=True)
        if not market_cache.get_market(config['SYMBOL']): logger.critical(f"{Back.RED}[{func_name}] Failed load market '{config['SYMBOL']}'.{Style.RESET_ALL}"); if exchange: await exchange.close(); return None
        if config.get('API_KEY') and config.get('API_SECRET'):
            logger.info(f"[{func_name}] Performing auth check..."); try: await exchange.fetch_balance(params={'accountType': 'UNIFIED'}); logger.info(f"[{func_name}] Auth check OK.")
            except AuthenticationError as auth_err: logger.critical(f"{Back.RED}[{func_name}] Auth FAILED check: {auth_err}.{Style.RESET_ALL}"); send_sms_alert(f"[BybitHelper] CRITICAL: Auth failed!", config); if exchange: await exchange.close(); return None
            except ExchangeError as bal_err: logger.warning(f"{Fore.YELLOW}[{func_name}] Auth check warning (balance): {bal_err}.{Style.RESET_ALL}")
        else: logger.info(f"[{func_name}] Skip auth check (no keys).")
        default_symbol=config['SYMBOL']; category=market_cache.get_category(default_symbol)
        if category in [Category.LINEAR, Category.INVERSE] and config.get('API_KEY'):
            logger.info(f"[{func_name}] Configuring default margin/leverage for {default_symbol}..."); try:
                if config['DEFAULT_MARGIN_MODE'] == 'isolated': initial_leverage=10; logger.info(f"[{func_name}] Set isolated via leverage {initial_leverage}x."); await set_leverage(exchange, default_symbol, initial_leverage, config)
                else: logger.info(f"[{func_name}] Cross margin selected (account level).")
            except Exception as e: logger.warning(f"{Fore.YELLOW}[{func_name}] Cannot pre-set margin/leverage: {type(e).__name__}.{Style.RESET_ALL}")
        elif not config.get('API_KEY'): logger.info(f"[{func_name}] Skip margin setup (no keys).")
        logger.success(f"{Fore.GREEN}[{func_name}] Bybit V5 exchange initialized successfully.{Style.RESET_ALL}"); return exchange
    except AuthenticationError as e: logger.critical(f"{Back.RED}[{func_name}] Init Auth Fail: {e}.{Style.RESET_ALL}"); send_sms_alert(f"[BybitHelper] CRITICAL: Auth fail!", config)
    except (NetworkError, ExchangeNotAvailable) as e: logger.critical(f"{Back.RED}[{func_name}] Init Network Fail: {e}.{Style.RESET_ALL}")
    except ExchangeError as e: logger.critical(f"{Back.RED}[{func_name}] Init Exchange Fail: {e}{Style.RESET_ALL}", exc_info=True); send_sms_alert(f"[BybitHelper] CRITICAL: Init ExchErr: {type(e).__name__}", config)
    except Exception as e: logger.critical(f"{Back.RED}[{func_name}] Init Unexpected Fail: {e}{Style.RESET_ALL}", exc_info=True); send_sms_alert(f"[BybitHelper] CRITICAL: Init Unexp Err: {type(e).__name__}", config)
    if exchange: try: logger.info(f"[{func_name}] Closing partially init exchange."); await exchange.close(); except Exception as cl_e: logger.error(f"[{func_name}] Error closing: {cl_e}")
    return None

# --- Account Functions ---
@retry_api_call()
async def set_leverage(exchange: ccxt.bybit, symbol: str, leverage: int, config: Config) -> bool:
    func_name="set_leverage"; log_prefix=f"[{func_name} ({symbol}->{leverage}x)]"
    if leverage<=0: logger.error(f"{Fore.RED}{log_prefix}: Leverage must be > 0.{Style.RESET_ALL}"); return False
    category=market_cache.get_category(symbol)
    if not category or category not in [Category.LINEAR,Category.INVERSE]: logger.error(f"{Fore.RED}{log_prefix}: Invalid category {category}.{Style.RESET_ALL}"); return False
    market=market_cache.get_market(symbol)
    if not market: logger.error(f"{Fore.RED}{log_prefix}: Market data not found.{Style.RESET_ALL}"); return False
    try:
        limits_leverage=market.get('limits',{}).get('leverage',{}); max_lev=safe_decimal_conversion(limits_leverage.get('max'),Decimal('100')); min_lev=safe_decimal_conversion(limits_leverage.get('min'),Decimal('1'))
        if max_lev is None or min_lev is None: raise ValueError("Limits missing.")
        if not (min_lev <= leverage <= max_lev): logger.error(f"{Fore.RED}{log_prefix}: Leverage {leverage}x outside range [{min_lev}x-{max_lev}x].{Style.RESET_ALL}"); return False
    except Exception as e: logger.warning(f"{Fore.YELLOW}{log_prefix}: Cannot parse lev limits: {e}.{Style.RESET_ALL}")
    params={'category':category.value, 'buyLeverage':str(leverage), 'sellLeverage':str(leverage)}; logger.info(f"{Fore.CYAN}{log_prefix}: Sending request...{Style.RESET_ALL}")
    try: response=await exchange.set_leverage(leverage, symbol, params=params); logger.debug(f"{log_prefix}: Raw response: {response}"); logger.success(f"{Fore.GREEN}{log_prefix}: Set OK.{Style.RESET_ALL}"); return True
    except ExchangeError as e: err_str=str(e).lower(); if "leverage not modified" in err_str or "110043" in str(e): logger.info(f"{Fore.YELLOW}{log_prefix}: Already set.{Style.RESET_ALL}"); return True; elif "110021" in str(e): logger.error(f"{Fore.RED}{log_prefix}: Failed: {e}. Hedge mode issue?{Style.RESET_ALL}"); return False; else: logger.error(f"{Fore.RED}{log_prefix}: ExchangeError: {e}{Style.RESET_ALL}", exc_info=True); return False
    except NetworkError as e: logger.warning(f"{Fore.YELLOW}{log_prefix}: Network error: {e}. Retry handled.{Style.RESET_ALL}"); raise
    except Exception as e: logger.error(f"{Fore.RED}{log_prefix}: Unexpected Error: {e}{Style.RESET_ALL}", exc_info=True); return False

@retry_api_call()
async def fetch_usdt_balance(exchange: ccxt.bybit, config: Config) -> Tuple[Optional[Decimal], Optional[Decimal]]:
    func_name="fetch_usdt_balance"; log_prefix=f"[{func_name}]"; usdt_symbol=config['USDT_SYMBOL']; logger.debug(f"{log_prefix}: Fetching UNIFIED balance...")
    try:
        bal_data=await exchange.fetch_balance(params={'accountType':'UNIFIED'}); equity:Optional[Decimal]=None; available:Optional[Decimal]=None; info_list=bal_data.get('info',{}).get('result',{}).get('list',[])
        if info_list:
            uni_info=next((a for a in info_list if a.get('accountType')=='UNIFIED'), None)
            if uni_info:
                equity=safe_decimal_conversion(uni_info.get('totalEquity')); logger.debug(f"{log_prefix}: Equity(info): {equity}")
                coin_list=uni_info.get('coin',[]); usdt_info=next((c for c in coin_list if c.get('coin')==usdt_symbol), None)
                if usdt_info: avail_str=usdt_info.get('availableToWithdraw') or usdt_info.get('availableBalance') or usdt_info.get('walletBalance'); available=safe_decimal_conversion(avail_str); logger.debug(f"{log_prefix}: Available(info): {available}")
                else: logger.warning(f"{log_prefix}: {usdt_symbol} not found in UNIFIED coin list.")
            else: logger.warning(f"{log_prefix}: UNIFIED not found in info list.")
        else: logger.warning(f"{log_prefix}: info.result.list empty.")
        if equity is None and usdt_symbol in bal_data: equity=safe_decimal_conversion(bal_data[usdt_symbol].get('total')); logger.debug(f"{log_prefix}: Equity(top): {equity}")
        if available is None and usdt_symbol in bal_data: available=safe_decimal_conversion(bal_data[usdt_symbol].get('free')); logger.debug(f"{log_prefix}: Available(top): {available}")
        final_equity=max(Decimal("0"), equity or Decimal("0")); final_available=max(Decimal("0"), available or Decimal("0"))
        logger.info(f"{Fore.GREEN}{log_prefix}: Success - Equity:{final_equity:.4f}, Avail:{final_available:.4f}{Style.RESET_ALL}"); return final_equity, final_available
    except AuthenticationError as e: logger.error(f"{Fore.RED}{log_prefix}: Auth error: {e}{Style.RESET_ALL}"); return None,None
    except (NetworkError, ExchangeNotAvailable) as e: logger.warning(f"{Fore.YELLOW}{log_prefix}: Network/Avail error: {e}. Retry handled.{Style.RESET_ALL}"); raise
    except ExchangeError as e: logger.error(f"{Fore.RED}{log_prefix}: Exchange error: {e}{Style.RESET_ALL}", exc_info=True); return None,None
    except Exception as e: logger.error(f"{Fore.RED}{log_prefix}: Unexpected error: {e}{Style.RESET_ALL}", exc_info=True); return None,None

# --- Market Data Functions ---
@retry_api_call()
async def fetch_ohlcv_paginated(exchange: ccxt.bybit, symbol: str, timeframe: str, since: Optional[int] = None, limit: Optional[int] = None, config: Optional[Config] = None) -> Optional[Union[pd.DataFrame, List[list]]]:
    """ Fetches OHLCV data, handling pagination. Returns DataFrame if pandas is installed, else list. """
    func_name="fetch_ohlcv_paginated"; log_prefix=f"[{func_name} ({symbol},{timeframe})]"; market=market_cache.get_market(symbol)
    if not market: logger.error(f"{Fore.RED}{log_prefix}: Market '{symbol}' not found.{Style.RESET_ALL}"); return None
    category=market_cache.get_category(symbol)
    if not category: logger.error(f"{Fore.RED}{log_prefix}: Category not found for '{symbol}'.{Style.RESET_ALL}"); return None
    try: timeframe_ms=exchange.parse_timeframe(timeframe)*1000; except Exception: logger.error(f"{log_prefix}: Invalid timeframe '{timeframe}'."); return None
    fetch_limit=min(limit,1000) if limit is not None else 1000; all_candles=[]; current_since=since; max_loops=200; loops=0; retries=config['RETRY_COUNT'] if config else 3; delay_secs=config['RETRY_DELAY_SECONDS'] if config else 1.0
    logger.info(f"{Fore.BLUE}{log_prefix}: Fetching, Limit/call:{fetch_limit}...{Style.RESET_ALL}"); params={'category':category.value}
    try:
        while loops<max_loops:
            loops+=1; logger.debug(f"{log_prefix}: Loop {loops}, Fetch since={current_since}...")
            @retry_api_call(max_retries=retries, initial_delay=delay_secs)
            async def fetch_candles_with_retry(since_ts): return await exchange.fetch_ohlcv(symbol,timeframe,since=since_ts,limit=fetch_limit,params=params)
            candles=await fetch_candles_with_retry(current_since)
            if not candles: logger.info(f"{log_prefix}: No more candles. Fetch complete."); break
            if all_candles and candles[0][0]<=all_candles[-1][0]: candles=[c for c in candles if c[0]>all_candles[-1][0]]; if not candles: logger.debug(f"{log_prefix}: All overlap."); break
            all_candles.extend(candles); last_ts=candles[-1][0]; logger.info(f"{log_prefix}: Fetched {len(candles)} up to {pd.to_datetime(last_ts, unit='ms') if pd else last_ts}")
            current_since=last_ts+1; await asyncio.sleep(exchange.rateLimit/1000 if exchange.enableRateLimit else 0.2)
            if len(candles)<fetch_limit: logger.info(f"{log_prefix}: Fetched less than limit. End."); break
        logger.info(f"{log_prefix}: Total raw candles: {len(all_candles)}")
        if not all_candles: logger.warning(f"{log_prefix}: No candles found."); return pd.DataFrame() if pd else []
        if pd:
            df=pd.DataFrame(all_candles, columns=['timestamp','open','high','low','close','volume']); df['datetime']=pd.to_datetime(df['timestamp'],unit='ms'); df.set_index('datetime',inplace=True)
            for col in ['open','high','low','close','volume']: try: df[col]=pd.to_numeric(df[col], errors='coerce'); except Exception as conv_err: logger.warning(f"{log_prefix}: Error converting '{col}': {conv_err}.")
            initial_len=len(df); df=df[~df.index.duplicated(keep='first')]; if len(df)<initial_len: logger.debug(f"{log_prefix}: Removed {initial_len - len(df)} duplicates.")
            df.sort_index(inplace=True); logger.success(f"{Fore.GREEN}{log_prefix}: Processed {len(df)} unique candles (DataFrame).{Style.RESET_ALL}"); return df
        else: logger.success(f"{Fore.GREEN}{log_prefix}: Processed {len(all_candles)} unique candles (List).{Style.RESET_ALL}"); return all_candles # Return list if no pandas
    except Exception as e: logger.error(f"{Fore.RED}{log_prefix}: Error fetching OHLCV: {e}{Style.RESET_ALL}", exc_info=True)
    if all_candles and pd: # Try process partial data if pandas available
        logger.warning(f"{log_prefix}: Returning partial DataFrame ({len(all_candles)} candles).")
        try: df=pd.DataFrame(all_candles, columns=['timestamp','open','high','low','close','volume']); df['datetime']=pd.to_datetime(df['timestamp'],unit='ms'); df.set_index('datetime',inplace=True); for col in ['open','high','low','close','volume']: df[col]=pd.to_numeric(df[col], errors='coerce'); df=df[~df.index.duplicated(keep='first')]; df.sort_index(inplace=True); return df
        except Exception as final_proc_err: logger.error(f"{Fore.RED}{log_prefix}: Error processing partial data: {final_proc_err}{Style.RESET_ALL}"); return None
    elif all_candles: logger.warning(f"{log_prefix}: Returning partial List ({len(all_candles)} candles)."); return all_candles
    return None

@retry_api_call()
async def fetch_ticker_validated(exchange: ccxt.bybit, symbol: str, config: Config) -> Optional[Dict]:
    """ Fetches ticker data, validates timestamp and essential keys. """
    func_name = "fetch_ticker_validated"; log_prefix = f"[{func_name} ({symbol})]"; logger.debug(f"{log_prefix}: Fetching...")
    category=market_cache.get_category(symbol)
    if not category: logger.error(f"{Fore.RED}{log_prefix}: Cannot determine category.{Style.RESET_ALL}"); return None
    params={'category':category.value}
    try:
        ticker=await exchange.fetch_ticker(symbol, params=params)
        required_keys=['symbol','last','bid','ask']; missing_keys=[k for k in required_keys if k not in ticker or ticker[k] is None]
        if missing_keys: logger.error(f"{Fore.RED}{log_prefix}: Ticker missing keys: {missing_keys}. Data: {ticker}{Style.RESET_ALL}"); return None
        common_keys=['timestamp','datetime','high','low','change','percentage','average','quoteVolume']; missing_common=[k for k in common_keys if k not in ticker or ticker[k] is None]
        if missing_common: logger.warning(f"{Fore.YELLOW}{log_prefix}: Ticker missing common keys: {missing_common}.{Style.RESET_ALL}")
        ticker_time_ms=ticker.get('timestamp'); current_time_ms=int(time.time()*1000); max_age_s=90; min_age_s=-10; max_diff_ms=max_age_s*1000; min_diff_ms=min_age_s*1000
        valid_ts=False; log_ts_msg="Timestamp: N/A"
        if ticker_time_ms is None: log_ts_msg=f"{Fore.YELLOW}Timestamp: Missing{Style.RESET_ALL}"
        elif not isinstance(ticker_time_ms, int): log_ts_msg=f"{Fore.YELLOW}Timestamp: Invalid Type ({type(ticker_time_ms).__name__}){Style.RESET_ALL}"
        else:
            time_diff_ms=current_time_ms-ticker_time_ms; age_s=time_diff_ms/1000.0; dt_str=ticker.get('datetime', f"ts({ticker_time_ms})")
            if time_diff_ms>max_diff_ms or time_diff_ms<min_diff_ms: logger.warning(f"{Fore.YELLOW}{log_prefix}: Ticker ts ({dt_str}) stale/invalid. Age: {age_s:.1f}s (Allow:{min_age_s:.1f}s-{max_age_s:.1f}s).{Style.RESET_ALL}"); log_ts_msg=f"{Fore.YELLOW}Timestamp: Stale/Invalid (Age: {age_s:.1f}s){Style.RESET_ALL}"
            else: valid_ts=True; log_ts_msg=f"Timestamp: OK (Age: {age_s:.1f}s)"
        logger.info(f"{Fore.GREEN}{log_prefix}: Fetched: Last={ticker.get('last')}, Bid={ticker.get('bid')}, Ask={ticker.get('ask')} | {log_ts_msg}{Style.RESET_ALL}"); return ticker
    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e: logger.warning(f"{Fore.YELLOW}{log_prefix}: API error: {type(e).__name__}. Retry handled.{Style.RESET_ALL}"); raise
    except AuthenticationError as e: logger.error(f"{Fore.RED}{log_prefix}: Auth error? {e}{Style.RESET_ALL}"); return None
    except ExchangeError as e: logger.error(f"{Fore.RED}{log_prefix}: Exchange error: {e}{Style.RESET_ALL}", exc_info=True); return None
    except Exception as e: logger.error(f"{Fore.RED}{log_prefix}: Unexpected error: {e}{Style.RESET_ALL}", exc_info=True); return None

@retry_api_call()
async def fetch_funding_rate(exchange: ccxt.bybit, symbol: str, config: Config, fetch_next: bool = False) -> Optional[Decimal]:
    """ Fetches the current or predicted next funding rate for a perpetual swap. """
    func_name="fetch_funding_rate"; rate_type="Next" if fetch_next else "Current"; log_prefix=f"[{func_name} ({symbol}-{rate_type})]"; market=market_cache.get_market(symbol)
    if not market or not market.get('swap', False): logger.error(f"{Fore.RED}{log_prefix}: Not a swap: '{symbol}'.{Style.RESET_ALL}"); return None
    category=market_cache.get_category(symbol)
    if category not in [Category.LINEAR, Category.INVERSE]: logger.error(f"{Fore.RED}{log_prefix}: Invalid category: {category}.{Style.RESET_ALL}"); return None
    params={'category':category.value, 'symbol':symbol}; logger.debug(f"{log_prefix}: Fetching with params: {params}")
    try:
        if fetch_next:
            logger.debug(f"{log_prefix}: Fetch ticker for next rate..."); ticker=await exchange.fetch_ticker(symbol, params=params)
            rate_str=ticker.get('info',{}).get('fundingRate'); time_ms=ticker.get('info',{}).get('nextFundingTime')
            if rate_str is not None: rate_dec=safe_decimal_conversion(rate_str); dt_str=pd.to_datetime(int(time_ms),unit='ms',errors='coerce') if time_ms and pd else "N/A"; logger.info(f"{Fore.GREEN}{log_prefix}: Success - Next Rate: {rate_dec:.8f} (At: {dt_str}){Style.RESET_ALL}"); return rate_dec
            else: logger.error(f"{Fore.RED}{log_prefix}: Cannot find 'fundingRate' in ticker info.{Style.RESET_ALL}"); return None
        else:
            logger.debug(f"{log_prefix}: Fetch history(limit=1) for last settled..."); history=await exchange.fetch_funding_history(symbol=symbol, limit=1, params=params)
            if history: last_int=history[0]; rate_str=last_int.get('info',{}).get('fundingRate'); dt_str=last_int.get('datetime')
            if rate_str is not None: rate_dec=safe_decimal_conversion(rate_str); logger.info(f"{Fore.GREEN}{log_prefix}: Success - Last Settled: {rate_dec:.8f} (Time: {dt_str}){Style.RESET_ALL}"); return rate_dec
            else: logger.error(f"{Fore.RED}{log_prefix}: Cannot find 'fundingRate' in history.{Style.RESET_ALL}"); return None
            else: logger.error(f"{Fore.RED}{log_prefix}: Failed fetch funding history.{Style.RESET_ALL}"); return None
    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e: logger.warning(f"{Fore.YELLOW}{log_prefix}: API error: {type(e).__name__}. Retry handled.{Style.RESET_ALL}"); raise
    except ExchangeError as e: logger.error(f"{Fore.RED}{log_prefix}: Exchange error: {e}{Style.RESET_ALL}", exc_info=True); return None
    except Exception as e: logger.error(f"{Fore.RED}{log_prefix}: Unexpected error: {e}{Style.RESET_ALL}", exc_info=True); return None

@retry_api_call()
async def fetch_l2_order_book_validated(exchange: ccxt.bybit, symbol: str, limit: int, config: Config) -> Optional[Dict]:
    """ Fetches L2 order book with basic validation. """
    func_name="fetch_l2_order_book"; log_prefix=f"[{func_name} ({symbol},l={limit})]"; logger.debug(f"{log_prefix}: Fetching...")
    category=market_cache.get_category(symbol)
    if not category: logger.error(f"{Fore.RED}{log_prefix}: No category.{Style.RESET_ALL}"); return None
    params={'category':category.value}
    try:
        ob=await exchange.fetch_l2_order_book(symbol, limit=limit, params=params)
        if not ob: logger.error(f"{Fore.RED}{log_prefix}: Empty OB response.{Style.RESET_ALL}"); return None
        if not ob.get('bids') or not ob.get('asks'): logger.warning(f"{Fore.YELLOW}{log_prefix}: Empty bids/asks.{Style.RESET_ALL}")
        if not ob.get('timestamp') or not ob.get('datetime'): logger.warning(f"{Fore.YELLOW}{log_prefix}: Missing timestamp.{Style.RESET_ALL}")
        logger.info(f"{Fore.GREEN}{log_prefix}: Fetched OK at {ob.get('datetime')}. Top Bid:{ob['bids'][0][0] if ob.get('bids') else 'N/A'}, Ask:{ob['asks'][0][0] if ob.get('asks') else 'N/A'}{Style.RESET_ALL}"); return ob
    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e: logger.warning(f"{Fore.YELLOW}{log_prefix}: API error: {type(e).__name__}. Retry handled.{Style.RESET_ALL}"); raise
    except ExchangeError as e: logger.error(f"{Fore.RED}{log_prefix}: Exchange error: {e}{Style.RESET_ALL}", exc_info=True); return None
    except Exception as e: logger.error(f"{Fore.RED}{log_prefix}: Unexpected error: {e}{Style.RESET_ALL}", exc_info=True); return None

@retry_api_call()
async def fetch_recent_trades(exchange: ccxt.bybit, symbol: str, limit: int, config: Config) -> List[Dict]:
    """ Fetches recent public market trades. """
    func_name="fetch_recent_trades"; log_prefix=f"[{func_name} ({symbol},l={limit})]"; logger.debug(f"{log_prefix}: Fetching...")
    category=market_cache.get_category(symbol)
    if not category: logger.error(f"{Fore.RED}{log_prefix}: No category.{Style.RESET_ALL}"); return []
    eff_limit=limit; if category==Category.SPOT and limit>60: logger.warning(f"{log_prefix}: Limit cap 60 SPOT."); eff_limit=60; elif category in [Category.LINEAR,Category.INVERSE] and limit>1000: logger.warning(f"{log_prefix}: Limit cap 1000 LINEAR/INVERSE."); eff_limit=1000
    params={'category':category.value, 'limit':eff_limit}
    try: trades=await exchange.fetch_trades(symbol, limit=eff_limit, params=params); logger.info(f"{Fore.GREEN}{log_prefix}: Fetched {len(trades)} trades.{Style.RESET_ALL}"); return trades
    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e: logger.warning(f"{Fore.YELLOW}{log_prefix}: API error: {type(e).__name__}. Retry handled.{Style.RESET_ALL}"); raise
    except ExchangeError as e: logger.error(f"{Fore.RED}{log_prefix}: Exchange error: {e}{Style.RESET_ALL}", exc_info=True); return []
    except Exception as e: logger.error(f"{Fore.RED}{log_prefix}: Unexpected error: {e}{Style.RESET_ALL}", exc_info=True); return []

# --- Order Management Functions ---
@retry_api_call(max_retries=1, initial_delay=0)
async def place_market_order_slippage_check(exchange: ccxt.bybit, symbol: str, side: Side, amount: Decimal, config: Config, max_slippage_pct: Optional[Decimal]=None, is_reduce_only: bool=False, time_in_force: TimeInForce=TimeInForce.IOC, client_order_id: Optional[str]=None, position_idx: Optional[PositionIdx]=None) -> Optional[Dict]:
    """ Places a market order with pre-execution spread check. """
    func_name="place_market_order"; action="Close" if is_reduce_only else "Open"; log_prefix=f"[{func_name} ({symbol},{side.value},{amount},{action})]"
    if amount <= config['POSITION_QTY_EPSILON']: logger.error(f"{Fore.RED}{log_prefix}: Invalid amount {amount}.{Style.RESET_ALL}"); return None
    category=market_cache.get_category(symbol); market=market_cache.get_market(symbol)
    if not category or not market: logger.error(f"{Fore.RED}{log_prefix}: Invalid category/market.{Style.RESET_ALL}"); return None
    fmt_amt=format_amount(exchange, symbol, amount); if fmt_amt is None: logger.error(f"{Fore.RED}{log_prefix}: Format amount fail.{Style.RESET_ALL}"); return None
    fmt_amt_float=float(fmt_amt); eff_slip=max_slippage_pct if max_slippage_pct is not None else config['DEFAULT_SLIPPAGE_PCT']
    logger.info(f"{Fore.BLUE}{log_prefix}: Placing. Amount:{fmt_amt}, TIF:{time_in_force.value}, Spread Check:{eff_slip:.4%}{Style.RESET_ALL}")
    ob=await analyze_order_book(exchange, symbol, config['SHALLOW_OB_FETCH_DEPTH'], config); bid,ask=ob.get('best_bid'),ob.get('best_ask')
    if bid and ask and bid>0: spread=(ask-bid)/bid; logger.debug(f"{log_prefix}: Spread:{spread:.4%}"); if spread>eff_slip: logger.error(f"{Back.RED}{log_prefix}: ABORTED Spread {spread:.4%} > Max {eff_slip:.4%}.{Style.RESET_ALL}"); return None
    elif bid is None or ask is None: logger.warning(f"{Fore.YELLOW}{log_prefix}: Cannot get OB for spread check.{Style.RESET_ALL}")
    params={'category':category.value, 'reduceOnly':is_reduce_only, 'timeInForce':time_in_force.value}
    if client_order_id: clean_cid=''.join(filter(lambda c: c.isalnum() or c in ['-','_'], client_order_id))[:36]; params['clientOrderId']=clean_cid
    if position_idx is not None: params['positionIdx']=position_idx.value
    try:
        logger.info(f"{log_prefix}: Sending create_market_order..."); order=await exchange.create_market_order(symbol, side.value, fmt_amt_float, params=params)
        oid,status,filled,avg=order.get('id'),order.get('status','?'),safe_decimal_conversion(order.get('filled','0')),safe_decimal_conversion(order.get('average'))
        color=Fore.GREEN if status in ['closed','filled'] else Fore.YELLOW
        logger.success(f"{color}{log_prefix}: SUCCESS - ID:...{format_order_id(oid)}, Status:{status}, Filled:{format_amount(exchange,symbol,filled)}@Avg:{format_price(exchange,symbol,avg)}{Style.RESET_ALL}")
        if time_in_force in [TimeInForce.IOC, TimeInForce.FOK] and filled<amount*(Decimal(1)-config['POSITION_QTY_EPSILON']): logger.warning(f"{Fore.YELLOW}{log_prefix}: Order {oid} ({time_in_force.value}) partially filled ({filled}/{amount}).{Style.RESET_ALL}")
        return order
    except InsufficientFunds as e: logger.error(f"{Back.RED}{log_prefix}: FAILED Insufficient Funds: {e}{Style.RESET_ALL}"); return None
    except InvalidOrder as e: logger.error(f"{Back.RED}{log_prefix}: FAILED Invalid Params: {e}{Style.RESET_ALL}"); return None
    except ExchangeError as e: logger.error(f"{Back.RED}{log_prefix}: FAILED Exchange Error: {e}{Style.RESET_ALL}", exc_info=True); return None
    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e: logger.error(f"{Back.RED}{log_prefix}: FAILED API Comm Error: {type(e).__name__}{Style.RESET_ALL}"); return None
    except Exception as e: logger.error(f"{Back.RED}{log_prefix}: FAILED Unexpected Error: {e}{Style.RESET_ALL}", exc_info=True); return None

@retry_api_call(max_retries=1)
async def place_limit_order_tif(exchange: ccxt.bybit, symbol: str, side: Side, amount: Decimal, price: Decimal, config: Config, time_in_force: TimeInForce=TimeInForce.GTC, is_reduce_only: bool=False, is_post_only: bool=False, client_order_id: Optional[str]=None, position_idx: Optional[PositionIdx]=None) -> Optional[Dict]:
    """ Places a limit order with TIF and optional post-only. """
    func_name="place_limit_order"; action="Close" if is_reduce_only else "Open"; tif_str=f"{time_in_force.value}{' PO' if is_post_only else ''}"; log_prefix=f"[{func_name} ({symbol},{side.value},{amount}@{price},{action},TIF:{tif_str})]"
    if amount<=config['POSITION_QTY_EPSILON'] or price<=0: logger.error(f"{Fore.RED}{log_prefix}: Invalid amount/price.{Style.RESET_ALL}"); return None
    if is_post_only: time_in_force=TimeInForce.POST_ONLY
    category=market_cache.get_category(symbol); market=market_cache.get_market(symbol)
    if not category or not market: logger.error(f"{Fore.RED}{log_prefix}: Invalid category/market.{Style.RESET_ALL}"); return None
    fmt_amt,fmt_px=format_amount(exchange, symbol, amount),format_price(exchange, symbol, price); if fmt_amt is None or fmt_px is None: logger.error(f"{Fore.RED}{log_prefix}: Format fail.{Style.RESET_ALL}"); return None
    fmt_amt_f,fmt_px_f=float(fmt_amt),float(fmt_px); logger.info(f"{Fore.BLUE}{log_prefix}: Placing...{Style.RESET_ALL}")
    params={'category':category.value, 'reduceOnly':is_reduce_only, 'timeInForce':time_in_force.value}
    if client_order_id: clean_cid=''.join(filter(lambda c: c.isalnum() or c in ['-','_'], client_order_id))[:36]; params['clientOrderId']=clean_cid
    if position_idx is not None: params['positionIdx']=position_idx.value
    try:
        logger.info(f"{log_prefix}: Sending create_limit_order..."); order=await exchange.create_limit_order(symbol,side.value,fmt_amt_f,fmt_px_f,params=params)
        oid,status,px=order.get('id'),order.get('status','?'),safe_decimal_conversion(order.get('price'))
        color=Fore.GREEN if status=='open' else Fore.YELLOW if status in ['triggered','new'] else Fore.RED
        logger.success(f"{color}{log_prefix}: SUCCESS - ID:...{format_order_id(oid)}, Status:{status}, Px:{format_price(exchange,symbol,px)}, Amt:{format_amount(exchange,symbol,order.get('amount'))}{Style.RESET_ALL}"); return order
    except OrderImmediatelyFillable as e: logger.warning(f"{Fore.YELLOW}{log_prefix}: PostOnly FAILED (immediate match): {e}{Style.RESET_ALL}"); return None # Expected failure for PO
    except InsufficientFunds as e: logger.error(f"{Back.RED}{log_prefix}: FAILED Insufficient Funds: {e}{Style.RESET_ALL}"); return None
    except InvalidOrder as e: logger.error(f"{Back.RED}{log_prefix}: FAILED Invalid Order/Rejected: {e}{Style.RESET_ALL}"); return None
    except ExchangeError as e: logger.error(f"{Back.RED}{log_prefix}: FAILED Exchange Error: {e}{Style.RESET_ALL}", exc_info=True); return None
    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e: logger.error(f"{Back.RED}{log_prefix}: FAILED API Comm Error: {type(e).__name__}{Style.RESET_ALL}"); return None
    except Exception as e: logger.error(f"{Back.RED}{log_prefix}: FAILED Unexpected Error: {e}{Style.RESET_ALL}", exc_info=True); return None

@retry_api_call(max_retries=1)
async def place_batch_orders(exchange: ccxt.bybit, orders: List[Dict[str, Any]], config: Config, category_override: Optional[Category]=None) -> Tuple[List[Optional[Dict]], List[Optional[Dict]]]:
    """ Places multiple orders in a single batch request (V5). """
    func_name="place_batch_orders"; num=len(orders); log_prefix=f"[{func_name} ({num} orders)]"; logger.info(f"{Fore.BLUE}{log_prefix}: Preparing...{Style.RESET_ALL}")
    if not orders: logger.warning(f"{Fore.YELLOW}{log_prefix}: No orders provided.{Style.RESET_ALL}"); return [],[]
    limit=10; if num>limit: logger.error(f"{Fore.RED}{log_prefix}: Batch size {num}>{limit}.{Style.RESET_ALL}"); return [None]*num, [{'code':-100, 'msg':f'Batch size limit {limit}'}]*num
    reqs:List[Optional[Dict]]=[None]*num; cat_use:Optional[str]=category_override.value if category_override else None; init_errs:List[Optional[Dict]]=[None]*num; valid_count=0
    for i, o_req in enumerate(orders):
        err:Optional[str]=None; sym=o_req.get('symbol'); side=o_req.get('side'); o_type=o_req.get('type'); amt=o_req.get('amount')
        if not all([sym,side,o_type,amt]): err="Missing required fields."
        elif safe_decimal_conversion(amt,Decimal(-1))<=config['POSITION_QTY_EPSILON']: err="Amount not positive."
        if err: logger.error(f"{Fore.RED}{log_prefix}: Order #{i+1} Input Err: {err}{Style.RESET_ALL}"); init_errs[i]={'code':-101,'msg':err}; continue
        cat_enum=market_cache.get_category(sym)
        if not cat_enum: err=f"No category for '{sym}'."; logger.error(f"{Fore.RED}{log_prefix}: Order #{i+1} Err: {err}{Style.RESET_ALL}"); init_errs[i]={'code':-102,'msg':err}; continue
        cat_str=cat_enum.value
        if category_override:
            if cat_str!=category_override.value: err=f"Cat mismatch:{cat_str}!={category_override.value}."; logger.error(f"{Fore.RED}{log_prefix}: Order #{i+1} Err:{err}{Style.RESET_ALL}"); init_errs[i]={'code':-103,'msg':err}; continue
            eff_cat=category_override.value
        else:
            if cat_use is None: cat_use=cat_str
            elif cat_str!=cat_use: err=f"Cat mismatch:{cat_str}!={cat_use}."; logger.error(f"{Fore.RED}{log_prefix}: Order #{i+1} Err:{err}{Style.RESET_ALL}"); init_errs[i]={'code':-104,'msg':err}; continue
            eff_cat=cat_use
        market=market_cache.get_market(sym); if not market: err=f"Market not found '{sym}'."; logger.error(f"{Fore.RED}{log_prefix}: Order #{i+1} Err:{err}{Style.RESET_ALL}"); init_errs[i]={'code':-105,'msg':err}; continue
        amt_str=format_amount(exchange,sym,amt); if amt_str is None: err=f"Invalid amount '{amt}'."; logger.error(f"{Fore.RED}{log_prefix}: Order #{i+1} Err:{err}{Style.RESET_ALL}"); init_errs[i]={'code':-106,'msg':err}; continue
        px_str:Optional[str]=None
        if o_type.capitalize()=='Limit':
            px_raw=o_req.get('price'); if px_raw is None or safe_decimal_conversion(px_raw,Decimal(-1))<=0: err="Limit needs valid price."; logger.error(f"{Fore.RED}{log_prefix}: Order #{i+1} Err:{err}{Style.RESET_ALL}"); init_errs[i]={'code':-107,'msg':err}; continue
            px_str=format_price(exchange,sym,px_raw); if px_str is None: err=f"Invalid price format '{px_raw}'."; logger.error(f"{Fore.RED}{log_prefix}: Order #{i+1} Err:{err}{Style.RESET_ALL}"); init_errs[i]={'code':-108,'msg':err}; continue
        side_val=side.value if isinstance(side,Side) else str(side).lower(); if side_val not in ['buy','sell']: err=f"Invalid side '{side}'."; logger.error(f"{Fore.RED}{log_prefix}: Order #{i+1} Err:{err}{Style.RESET_ALL}"); init_errs[i]={'code':-109,'msg':err}; continue
        bybit_side=side_val.capitalize(); v5_req={"symbol":sym, "side":bybit_side, "orderType":o_type.capitalize(), "qty":amt_str, "category":eff_cat, **{k:v for k,v in o_req.items() if k not in ['symbol','side','type','amount','price','category'] and v is not None}}
        if px_str: v5_req["price"]=px_str
        if o_req.get("clientOrderId"): cid=str(o_req["clientOrderId"]); clean_cid=''.join(filter(lambda c: c.isalnum() or c in ['-','_'], cid))[:36]; v5_req["clientOrderId"]=clean_cid
        if "reduceOnly" in v5_req: v5_req["reduceOnly"]=bool(v5_req["reduceOnly"])
        if "positionIdx" in v5_req and isinstance(v5_req["positionIdx"], PositionIdx): v5_req["positionIdx"]=v5_req["positionIdx"].value
        reqs[i]=v5_req; valid_count+=1; logger.debug(f"{log_prefix}: Prepared #{i+1}: {v5_req}")
    valid_reqs=[r for r in reqs if r is not None]
    if not valid_reqs: logger.error(f"{Fore.RED}{log_prefix}: No valid orders to send.{Style.RESET_ALL}"); return [None]*num, init_errs
    final_cat=cat_use; if not final_cat: logger.error(f"{Fore.RED}{log_prefix}: Cannot determine batch category.{Style.RESET_ALL}"); init_errs[0]=init_errs[0] or {'code':-199,'msg':'Batch category missing'}; return [None]*num, init_errs
    final_success:List[Optional[Dict]]=[None]*num; final_errors:List[Optional[Dict]]=list(init_errs)
    try:
        logger.info(f"{log_prefix}: Sending batch ({len(valid_reqs)} valid, Cat:{final_cat})..."); params={'category':final_cat, 'request':valid_reqs}
        response=await exchange.private_post_v5_order_create_batch(params); logger.debug(f"{log_prefix}: Raw response: {response}")
        ret_code=response.get('retCode'); ret_msg=response.get('retMsg','N/A')
        if ret_code==0:
            res_data=response.get('result',{}); success_raw=res_data.get('list',[]); errors_raw=res_data.get('errInfo',[])
            logger.info(f"{Fore.GREEN}{log_prefix}: Processed. Success:{len(success_raw)}, Failures:{len(errors_raw)}{Style.RESET_ALL}")
            success_by_cid={str(o.get('clientOrderId')):o for o in success_raw if o.get('clientOrderId')}; processed_indices=set()
            for err in errors_raw:
                req_idx=err.get('idx'); if req_idx is None or req_idx>=len(valid_reqs): logger.error(f"{log_prefix}: Invalid error index {req_idx}."); continue
                list_idx=-1; valid_c=-1
                for k, r in enumerate(reqs):
                     if r is not None: valid_c+=1;
                     if valid_c==req_idx: list_idx=k; break
                if list_idx!=-1: err_code=err.get('code',-1); err_msg=err.get('msg','?'); logger.error(f"{Fore.RED}{log_prefix}: Order #{list_idx+1} FAILED. Code:{err_code}, Msg:{err_msg}{Style.RESET_ALL}"); final_errors[list_idx]={'code':err_code,'msg':err_msg}; processed_indices.add(list_idx)
                else: logger.error(f"{log_prefix}: Cannot map error index {req_idx}.")
            success_counter=0
            for i, o_req in enumerate(reqs):
                if o_req is None or i in processed_indices: continue
                matched=False; cid=o_req.get('clientOrderId')
                if cid and str(cid) in success_by_cid:
                     raw_o=success_by_cid[str(cid)]; try: if not exchange.markets: await market_cache.load_markets(exchange); parsed=exchange.parse_order(raw_o); final_success[i]=parsed; logger.success(f"{Fore.GREEN}{log_prefix}: Order #{i+1} (CID:{cid}) PLACED. ID:...{format_order_id(parsed.get('id'))}{Style.RESET_ALL}"); matched=True; except Exception as pe: logger.error(f"{log_prefix}: Parse fail #{i+1}: {pe}. Raw."); final_success[i]=raw_o; matched=True
                if not matched and success_counter<len(success_raw):
                    raw_o=success_raw[success_counter]; if raw_o.get('symbol')==o_req.get('symbol'):
                        try: if not exchange.markets: await market_cache.load_markets(exchange); parsed=exchange.parse_order(raw_o); final_success[i]=parsed; logger.success(f"{Fore.GREEN}{log_prefix}: Order #{i+1} PLACED (by order). ID:...{format_order_id(parsed.get('id'))}{Style.RESET_ALL}"); matched=True; except Exception as pe: logger.error(f"{log_prefix}: Parse fail #{i+1} (by order): {pe}. Raw."); final_success[i]=raw_o; matched=True
                        success_counter+=1
                if not matched: logger.warning(f"{Fore.YELLOW}{log_prefix}: Order #{i+1} status uncertain.{Style.RESET_ALL}"); final_errors[i]={'code':-200,'msg':'Status uncertain'}
            return final_success, final_errors
        else:
            logger.error(f"{Back.RED}{log_prefix}: Batch request FAILED. Code:{ret_code}, Msg:{ret_msg}{Style.RESET_ALL}"); err_detail={'code':ret_code,'msg':f"Batch Failed:{ret_msg}"}; [(final_errors.__setitem__(i, err_detail)) for i in range(num) if final_errors[i] is None]; return final_success, final_errors
    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e: logger.error(f"{Back.RED}{log_prefix}: FAILED API Comm Error: {type(e).__name__}{Style.RESET_ALL}"); comm_err={'code':-300,'msg':f"API Comm Err:{type(e).__name__}"}; [(final_errors.__setitem__(i, comm_err)) for i in range(num) if final_errors[i] is None]; return final_success, final_errors
    except ExchangeError as e: logger.error(f"{Back.RED}{log_prefix}: FAILED Exchange Error: {e}{Style.RESET_ALL}", exc_info=True); exc_err={'code':-400,'msg':f"ExchErr:{str(e)}"}; [(final_errors.__setitem__(i, exc_err)) for i in range(num) if final_errors[i] is None]; return final_success, final_errors
    except Exception as e: logger.error(f"{Back.RED}{log_prefix}: FAILED Unexpected Error: {e}{Style.RESET_ALL}", exc_info=True); unexp_err={'code':-500,'msg':f"Unexp Err:{str(e)}"}; [(final_errors.__setitem__(i, unexp_err)) for i in range(num) if final_errors[i] is None]; return final_success, final_errors

@retry_api_call(max_retries=2, initial_delay=1.0)
async def cancel_all_orders(exchange: ccxt.bybit, symbol: Optional[str]=None, config: Optional[Config]=None, category: Optional[Category]=None, order_filter: Optional[OrderFilter]=None, reason: str="Cleanup") -> bool:
    """ Cancels open orders using Bybit V5 cancelAll endpoint. """
    func_name="cancel_all_orders"; log_prefix=f"[{func_name} ({reason})]"; eff_cat:Optional[str]=None
    if category: eff_cat=category.value; log_prefix+=f"|Cat:{eff_cat}"
    elif symbol: cat_enum=market_cache.get_category(symbol); if cat_enum: eff_cat=cat_enum.value; log_prefix+=f"|Sym:{symbol}(Cat:{eff_cat})"; else: logger.error(f"{Fore.RED}{log_prefix}: No category for '{symbol}'.{Style.RESET_ALL}"); return False
    else: logger.error(f"{Fore.RED}{log_prefix}: Need symbol or category.{Style.RESET_ALL}"); return False
    params={'category':eff_cat}; target_desc=""
    if symbol: params['symbol']=symbol; target_desc=f"for {symbol}"
    else: logger.warning(f"{Back.YELLOW}{Fore.BLACK}{log_prefix}: No symbol->cancel ALL in cat '{eff_cat}'.{Style.RESET_ALL}"); target_desc=f"ALL in cat {eff_cat}"
    if order_filter: params['orderFilter']=order_filter.value; log_prefix+=f"|Filter:{order_filter.value}"; target_desc+=f" filter {order_filter.value}"
    logger.info(f"{Fore.CYAN}{log_prefix}: Sending cancelAll {target_desc}...{Style.RESET_ALL}")
    try:
        response=await exchange.private_post_v5_order_cancel_all(params=params); logger.debug(f"{log_prefix}: Raw response: {response}")
        ret_code=response.get('retCode'); ret_msg=response.get('retMsg','N/A')
        if ret_code==0: count=len(response.get('result',{}).get('list',[])); logger.success(f"{Fore.GREEN}{log_prefix}: Cancelled {count} order(s) OK.{Style.RESET_ALL}") if count>0 else logger.info(f"{Fore.YELLOW}{log_prefix}: OK, no matching orders found.{Style.RESET_ALL}"); return True
        else: logger.error(f"{Fore.RED}{log_prefix}: FAILED {target_desc}. Code:{ret_code}, Msg:{ret_msg}{Style.RESET_ALL}"); return False
    except AuthenticationError as e: logger.error(f"{Fore.RED}{log_prefix}: Auth error: {e}{Style.RESET_ALL}"); return False
    except NotSupported as e: logger.error(f"{Fore.RED}{log_prefix}: CCXT method unsupported? Error: {e}{Style.RESET_ALL}"); return False
    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e: logger.warning(f"{Fore.YELLOW}{log_prefix}: API error: {type(e).__name__}. Retry handled.{Style.RESET_ALL}"); raise
    except ExchangeError as e: logger.error(f"{Fore.RED}{log_prefix}: Exchange error: {e}{Style.RESET_ALL}", exc_info=True); return False
    except Exception as e: logger.error(f"{Fore.RED}{log_prefix}: Unexpected error: {e}{Style.RESET_ALL}", exc_info=True); return False

@retry_api_call(max_retries=2, initial_delay=0.5)
async def cancel_order(exchange: ccxt.bybit, symbol: str, order_id: Optional[str]=None, client_order_id: Optional[str]=None, config: Optional[Config]=None, order_filter: Optional[OrderFilter]=None) -> bool:
    """ Cancels a single order by ID or client ID. """
    func_name="cancel_order";
    if not order_id and not client_order_id: logger.error(f"{Fore.RED}[{func_name}] Need id or client id.{Style.RESET_ALL}"); return False
    primary_id=order_id if order_id else client_order_id; id_type="Order ID" if order_id else "Client ID"; id_log=format_order_id(order_id) if order_id else client_order_id; log_prefix=f"[{func_name} ({symbol},{id_type}:...{id_log})]"
    category=market_cache.get_category(symbol); if not category: logger.error(f"{Fore.RED}{log_prefix}: No category.{Style.RESET_ALL}"); return False
    params={'category':category.value, 'symbol':symbol}; if order_filter: params['orderFilter']=order_filter.value; log_prefix+=f" Filter:{order_filter.value}"
    logger.info(f"{Fore.CYAN}{log_prefix}: Sending cancel...{Style.RESET_ALL}")
    try:
        response=await exchange.cancel_order(id=primary_id, symbol=symbol, params=params); logger.debug(f"{log_prefix}: Raw response: {response}")
        logger.success(f"{Fore.GREEN}{log_prefix}: Cancel request sent OK.{Style.RESET_ALL}"); return True
    except OrderNotFound as e: logger.warning(f"{Fore.YELLOW}{log_prefix}: Not found (already gone?). ({e}){Style.RESET_ALL}"); return True
    except InvalidOrder as e: logger.warning(f"{Fore.YELLOW}{log_prefix}: Invalid state (filled/cancelled?). ({e}){Style.RESET_ALL}"); err_str=str(e).lower(); if any(c in err_str for c in ["170145","170146","170131","order not exists"]): return True; else: logger.error(f"{Fore.RED}{log_prefix}: InvalidOrder: {e}{Style.RESET_ALL}"); return False
    except AuthenticationError as e: logger.error(f"{Fore.RED}{log_prefix}: Auth error: {e}{Style.RESET_ALL}"); return False
    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e: logger.warning(f"{Fore.YELLOW}{log_prefix}: API error: {type(e).__name__}. Retry handled.{Style.RESET_ALL}"); raise
    except ExchangeError as e: err_str=str(e).lower(); if any(c in err_str for c in ["170145","170146","170131","order not exists"]): logger.warning(f"{Fore.YELLOW}{log_prefix}: ExchErr indicates order gone ({e}). Success.{Style.RESET_ALL}"); return True; else: logger.error(f"{Fore.RED}{log_prefix}: Exchange error: {e}{Style.RESET_ALL}", exc_info=True); return False
    except Exception as e: logger.error(f"{Fore.RED}{log_prefix}: Unexpected error: {e}{Style.RESET_ALL}", exc_info=True); return False

@retry_api_call()
async def fetch_order(exchange: ccxt.bybit, symbol: str, order_id: Optional[str]=None, client_order_id: Optional[str]=None, config: Optional[Config]=None, order_filter: Optional[OrderFilter]=None) -> Optional[Dict]:
    """ Fetches order details by ID or client ID. """
    func_name="fetch_order";
    if not order_id and not client_order_id: logger.error(f"{Fore.RED}[{func_name}] Need id or client id.{Style.RESET_ALL}"); return None
    primary_id=order_id if order_id else client_order_id; id_type="Order ID" if order_id else "Client ID"; id_log=format_order_id(order_id) if order_id else client_order_id; log_prefix=f"[{func_name} ({symbol},{id_type}:...{id_log})]"
    category=market_cache.get_category(symbol); if not category: logger.error(f"{Fore.RED}{log_prefix}: No category.{Style.RESET_ALL}"); return None
    params={'category':category.value}; if order_filter: params['orderFilter']=order_filter.value; log_prefix+=f" Filter:{order_filter.value}"
    logger.debug(f"{log_prefix}: Sending fetch with params {params}...")
    try:
        order_data=await exchange.fetch_order(id=primary_id, symbol=symbol, params=params)
        status=order_data.get('status','?'); returned_id=order_data.get('id'); color=Fore.GREEN if status in ['closed','filled','canceled'] else Fore.YELLOW if status=='open' else Fore.CYAN
        logger.info(f"{color}{log_prefix}: Fetched OK. Status:{status}, ID:...{format_order_id(returned_id)}{Style.RESET_ALL}"); return order_data
    except OrderNotFound as e: logger.warning(f"{Fore.YELLOW}{log_prefix}: Order not found. ({e}){Style.RESET_ALL}"); return None
    except AuthenticationError as e: logger.error(f"{Fore.RED}{log_prefix}: Auth error: {e}{Style.RESET_ALL}"); return None
    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e: logger.warning(f"{Fore.YELLOW}{log_prefix}: API error: {type(e).__name__}. Retry handled.{Style.RESET_ALL}"); raise
    except ExchangeError as e: err_str=str(e).lower(); if any(c in err_str for c in ["170131","170214","order does not exist"]): logger.warning(f"{Fore.YELLOW}{log_prefix}: ExchErr indicates Not Found ({e}).{Style.RESET_ALL}"); return None; elif "order_filter" in err_str: logger.warning(f"{log_prefix}: Fetch needs 'orderFilter'? Err:{e}"); return None; else: logger.error(f"{Fore.RED}{log_prefix}: Exchange error: {e}{Style.RESET_ALL}", exc_info=True); return None
    except Exception as e: logger.error(f"{Fore.RED}{log_prefix}: Unexpected error: {e}{Style.RESET_ALL}", exc_info=True); return None

@retry_api_call()
async def fetch_open_orders_filtered(exchange: ccxt.bybit, symbol: Optional[str]=None, config: Optional[Config]=None, category: Optional[Category]=None, order_filter: Optional[OrderFilter]=None, limit: Optional[int]=None) -> List[Dict]:
    """ Fetches open orders, allowing filtering by V5 parameters. """
    func_name="fetch_open_orders"; log_prefix=f"[{func_name}]"; eff_cat:Optional[str]=None
    if category: eff_cat=category.value; log_prefix+=f"|Cat:{eff_cat}"
    elif symbol: cat_enum=market_cache.get_category(symbol); if cat_enum: eff_cat=cat_enum.value; log_prefix+=f"|Sym:{symbol}(Cat:{eff_cat})"; else: logger.error(f"{Fore.RED}{log_prefix}: No cat for '{symbol}'.{Style.RESET_ALL}"); return []
    else: def_sym=config.get('SYMBOL') if config else None; if def_sym: cat_enum=market_cache.get_category(def_sym); if cat_enum: eff_cat=cat_enum.value; logger.warning(f"{log_prefix}: Using cat '{eff_cat}' from default '{def_sym}'."); else: logger.error(f"{Fore.RED}{log_prefix}: No cat from default '{def_sym}'.{Style.RESET_ALL}"); return [] ; else: logger.error(f"{Fore.RED}{log_prefix}: Need symbol or category.{Style.RESET_ALL}"); return []
    if not eff_cat: logger.error(f"{Fore.RED}{log_prefix}: Cannot determine category.{Style.RESET_ALL}"); return []
    params={'category':eff_cat}; target_desc=f"cat {eff_cat}"
    if symbol: params['symbol']=symbol; target_desc=f"sym {symbol}"
    if order_filter: params['orderFilter']=order_filter.value; log_prefix+=f"|Filter:{order_filter.value}"; target_desc+=f", filter {order_filter.value}"
    if limit: params['limit']=min(limit,50); target_desc+=f", limit {params['limit']}"
    logger.info(f"{Fore.CYAN}{log_prefix}: Fetching open orders {target_desc}...{Style.RESET_ALL}")
    try: open_orders=await exchange.fetch_open_orders(symbol=symbol, params=params); logger.info(f"{Fore.GREEN}{log_prefix}: Found {len(open_orders)} open order(s).{Style.RESET_ALL}"); return open_orders
    except AuthenticationError as e: logger.error(f"{Fore.RED}{log_prefix}: Auth error: {e}{Style.RESET_ALL}"); return []
    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e: logger.warning(f"{Fore.YELLOW}{log_prefix}: API error: {type(e).__name__}. Retry handled.{Style.RESET_ALL}"); raise
    except ExchangeError as e: logger.error(f"{Fore.RED}{log_prefix}: Exchange error: {e}{Style.RESET_ALL}", exc_info=True); return []
    except Exception as e: logger.error(f"{Fore.RED}{log_prefix}: Unexpected error: {e}{Style.RESET_ALL}", exc_info=True); return []

# --- Position Management Functions ---
@retry_api_call()
async def get_current_position_bybit_v5(exchange: ccxt.bybit, symbol: str, config: Config) -> Optional[Union[Dict, List[Dict]]]:
    """ Fetches current position details for a symbol using Bybit V5 endpoint. """
    func_name="get_pos_v5"; log_prefix=f"[{func_name} ({symbol})]"; logger.debug(f"{log_prefix}: Fetching...")
    category=market_cache.get_category(symbol)
    if not category or category in [Category.SPOT, Category.OPTION]: logger.debug(f"{log_prefix}: Positions N/A for cat '{category}'."); return None
    params={'category':category.value, 'symbol':symbol}
    try:
        response=await exchange.private_get_v5_position_list(params=params)
        ret_code=response.get('retCode'); if ret_code!=0: ret_msg=response.get('retMsg','?'); logger.error(f"{Fore.RED}{log_prefix}: API error {ret_code}, Msg:{ret_msg}{Style.RESET_ALL}"); return None
        pos_list_raw=response.get('result',{}).get('list',[]); if not pos_list_raw: logger.info(f"{log_prefix}: No active position."); return None
        epsilon=config.get('POSITION_QTY_EPSILON', Decimal('1E-8')); open_pos_raw=[p for p in pos_list_raw if abs(safe_decimal_conversion(p.get('size','0'),Decimal(0)))>epsilon]
        if not open_pos_raw: logger.info(f"{log_prefix}: Position size is zero."); return None
        parsed_pos=[];
        for pos_data in open_pos_raw:
             try: if not exchange.markets: await market_cache.load_markets(exchange); parsed=exchange.parse_position(pos_data); parsed['info']=pos_data; parsed['misc']={k: pos_data.get(k) for k in ['positionIdx','riskId','riskLimitValue','takeProfit','stopLoss','trailingStop','tpslMode','adlRankIndicator','createdTime','updatedTime']}; parsed_pos.append(parsed)
             except Exception as pe: logger.error(f"{log_prefix}: Parse fail: {pos_data}. Err:{pe}", exc_info=True)
        if not parsed_pos: logger.error(f"{log_prefix}: Failed parse valid positions."); return None
        if len(parsed_pos)==1: pos=parsed_pos[0]; idx=pos['misc'].get('positionIdx'); mode="One-Way" if idx==PositionIdx.ONE_WAY else "Hedge"; logger.info(f"{Fore.GREEN}{log_prefix}: Found ({mode}): Side:{pos.get('side')}, Size:{pos.get('contracts')}, Entry:{pos.get('entryPrice')}{Style.RESET_ALL}"); return pos
        else: logger.info(f"{Fore.GREEN}{log_prefix}: Found {len(parsed_pos)} entries (Hedge). List returned.{Style.RESET_ALL}"); [(logger.info(f"  - Side:{p.get('side')}, Size:{p.get('contracts')}, Idx:{p['misc'].get('positionIdx')}")) for p in parsed_pos]; return parsed_pos
    except AuthenticationError as e: logger.error(f"{Fore.RED}{log_prefix}: Auth error: {e}{Style.RESET_ALL}"); return None
    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e: logger.warning(f"{Fore.YELLOW}{log_prefix}: API error: {type(e).__name__}. Retry handled.{Style.RESET_ALL}"); raise
    except ExchangeError as e: logger.error(f"{Fore.RED}{log_prefix}: Exchange error: {e}{Style.RESET_ALL}", exc_info=True); return None
    except Exception as e: logger.error(f"{Fore.RED}{log_prefix}: Unexpected error: {e}{Style.RESET_ALL}", exc_info=True); return None

async def close_position_reduce_only(exchange: ccxt.bybit, symbol: str, config: Config) -> bool:
    """ Closes entire position(s) for a symbol using reduceOnly market order(s). """
    func_name="close_position"; log_prefix=f"[{func_name} ({symbol})]"; logger.info(f"{Fore.YELLOW}{log_prefix}: Attempting close via reduceOnly market...{Style.RESET_ALL}")
    pos_data=await get_current_position_bybit_v5(exchange, symbol, config)
    if pos_data is None: logger.info(f"{log_prefix}: No position. OK."); return True
    pos_to_close=pos_data if isinstance(pos_data, list) else [pos_data]; closed_orders=[]; all_ok=True
    for pos in pos_to_close:
        size=pos.get('contracts'); side=pos.get('side'); idx_val=pos.get('misc',{}).get('positionIdx'); idx_enum=PositionIdx(idx_val) if idx_val is not None else None
        if not size or not side: logger.error(f"{Fore.RED}{log_prefix}: Invalid pos data: {pos}. Skip.{Style.RESET_ALL}"); all_ok=False; continue
        close_side=Side.SELL if side=='buy' else Side.BUY; close_amt=Decimal(str(size))
        mode_desc=f"(Idx:{idx_val})" if idx_enum!=PositionIdx.ONE_WAY else ""
        logger.info(f"{log_prefix}: Pos {mode_desc}: {side} {close_amt}. Placing {close_side.value} reduceOnly market.")
        close_order=await place_market_order_slippage_check(exchange, symbol, close_side, close_amt, config, is_reduce_only=True, client_order_id=f"close_{symbol}_{idx_val}_{int(time.time()*1000)}", position_idx=idx_enum)
        closed_orders.append(close_order)
        if close_order and close_order.get('status') in ['closed','filled']: logger.success(f"{Fore.GREEN}{log_prefix}: Pos entry {mode_desc} closed OK by ID ...{format_order_id(close_order.get('id'))}.{Style.RESET_ALL}")
        elif close_order: logger.warning(f"{Fore.YELLOW}{log_prefix}: Close order {mode_desc} status '{close_order.get('status')}'. May not be fully closed.{Style.RESET_ALL}"); all_ok=False
        else: logger.error(f"{Fore.RED}{log_prefix}: Failed place closing order {mode_desc}.{Style.RESET_ALL}"); all_ok=False
        if len(pos_to_close)>1: await asyncio.sleep(0.3)
    if all_ok:
        logger.info(f"{log_prefix}: Close orders sent OK. Verifying..."); await asyncio.sleep(config.get('DEFAULT_RECV_WINDOW',5000)/1000 + 1.0)
        final_pos=await get_current_position_bybit_v5(exchange, symbol, config)
        if final_pos is None: logger.success(f"{Fore.GREEN}{log_prefix}: Position confirmed closed.{Style.RESET_ALL}"); return True
        else: logger.warning(f"{Fore.YELLOW}{log_prefix}: Verification FAIL - position still open? Details: {final_pos}{Style.RESET_ALL}"); return False
    else: logger.error(f"{Fore.RED}{log_prefix}: One or more closing orders failed. Closure failed.{Style.RESET_ALL}"); return False

# --- WebSocket Functionality ---
_active_websockets: Dict[str, Any]={}; _websocket_tasks: Dict[str, asyncio.Task]={}; _ws_manage_lock=asyncio.Lock()
async def _handle_websocket_message(ws: websockets.WebSocketClientProtocol, url: str, callback: Callable[[Dict], Coroutine[Any, Any, None]], ping_interval: Optional[float]=20.0):
    func_name="_handle_ws_msg"; logger.info(f"[{func_name}] Start handler {url}"); last_ping=time.monotonic(); is_priv='/private' in url
    while not ws.closed:
        try:
            timeout=ping_interval/2 if ping_interval else 10.0; msg_str=await asyncio.wait_for(ws.recv(), timeout=timeout)
            try:
                msg_data=json.loads(msg_str)
                if msg_data.get("op")=="ping": await ws.send(json.dumps({"op":"pong", "req_id":msg_data.get("req_id")})); logger.debug(f"[{func_name}({url})] Sent PONG."); continue
                if is_priv and msg_data.get("op")=="auth":
                    if msg_data.get("success"): logger.success(f"{Fore.GREEN}[{func_name}({url})] WS auth OK.{Style.RESET_ALL}")
                    else: err_msg=msg_data.get("ret_msg","?"); logger.error(f"{Back.RED}[{func_name}({url})] WS auth FAIL: {err_msg}{Style.RESET_ALL}"); await ws.close(code=1008); break
                    continue
                if msg_data.get("op")=="subscribe":
                    if msg_data.get("success"): args=msg_data.get("req",{}).get("args",msg_data.get("args",[])); logger.info(f"{Fore.GREEN}[{func_name}({url})] Sub OK: {args}{Style.RESET_ALL}")
                    else: err_msg=msg_data.get("ret_msg","?"); logger.error(f"{Back.RED}[{func_name}({url})] Sub FAIL: {err_msg}{Style.RESET_ALL}")
                    continue
                await callback(msg_data)
            except json.JSONDecodeError: logger.warning(f"[{func_name}({url})] Non-JSON msg: {msg_str[:100]}...")
            except Exception as cb_err: logger.error(f"[{func_name}({url})] Callback error: {cb_err}", exc_info=True)
        except asyncio.TimeoutError:
            if ping_interval and (time.monotonic()-last_ping > ping_interval):
                 try: await ws.send(json.dumps({"req_id":f"ping_{int(time.time()*1000)}","op":"ping"})); last_ping=time.monotonic(); logger.debug(f"[{func_name}({url})] Sent PING.")
                 except ConnectionClosed: logger.warning(f"[{func_name}({url})] Closed sending ping."); break; except Exception as pe: logger.error(f"[{func_name}({url})] Ping error: {pe}")
            continue
        except ConnectionClosedOK: logger.info(f"[{func_name}({url})] Closed normally."); break
        except ConnectionClosedError as e: logger.warning(f"[{func_name}({url})] Closed with error: {e}."); break
        except WebSocketException as e: logger.error(f"[{func_name}({url})] WS exception: {e}", exc_info=True); break
        except Exception as e: logger.error(f"[{func_name}({url})] Unexpected handler error: {e}", exc_info=True); break
    logger.info(f"[{func_name}] Handler stopped for {url}.")
    async with _ws_manage_lock:
        if url in _active_websockets: del _active_websockets[url]
        if url in _websocket_tasks:
            if not _websocket_tasks[url].done(): _websocket_tasks[url].cancel()
            del _websocket_tasks[url]
    logger.debug(f"[{func_name}] Cleaned up tracking {url}.")

async def subscribe_to_websocket(topics: List[str], config: Config, callback: Callable[[Dict], Coroutine[Any, Any, None]], endpoint_type: Literal['public','private']='public', market_category: Category=Category.LINEAR, connect_timeout: float=10.0, ping_interval: Optional[float]=20.0) -> bool:
    """ Subscribes to Bybit V5 WebSocket streams. """
    func_name="subscribe_ws"; log_prefix=f"[{func_name}]"
    if not websockets: logger.error(f"{Fore.RED}{log_prefix}: 'websockets' not installed.{Style.RESET_ALL}"); return False
    if not topics: logger.warning(f"{Fore.YELLOW}{log_prefix}: No topics.{Style.RESET_ALL}"); return False
    if endpoint_type=='private' and (not config.get('API_KEY') or not config.get('API_SECRET')): logger.error(f"{Fore.RED}{log_prefix}: Private needs keys.{Style.RESET_ALL}"); return False
    base=f"wss://stream{'-testnet' if config['TESTNET_MODE'] else ''}.bybit.com/v5"; url=f"{base}/{endpoint_type}/{market_category.value}"
    logger.info(f"{Fore.CYAN}{log_prefix}: Subscribing to {url} for {topics}{Style.RESET_ALL}"); ws:Optional[Any]=None
    async with _ws_manage_lock:
        if url in _active_websockets and not _active_websockets[url].closed: ws=_active_websockets[url]; logger.info(f"{log_prefix}: Reusing connection {url}")
        else:
            logger.info(f"{log_prefix}: Connecting to {url}..."); try:
                headers={"User-Agent": f"PyrmethusV3-Helper"}; ws=await asyncio.wait_for(websockets.connect(url, extra_headers=headers, ping_interval=None), timeout=connect_timeout)
                _active_websockets[url]=ws; logger.info(f"{log_prefix}: Connected. Start handler...")
                task=asyncio.create_task(_handle_websocket_message(ws, url, callback, ping_interval)); _websocket_tasks[url]=task
                task.add_done_callback(lambda t: logger.info(f"WS task {url} done. Res/Exc: {t.result() if not t.cancelled() else 'Cancelled'}"))
            except asyncio.TimeoutError: logger.error(f"{Back.RED}{log_prefix}: Timeout connecting: {url}{Style.RESET_ALL}"); return False
            except (InvalidURI, WebSocketException) as e: logger.error(f"{Back.RED}{log_prefix}: WS connect fail: {e}{Style.RESET_ALL}"); return False
            except Exception as e: logger.error(f"{Back.RED}{log_prefix}: Unexpected connect err: {e}{Style.RESET_ALL}", exc_info=True); return False
        if ws and endpoint_type=='private':
            try:
                logger.info(f"{log_prefix}: Sending auth..."); temp_ex=ccxt.bybit({'apiKey':config['API_KEY'],'secret':config['API_SECRET']})
                expires=int((time.time()+10)*1000); sig=temp_ex.hmac(f'GET/realtime{expires}'.encode(),config['API_SECRET'].encode(),'sha256')
                auth={"op":"auth", "args":[config['API_KEY'], expires, sig]}; await ws.send(json.dumps(auth))
            except Exception as ae: logger.error(f"{log_prefix}: Failed send auth: {ae}"); return False
        if ws:
            try: sub={"req_id":f"sub_{int(time.time()*1000)}", "op":"subscribe", "args":topics}; await ws.send(json.dumps(sub)); logger.info(f"{log_prefix}: Sub request sent."); return True
            except ConnectionClosed: logger.error(f"{log_prefix}: Closed before sub."); return False; except Exception as se: logger.error(f"{log_prefix}: Failed send sub: {se}"); return False
        else: logger.error(f"{log_prefix}: WS unavailable."); return False

async def unsubscribe_from_websocket(url: str, topics: Optional[List[str]]=None) -> bool:
    """ Unsubscribes from topics or closes a specific WebSocket connection. """
    func_name="unsubscribe_ws"; log_prefix=f"[{func_name} ({url})]"
    if not websockets: return True
    async with _ws_manage_lock:
        if url not in _active_websockets: logger.warning(f"{Fore.YELLOW}{log_prefix}: No active connection.{Style.RESET_ALL}"); if url in _websocket_tasks: del _websocket_tasks[url]; return True
        ws=_active_websockets[url]
        if ws.closed: logger.warning(f"{Fore.YELLOW}{log_prefix}: Already closed.{Style.RESET_ALL}"); del _active_websockets[url]; if url in _websocket_tasks: del _websocket_tasks[url]; return True
        try:
            if topics: unsub={"req_id":f"unsub_{int(time.time()*1000)}", "op":"unsubscribe", "args":topics}; await ws.send(json.dumps(unsub)); logger.info(f"{log_prefix}: Unsub request sent for {topics}.")
            else: logger.info(f"{log_prefix}: Closing connection..."); await ws.close(code=1000); logger.info(f"{log_prefix}: Connection closed.")
            return True
        except ConnectionClosed: logger.warning(f"{log_prefix}: Closed unexpectedly."); return True
        except WebSocketException as e: logger.error(f"{Fore.RED}{log_prefix}: WS error: {e}{Style.RESET_ALL}"); return False
        except Exception as e: logger.error(f"{Fore.RED}{log_prefix}: Unexpected error: {e}{Style.RESET_ALL}", exc_info=True); return False

# --- Placeholder/Misc Functions ---
async def validate_market(exchange:ccxt.bybit, symbol:str, config:Config, expected_type:Optional[Literal['swap','spot','option','future']]=None, expected_logic:Optional[Literal['linear','inverse']]=None, check_active:bool=True, require_contract:Optional[bool]=None) -> Optional[Dict]:
    """ Validates market symbol using cached data. """
    func_name="validate_market"; log_prefix=f"[{func_name} ({symbol})]"; logger.debug(f"{log_prefix}: Validating...")
    market=market_cache.get_market(symbol); if not market: logger.error(f"{Fore.RED}{log_prefix}: FAIL - Not found.{Style.RESET_ALL}"); return None
    is_active=market.get('active',False); if check_active and not is_active: logger.error(f"{Fore.RED}{log_prefix}: FAIL - Inactive.{Style.RESET_ALL}"); return None; elif not is_active: logger.warning(f"{Fore.YELLOW}{log_prefix}: Inactive.{Style.RESET_ALL}")
    act_type=market.get('type'); tgt_type=expected_type or config.get('EXPECTED_MARKET_TYPE'); if tgt_type and act_type!=tgt_type: logger.error(f"{Fore.RED}{log_prefix}: FAIL - Type mismatch (Exp:{tgt_type},Got:{act_type}).{Style.RESET_ALL}"); return None
    act_cat=market_cache.get_category(symbol); tgt_logic=expected_logic or config.get('EXPECTED_MARKET_LOGIC')
    if act_cat in [Category.LINEAR,Category.INVERSE] and tgt_logic:
        if act_cat.value!=tgt_logic: logger.error(f"{Fore.RED}{log_prefix}: FAIL - Logic mismatch (Exp:{tgt_logic},Got:{act_cat.value}).{Style.RESET_ALL}"); return None
    elif tgt_logic and act_cat not in [Category.LINEAR,Category.INVERSE]: logger.warning(f"{Fore.YELLOW}{log_prefix}: Logic check skip non-deriv '{act_cat}'.{Style.RESET_ALL}")
    is_contract=market.get('contract',False); if require_contract is True and not is_contract: logger.error(f"{Fore.RED}{log_prefix}: FAIL - Not contract.{Style.RESET_ALL}"); return None; if require_contract is False and is_contract: logger.error(f"{Fore.RED}{log_prefix}: FAIL - Is contract (should not be).{Style.RESET_ALL}"); return None
    logger.info(f"{Fore.GREEN}{log_prefix}: PASSED. Type:{act_type}, Cat:{act_cat}, Active:{is_active}, Contract:{is_contract}{Style.RESET_ALL}"); return market

async def set_position_mode_bybit_v5(exchange: ccxt.bybit, config: Config, mode: Literal['one-way', 'hedge'], category: Optional[Category]=None, symbol: Optional[str]=None) -> bool:
    """ Sets position mode per category (V5). """
    func_name="set_pos_mode"; log_prefix=f"[{func_name}]"; logger.warning(f"{Fore.YELLOW}{log_prefix}: Basic impl. Verify docs.{Style.RESET_ALL}")
    tgt_cat:Optional[str]=None
    if category: tgt_cat=category.value
    elif symbol: cat_enum=market_cache.get_category(symbol); tgt_cat=cat_enum.value if cat_enum else None
    elif config.get('SYMBOL'): cat_enum=market_cache.get_category(config['SYMBOL']); tgt_cat=cat_enum.value if cat_enum else None
    if not tgt_cat or tgt_cat==Category.SPOT.value: logger.error(f"{log_prefix}: Invalid/missing category: {tgt_cat}"); return False
    bybit_mode=3 if mode=='hedge' else 0; params={'category':tgt_cat, 'mode':bybit_mode}
    logger.info(f"{Fore.CYAN}{log_prefix}: Setting mode '{mode}'({bybit_mode}) for cat {tgt_cat}...{Style.RESET_ALL}")
    try:
        response=await exchange.private_post_v5_position_switch_mode(params=params); logger.debug(f"{log_prefix}: Raw resp: {response}")
        ret_code=response.get('retCode')
        if ret_code==0: logger.success(f"{Fore.GREEN}{log_prefix}: Mode set '{mode}'.{Style.RESET_ALL}"); return True
        else: ret_msg=response.get('retMsg','?').lower(); if ret_code in [110021,34036] or "not modified" in ret_msg: logger.info(f"{Fore.CYAN}{log_prefix}: Mode already '{mode}'.{Style.RESET_ALL}"); return True; elif ret_code==110020 or "have position" in ret_msg or "active order" in ret_msg: logger.error(f"{Fore.RED}{log_prefix}: Cannot switch: Active pos/orders exist. Msg: {response.get('retMsg')}{Style.RESET_ALL}"); return False; else: logger.error(f"{Fore.RED}{log_prefix}: Failed. Code:{ret_code}, Msg:{response.get('retMsg')}{Style.RESET_ALL}"); return False
    except Exception as e: logger.error(f"{Fore.RED}{log_prefix}: Error: {e}{Style.RESET_ALL}", exc_info=True); return False

async def place_native_stop_loss(exchange: ccxt.bybit, symbol: str, side: Side, amount: Decimal, stop_price: Decimal, config: Config, base_price: Optional[Decimal]=None, trigger_direction: Optional[TriggerDirection]=None, is_reduce_only: bool=True, order_type: Literal['Market','Limit']='Market', limit_price: Optional[Decimal]=None, position_idx: Optional[PositionIdx]=None, trigger_by: TriggerBy=TriggerBy.MARK) -> Optional[Dict]:
    """ Places a native stop-loss order using conditional order endpoint (V5). """
    func_name="place_native_sl"; log_prefix=f"[{func_name} ({symbol},{side.value},SL:{stop_price})]"; logger.warning(f"{Fore.YELLOW}{log_prefix}: Basic V5 SL. Test carefully.{Style.RESET_ALL}")
    category=market_cache.get_category(symbol)
    if not category or category==Category.SPOT: logger.error(f"{Fore.RED}{log_prefix}: Invalid cat '{category}'.{Style.RESET_ALL}"); return None
    if trigger_direction is None: trigger_direction=TriggerDirection.FALL if side==Side.SELL else TriggerDirection.RISE; logger.debug(f"{log_prefix}: Auto triggerDir:{trigger_direction.name}")
    if base_price is None:
        ticker=await fetch_ticker_validated(exchange, symbol, config); if ticker and ticker.get('markPrice'): base_price=safe_decimal_conversion(ticker['markPrice']); elif ticker and ticker.get('last'): base_price=safe_decimal_conversion(ticker['last'])
        if base_price is None: logger.error(f"{Fore.RED}{log_prefix}: Cannot get base_price.{Style.RESET_ALL}"); return None
        logger.debug(f"{log_prefix}: Using base_price:{base_price}")
    amt_str,sl_px_str,base_px_str=format_amount(exchange,symbol,amount),format_price(exchange,symbol,stop_price),format_price(exchange,symbol,base_price); lim_px_str=format_price(exchange,symbol,limit_price) if order_type=='Limit' else None
    if not all([amt_str,sl_px_str,base_px_str]): logger.error(f"{Fore.RED}{log_prefix}: Format fail inputs.{Style.RESET_ALL}"); return None
    if order_type=='Limit' and not lim_px_str: logger.error(f"{Fore.RED}{log_prefix}: Need limit price.{Style.RESET_ALL}"); return None
    params={'category':category.value, 'symbol':symbol, 'side':side.value.capitalize(), 'orderType':order_type.capitalize(), 'qty':amt_str, 'triggerPrice':sl_px_str, 'triggerDirection':trigger_direction.value, 'basePrice':base_px_str, 'orderFilter':OrderFilter.STOP_ORDER.value, 'reduceOnly':is_reduce_only, 'triggerBy':trigger_by.value} # Added triggerBy
    if order_type=='Limit' and lim_px_str: params['price']=lim_px_str
    if position_idx is not None: params['positionIdx']=position_idx.value
    logger.info(f"{Fore.CYAN}{log_prefix}: Placing conditional stop params: {params}...{Style.RESET_ALL}")
    try:
        order=await exchange.create_order(symbol,order_type,side.value,float(amt_str),float(lim_px_str) if order_type=='Limit' and lim_px_str else None, params=params)
        logger.success(f"{Fore.GREEN}{log_prefix}: Placed OK. ID:...{format_order_id(order.get('id'))}, Status:{order.get('status')}{Style.RESET_ALL}"); return order
    except Exception as e: logger.error(f"{Fore.RED}{log_prefix}: Failed place: {e}{Style.RESET_ALL}", exc_info=True); return None

async def place_native_trailing_stop(exchange: ccxt.bybit, symbol: str, side: Side, amount: Decimal, trailing_offset: Union[Decimal, str], config: Config, activation_price: Optional[Decimal]=None, trigger_by: TriggerBy=TriggerBy.MARK, client_order_id: Optional[str]=None, position_idx: Optional[PositionIdx]=None) -> Optional[Dict]:
    """ Places a native Trailing Stop Market order (V5, reduceOnly). """
    func_name="place_native_tsl"; log_prefix=f"[{func_name} ({symbol},{side.value})]"; params:Dict[str,Any]={}; trail_log=""
    if isinstance(trailing_offset, str) and trailing_offset.endswith('%'):
        try: perc=Decimal(trailing_offset.rstrip('%')); if not(Decimal("0.1")<=perc<=Decimal("10.0")): raise ValueError("Perc out of range"); params['trailingStop']=str(perc.quantize(Decimal("0.01"))); trail_log=f"{perc}%"
        except (ValueError, InvalidOperation) as e: logger.error(f"{Fore.RED}{log_prefix}: Invalid trail '%': {e}{Style.RESET_ALL}"); return None
    elif isinstance(trailing_offset, Decimal):
        if trailing_offset<=0: logger.error(f"{Fore.RED}{log_prefix}: Trail delta must be > 0.{Style.RESET_ALL}"); return None
        try: delta_str=format_price(exchange,symbol,trailing_offset); params['trailingMove']=delta_str; trail_log=f"{delta_str}(abs)" # Using potential param
        except Exception as fmt_e: logger.error(f"{Fore.RED}{log_prefix}: Cannot format trail offset {trailing_offset}: {fmt_e}{Style.RESET_ALL}"); return None
    else: logger.error(f"{Fore.RED}{log_prefix}: Invalid trail offset type: {type(trailing_offset)}{Style.RESET_ALL}"); return None
    if activation_price is not None and activation_price<=0: logger.error(f"{Fore.RED}{log_prefix}: Activation price must be > 0.{Style.RESET_ALL}"); return None
    logger.info(f"{Fore.CYAN}{log_prefix}: Init {format_amount(exchange,symbol,amount)} {symbol}, Trail:{trail_log}, ActPx:{format_price(exchange,symbol,activation_price) or 'Imm'}, Trigger:{trigger_by.value}, PosIdx:{position_idx.value if position_idx else 0}{Style.RESET_ALL}")
    try:
        market=exchange.market(symbol); category=market_cache.get_category(symbol)
        if not category or category not in [Category.LINEAR, Category.INVERSE]: logger.error(f"{Fore.RED}[{func_name}] Not contract symbol.{Style.RESET_ALL}"); return None
        amt_str=format_amount(exchange,symbol,amount); amt_f=float(amt_str); act_px_str=format_price(exchange,symbol,activation_price) if activation_price else None
        params.update({'category':category.value, 'reduceOnly':True, 'positionIdx':position_idx.value if position_idx else 0, 'tpslMode':'Full', 'triggerBy':trigger_by.value}) # TSL is usually Market exec
        if act_px_str is not None: params['activePrice']=act_px_str
        if client_order_id: clean_cid=''.join(filter(lambda c: c.isalnum() or c in ['-','_'], client_order_id))[:36]; params['clientOrderId']=clean_cid
        logger.warning(f"{Back.YELLOW}{Fore.BLACK}{log_prefix}: Placing NATIVE TSL -> Qty:{amt_f}, Side:{side.value}, Params:{params}{Style.RESET_ALL}")
        tsl_order=await exchange.create_order(symbol=symbol, type='market', side=side.value, amount=amt_f, params=params) # Use type='market' for TSL usually
        oid=tsl_order.get('id'); status=tsl_order.get('status','?'); ret_trail=tsl_order.get('info',{}).get('trailingStop') or tsl_order.get('info',{}).get('trailingMove'); ret_act=safe_decimal_conversion(tsl_order.get('info',{}).get('activePrice')); ret_trig=tsl_order.get('info',{}).get('triggerBy')
        logger.success(f"{Fore.GREEN}{log_prefix}: Native TSL placed. ID:...{format_order_id(oid)}, Status:{status}, Trail:{ret_trail}, ActPx:{format_price(exchange,symbol,ret_act)}, TrigBy:{ret_trig}{Style.RESET_ALL}"); return tsl_order
    except (InvalidOrder, ExchangeError, NetworkError, BadSymbol, ValueError) as e: logger.error(f"{Fore.RED}{log_prefix}: API/Input Error: {type(e).__name__} - {e}{Style.RESET_ALL}"); return None
    except Exception as e: logger.critical(f"{Back.RED}[{func_name}] Unexpected TSL error: {e}{Style.RESET_ALL}", exc_info=True); send_sms_alert(f"[{symbol.split('/')[0]}] TSL PLACE FAIL ({side.value}): Unexpected {type(e).__name__}", config); return None

async def update_limit_order(exchange: ccxt.bybit, symbol: str, order_id: str, config: Config, new_amount: Optional[Decimal]=None, new_price: Optional[Decimal]=None, new_client_order_id: Optional[str]=None) -> Optional[Dict]:
    """ Attempts to modify an existing open limit order (V5). """
    func_name="update_limit_order"; log_prefix=f"[{func_name} (...{format_order_id(order_id)})]"
    if new_amount is None and new_price is None: logger.warning(f"{log_prefix}: No new amount/price."); return None
    if new_amount is not None and new_amount<=config['POSITION_QTY_EPSILON']: logger.error(f"{Fore.RED}{log_prefix}: Invalid new amount {new_amount}.{Style.RESET_ALL}"); return None
    if new_price is not None and new_price<=0: logger.error(f"{Fore.RED}{log_prefix}: Invalid new price {new_price}.{Style.RESET_ALL}"); return None
    logger.info(f"{Fore.CYAN}{log_prefix}: Update {symbol} (Amt:{format_amount(exchange,symbol,new_amount) or 'NC'}, Px:{format_price(exchange,symbol,new_price) or 'NC'})...{Style.RESET_ALL}")
    try:
        if not exchange.has.get('editOrder'): logger.error(f"{Fore.RED}{log_prefix}: editOrder not supported.{Style.RESET_ALL}"); return None
        logger.debug(f"{log_prefix}: Fetching current state..."); market=exchange.market(symbol); category=market_cache.get_category(symbol); if not category: raise ValueError(f"No category {symbol}")
        curr_order=await fetch_order(exchange, symbol, order_id=order_id, config=config); if not curr_order: logger.error(f"{log_prefix}: Cannot fetch current order."); return None
        status=curr_order.get('status'); o_type=curr_order.get('type'); filled=safe_decimal_conversion(curr_order.get('filled','0'))
        if status!='open': logger.error(f"{log_prefix}: Status '{status}' not open."); return None; if o_type!='limit': logger.error(f"{log_prefix}: Type '{o_type}' not limit."); return None
        allow_partial=False; if not allow_partial and filled>config['POSITION_QTY_EPSILON']: logger.warning(f"{log_prefix}: Update abort: partially filled ({format_amount(exchange,symbol,filled)}).{Style.RESET_ALL}"); return None
        final_amt=new_amount if new_amount is not None else safe_decimal_conversion(curr_order.get('amount')); final_px=new_price if new_price is not None else safe_decimal_conversion(curr_order.get('price'))
        if final_amt is None or final_px is None or final_amt<=config['POSITION_QTY_EPSILON'] or final_px<=0: raise ValueError("Invalid final amt/px.")
        edit_params={'category':category.value}; if new_client_order_id: clean_cid=''.join(filter(lambda c:c.isalnum() or c in ['-','_'],new_client_order_id))[:36]; edit_params['clientOrderId']=clean_cid # Check V5 param name
        final_amt_f=float(format_amount(exchange,symbol,final_amt)); final_px_f=float(format_price(exchange,symbol,final_px))
        logger.info(f"{Fore.CYAN}{log_prefix}: Submit update->Amt:{final_amt_f}, Px:{final_px_f}, Side:{curr_order['side']}, Params:{edit_params}{Style.RESET_ALL}")
        updated=await exchange.edit_order(order_id,symbol,'limit',curr_order['side'],final_amt_f,final_px_f,params=edit_params)
        if updated: new_id=updated.get('id',order_id); status_after=updated.get('status','?'); new_cid_resp=updated.get('clientOrderId',edit_params.get('clientOrderId','?')); logger.success(f"{Fore.GREEN}{log_prefix}: Update OK. NewID:...{format_order_id(new_id)}, Status:{status_after}, ClientOID:{new_cid_resp}{Style.RESET_ALL}"); return updated
        else: logger.warning(f"{Fore.YELLOW}{log_prefix}: edit_order returned None. Check status.{Style.RESET_ALL}"); return None
    except (OrderNotFound, InvalidOrder, NotSupported, ExchangeError, NetworkError, BadSymbol, ValueError) as e: logger.error(f"{Fore.RED}{log_prefix}: Failed update: {type(e).__name__} - {e}{Style.RESET_ALL}"); return None
    except Exception as e: logger.critical(f"{Back.RED}{log_prefix}: Unexpected update error: {e}{Style.RESET_ALL}", exc_info=True); return None

async def fetch_position_risk_bybit_v5(exchange: ccxt.bybit, symbol: str, config: Config) -> Optional[Dict[str, Any]]:
    """ Fetches detailed risk metrics for the current position (V5). Focuses on One-Way. """
    func_name="fetch_pos_risk_v5"; log_prefix=f"[{func_name} ({symbol})]"; logger.debug(f"{log_prefix}: Fetching...")
    default_risk={'symbol':symbol, 'side':config.POS_NONE, 'qty':Decimal("0"), 'entry_price':Decimal("0"), 'mark_price':None, 'liq_price':None, 'leverage':None, 'initial_margin':None, 'maint_margin':None, 'unrealized_pnl':None, 'imr':None, 'mmr':None, 'position_value':None, 'risk_limit_value':None, 'info':{}}
    try:
        market=exchange.market(symbol); market_id=market['id']; category=market_cache.get_category(symbol)
        if not category or category not in [Category.LINEAR,Category.INVERSE]: logger.error(f"{Fore.RED}{log_prefix}: Not contract symbol.{Style.RESET_ALL}"); return default_risk
        params={'category':category.value,'symbol':market_id}; pos_data:Optional[List[Dict]]=None; method="N/A"
        if exchange.has.get('fetchPositionsRisk'): try: logger.debug(f"{log_prefix}: Use fetchPositionsRisk..."); pos_data=await exchange.fetch_positions_risk([symbol],params); method="fetchPositionsRisk"; except Exception as e: logger.warning(f"{log_prefix}: fetchPosRisk fail ({type(e).__name__}). Fallback."); pos_data=None
        if pos_data is None: if exchange.has.get('fetchPositions'): logger.debug(f"{log_prefix}: Fallback fetchPositions..."); pos_data=await exchange.fetch_positions([symbol],params); method="fetchPositions"; else: logger.error(f"{Fore.RED}{log_prefix}: No pos fetch methods.{Style.RESET_ALL}"); return default_risk
        if pos_data is None: logger.error(f"{Fore.RED}{log_prefix}: Failed fetch ({method}).{Style.RESET_ALL}"); return default_risk
        active_risk:Optional[Dict]=None
        for pos in pos_data: # Corrected loop for fetchPositionsRisk/fetchPositions structure
            info=pos.get('info',{}); sym=info.get('symbol'); side=info.get('side','None'); size_str=info.get('size'); idx=int(info.get('positionIdx',-1))
            if sym==market_id and side!='None' and idx==0: # One-Way Mode focus
                size=safe_decimal_conversion(size_str,Decimal(0)); if size is not None and abs(size)>config['POSITION_QTY_EPSILON']: active_risk=pos; logger.debug(f"{log_prefix}: Found active One-Way data ({method})."); break
        if not active_risk: logger.info(f"{log_prefix}: No active One-Way position found."); return default_risk
        try:
            info=active_risk.get('info',{}); size=safe_decimal_conversion(active_risk.get('contracts',info.get('size'))); entry=safe_decimal_conversion(active_risk.get('entryPrice',info.get('avgPrice'))); mark=safe_decimal_conversion(active_risk.get('markPrice',info.get('markPrice'))); liq=safe_decimal_conversion(active_risk.get('liquidationPrice',info.get('liqPrice'))); lev=safe_decimal_conversion(active_risk.get('leverage',info.get('leverage'))); im=safe_decimal_conversion(active_risk.get('initialMargin',info.get('positionIM'))); mm=safe_decimal_conversion(active_risk.get('maintenanceMargin',info.get('positionMM'))); pnl=safe_decimal_conversion(active_risk.get('unrealizedPnl',info.get('unrealisedPnl'))); imr=safe_decimal_conversion(active_risk.get('initialMarginPercentage',info.get('imr'))); mmr=safe_decimal_conversion(active_risk.get('maintenanceMarginPercentage',info.get('mmr'))); val=safe_decimal_conversion(active_risk.get('contractsValue',info.get('positionValue'))); risk_lim=safe_decimal_conversion(info.get('riskLimitValue'))
            side_str=info.get('side'); pos_side=config.POS_LONG if side_str=='Buy' else (config.POS_SHORT if side_str=='Sell' else config.POS_NONE); qty=abs(size) if size is not None else Decimal("0")
            if pos_side==config.POS_NONE or qty<=config['POSITION_QTY_EPSILON']: logger.info(f"{log_prefix}: Parsed pos negligible."); return default_risk
            color=Fore.GREEN if pos_side==config.POS_LONG else Fore.RED; logger.info(f"{color}[{log_prefix}] Pos Risk {symbol} ({pos_side}):{Style.RESET_ALL}")
            m_quote=market.get('quote',config.USDT_SYMBOL); logger.info(f"  Qty:{format_amount(exchange,symbol,qty)}, Entry:{format_price(exchange,symbol,entry)}, Mark:{format_price(exchange,symbol,mark)}")
            logger.info(f"  Liq:{format_price(exchange,symbol,liq)}, Lev:{lev}x, uPNL:{format_price(exchange,m_quote,pnl)}")
            logger.info(f"  IM:{format_price(exchange,m_quote,im)}, MM:{format_price(exchange,m_quote,mm)}")
            logger.info(f"  IMR:{imr:.4% if imr else 'N/A'}, MMR:{mmr:.4% if mmr else 'N/A'}, Value:{format_price(exchange,m_quote,val)}")
            logger.info(f"  RiskLimit:{risk_lim or 'N/A'}")
            return {'symbol':symbol,'side':pos_side,'qty':qty,'entry_price':entry,'mark_price':mark,'liq_price':liq,'leverage':lev,'initial_margin':im,'maint_margin':mm,'unrealized_pnl':pnl,'imr':imr,'mmr':mmr,'position_value':val,'risk_limit_value':risk_lim,'info':info}
        except Exception as parse_err: logger.warning(f"{Fore.YELLOW}[{log_prefix}] Parse pos risk err: {parse_err}. Data:{str(active_risk)[:300]}{Style.RESET_ALL}"); return default_risk
    except (NetworkError, ExchangeError, BadSymbol) as e: logger.warning(f"{Fore.YELLOW}[{log_prefix}] API Error fetch pos risk: {e}{Style.RESET_ALL}"); raise
    except Exception as e: logger.error(f"{Fore.RED}[{log_prefix}] Unexpected fetch pos risk err: {e}{Style.RESET_ALL}", exc_info=True); return default_risk

async def set_isolated_margin_bybit_v5(exchange: ccxt.bybit, symbol: str, leverage: int, config: Config) -> bool:
    """ Sets margin mode to ISOLATED for a symbol via leverage setting (V5). """
    func_name="set_isolated_margin_v5"; log_prefix=f"[{func_name} ({symbol})]"
    logger.info(f"{Fore.CYAN}{log_prefix}: Setting ISOLATED by setting leverage to {leverage}x...{Style.RESET_ALL}")
    # Setting leverage implicitly sets isolated mode in V5
    return await set_leverage(exchange, symbol, leverage, config)

async def fetch_account_info_bybit_v5(exchange: ccxt.bybit, config: Config) -> Optional[Dict[str, Any]]:
    """ Fetches general V5 account info (UTA status, margin mode). """
    func_name="fetch_account_info_v5"; log_prefix=f"[{func_name}]"; logger.debug(f"{log_prefix}: Fetching...")
    try:
        if hasattr(exchange, 'private_get_v5_account_info'):
            logger.debug(f"{log_prefix}: Use private_get_v5_account_info."); raw_info=await exchange.private_get_v5_account_info(); logger.debug(f"{log_prefix}: Raw:{str(raw_info)[:400]}...")
            ret_code=raw_info.get('retCode'); ret_msg=raw_info.get('retMsg')
            if ret_code==0 and 'result' in raw_info:
                res=raw_info['result']; parsed={'unifiedMarginStatus':res.get('unifiedMarginStatus'),'marginMode':res.get('marginMode'),'dcpStatus':res.get('dcpStatus'),'timeWindow':res.get('timeWindow'),'smtCode':res.get('smtCode'),'isMasterTrader':res.get('isMasterTrader'),'updateTime':res.get('updateTime'),'rawInfo':res}
                logger.info(f"{log_prefix}: Info: UTA={parsed.get('unifiedMarginStatus','?')}, MarginMode={parsed.get('marginMode','?')}, DCP={parsed.get('dcpStatus','?')}")
                return parsed
            else: raise ExchangeError(f"Failed fetch/parse account info. Code={ret_code}, Msg='{ret_msg}'")
        else: logger.warning(f"{log_prefix}: CCXT lacks private_get_v5_account_info. Cannot fetch V5 info."); return None
    except (NetworkError, ExchangeError, AuthenticationError) as e: logger.warning(f"{Fore.YELLOW}[{func_name}] API Error: {e}{Style.RESET_ALL}"); raise
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error: {e}{Style.RESET_ALL}", exc_info=True); return None

def calculate_margin_requirement(exchange: ccxt.bybit, symbol: str, amount: Decimal, price: Decimal, leverage: Decimal, config: Config, order_side: Literal['buy','sell'], is_maker: bool=False) -> Tuple[Optional[Decimal],Optional[Decimal]]:
    """ Calculates estimated Initial Margin (IM) requirement. MM is basic placeholder. """
    func_name="calc_margin_req"; log_prefix=f"[{func_name} ({symbol})]"; logger.debug(f"{log_prefix}: Calc: {order_side} {format_amount(exchange,symbol,amount)}@{format_price(exchange,symbol,price)}, Lev:{leverage}x")
    if amount<=0 or price<=0 or leverage<=0: logger.error(f"{Fore.RED}{log_prefix}: Invalid inputs.{Style.RESET_ALL}"); return None,None
    try:
        market=market_cache.get_market(symbol); if not market: raise ValueError("Market not found"); quote_curr=market.get('quote',config.USDT_SYMBOL)
        if not market.get('contract'): logger.error(f"{Fore.RED}{log_prefix}: Not contract.{Style.RESET_ALL}"); return None,None
        order_val=amount*price; logger.debug(f"{log_prefix}: Order Val:{format_price(exchange,quote_curr,order_val)} {quote_curr}")
        im_base=order_val/leverage; logger.debug(f"{log_prefix}: Base IM:{format_price(exchange,quote_curr,im_base)} {quote_curr}")
        fee_rate=config.MAKER_FEE_RATE if is_maker else config.TAKER_FEE_RATE; fee_est=order_val*fee_rate; logger.debug(f"{log_prefix}: Est Fee({fee_rate:.4%}):{format_price(exchange,quote_curr,fee_est)} {quote_curr}")
        total_im_est=im_base+fee_est; logger.info(f"{log_prefix}: Est TOTAL IM Req:{format_price(exchange,quote_curr,total_im_est)} {quote_curr}"); mm_est:Optional[Decimal]=None
        try:
            mmr_keys=['maintenanceMarginRate','mmr']; mmr_rate_str=None
            for key in mmr_keys: val_info=market.get('info',{}).get(key); val_root=market.get(key); mmr_rate_str=val_info or val_root; if mmr_rate_str: break
            if mmr_rate_str: mmr_rate=safe_decimal_conversion(mmr_rate_str); if mmr_rate and mmr_rate>0: mm_est=order_val*mmr_rate; logger.debug(f"{log_prefix}: Basic MM Est({mmr_rate:.4%}):{format_price(exchange,quote_curr,mm_est)} {quote_curr}"); else: logger.debug(f"{log_prefix}: Cannot parse MMR '{mmr_rate_str}'.")
            else: logger.debug(f"{log_prefix}: MMR key not found.")
        except Exception as mm_err: logger.warning(f"[{func_name}] Cannot estimate MM: {mm_err}")
        return total_im_est, mm_est
    except (DivisionByZero, KeyError, ValueError) as e: logger.error(f"{Fore.RED}{log_prefix}: Calc error: {e}{Style.RESET_ALL}"); return None,None
    except Exception as e: logger.error(f"{Fore.RED}{log_prefix}: Unexpected margin calc err: {e}{Style.RESET_ALL}", exc_info=True); return None,None

# --- Main Execution Block ---
if __name__ == "__main__":
    print(f"{Style.BRIGHT}{Fore.YELLOW}--- Bybit V5 Helpers v3.2 Standalone Execution ---{Style.RESET_ALL}")
    API_KEY = os.getenv("BYBIT_API_KEY"); API_SECRET = os.getenv("BYBIT_API_SECRET"); USE_TESTNET = os.getenv("BYBIT_USE_TESTNET", "True").lower() != "false"
    if not API_KEY or not API_SECRET: print(f"{Fore.RED}WARNING: API Keys not set. Using PLACEHOLDERS. Auth WILL FAIL.{Style.RESET_ALL}"); API_KEY = "PLACEHOLDER_KEY"; API_SECRET = "PLACEHOLDER_SECRET"
    example_config: Config = {
        'EXCHANGE_ID': 'bybit', 'API_KEY': API_KEY, 'API_SECRET': API_SECRET, 'TESTNET_MODE': USE_TESTNET, 'SYMBOL': 'BTC/USDT:USDT', 'USDT_SYMBOL': 'USDT',
        'DEFAULT_MARGIN_MODE': 'isolated', 'DEFAULT_RECV_WINDOW': 10000, 'DEFAULT_SLIPPAGE_PCT': Decimal('0.005'), 'POSITION_QTY_EPSILON': Decimal('1E-8'),
        'SHALLOW_OB_FETCH_DEPTH': 5, 'ORDER_BOOK_FETCH_LIMIT': 50, 'EXPECTED_MARKET_TYPE': 'swap', 'EXPECTED_MARKET_LOGIC': 'linear', 'RETRY_COUNT': 2, 'RETRY_DELAY_SECONDS': 1.0,
        'POS_NONE': 'NONE', 'POS_LONG': 'LONG', 'POS_SHORT': 'SHORT', 'SIDE_BUY': 'buy', 'SIDE_SELL': 'sell', 'MAKER_FEE_RATE': Decimal('0.0001'), 'TAKER_FEE_RATE': Decimal('0.0006') # Example fees
    }
    logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)-5s] %(name)-20s | %(message)s", datefmt="%H:%M:%S"); logging.getLogger(__name__).setLevel(logging.DEBUG); logging.getLogger("websockets").setLevel(logging.INFO); logging.getLogger("ccxt").setLevel(logging.INFO)

    async def run_example():
        print(f"\n{Style.BRIGHT}{Fore.CYAN}--- Running Example Usage (Testnet: {USE_TESTNET}) ---{Style.RESET_ALL}"); exchange = await initialize_bybit(example_config)
        if not exchange: print(f"{Back.RED} FATAL: Init fail. Exit. {Style.RESET_ALL}"); return
        try:
            print(f"\n{Fore.MAGENTA}--- 1. Basic Info ---{Style.RESET_ALL}")
            if API_KEY != "PLACEHOLDER_KEY": await fetch_usdt_balance(exchange, example_config)
            else: print(f"{Fore.YELLOW}Skip balance (no API keys).{Style.RESET_ALL}")
            if not await validate_market(exchange, example_config['SYMBOL'], example_config): print(f"{Fore.RED}Default symbol validation failed!{Style.RESET_ALL}")
            await fetch_ticker_validated(exchange, example_config['SYMBOL'], example_config)
            if pd: ohlcv = await fetch_ohlcv_paginated(exchange, example_config['SYMBOL'], '1m', limit=10); if ohlcv is not None and not ohlcv.empty: print(f"Fetched {len(ohlcv)} 1m candles:\n{ohlcv.tail(3)}")
            if API_KEY != "PLACEHOLDER_KEY":
                 print(f"\n{Fore.MAGENTA}--- 2. Auth Actions ---{Style.RESET_ALL}")
                 await set_leverage(exchange, example_config['SYMBOL'], 5, example_config) # Set 5x
                 pos = await get_current_position_bybit_v5(exchange, example_config['SYMBOL'], example_config); if pos: print(f"{Fore.YELLOW}Existing pos - closing...{Style.RESET_ALL}"); await close_position_reduce_only(exchange, example_config['SYMBOL'], example_config); await asyncio.sleep(2)
                 # Add more authenticated examples (orders, etc.) here
            else: print(f"\n{Fore.YELLOW}--- Skip Auth Actions (no API keys) ---{Style.RESET_ALL}")
            # Add WS Example if needed
        except Exception as e: logger.critical(f"{Back.RED} Example run error: {e} {Style.RESET_ALL}", exc_info=True)
        finally:
            if exchange and not exchange.closed: print(f"\n{Fore.CYAN}--- Closing Connection ---{Style.RESET_ALL}"); await exchange.close(); print("Connection closed.")
            # Final WS cleanup
            async with _ws_manage_lock:
                 for url, task in list(_websocket_tasks.items()):
                      if not task.done(): logger.warning(f"Force cancelling WS task {url}"); task.cancel()
                 for url, ws_conn in list(_active_websockets.items()):
                      if not ws_conn.closed: logger.warning(f"Force closing WS conn {url}"); await ws_conn.close()

    try: asyncio.run(run_example())
    except KeyboardInterrupt: print(f"\n{Fore.YELLOW}--- Interrupted ---{Style.RESET_ALL}")
    except Exception as main_err: logger.critical(f"Top Level Error: {main_err}", exc_info=True)
    print(f"\n{Style.BRIGHT}{Fore.GREEN}--- Standalone Example Finished ---{Style.RESET_ALL}")
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Bybit V5 CCXT Helper Functions (v3.0)

A robust, modular, and enhanced collection of helper functions for interacting with
the Bybit V5 API (Unified Trading Account) using the CCXT library.

Key Features:
- Logically grouped functions (can be split into submodules).
- Enhanced type safety with TypedDict, Enums, and precise hints.
- Performance optimizations via MarketCache for market data.
- Centralized asynchronous error handling and retry logic via decorator.
- Structured logging with conditional color support.
- Implemented features: Batch order placement, WebSocket streaming.
- Increased robustness and handling of Bybit V5 specifics.

Version: 3.0
"""

# Standard Library Imports
import logging
import os
import sys
import time
import random
import json
from decimal import Decimal, ROUND_HALF_UP, getcontext, InvalidOperation
from typing import (Optional, Dict, List, Tuple, Any, Literal, Union,
                    TypedDict, Callable, Coroutine)
from enum import Enum
import asyncio
import math

# Third-party Libraries
try:
    import ccxt.async_support as ccxt
    from ccxt.base.errors import (
        ExchangeError, NetworkError, RateLimitExceeded, AuthenticationError,
        OrderNotFound, InvalidOrder, InsufficientFunds, ExchangeNotAvailable,
        NotSupported
    )
except ImportError:
    print("FATAL ERROR: CCXT library not found.")
    print("Please install it: pip install ccxt>=2.0.0") # Specify a recent version
    sys.exit(1)
try:
    import pandas as pd
except ImportError:
    print("ERROR: pandas library not found.")
    print("Please install it: pip install pandas>=2.0.0")
    # Depending on usage, pandas might be optional, but fetch_ohlcv uses it.
    # Consider making OHLCV return list of lists if pandas is optional.
    pd = None # Allow script to run, but OHLCV will fail if called.
    # sys.exit(1) # Or exit if pandas is mandatory
try:
    from colorama import Fore, Style, Back, init
    # Initialize colorama on Windows
    if os.name == 'nt':
        init()
except ImportError:
    print("Warning: colorama not found. Logs will be uncolored.")
    print("Install for colored logs: pip install colorama")
    # Create dummy classes/objects if colorama is not found
    class DummyColor:
        def __getattr__(self, name: str) -> str: return ""
    Fore = Style = Back = DummyColor()
try:
    import websockets
    from websockets.exceptions import WebSocketException, ConnectionClosed, ConnectionClosedOK, ConnectionClosedError, InvalidURI
except ImportError:
    print("Warning: websockets library not found. WebSocket features disabled.")
    print("Install for WebSocket support: pip install websockets>=10.0")
    websockets = None # Set to None if not installed
    # Define dummy exception classes if websockets is None
    class DummyWebSocketException(Exception): pass
    WebSocketException = ConnectionClosed = ConnectionClosedOK = ConnectionClosedError = InvalidURI = DummyWebSocketException


# --- Configuration & Constants ---

# Set Decimal context precision (adjust if higher precision is needed)
getcontext().prec = 28

# Default configuration structure type
class Config(TypedDict):
    EXCHANGE_ID: Literal['bybit'] # Force 'bybit'
    API_KEY: str
    API_SECRET: str
    TESTNET_MODE: bool
    SYMBOL: str             # Default symbol, e.g., 'BTC/USDT:USDT'
    USDT_SYMBOL: str        # Typically 'USDT'
    DEFAULT_MARGIN_MODE: Literal['isolated', 'cross'] # Maps to Bybit's modes
    DEFAULT_RECV_WINDOW: int # Milliseconds for API request validity
    DEFAULT_SLIPPAGE_PCT: Decimal # e.g., Decimal('0.005') for 0.5%
    POSITION_QTY_EPSILON: Decimal # Small value for float comparisons, e.g., Decimal('1E-8')
    SHALLOW_OB_FETCH_DEPTH: int   # Depth for quick slippage check in analyze_order_book
    ORDER_BOOK_FETCH_LIMIT: int   # Max depth for full order book fetch (e.g., 50, 100, 200, 500)
    EXPECTED_MARKET_TYPE: Literal['swap', 'spot', 'option', 'future'] # Default expected type
    EXPECTED_MARKET_LOGIC: Literal['linear', 'inverse'] # Default expected logic for derivatives
    RETRY_COUNT: int # Number of retries for API calls
    # Optional fields can be added here if needed later

# Enums for type safety and clarity
class Side(str, Enum):
    BUY = "buy"
    SELL = "sell"

class Category(str, Enum):
    LINEAR = "linear"   # USDT Perpetual, USDC Perpetual, USDC Futures
    INVERSE = "inverse" # Inverse Contracts
    SPOT = "spot"       # Spot
    OPTION = "option"   # USDC Options

class OrderFilter(str, Enum):
    ORDER = "Order"             # Active Order (spot, linear, inverse)
    STOP_ORDER = "StopOrder"    # Conditional Order (spot, linear, inverse)
    TPSL_ORDER = "tpslOrder"    # TP/SL Order (UTA specific)
    # Add more filters if Bybit V5 introduces them (e.g., OCO, BatchOrder)

class TimeInForce(str, Enum):
    GTC = "GTC"         # Good Til Canceled
    IOC = "IOC"         # Immediate Or Cancel
    FOK = "FOK"         # Fill Or Kill
    POST_ONLY = "PostOnly" # Only Maker

class TriggerDirection(int, Enum):
    RISE = 1 # Trigger when price rises to triggerPrice
    FALL = 2 # Trigger when price falls to triggerPrice

class PositionIdx(int, Enum):
    ONE_WAY = 0
    BUY_SIDE = 1 # Hedge mode long
    SELL_SIDE = 2 # Hedge mode short

# --- Logger Setup ---
logger = logging.getLogger(__name__)
if not logger.hasHandlers():
    logger.setLevel(logging.DEBUG) # Set default level
    handler = logging.StreamHandler(sys.stdout)
    formatter = logging.Formatter(
        "%(asctime)s [%(levelname)s] {%(filename)s:%(lineno)d:%(funcName)s} - %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S"
    )
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    # logger.propagate = False # Uncomment if you don't want logs going to root logger


# --- Market Cache ---
class MarketCache:
    """ Caches market data fetched from the exchange to reduce API calls. """
    def __init__(self):
        self._markets: Dict[str, Dict[str, Any]] = {}
        self._categories: Dict[str, Optional[Category]] = {}
        self._lock = asyncio.Lock() # Lock for async safety when loading markets

    async def load_markets(self, exchange: ccxt.bybit, reload: bool = False):
        """ Loads or reloads all markets into the cache asynchronously and safely. """
        async with self._lock:
            if not self._markets or reload:
                logger.info(f"{Fore.BLUE}[MarketCache] {'Reloading' if reload else 'Loading'} markets...{Style.RESET_ALL}")
                try:
                    all_markets = await exchange.load_markets(reload=reload)
                    if not all_markets:
                         # This case indicates a severe issue with exchange connection or API response
                         logger.critical(f"{Back.RED}[MarketCache] Failed to load markets - Received empty market data from CCXT.{Style.RESET_ALL}")
                         # Decide on behavior: keep old cache (if any), clear, or raise error.
                         # Keeping old cache might be dangerous. Clearing is safer.
                         self._markets = {}
                         self._categories = {}
                         # Consider raising an exception here if market data is critical for operation
                         # raise ExchangeError("Failed to load markets: received empty data.")
                         return # Or simply return if non-critical

                    self._markets = all_markets
                    self._categories.clear() # Clear categories when markets reload
                    logger.success(f"{Fore.GREEN}[MarketCache] Loaded {len(self._markets)} markets successfully.{Style.RESET_ALL}")
                except (NetworkError, ExchangeNotAvailable) as e:
                    logger.error(f"{Fore.RED}[MarketCache] Network/Availability error loading markets: {e}{Style.RESET_ALL}")
                    # Don't clear cache here, retry might work later.
                except ExchangeError as e:
                    logger.error(f"{Fore.RED}[MarketCache] Exchange error loading markets: {e}{Style.RESET_ALL}", exc_info=True)
                    # Consider clearing cache on certain exchange errors if data becomes invalid
                except Exception as e:
                    logger.critical(f"{Back.RED}[MarketCache] Unexpected critical error loading markets: {e}{Style.RESET_ALL}", exc_info=True)
                    self._markets = {} # Clear cache on critical failure
                    self._categories = {}
                    # raise # Re-raise critical errors?

    def get_market(self, symbol: str) -> Optional[Dict[str, Any]]:
        """ Retrieves market data for a symbol from the cache. """
        market = self._markets.get(symbol)
        # if not market:
        #      logger.warning(f"[MarketCache] Market data for '{symbol}' not found in cache. Was load_markets called successfully?")
        return market

    def get_category(self, symbol: str) -> Optional[Category]:
        """ Retrieves the V5 category for a symbol from the cache. """
        if symbol not in self._categories:
            market = self.get_market(symbol)
            if market:
                category_str = _get_v5_category(market)
                try:
                    self._categories[symbol] = Category(category_str) if category_str else None
                except ValueError: # Handle case where _get_v5_category returns unexpected string
                     logger.error(f"[MarketCache] Invalid category value '{category_str}' returned for symbol '{symbol}'. Setting category to None.")
                     self._categories[symbol] = None
            else:
                self._categories[symbol] = None # Mark as None if market not found
        return self._categories[symbol]

    def get_all_symbols(self) -> List[str]:
        """ Returns a list of all symbols currently loaded in the cache. """
        return list(self._markets.keys())

# Initialize a global cache instance
market_cache = MarketCache()


# --- Utility Functions ---
# ============================
# MODULE: utils.py (Potential Split)
# ============================

def safe_decimal_conversion(value: Any, default: Optional[Decimal] = None) -> Optional[Decimal]:
    """ Safely converts a value to Decimal, handling None, strings, ints, floats. """
    if value is None or value == '':
        return default
    try:
        # Ensure conversion via string to handle floats accurately
        d = Decimal(str(value))
        # Check for NaN or Infinity which are invalid in many contexts
        if d.is_nan() or d.is_infinite():
            logger.warning(f"[safe_decimal_conversion] Value '{value}' results in NaN or Infinity.")
            return default
        # Optional: Quantize to a reasonable precision if needed globally
        # return d.quantize(Decimal('1E-8'), rounding=ROUND_HALF_UP)
        return d
    except (ValueError, TypeError, InvalidOperation):
        # logger.warning(f"[safe_decimal_conversion] Could not convert '{value}' (type: {type(value)}) to Decimal.") # Can be noisy
        return default

def format_price(exchange: ccxt.bybit, symbol: str, price: Optional[Union[Decimal, float, str]]) -> Optional[str]:
    """ Formats a price according to the market's precision using the cache. """
    if price is None: return None
    market = market_cache.get_market(symbol)
    if not market:
        logger.warning(f"[format_price] Market data for {symbol} not found. Cannot determine precision.")
        return str(price) # Return as string, potentially imprecise

    price_decimal = safe_decimal_conversion(price)
    if price_decimal is None:
        logger.error(f"[format_price] Invalid price value '{price}' for {symbol}.")
        return None

    try:
        # Use CCXT's price_to_precision for correct formatting rules
        return exchange.price_to_precision(symbol, float(price_decimal))
    except Exception as e:
        logger.error(f"[format_price] Error formatting price {price_decimal} for {symbol}: {e}", exc_info=True)
        # Fallback to simple string formatting if CCXT method fails unexpectedly
        prec = market.get('precision', {}).get('price', 8) # Default 8 decimals
        try:
             return f"{price_decimal:.{prec}f}"
        except Exception:
             return str(price_decimal) # Absolute fallback

def format_amount(exchange: ccxt.bybit, symbol: str, amount: Optional[Union[Decimal, float, str]]) -> Optional[str]:
    """ Formats an amount according to the market's precision using the cache. """
    if amount is None: return None
    market = market_cache.get_market(symbol)
    if not market:
        logger.warning(f"[format_amount] Market data for {symbol} not found. Cannot determine precision.")
        return str(amount)

    amount_decimal = safe_decimal_conversion(amount)
    if amount_decimal is None:
        logger.error(f"[format_amount] Invalid amount value '{amount}' for {symbol}.")
        return None

    try:
        # Use CCXT's amount_to_precision
        return exchange.amount_to_precision(symbol, float(amount_decimal))
    except Exception as e:
        logger.error(f"[format_amount] Error formatting amount {amount_decimal} for {symbol}: {e}", exc_info=True)
        prec = market.get('precision', {}).get('amount', 8) # Default 8 decimals
        try:
             return f"{amount_decimal:.{prec}f}"
        except Exception:
             return str(amount_decimal)

def format_order_id(order_id: Optional[str]) -> str:
    """ Returns a truncated version of the order ID for cleaner logging. """
    if not order_id: return "N/A"
    return order_id[-8:] if len(order_id) > 8 else order_id

def send_sms_alert(message: str, config: Optional[Config] = None) -> None:
    """ Placeholder for sending SMS alerts via a service (e.g., Twilio). """
    logger.warning(f"{Back.YELLOW}{Fore.BLACK}[SMS Alert Placeholder]{Style.RESET_ALL} >> {message}")
    # Add actual SMS integration here if needed, using config for credentials/numbers

def _get_v5_category(market: Dict[str, Any]) -> Optional[str]:
    """
    Internal helper to determine the Bybit V5 API 'category' based on CCXT market info.
    Prioritizes explicit CCXT flags, then infers from type and naming conventions.
    Returns the category string (e.g., 'linear', 'spot') or None if indeterminable.
    """
    if not market:
        # logger.warning("[_get_v5_category] Received empty market data.") # Can be noisy
        return None

    # 1. Check explicit CCXT flags (most reliable)
    if market.get('spot', False): return Category.SPOT.value
    if market.get('option', False): return Category.OPTION.value
    if market.get('linear', False): return Category.LINEAR.value
    if market.get('inverse', False): return Category.INVERSE.value

    # 2. Infer from 'type' and other info if explicit flags are missing
    market_type = market.get('type')
    symbol = market.get('symbol', 'N/A')
    # logger.debug(f"[_get_v5_category] Inferring category for '{symbol}'. Type: {market_type}, Info: {market.get('info', {})}")

    if market_type == 'spot':
        return Category.SPOT.value
    elif market_type == 'option':
        # Ensure it's USDC option as Bybit V5 primarily supports that
        if market.get('settle', '').upper() == 'USDC':
            return Category.OPTION.value
        else:
            logger.warning(f"[_get_v5_category] Unsupported option type for {symbol} (settle: {market.get('settle')}). V5 expects USDC options.")
            return None
    elif market_type in ['swap', 'future']:
        # For derivatives, determine linear vs inverse
        settle_asset = market.get('settle', '').upper()
        base_asset = market.get('base', '').upper()
        quote_asset = market.get('quote', '').upper()
        info = market.get('info', {})

        # Check info fields that might explicitly state it
        contract_type = str(info.get('contractType', '')).lower()
        if contract_type == 'linear': return Category.LINEAR.value
        if contract_type == 'inverse': return Category.INVERSE.value

        # Infer based on settle currency (common convention)
        if settle_asset in ['USDT', 'USDC'] or info.get('settleCoin') in ['USDT', 'USDC']:
            return Category.LINEAR.value
        # Infer if settle is base (characteristic of inverse)
        # Caution: This might not hold for all exchanges/contracts
        elif settle_asset == base_asset and settle_asset:
             return Category.INVERSE.value
        # Final guess based on quote currency containing USDT/USD (less reliable)
        elif 'USD' in quote_asset: # Includes USDT, USDC, USD pairs
             logger.debug(f"[_get_v5_category] Assuming LINEAR for {symbol} based on 'USD' in quote asset.")
             return Category.LINEAR.value
        else:
            logger.warning(f"[_get_v5_category] Could not reliably determine category for derivative {symbol} (Type: {market_type}, Settle: {settle_asset}). Needs verification.")
            return None # Cannot determine
    else:
        logger.warning(f"[_get_v5_category] Unknown or unsupported market type '{market_type}' for symbol {symbol}.")
        return None


# --- Asynchronous Retry Decorator ---
def retry_api_call(
    max_retries: int = 3,
    initial_delay: float = 1.0, # seconds
    backoff_factor: float = 2.0,
    jitter: float = 0.1, # +/- 10% jitter
    retry_on_exceptions: Tuple[type[Exception], ...] = (
        NetworkError, RateLimitExceeded, ExchangeNotAvailable, # Common transient errors
        # Add specific exchange errors if they are known to be retryable
        # e.g., Bybit specific temporary system errors if identifiable by code/message
    )
):
    """
    Asynchronous decorator to automatically retry a function call on specific exceptions
    with exponential backoff and jitter.

    Args:
        max_retries: Maximum number of retries (default: 3). 0 means no retries.
        initial_delay: Delay before the first retry in seconds (default: 1.0).
        backoff_factor: Multiplier for the delay in each subsequent retry (default: 2.0).
        jitter: Factor for randomizing delay (+/- jitter * delay) (default: 0.1).
        retry_on_exceptions: Tuple of exception types to catch and retry on.
    """
    def decorator(func: Callable[..., Coroutine[Any, Any, Any]]):
        async def async_wrapper(*args, **kwargs):
            retries = kwargs.pop('retries', max_retries) # Allow overriding retries per call if needed
            current_delay = initial_delay
            last_exception: Optional[Exception] = None

            for attempt in range(retries + 1): # Total attempts = 1 initial + max_retries
                try:
                    # logger.debug(f"Attempt {attempt + 1}/{retries + 1} calling {func.__name__}")
                    return await func(*args, **kwargs)
                except retry_on_exceptions as e:
                    last_exception = e
                    if attempt == retries:
                        logger.error(f"{Fore.RED}[{func.__name__}] Max retries ({retries}) reached. Last error: {type(e).__name__}: {e}{Style.RESET_ALL}")
                        raise # Re-raise the last caught retryable exception
                    else:
                        # Calculate delay with backoff and jitter
                        actual_jitter = random.uniform(-jitter, jitter)
                        wait_time = current_delay + (current_delay * actual_jitter)
                        logger.warning(f"{Fore.YELLOW}[{func.__name__}] Attempt {attempt+1}/{retries+1} failed: {type(e).__name__}. Retrying in {wait_time:.2f}s...{Style.RESET_ALL}")
                        await asyncio.sleep(wait_time)
                        current_delay *= backoff_factor # Increase delay for next potential retry
                except Exception as e:
                    # Catch other unexpected exceptions, log, and re-raise immediately (don't retry)
                    logger.error(f"{Fore.RED}[{func.__name__}] Unhandled exception during attempt {attempt+1}: {type(e).__name__}: {e}{Style.RESET_ALL}", exc_info=True)
                    raise # Re-raise unexpected exceptions

            # Should only be reached if max_retries is 0 and the first attempt failed with a retryable exception
            if last_exception:
                 raise last_exception
            # Fallback if logic somehow allows reaching here without an exception (should not happen)
            return None

        # Preserve original function signature etc. for introspection
        async_wrapper.__name__ = func.__name__
        async_wrapper.__doc__ = func.__doc__
        # Consider using functools.wraps if preserving more metadata is needed
        return async_wrapper
    return decorator


# --- Exchange Initialization & Configuration ---
# ============================
# MODULE: exchange.py (Potential Split)
# ============================

@retry_api_call(max_retries=2, initial_delay=3.0, retry_on_exceptions=(NetworkError, ExchangeNotAvailable)) # Retry init on network issues
async def initialize_bybit(config: Config) -> Optional[ccxt.bybit]:
    """
    Initializes the Bybit CCXT exchange instance for V5 API.

    Args:
        config: Configuration dictionary adhering to the Config TypedDict structure.

    Returns:
        Configured `ccxt.async_support.bybit` instance or None if initialization fails.
    """
    func_name = "initialize_bybit"
    logger.info(f"{Fore.BLUE}[{func_name}] Initializing Bybit V5 ({'Testnet' if config['TESTNET_MODE'] else 'Mainnet'})...{Style.RESET_ALL}")
    exchange: Optional[ccxt.bybit] = None # Define exchange variable outside try block

    try:
        if not config.get('API_KEY') or not config.get('API_SECRET'):
             logger.warning(f"{Fore.YELLOW}[{func_name}] API Key or Secret not provided. Initializing in public-only mode.{Style.RESET_ALL}")
             # Allow initialization without keys for public endpoints, but log clearly.
             # Authenticated calls will fail later if keys are missing.

        exchange_options = {
            'apiKey': config.get('API_KEY'), # Use .get() to handle missing keys gracefully
            'secret': config.get('API_SECRET'),
            'enableRateLimit': True,
            'options': {
                'defaultType': config['EXPECTED_MARKET_TYPE'],
                'adjustForTimeDifference': True,
                'recvWindow': config['DEFAULT_RECV_WINDOW'],
                'brokerId': 'PB_PyrmethusV3', # Unique ID for tracking via Bybit Broker program
                # V5 Specific options if needed (though CCXT usually handles defaults)
                # 'api-expires': str(int(time.time() * 1000 + config['DEFAULT_RECV_WINDOW'])), # Sometimes needed? CCXT handles usually.
                # 'verbose': True, # Uncomment for very detailed CCXT logging
            }
        }

        # Instantiate the exchange using ccxt.async_support
        exchange = ccxt.bybit(exchange_options)

        if config['TESTNET_MODE']:
            exchange.set_sandbox_mode(True)
            logger.info(f"[{func_name}] Sandbox mode enabled (API endpoint: {exchange.urls['api']}).")
        else:
             logger.info(f"[{func_name}] Mainnet mode enabled (API endpoint: {exchange.urls['api']}).")


        # --- Load markets and perform checks ---
        # Load markets into exchange instance and our cache
        await market_cache.load_markets(exchange, reload=True) # Force reload on init
        if not market_cache.get_market(config['SYMBOL']): # Check if default symbol loaded
            logger.critical(f"{Back.RED}[{func_name}] Failed to load market data for default symbol '{config['SYMBOL']}'. Check symbol format and connectivity.{Style.RESET_ALL}")
            # Attempt to close exchange if partially initialized
            if exchange: await exchange.close()
            return None

        # Perform connectivity check ONLY if API keys are present
        if config.get('API_KEY') and config.get('API_SECRET'):
            logger.info(f"[{func_name}] Performing authenticated connectivity check (fetching balance)...")
            try:
                # Fetch balance for UNIFIED account type. Adjust if using SPOT/CONTRACT.
                await exchange.fetch_balance(params={'accountType': 'UNIFIED'})
                logger.info(f"[{func_name}] Authenticated connectivity check passed.")
            except AuthenticationError as auth_err:
                 logger.critical(f"{Back.RED}[{func_name}] Authentication failed during connectivity check: {auth_err}. Check API key/secret.{Style.RESET_ALL}")
                 send_sms_alert(f"[BybitHelper] CRITICAL: Auth failed during init check!", config)
                 if exchange: await exchange.close()
                 return None
            except ExchangeError as bal_err: # Catch other errors during balance fetch
                 logger.warning(f"{Fore.YELLOW}[{func_name}] Connectivity check warning (fetch_balance failed): {bal_err}. Proceeding, but account access might be limited.{Style.RESET_ALL}")
                 # Decide if this should be a critical failure depending on requirements
        else:
             logger.info(f"[{func_name}] Skipping authenticated connectivity check (API keys not provided).")

        # --- Set default margin mode/leverage for the primary symbol ---
        default_symbol = config['SYMBOL']
        category = market_cache.get_category(default_symbol)
        if category in [Category.LINEAR, Category.INVERSE] and config.get('API_KEY'):
            logger.info(f"[{func_name}] Attempting to configure default margin/leverage for {default_symbol}...")
            try:
                if config['DEFAULT_MARGIN_MODE'] == 'isolated':
                    # Setting leverage implicitly sets isolated mode for the symbol in V5
                    initial_leverage = 10 # Default leverage, consider adding to Config
                    logger.info(f"[{func_name}] Setting isolated margin via leverage ({initial_leverage}x) for {default_symbol}.")
                    await set_leverage(exchange, default_symbol, initial_leverage, config)
                else: # cross margin ('REGULAR_MARGIN' in V5)
                    # Cross margin is often account-wide for UTA, less direct control per symbol.
                    # We might ensure leverage isn't explicitly set (which implies isolated)
                    # or try to switch account mode if an API exists (less common via CCXT)
                    logger.info(f"[{func_name}] Cross margin ('{config['DEFAULT_MARGIN_MODE']}') selected. Mode is typically account-level for UTA.")
                    # Verify if any specific action needed for cross mode setup. Often it's the default.
                    # Example: Check if set_margin_mode works for V5 cross
                    # try:
                    #     await exchange.set_margin_mode('cross', symbol=default_symbol, params={'category': category.value})
                    # except Exception as mm_err:
                    #     logger.warning(f"Could not explicitly set cross margin mode via set_margin_mode: {mm_err}")
            except Exception as e:
                logger.warning(f"{Fore.YELLOW}[{func_name}] Could not pre-set margin mode/leverage for {default_symbol}: {type(e).__name__}. Manual setup or config adjustment might be needed.{Style.RESET_ALL}")
        elif not config.get('API_KEY'):
             logger.info(f"[{func_name}] Skipping default margin/leverage setup (API keys not provided).")


        logger.success(f"{Fore.GREEN}[{func_name}] Bybit V5 exchange initialized successfully.{Style.RESET_ALL}")
        return exchange

    # --- Exception Handling for Initialization ---
    except AuthenticationError as e:
        # This might happen if keys are wrong during initial class instantiation too
        logger.critical(f"{Back.RED}[{func_name}] Authentication failed during initialization: {e}. Check API key and secret.{Style.RESET_ALL}")
        send_sms_alert(f"[BybitHelper] CRITICAL: Auth failed!", config)
    except (NetworkError, ExchangeNotAvailable) as e:
         # These were already handled by retry, so if they reach here, retries failed.
         logger.critical(f"{Back.RED}[{func_name}] Network error during initialization after retries: {e}. Check connection.{Style.RESET_ALL}")
    except ExchangeError as e:
        # Catch other CCXT exchange errors
        logger.critical(f"{Back.RED}[{func_name}] Exchange error during initialization: {e}{Style.RESET_ALL}", exc_info=True)
        send_sms_alert(f"[BybitHelper] CRITICAL: Init ExchangeError: {type(e).__name__}", config)
    except Exception as e:
        # Catch any other unexpected Python errors
        logger.critical(f"{Back.RED}[{func_name}] Unexpected critical error during initialization: {e}{Style.RESET_ALL}", exc_info=True)
        send_sms_alert(f"[BybitHelper] CRITICAL: Init Unexpected Error: {type(e).__name__}", config)

    # Ensure cleanup if initialization failed after instance creation
    if exchange:
        try:
            logger.info(f"[{func_name}] Closing potentially partially initialized exchange instance due to error.")
            await exchange.close()
        except Exception as close_err:
             logger.error(f"[{func_name}] Error closing exchange instance during cleanup: {close_err}")
    return None


# --- Account Functions ---
# ============================
# MODULE: account.py (Potential Split)
# ============================

@retry_api_call(max_retries=3, initial_delay=1.0)
async def set_leverage(exchange: ccxt.bybit, symbol: str, leverage: int, config: Config) -> bool:
    """
    Sets the leverage for a specific symbol (Linear or Inverse contracts).

    Args:
        exchange: Initialized `ccxt.async_support.bybit` instance.
        symbol: Market symbol (e.g., 'BTC/USDT:USDT').
        leverage: Desired integer leverage level (e.g., 10 for 10x).
        config: Configuration object.

    Returns:
        True if leverage was set successfully or was already set to the desired value.
        False otherwise.

    Note:
        Bybit V5 requires `buyLeverage` and `sellLeverage` parameters.
        Setting leverage implicitly sets the margin mode to ISOLATED for that symbol.
    """
    func_name = "set_leverage"
    log_prefix = f"[{func_name}] Set Leverage ({symbol} -> {leverage}x)"

    if leverage <= 0:
        logger.error(f"{Fore.RED}{log_prefix}: Invalid leverage value: {leverage}. Must be > 0.{Style.RESET_ALL}")
        return False

    category = market_cache.get_category(symbol)
    if not category or category not in [Category.LINEAR, Category.INVERSE]:
        logger.error(f"{Fore.RED}{log_prefix}: Leverage can only be set for LINEAR or INVERSE contracts. Category for {symbol} is {category}.{Style.RESET_ALL}")
        return False

    market = market_cache.get_market(symbol)
    if not market:
         logger.error(f"{Fore.RED}{log_prefix}: Market data for {symbol} not found. Cannot validate or set leverage.{Style.RESET_ALL}")
         return False

    # Validate against market limits if available in cache info
    try:
        limits_leverage = market.get('limits', {}).get('leverage', {})
        max_leverage = safe_decimal_conversion(limits_leverage.get('max'), Decimal('100')) # Default reasonable max
        min_leverage = safe_decimal_conversion(limits_leverage.get('min'), Decimal('1'))   # Default 1
        if max_leverage is None or min_leverage is None:
             raise ValueError("Leverage limits not found or invalid in market data.")

        if not (min_leverage <= leverage <= max_leverage):
            logger.error(f"{Fore.RED}{log_prefix}: Leverage {leverage}x is outside the allowed range [{min_leverage}x - {max_leverage}x] for {symbol}.{Style.RESET_ALL}")
            return False
    except Exception as e:
         logger.warning(f"{Fore.YELLOW}{log_prefix}: Could not reliably parse leverage limits for {symbol}: {e}. Proceeding with caution.{Style.RESET_ALL}")

    # Bybit V5 requires buyLeverage and sellLeverage
    params = {
        'category': category.value,
        'buyLeverage': str(leverage),
        'sellLeverage': str(leverage)
    }
    logger.info(f"{Fore.CYAN}{log_prefix}: Sending request with params: {params}...{Style.RESET_ALL}")

    try:
        response = await exchange.set_leverage(leverage, symbol, params=params)
        logger.debug(f"{log_prefix}: Raw response: {response}")
        logger.success(f"{Fore.GREEN}{log_prefix}: Leverage successfully set to {leverage}x. (Implicitly ISOLATED mode).{Style.RESET_ALL}")
        return True
    except ExchangeError as e:
        error_str = str(e).lower()
        # Bybit error codes: 110043 (Leverage not modified), 110025 (Leverage invalid range)
        if "leverage not modified" in error_str or "110043" in str(e):
            logger.info(f"{Fore.YELLOW}{log_prefix}: Leverage for {symbol} is already {leverage}x.{Style.RESET_ALL}")
            return True
        elif "position idx" in error_str or "110021" in str(e):
             logger.error(f"{Fore.RED}{log_prefix}: Failed: {e}. This might relate to position mode (Hedge/One-way). Ensure consistency.{Style.RESET_ALL}")
             return False
        else:
            logger.error(f"{Fore.RED}{log_prefix}: Failed with ExchangeError: {e}{Style.RESET_ALL}", exc_info=True)
            return False
    except NetworkError as e:
         logger.warning(f"{Fore.YELLOW}{log_prefix}: Network error: {e}. Retry handled by decorator.{Style.RESET_ALL}")
         raise # Let decorator handle retry
    except Exception as e:
        logger.error(f"{Fore.RED}{log_prefix}: Failed with Unexpected Error: {e}{Style.RESET_ALL}", exc_info=True)
        return False


@retry_api_call(max_retries=3, initial_delay=1.0)
async def fetch_usdt_balance(exchange: ccxt.bybit, config: Config) -> Tuple[Optional[Decimal], Optional[Decimal]]:
    """
    Fetches USDT equity and available balance from the Bybit V5 UNIFIED account.

    Args:
        exchange: Initialized `ccxt.async_support.bybit` instance.
        config: Configuration object (used for USDT symbol).

    Returns:
        Tuple of (total_equity, available_balance) as Decimals, or (None, None) on critical failure.
        Returns (Decimal(0), Decimal(0)) if balance is zero or USDT info not found but call succeeded.
    """
    func_name = "fetch_usdt_balance"
    log_prefix = f"[{func_name}] Fetch USDT Balance"
    usdt_symbol = config['USDT_SYMBOL'] # e.g., 'USDT'

    logger.debug(f"{log_prefix}: Fetching balance for UNIFIED account...")
    try:
        balance_data = await exchange.fetch_balance(params={'accountType': 'UNIFIED'})
        # logger.debug(f"{log_prefix}: Raw balance data: {balance_data}")

        total_equity: Optional[Decimal] = None
        available_balance: Optional[Decimal] = None

        # --- Parsing Logic ---
        # Primary Method: Use 'info' structure from V5 response
        info_list = balance_data.get('info', {}).get('result', {}).get('list', [])
        if info_list:
            unified_account_info = next((acc for acc in info_list if acc.get('accountType') == 'UNIFIED'), None)
            if unified_account_info:
                total_equity = safe_decimal_conversion(unified_account_info.get('totalEquity'))
                logger.debug(f"{log_prefix}: Equity from info.totalEquity: {total_equity}")

                coin_list = unified_account_info.get('coin', [])
                usdt_coin_info = next((coin for coin in coin_list if coin.get('coin') == usdt_symbol), None)
                if usdt_coin_info:
                    # V5 fields: availableToWithdraw, walletBalance
                    available_str = usdt_coin_info.get('availableToWithdraw') # Preferred field
                    if available_str is None:
                         available_str = usdt_coin_info.get('availableBalance') # Fallback - check if this exists
                    if available_str is None:
                        available_str = usdt_coin_info.get('walletBalance') # Alternative fallback

                    available_balance = safe_decimal_conversion(available_str)
                    logger.debug(f"{log_prefix}: Available from info.coin ('{available_str}'): {available_balance}")
                else:
                    logger.warning(f"{log_prefix}: '{usdt_symbol}' coin data not found within UNIFIED account info.")
            else:
                 logger.warning(f"{log_prefix}: UNIFIED account details not found in info.result.list.")
        else:
            logger.warning(f"{log_prefix}: info.result.list is empty or not present in balance response.")


        # Fallback Method: Use top-level CCXT structure if 'info' parsing failed
        if total_equity is None:
            if usdt_symbol in balance_data:
                 total_equity = safe_decimal_conversion(balance_data[usdt_symbol].get('total'))
                 logger.debug(f"{log_prefix}: Equity from top-level '{usdt_symbol}'.total: {total_equity}")

        if available_balance is None:
             if usdt_symbol in balance_data:
                 available_balance = safe_decimal_conversion(balance_data[usdt_symbol].get('free'))
                 logger.debug(f"{log_prefix}: Available from top-level '{usdt_symbol}'.free: {available_balance}")

        # --- Final Validation and Return ---
        if total_equity is None:
             logger.warning(f"{log_prefix}: Could not determine total USDT equity after parsing attempts.")
             total_equity = Decimal("0.0") # Default to 0 if completely unavailable but call succeeded

        if available_balance is None:
             logger.warning(f"{log_prefix}: Could not determine available USDT balance after parsing attempts.")
             available_balance = Decimal("0.0") # Default to 0

        # Ensure non-negative values
        total_equity = max(Decimal("0.0"), total_equity)
        available_balance = max(Decimal("0.0"), available_balance)

        logger.info(f"{Fore.GREEN}{log_prefix}: Success - Equity: {total_equity:.4f} {usdt_symbol}, Available: {available_balance:.4f} {usdt_symbol}{Style.RESET_ALL}")
        return total_equity, available_balance

    except AuthenticationError as e:
         logger.error(f"{Fore.RED}{log_prefix}: Authentication error: {e}{Style.RESET_ALL}")
         return None, None # Critical failure
    except (NetworkError, ExchangeNotAvailable) as e:
        logger.warning(f"{Fore.YELLOW}{log_prefix}: Network/Availability error: {e}. Retry handled by decorator.{Style.RESET_ALL}")
        raise # Let decorator handle retry
    except ExchangeError as e:
        logger.error(f"{Fore.RED}{log_prefix}: Exchange error: {e}{Style.RESET_ALL}", exc_info=True)
        return None, None # Treat as critical failure for balance check
    except Exception as e:
        logger.error(f"{Fore.RED}{log_prefix}: Unexpected error: {e}{Style.RESET_ALL}", exc_info=True)
        return None, None # Critical failure

# --- Market Data Functions ---
# ============================
# MODULE: market_data.py (Potential Split)
# ============================

@retry_api_call()
async def fetch_ohlcv_paginated(
    exchange: ccxt.bybit,
    symbol: str,
    timeframe: str,
    since: Optional[int] = None, # Timestamp in milliseconds
    limit: Optional[int] = None, # Number of candles per request
    config: Config = None # Pass config for retry count etc.
) -> Optional[pd.DataFrame]:
    """
    Fetches OHLCV data for a given symbol and timeframe, handling pagination.

    Args:
        exchange: Initialized `ccxt.async_support.bybit` instance.
        symbol: Market symbol (e.g., 'BTC/USDT:USDT').
        timeframe: Timeframe string (e.g., '1m', '5m', '1h', '1d').
        since: Start time timestamp in milliseconds (optional).
        limit: Number of candles per API request (Bybit V5 max is 1000, default here 1000).
        config: Configuration object (used for retry settings).

    Returns:
        A pandas DataFrame containing OHLCV data sorted by timestamp,
        or None if fetching fails critically or pandas is not installed.
    """
    func_name = "fetch_ohlcv_paginated"
    log_prefix = f"[{func_name} ({symbol}, {timeframe})]"

    if pd is None:
        logger.error(f"{Fore.RED}{log_prefix}: 'pandas' library is not installed. Cannot return DataFrame.{Style.RESET_ALL}")
        return None

    market = market_cache.get_market(symbol)
    if not market:
        logger.error(f"{Fore.RED}{log_prefix}: Market '{symbol}' not found in cache.{Style.RESET_ALL}")
        return None

    category = market_cache.get_category(symbol)
    if not category:
        logger.error(f"{Fore.RED}{log_prefix}: Category not found for '{symbol}'.{Style.RESET_ALL}")
        return None

    fetch_limit = min(limit, 1000) if limit is not None else 1000 # Ensure limit <= 1000
    all_candles = []
    current_since = since
    max_loops = 200 # Safety break to prevent infinite loops in unexpected scenarios
    loops = 0
    retries = config['RETRY_COUNT'] if config else 3

    logger.info(f"{Fore.BLUE}{log_prefix}: Fetching OHLCV, Limit per call: {fetch_limit}...{Style.RESET_ALL}")

    params = {'category': category.value}
    # Determine if market is inverse for potential volume adjustment (optional)
    is_inverse = category == Category.INVERSE

    try:
        while loops < max_loops:
            loops += 1
            logger.debug(f"{log_prefix}: Loop {loops}/{max_loops}, Fetching since={current_since} (datetime: {pd.to_datetime(current_since, unit='ms', errors='coerce') if current_since else 'None'}), limit={fetch_limit}")

            # Define the inner fetch function for the retry decorator
            @retry_api_call(max_retries=retries, initial_delay=1.5)
            async def fetch_candles_with_retry(since_ts):
                 # logger.debug(f"Calling exchange.fetch_ohlcv(symbol={symbol}, timeframe={timeframe}, since={since_ts}, limit={fetch_limit}, params={params})")
                 return await exchange.fetch_ohlcv(symbol, timeframe, since=since_ts, limit=fetch_limit, params=params)

            candles = await fetch_candles_with_retry(current_since)

            if not candles: # No more data returned or initial fetch failed after retries
                logger.info(f"{log_prefix}: No more candles returned from API. Fetch complete.")
                break

            # Filter out potential duplicates if 'since' logic isn't perfect
            if all_candles and candles[0][0] <= all_candles[-1][0]:
                 candles = [c for c in candles if c[0] > all_candles[-1][0]]
                 if not candles:
                     logger.debug(f"{log_prefix}: All fetched candles were duplicates or older. Stopping.")
                     break # Stop if only duplicates were received

            all_candles.extend(candles)
            last_timestamp = candles[-1][0]
            first_timestamp = candles[0][0]
            logger.info(f"{log_prefix}: Fetched {len(candles)} candles. Range: {pd.to_datetime(first_timestamp, unit='ms')} to {pd.to_datetime(last_timestamp, unit='ms')}")

            # Calculate 'since' for the next iteration (start from the timestamp AFTER the last received candle)
            current_since = last_timestamp + 1 # Millisecond precision needed? Check timeframe granularity

            # Optional: Add delay between paginated requests to respect rate limits further
            await asyncio.sleep(exchange.rateLimit / 1000 if exchange.enableRateLimit else 0.2) # Use CCXT rateLimit or default

            # Stop if we fetched less than the limit asked for (usually indicates end of data)
            if len(candles) < fetch_limit:
                logger.info(f"{log_prefix}: Fetched less than limit ({len(candles)} < {fetch_limit}). Assuming end of available data.")
                break

        logger.info(f"{log_prefix}: Total raw candles fetched: {len(all_candles)}")

        if not all_candles:
            logger.warning(f"{log_prefix}: No candles found for the specified parameters.")
            return pd.DataFrame()

        # --- Convert to DataFrame and Process ---
        df = pd.DataFrame(all_candles, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        df['datetime'] = pd.to_datetime(df['timestamp'], unit='ms')
        df.set_index('datetime', inplace=True)

        # Convert columns to appropriate numeric types (prefer Decimal via object, fallback float)
        for col in ['open', 'high', 'low', 'close', 'volume']:
             try:
                 # Attempt direct conversion to float first (often sufficient)
                 df[col] = pd.to_numeric(df[col], errors='coerce')
                 # Optional: Convert to Decimal if high precision needed
                 # df[col] = df[col].apply(lambda x: safe_decimal_conversion(x) if pd.notna(x) else None)
             except Exception as conv_err:
                  logger.warning(f"{log_prefix}: Error converting column '{col}' to numeric: {conv_err}. Leaving as object.")

        # Handle potential volume differences for inverse contracts (Volume is in Base currency)
        # if is_inverse:
        #     logger.debug(f"{log_prefix}: Adjusting volume for inverse contract (volume is in base currency).")
            # If caller expects volume in Quote currency, calculation needed: volume_quote = volume_base * average_price
            # This is complex and might be better handled by the caller. Sticking to raw volume for now.

        # Remove exact duplicates based on index (timestamp)
        initial_len = len(df)
        df = df[~df.index.duplicated(keep='first')]
        if len(df) < initial_len:
             logger.debug(f"{log_prefix}: Removed {initial_len - len(df)} duplicate timestamp entries.")

        # Ensure DataFrame is sorted chronologically
        df.sort_index(inplace=True)

        logger.success(f"{Fore.GREEN}{log_prefix}: Successfully processed {len(df)} unique OHLCV candles.{Style.RESET_ALL}")
        return df

    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e:
         logger.error(f"{Fore.RED}{log_prefix}: API communication error after retries: {type(e).__name__}: {e}{Style.RESET_ALL}", exc_info=True)
         # Return partial data if any was fetched
    except ExchangeError as e:
         logger.error(f"{Fore.RED}{log_prefix}: Exchange error during fetch: {e}{Style.RESET_ALL}", exc_info=True)
    except Exception as e:
         logger.error(f"{Fore.RED}{log_prefix}: Unexpected error: {e}{Style.RESET_ALL}", exc_info=True)

    # If errors occurred, try to return partial data
    if all_candles:
        logger.warning(f"{log_prefix}: Returning partial data ({len(all_candles)} candles) due to error.")
        try:
            df = pd.DataFrame(all_candles, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['datetime'] = pd.to_datetime(df['timestamp'], unit='ms')
            df.set_index('datetime', inplace=True)
            for col in ['open', 'high', 'low', 'close', 'volume']:
                 df[col] = pd.to_numeric(df[col], errors='coerce')
            df = df[~df.index.duplicated(keep='first')]
            df.sort_index(inplace=True)
            return df
        except Exception as final_proc_err:
             logger.error(f"{Fore.RED}{log_prefix}: Error processing partial data: {final_proc_err}{Style.RESET_ALL}")
             return None # Cannot even process partial data
    else:
        return None # No data fetched or processed

@retry_api_call()
async def fetch_ticker_validated(exchange: ccxt.bybit, symbol: str, config: Config) -> Optional[Dict]:
    """ Fetches ticker data and performs basic validation on timestamp and key fields. """
    func_name = "fetch_ticker_validated"
    log_prefix = f"[{func_name} ({symbol})]"
    logger.debug(f"{log_prefix}: Fetching ticker...")

    category = market_cache.get_category(symbol)
    if not category:
         logger.error(f"{Fore.RED}{log_prefix}: Cannot determine category.{Style.RESET_ALL}")
         return None

    params = {'category': category.value}
    try:
        ticker = await exchange.fetch_ticker(symbol, params=params)

        # --- Validation ---
        required_keys = ['symbol', 'timestamp', 'datetime', 'high', 'low', 'bid', 'ask', 'last', 'change', 'percentage', 'average', 'quoteVolume']
        missing_keys = [key for key in required_keys if key not in ticker or ticker[key] is None]
        if missing_keys:
             logger.warning(f"{Fore.YELLOW}{log_prefix}: Fetched ticker is missing keys: {missing_keys}. Data: {ticker}{Style.RESET_ALL}")
             # Decide if this is critical - maybe allow if 'last', 'bid', 'ask' are present?
             if not all(k in ticker for k in ['last', 'bid', 'ask']): return None


        # Timestamp validation (check if reasonably recent)
        current_time_ms = int(time.time() * 1000)
        ticker_time_ms = ticker.get('timestamp')
        max_allowed_diff_ms = 60 * 1000 # 60 seconds tolerance

        if ticker_time_ms and isinstance(ticker_time_ms, int):
             time_diff = abs(current_time_ms - ticker_time_ms)
             if time_diff > max_allowed_diff_ms:
                  logger.warning(f"{Fore.YELLOW}{log_prefix}: Ticker timestamp ({ticker.get('datetime')}) seems stale. Difference: {time_diff/1000:.1f}s (Max allowed: {max_allowed_diff_ms/1000}s).{Style.RESET_ALL}")
                  # Decide if stale data should be returned or treated as error
                  # return None # Option: Return None if stale
        elif ticker_time_ms is None:
             logger.warning(f"{Fore.YELLOW}{log_prefix}: Ticker timestamp is missing.{Style.RESET_ALL}")


        logger.info(f"{Fore.GREEN}{log_prefix}: Fetched: Last={ticker.get('last')}, Bid={ticker.get('bid')}, Ask={ticker.get('ask')}{Style.RESET_ALL}")
        return ticker

    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e:
         logger.warning(f"{Fore.YELLOW}{log_prefix}: API communication error: {type(e).__name__}. Retry handled by decorator.{Style.RESET_ALL}")
         raise # Re-raise for retry
    except ExchangeError as e:
         logger.error(f"{Fore.RED}{log_prefix}: Exchange error: {e}{Style.RESET_ALL}", exc_info=True)
         return None
    except Exception as e:
         logger.error(f"{Fore.RED}{log_prefix}: Unexpected error: {e}{Style.RESET_ALL}", exc_info=True)
         return None


@retry_api_call()
async def fetch_funding_rate(exchange: ccxt.bybit, symbol: str, config: Config, fetch_next: bool = False) -> Optional[Decimal]:
    """
    Fetches the current or predicted next funding rate for a perpetual swap.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Market symbol (must be a perpetual swap).
        config: Configuration object.
        fetch_next: If True, attempts to fetch the predicted rate for the *next* interval.
                    If False (default), fetches the rate for the *current* interval.

    Returns:
        The funding rate as a Decimal, or None if not applicable or fetch fails.
    """
    func_name = "fetch_funding_rate"
    rate_type = "Next Predicted" if fetch_next else "Current"
    log_prefix = f"[{func_name} ({symbol} - {rate_type})]"

    # Validate market is a swap
    market = market_cache.get_market(symbol)
    if not market or not market.get('swap', False): # Check CCXT 'swap' flag
        logger.error(f"{Fore.RED}{log_prefix}: Symbol '{symbol}' is not a perpetual swap market.{Style.RESET_ALL}")
        return None

    category = market_cache.get_category(symbol)
    if category not in [Category.LINEAR, Category.INVERSE]:
        logger.error(f"{Fore.RED}{log_prefix}: Funding rates only apply to LINEAR or INVERSE contracts. Category: {category}{Style.RESET_ALL}")
        return None

    params = {'category': category.value, 'symbol': symbol}
    logger.debug(f"{log_prefix}: Fetching with params: {params}")

    try:
        if fetch_next:
            # Bybit V5 Ticker ('fundingRate' field) usually shows the predicted rate for the next interval.
            logger.debug(f"{log_prefix}: Fetching ticker data for next funding rate...")
            ticker = await exchange.fetch_ticker(symbol, params=params)
            # logger.debug(f"{log_prefix}: Ticker raw info: {ticker.get('info')}")

            # The 'fundingRate' in the ticker is the predicted rate for the next interval.
            next_rate_str = ticker.get('info', {}).get('fundingRate')
            next_time_ms = ticker.get('info', {}).get('nextFundingTime')

            if next_rate_str is not None:
                rate_decimal = safe_decimal_conversion(next_rate_str)
                next_dt_str = pd.to_datetime(int(next_time_ms), unit='ms', errors='coerce') if next_time_ms else "N/A"
                logger.info(f"{Fore.GREEN}{log_prefix}: Success - Next Rate: {rate_decimal:.8f} (Effective at: {next_dt_str}){Style.RESET_ALL}")
                return rate_decimal
            else:
                 logger.error(f"{Fore.RED}{log_prefix}: Could not find 'fundingRate' in ticker info for next rate.{Style.RESET_ALL}")
                 return None
        else:
            # Fetch the rate for the current funding interval.
            # CCXT's fetch_funding_rate might return current or previous, depending on timing.
            # Using fetch_funding_history(limit=1) might be more reliable for the *last settled* rate.
            logger.debug(f"{log_prefix}: Fetching funding history (limit=1) for last settled rate...")
            history = await exchange.fetch_funding_history(symbol=symbol, limit=1, params=params)
            # logger.debug(f"{log_prefix}: Funding history raw: {history}")

            if history:
                last_interval = history[0] # Get the most recent interval
                rate_str = last_interval.get('info', {}).get('fundingRate') # Get rate from raw info
                timestamp_ms = last_interval.get('timestamp')
                dt_str = last_interval.get('datetime')

                if rate_str is not None:
                     rate_decimal = safe_decimal_conversion(rate_str)
                     logger.info(f"{Fore.GREEN}{log_prefix}: Success - Last Settled Rate: {rate_decimal:.8f} (Timestamp: {dt_str}){Style.RESET_ALL}")
                     return rate_decimal
                else:
                     logger.error(f"{Fore.RED}{log_prefix}: Could not find 'fundingRate' in last history interval.{Style.RESET_ALL}")
                     return None
            else:
                 logger.error(f"{Fore.RED}{log_prefix}: Failed to fetch funding history.{Style.RESET_ALL}")
                 return None

    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e:
        logger.warning(f"{Fore.YELLOW}{log_prefix}: API communication error: {type(e).__name__}. Retry handled by decorator.{Style.RESET_ALL}")
        raise # Re-raise for retry
    except ExchangeError as e:
        logger.error(f"{Fore.RED}{log_prefix}: Exchange error: {e}{Style.RESET_ALL}", exc_info=True)
        return None
    except Exception as e:
        logger.error(f"{Fore.RED}{log_prefix}: Unexpected error: {e}{Style.RESET_ALL}", exc_info=True)
        return None


@retry_api_call()
async def fetch_l2_order_book_validated(exchange: ccxt.bybit, symbol: str, limit: int, config: Config) -> Optional[Dict]:
    """ Fetches L2 order book with basic validation. """
    func_name = "fetch_l2_order_book_validated"
    log_prefix = f"[{func_name} ({symbol}, limit={limit})]"
    logger.debug(f"{log_prefix}: Fetching...")

    category = market_cache.get_category(symbol)
    if not category:
         logger.error(f"{Fore.RED}{log_prefix}: Cannot determine category.{Style.RESET_ALL}")
         return None

    # Bybit V5 limits: spot (50, 200), linear/inverse (50, 200, 500), option (25, 100, 200)
    # CCXT might handle mapping, but good to be aware. Clamp limit if needed.
    # valid_limits = [25, 50, 100, 200, 500] # Combine all possible
    # if limit not in valid_limits: logger.warning(f"{log_prefix}: Limit {limit} may not be optimal for Bybit V5.")

    params = {'category': category.value}
    try:
        # fetch_l2_order_book is preferred over fetch_order_book for depth=L2
        order_book = await exchange.fetch_l2_order_book(symbol, limit=limit, params=params)

        # --- Validation ---
        if not order_book:
            logger.error(f"{Fore.RED}{log_prefix}: Received empty order book response.{Style.RESET_ALL}")
            return None
        if not order_book.get('bids') or not order_book.get('asks'):
             logger.warning(f"{Fore.YELLOW}{log_prefix}: Fetched order book has empty bids or asks. May be thin market.{Style.RESET_ALL}")
             # Return empty book? Or None? Returning the book allows caller to decide.
        if not order_book.get('timestamp') or not order_book.get('datetime'):
             logger.warning(f"{Fore.YELLOW}{log_prefix}: Order book missing timestamp/datetime.{Style.RESET_ALL}")

        # Optional: Check spread? (analyze_order_book does this)
        # Optional: Check price ordering? (CCXT usually handles)

        logger.info(f"{Fore.GREEN}{log_prefix}: Fetched successfully at {order_book.get('datetime')}. Top Bid: {order_book['bids'][0][0] if order_book.get('bids') else 'N/A'}, Top Ask: {order_book['asks'][0][0] if order_book.get('asks') else 'N/A'}{Style.RESET_ALL}")
        return order_book

    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e:
        logger.warning(f"{Fore.YELLOW}{log_prefix}: API communication error: {type(e).__name__}. Retry handled by decorator.{Style.RESET_ALL}")
        raise # Re-raise for retry
    except ExchangeError as e:
         logger.error(f"{Fore.RED}{log_prefix}: Exchange error: {e}{Style.RESET_ALL}", exc_info=True)
         return None
    except Exception as e:
         logger.error(f"{Fore.RED}{log_prefix}: Unexpected error: {e}{Style.RESET_ALL}", exc_info=True)
         return None


@retry_api_call()
async def fetch_recent_trades(exchange: ccxt.bybit, symbol: str, limit: int, config: Config) -> List[Dict]:
    """ Fetches recent public market trades. """
    func_name = "fetch_recent_trades"
    log_prefix = f"[{func_name} ({symbol}, limit={limit})]"
    logger.debug(f"{log_prefix}: Fetching...")

    category = market_cache.get_category(symbol)
    if not category:
        logger.error(f"{Fore.RED}{log_prefix}: Cannot determine category.{Style.RESET_ALL}")
        return []

    # Bybit V5 limit: spot (60), linear/inverse (1000), option (?)
    effective_limit = limit
    if category == Category.SPOT and limit > 60:
         logger.warning(f"{log_prefix}: Limit capped at 60 for SPOT trades.")
         effective_limit = 60
    elif category in [Category.LINEAR, Category.INVERSE] and limit > 1000:
         logger.warning(f"{log_prefix}: Limit capped at 1000 for LINEAR/INVERSE trades.")
         effective_limit = 1000

    params = {'category': category.value, 'limit': effective_limit}
    try:
        trades = await exchange.fetch_trades(symbol, limit=effective_limit, params=params)
        logger.info(f"{Fore.GREEN}{log_prefix}: Fetched {len(trades)} recent trades.{Style.RESET_ALL}")
        return trades
    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e:
         logger.warning(f"{Fore.YELLOW}{log_prefix}: API communication error: {type(e).__name__}. Retry handled by decorator.{Style.RESET_ALL}")
         raise # Re-raise for retry
    except ExchangeError as e:
         logger.error(f"{Fore.RED}{log_prefix}: Exchange error: {e}{Style.RESET_ALL}", exc_info=True)
         return []
    except Exception as e:
         logger.error(f"{Fore.RED}{log_prefix}: Unexpected error: {e}{Style.RESET_ALL}", exc_info=True)
         return []


# --- Order Management Functions ---
# ============================
# MODULE: orders.py (Potential Split)
# ============================

@retry_api_call(max_retries=1, initial_delay=0) # Typically don't retry market orders unless specific error
async def place_market_order_slippage_check(
    exchange: ccxt.bybit,
    symbol: str,
    side: Side,
    amount: Decimal,
    config: Config,
    max_slippage_pct: Optional[Decimal] = None,
    is_reduce_only: bool = False,
    time_in_force: TimeInForce = TimeInForce.IOC, # IOC default for market
    client_order_id: Optional[str] = None,
    position_idx: Optional[PositionIdx] = None # For Hedge Mode
) -> Optional[Dict]:
    """
    Places a market order with a pre-execution spread check.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Market symbol.
        side: Side.BUY or Side.SELL.
        amount: Order quantity (positive Decimal).
        config: Configuration object.
        max_slippage_pct: Overrides config['DEFAULT_SLIPPAGE_PCT'] if provided. Check is based on spread.
        is_reduce_only: If True, sets 'reduceOnly' flag.
        time_in_force: Time in force (IOC or FOK recommended for market).
        client_order_id: Optional client order ID (max 36 chars).
        position_idx: Required for Hedge Mode positions (BUY_SIDE or SELL_SIDE).

    Returns:
        CCXT order dictionary if successfully placed, None otherwise.
    """
    func_name = "place_market_order_slippage_check"
    action = "Close" if is_reduce_only else "Open/Increase"
    log_prefix = f"[{func_name} ({symbol}, {side.value.upper()}, {amount}, {action})]"

    # --- Input Validation ---
    if amount <= config['POSITION_QTY_EPSILON']:
        logger.error(f"{Fore.RED}{log_prefix}: Invalid amount: {amount}. Must be positive.{Style.RESET_ALL}")
        return None
    if time_in_force not in [TimeInForce.IOC, TimeInForce.FOK]:
         logger.warning(f"{Fore.YELLOW}{log_prefix}: Recommended TIF for market orders is IOC or FOK. Using '{time_in_force.value}'.{Style.RESET_ALL}")

    category = market_cache.get_category(symbol)
    if not category:
        logger.error(f"{Fore.RED}{log_prefix}: Cannot determine market category. Order cancelled.{Style.RESET_ALL}")
        return None
    market = market_cache.get_market(symbol)
    if not market:
        logger.error(f"{Fore.RED}{log_prefix}: Market data not found. Order cancelled.{Style.RESET_ALL}")
        return None

    # Format amount
    formatted_amount_str = format_amount(exchange, symbol, amount)
    if formatted_amount_str is None:
         logger.error(f"{Fore.RED}{log_prefix}: Failed to format amount {amount}. Order cancelled.{Style.RESET_ALL}")
         return None
    formatted_amount_float = float(formatted_amount_str)

    effective_max_slippage = max_slippage_pct if max_slippage_pct is not None else config['DEFAULT_SLIPPAGE_PCT']
    logger.info(f"{Fore.BLUE}{log_prefix}: Placing order. Amount: {formatted_amount_str}, TIF: {time_in_force.value}, Max Spread Check: {effective_max_slippage:.4%}{Style.RESET_ALL}")

    # --- Spread/Slippage Check (Pre-execution) ---
    logger.debug(f"{log_prefix}: Performing pre-execution spread check...")
    # Use analyze_order_book to get best bid/ask (fetches shallow OB)
    ob_analysis = await analyze_order_book(exchange, symbol, config['SHALLOW_OB_FETCH_DEPTH'], config)
    best_bid = ob_analysis.get('best_bid')
    best_ask = ob_analysis.get('best_ask')

    if best_bid and best_ask and best_bid > 0:
        spread = (best_ask - best_bid) / best_bid
        logger.debug(f"{log_prefix}: Current Spread: {spread:.4%} (Bid: {best_bid}, Ask: {best_ask})")
        if spread > effective_max_slippage:
            logger.error(f"{Back.RED}{log_prefix}: ABORTED. Spread {spread:.4%} > Max Allowed {effective_max_slippage:.4%}.{Style.RESET_ALL}")
            return None
    elif best_bid is None or best_ask is None:
         logger.warning(f"{Fore.YELLOW}{log_prefix}: Could not get valid bid/ask for spread check. Proceeding without check.{Style.RESET_ALL}")
    # else: best_bid is likely 0, proceed without check

    # --- Prepare Order Parameters ---
    params: Dict[str, Any] = {
        'category': category.value,
        'reduceOnly': is_reduce_only,
        'timeInForce': time_in_force.value,
    }
    if client_order_id:
        clean_cid = ''.join(filter(lambda c: c.isalnum() or c in ['-', '_'], client_order_id))[:36]
        params['clientOrderId'] = clean_cid
        logger.debug(f"{log_prefix}: Using clientOrderId: {clean_cid}")
    if position_idx is not None:
        params['positionIdx'] = position_idx.value
        logger.debug(f"{log_prefix}: Using positionIdx: {position_idx.value} (Hedge Mode)")

    # --- Place Order ---
    try:
        logger.info(f"{log_prefix}: Sending create_market_order request...")
        order = await exchange.create_market_order(
            symbol=symbol,
            side=side.value,
            amount=formatted_amount_float,
            params=params
        )
        # --- Post-Placement Log ---
        order_id = order.get('id')
        status = order.get('status', 'N/A')
        filled_amount = safe_decimal_conversion(order.get('filled', '0'))
        avg_price = safe_decimal_conversion(order.get('average'))
        log_color = Fore.GREEN if status in ['closed', 'filled'] else Fore.YELLOW

        logger.success(f"{log_color}{log_prefix}: SUCCESS - ID: ...{format_order_id(order_id)}, Status: {status}, Filled: {format_amount(exchange, symbol, filled_amount)} @ Avg Price: {format_price(exchange, symbol, avg_price)}{Style.RESET_ALL}")

        # Check partial fills for IOC/FOK
        if time_in_force in [TimeInForce.IOC, TimeInForce.FOK] and filled_amount < amount * (Decimal(1) - config['POSITION_QTY_EPSILON']):
             logger.warning(f"{Fore.YELLOW}{log_prefix}: Order {order_id} ({time_in_force.value}) filled partially ({filled_amount}/{amount}). Check details.{Style.RESET_ALL}")

        return order

    except InsufficientFunds as e:
         logger.error(f"{Back.RED}{log_prefix}: FAILED - Insufficient Funds: {e}{Style.RESET_ALL}")
         # send_sms_alert(...) # Optional alert
         return None
    except InvalidOrder as e: # e.g., quantity/price precision error, below min size
         logger.error(f"{Back.RED}{log_prefix}: FAILED - Invalid Order Parameters: {e}{Style.RESET_ALL}")
         return None
    except ExchangeError as e:
         logger.error(f"{Back.RED}{log_prefix}: FAILED - Exchange Error: {e}{Style.RESET_ALL}", exc_info=True)
         return None
    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e:
         # Should be caught by retry decorator, but log if it somehow gets here
         logger.error(f"{Back.RED}{log_prefix}: FAILED - API Communication Error: {type(e).__name__}: {e}{Style.RESET_ALL}")
         return None # Don't raise here as retry decorator handles raising
    except Exception as e:
         logger.error(f"{Back.RED}{log_prefix}: FAILED - Unexpected Error: {e}{Style.RESET_ALL}", exc_info=True)
         return None


@retry_api_call(max_retries=1) # Don't retry limit order placement usually
async def place_limit_order_tif(
    exchange: ccxt.bybit,
    symbol: str,
    side: Side,
    amount: Decimal,
    price: Decimal,
    config: Config,
    time_in_force: TimeInForce = TimeInForce.GTC,
    is_reduce_only: bool = False,
    is_post_only: bool = False, # Specific flag for post-only
    client_order_id: Optional[str] = None,
    position_idx: Optional[PositionIdx] = None # For Hedge Mode
) -> Optional[Dict]:
    """
    Places a limit order with specified time-in-force and optional post-only.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Market symbol.
        side: Side.BUY or Side.SELL.
        amount: Order quantity (positive Decimal).
        price: Order price (positive Decimal).
        config: Configuration object.
        time_in_force: Time in force (GTC, IOC, FOK). PostOnly handled by `is_post_only`.
        is_reduce_only: If True, sets 'reduceOnly' flag.
        is_post_only: If True, ensures the order is only accepted if it's a maker order.
        client_order_id: Optional client order ID (max 36 chars).
        position_idx: Required for Hedge Mode positions.

    Returns:
        CCXT order dictionary if successfully placed, None otherwise.
    """
    func_name = "place_limit_order_tif"
    action = "Close" if is_reduce_only else "Open/Increase"
    tif_str = f"{time_in_force.value}{' PostOnly' if is_post_only else ''}"
    log_prefix = f"[{func_name} ({symbol}, {side.value.upper()}, {amount} @ {price}, {action}, TIF:{tif_str})]"

     # --- Input Validation ---
    if amount <= config['POSITION_QTY_EPSILON']:
        logger.error(f"{Fore.RED}{log_prefix}: Invalid amount: {amount}.{Style.RESET_ALL}")
        return None
    if price <= Decimal('0'):
         logger.error(f"{Fore.RED}{log_prefix}: Invalid price: {price}.{Style.RESET_ALL}")
         return None
    if is_post_only and time_in_force != TimeInForce.GTC:
        # Bybit V5 PostOnly is a specific TIF value, not compatible with IOC/FOK.
        # CCXT might handle this mapping. Let's use Bybit's logic: TIF should be PostOnly.
        # logger.warning(f"{Fore.YELLOW}{log_prefix}: PostOnly is usually used with GTC TIF. Adjusting TIF to PostOnly.")
        time_in_force = TimeInForce.POST_ONLY # Use the specific PostOnly TIF value

    category = market_cache.get_category(symbol)
    if not category:
        logger.error(f"{Fore.RED}{log_prefix}: Cannot determine category.{Style.RESET_ALL}")
        return None
    market = market_cache.get_market(symbol)
    if not market:
        logger.error(f"{Fore.RED}{log_prefix}: Market data not found.{Style.RESET_ALL}")
        return None

    # Format amount and price
    formatted_amount_str = format_amount(exchange, symbol, amount)
    formatted_price_str = format_price(exchange, symbol, price)
    if formatted_amount_str is None or formatted_price_str is None:
         logger.error(f"{Fore.RED}{log_prefix}: Failed to format amount/price.{Style.RESET_ALL}")
         return None
    formatted_amount_float = float(formatted_amount_str)
    formatted_price_float = float(formatted_price_str)

    logger.info(f"{Fore.BLUE}{log_prefix}: Placing order...{Style.RESET_ALL}")

    # --- Prepare Order Parameters ---
    params: Dict[str, Any] = {
        'category': category.value,
        'reduceOnly': is_reduce_only,
        'timeInForce': time_in_force.value, # Pass GTC, IOC, FOK, or PostOnly
        # 'postOnly': is_post_only, # CCXT might use this param instead of TIF for postOnly
    }
    if client_order_id:
        clean_cid = ''.join(filter(lambda c: c.isalnum() or c in ['-', '_'], client_order_id))[:36]
        params['clientOrderId'] = clean_cid
        logger.debug(f"{log_prefix}: Using clientOrderId: {clean_cid}")
    if position_idx is not None:
        params['positionIdx'] = position_idx.value
        logger.debug(f"{log_prefix}: Using positionIdx: {position_idx.value} (Hedge Mode)")

    # --- Place Order ---
    try:
        logger.info(f"{log_prefix}: Sending create_limit_order request...")
        # CCXT create_limit_order should map parameters correctly
        order = await exchange.create_limit_order(
            symbol=symbol,
            side=side.value,
            amount=formatted_amount_float,
            price=formatted_price_float,
            params=params
        )
        # --- Post-Placement Log ---
        order_id = order.get('id')
        status = order.get('status', 'N/A')
        order_price = safe_decimal_conversion(order.get('price'))
        log_color = Fore.GREEN if status == 'open' else Fore.YELLOW if status in ['triggered', 'new'] else Fore.RED

        logger.success(f"{log_color}{log_prefix}: SUCCESS - ID: ...{format_order_id(order_id)}, Status: {status}, Price: {format_price(exchange, symbol, order_price)}, Amount: {format_amount(exchange, symbol, order.get('amount'))}{Style.RESET_ALL}")
        return order

    except InsufficientFunds as e:
         logger.error(f"{Back.RED}{log_prefix}: FAILED - Insufficient Funds: {e}{Style.RESET_ALL}")
         return None
    except InvalidOrder as e: # Catches post-only failures, precision errors, etc.
         logger.error(f"{Back.RED}{log_prefix}: FAILED - Invalid Order Parameters or Rejected (e.g., PostOnly failed): {e}{Style.RESET_ALL}")
         return None
    except ExchangeError as e: # Catch other specific exchange rejections
         logger.error(f"{Back.RED}{log_prefix}: FAILED - Exchange Error: {e}{Style.RESET_ALL}", exc_info=True)
         return None
    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e:
         logger.error(f"{Back.RED}{log_prefix}: FAILED - API Communication Error: {type(e).__name__}: {e}{Style.RESET_ALL}")
         return None # Let retry decorator handle raising if applicable
    except Exception as e:
         logger.error(f"{Back.RED}{log_prefix}: FAILED - Unexpected Error: {e}{Style.RESET_ALL}", exc_info=True)
         return None


@retry_api_call(max_retries=1) # No retry for batch placement logic itself
async def place_batch_orders(
    exchange: ccxt.bybit,
    orders: List[Dict[str, Any]],
    config: Config,
    category_override: Optional[Category] = None
) -> Tuple[List[Optional[Dict]], List[Optional[Dict]]]:
    """
    Places multiple orders in a single batch request using Bybit V5's batch order endpoint.

    Args:
        exchange: Initialized ccxt.bybit instance.
        orders: List of order request dictionaries. Required keys per order:
                'symbol', 'side' (Side enum or 'buy'/'sell'), 'type' ('Limit', 'Market'),
                'amount' (Decimal or float/str). Optional: 'price' (for Limit), etc.
                (See Bybit V5 API docs for POST /v5/order/create-batch `request` object).
        config: Configuration object.
        category_override: Force this category for ALL orders in the batch. If None,
                           category is determined per order, and all must match.

    Returns:
        Tuple: (success_orders, error_details)
            - success_orders: List mirroring input `orders`. Contains CCXT-like order dict
                              for successful orders, None otherwise.
            - error_details: List mirroring input `orders`. Contains error dict
                             {'code': ..., 'msg': ...} for failed orders, None otherwise.
    """
    func_name = "place_batch_orders"
    num_orders = len(orders)
    log_prefix = f"[{func_name} ({num_orders} orders)]"
    logger.info(f"{Fore.BLUE}{log_prefix}: Preparing batch order request...{Style.RESET_ALL}")

    if not orders:
        logger.warning(f"{Fore.YELLOW}{log_prefix}: No orders provided in the batch.{Style.RESET_ALL}")
        return [], []

    # Bybit V5 limits: Linear/Inverse (10), Spot (10), Option (?)
    # Enforce limit here
    limit = 10 # Default limit, adjust if needed for spot/option based on docs
    if num_orders > limit:
        logger.error(f"{Fore.RED}{log_prefix}: Batch size ({num_orders}) exceeds the limit ({limit}). Aborting.{Style.RESET_ALL}")
        # Return error details indicating the batch size issue
        return [None] * num_orders, [{'code': -100, 'msg': f'Batch size {num_orders} exceeds limit {limit}'}] * num_orders


    # --- Prepare and Validate Individual Orders ---
    batch_requests: List[Optional[Dict]] = [None] * num_orders # Pre-fill with None
    category_to_use: Optional[str] = category_override.value if category_override else None
    initial_errors: List[Optional[Dict]] = [None] * num_orders
    valid_request_count = 0

    for i, order_req in enumerate(orders):
        error_msg: Optional[str] = None
        symbol = order_req.get('symbol')
        side_raw = order_req.get('side')
        order_type_raw = order_req.get('type') # Expect 'Limit' or 'Market'
        amount_raw = order_req.get('amount')

        # Basic field validation
        if not all([symbol, side_raw, order_type_raw, amount_raw]):
            error_msg = "Missing required fields (symbol, side, type, amount)."
        elif not isinstance(symbol, str): error_msg = "Symbol must be a string."
        elif not isinstance(side_raw, (Side, str)): error_msg = "Side must be Side enum or string."
        elif not isinstance(order_type_raw, str): error_msg = "Type must be a string ('Limit' or 'Market')."
        elif order_type_raw.capitalize() not in ['Limit', 'Market']: error_msg = "Invalid order type."
        elif safe_decimal_conversion(amount_raw, Decimal(-1)) <= config['POSITION_QTY_EPSILON']: error_msg = "Amount must be positive."

        if error_msg:
            logger.error(f"{Fore.RED}{log_prefix}: Order #{i+1} Invalid Input: {error_msg}{Style.RESET_ALL}")
            initial_errors[i] = {'code': -101, 'msg': f"Input Validation Error: {error_msg}"}
            continue # Skip this order

        # Determine and validate category
        current_category_enum = market_cache.get_category(symbol)
        if not current_category_enum:
            error_msg = f"Cannot determine category for symbol '{symbol}'."
            logger.error(f"{Fore.RED}{log_prefix}: Order #{i+1} ({symbol}) Error: {error_msg}{Style.RESET_ALL}")
            initial_errors[i] = {'code': -102, 'msg': error_msg}
            continue
        current_category_str = current_category_enum.value

        if category_override:
            if current_category_str != category_override.value:
                error_msg = f"Symbol '{symbol}' category '{current_category_str}' does not match override '{category_override.value}'."
                logger.error(f"{Fore.RED}{log_prefix}: Order #{i+1} Error: {error_msg}{Style.RESET_ALL}")
                initial_errors[i] = {'code': -103, 'msg': error_msg}
                continue
            effective_category = category_override.value
        else:
            if category_to_use is None: # First valid order sets the batch category
                category_to_use = current_category_str
            elif current_category_str != category_to_use:
                error_msg = f"Category '{current_category_str}' differs from batch category '{category_to_use}'. Mixing categories not allowed."
                logger.error(f"{Fore.RED}{log_prefix}: Order #{i+1} ({symbol}) Error: {error_msg}{Style.RESET_ALL}")
                initial_errors[i] = {'code': -104, 'msg': error_msg}
                continue
            effective_category = category_to_use

        # Format amount and price
        market = market_cache.get_market(symbol)
        if not market:
             error_msg = f"Market data not found for symbol '{symbol}'."
             logger.error(f"{Fore.RED}{log_prefix}: Order #{i+1} ({symbol}) Error: {error_msg}{Style.RESET_ALL}")
             initial_errors[i] = {'code': -105, 'msg': error_msg}
             continue

        amount_str = format_amount(exchange, symbol, amount_raw)
        if amount_str is None:
              error_msg = f"Invalid amount format for value '{amount_raw}'."
              logger.error(f"{Fore.RED}{log_prefix}: Order #{i+1} ({symbol}) Error: {error_msg}{Style.RESET_ALL}")
              initial_errors[i] = {'code': -106, 'msg': error_msg}
              continue

        price_str: Optional[str] = None
        if order_type_raw.capitalize() == 'Limit':
            price_raw = order_req.get('price')
            if price_raw is None or safe_decimal_conversion(price_raw, Decimal(-1)) <= Decimal(0):
                 error_msg = f"Limit order requires a valid positive 'price'."
                 logger.error(f"{Fore.RED}{log_prefix}: Order #{i+1} ({symbol}) Error: {error_msg}{Style.RESET_ALL}")
                 initial_errors[i] = {'code': -107, 'msg': error_msg}
                 continue
            price_str = format_price(exchange, symbol, price_raw)
            if price_str is None:
                 error_msg = f"Invalid price format for value '{price_raw}'."
                 logger.error(f"{Fore.RED}{log_prefix}: Order #{i+1} ({symbol}) Error: {error_msg}{Style.RESET_ALL}")
                 initial_errors[i] = {'code': -108, 'msg': error_msg}
                 continue

        # Normalize side ('buy'/'sell' -> 'Buy'/'Sell')
        side_val = side_raw.value if isinstance(side_raw, Side) else str(side_raw).lower()
        if side_val not in ['buy', 'sell']:
            error_msg = f"Invalid side value '{side_raw}'."
            logger.error(f"{Fore.RED}{log_prefix}: Order #{i+1} ({symbol}) Error: {error_msg}{Style.RESET_ALL}")
            initial_errors[i] = {'code': -109, 'msg': error_msg}
            continue
        bybit_side = side_val.capitalize()

        # --- Build the V5 request object for this order ---
        # Keys must match Bybit V5 API spec: POST /v5/order/create-batch `request` object items
        v5_order_req = {
            "symbol": symbol,
            "side": bybit_side,
            "orderType": order_type_raw.capitalize(),
            "qty": amount_str,
            "category": effective_category, # Include category within each order object too
            # Add other optional parameters passed in order_req, mapping names if necessary
            **{k: v for k, v in order_req.items() if k not in ['symbol', 'side', 'type', 'amount', 'price', 'category'] and v is not None}
        }
        # Add price only for Limit orders
        if price_str:
            v5_order_req["price"] = price_str
        # Handle clientOrderId specifically
        if order_req.get("clientOrderId"):
             cid = str(order_req["clientOrderId"])
             clean_cid = ''.join(filter(lambda c: c.isalnum() or c in ['-', '_'], cid))[:36]
             v5_order_req["clientOrderId"] = clean_cid
        # Handle boolean flags (ensure they are bool, not string 'true'/'false')
        if "reduceOnly" in v5_order_req: v5_order_req["reduceOnly"] = bool(v5_order_req["reduceOnly"])
        if "postOnly" in v5_order_req: v5_order_req["postOnly"] = bool(v5_order_req["postOnly"]) # V5 might use TIF=PostOnly instead
        # Handle enums like positionIdx
        if "positionIdx" in v5_order_req and isinstance(v5_order_req["positionIdx"], PositionIdx):
            v5_order_req["positionIdx"] = v5_order_req["positionIdx"].value
        # Add mappings for TP/SL, conditional params if passed in order_req...

        batch_requests[i] = v5_order_req # Store the valid request at the correct index
        valid_request_count += 1
        logger.debug(f"{log_prefix}: Prepared Order #{i+1}: {v5_order_req}")

    # --- Filter out invalid requests ---
    valid_v5_requests = [req for req in batch_requests if req is not None]

    if not valid_v5_requests:
         logger.error(f"{Fore.RED}{log_prefix}: No valid orders found in the batch to send.{Style.RESET_ALL}")
         # Return lists matching the original input length, populated with initial errors
         return [None] * num_orders, initial_errors

    # --- Execute Batch Request ---
    final_batch_category = category_to_use # The determined consistent category
    if not final_batch_category:
         # This should not happen if valid_requests is not empty, but safeguard anyway
         logger.error(f"{Fore.RED}{log_prefix}: Could not determine final batch category. Aborting.{Style.RESET_ALL}")
         initial_errors[0] = initial_errors[0] or {'code': -199, 'msg': 'Internal error: Batch category missing'} # Mark first order?
         return [None] * num_orders, initial_errors


    final_success_orders: List[Optional[Dict]] = [None] * num_orders
    final_error_details: List[Optional[Dict]] = list(initial_errors) # Start with pre-validation errors

    try:
        logger.info(f"{log_prefix}: Sending batch create request for {len(valid_v5_requests)} valid orders (Category: {final_batch_category})...")
        params = {
            'category': final_batch_category,
            'request': valid_v5_requests
        }
        response = await exchange.private_post_v5_order_create_batch(params)
        logger.debug(f"{log_prefix}: Raw response: {response}")

        # --- Process Batch Response ---
        ret_code = response.get('retCode')
        ret_msg = response.get('retMsg', 'N/A')

        if ret_code == 0: # Batch request syntax OK, check individual results
            result_data = response.get('result', {})
            success_results_raw = result_data.get('list', []) # List of successful order creations
            error_info_raw = result_data.get('errInfo', [])   # List of failures within the batch

            logger.info(f"{Fore.GREEN}{log_prefix}: Batch processed. Success results: {len(success_results_raw)}, Failures reported: {len(error_info_raw)}{Style.RESET_ALL}")

            # --- Map results back to original indices ---
            # Use a map for efficient lookup of successful orders by clientOrderId if available
            success_by_cid = {str(o.get('clientOrderId')): o for o in success_results_raw if o.get('clientOrderId')}

            # Process errors first using the index provided by Bybit
            processed_indices = set()
            for err in error_info_raw:
                original_req_idx = err.get('idx') # 0-based index in the *sent* valid_v5_requests list
                if original_req_idx is None or original_req_idx >= len(valid_v5_requests):
                     logger.error(f"{log_prefix}: Invalid error index {original_req_idx} received from Bybit.")
                     continue

                # Find the corresponding index in the *original* batch_requests list
                original_list_idx = -1
                valid_count = -1
                for k, req in enumerate(batch_requests):
                     if req is not None: # Count only valid requests sent
                         valid_count += 1
                         if valid_count == original_req_idx:
                              original_list_idx = k
                              break

                if original_list_idx != -1:
                     err_code = err.get('code', -1)
                     err_msg = err.get('msg', 'Unknown error')
                     logger.error(f"{Fore.RED}{log_prefix}: Order #{original_list_idx+1} ({batch_requests[original_list_idx].get('symbol')}) FAILED in batch. Code: {err_code}, Msg: {err_msg}{Style.RESET_ALL}")
                     final_error_details[original_list_idx] = {'code': err_code, 'msg': err_msg}
                     processed_indices.add(original_list_idx)
                else:
                     logger.error(f"{log_prefix}: Could not map error index {original_req_idx} back to original order list.")


            # Process successes
            success_idx_counter = 0 # Track index within success_results_raw
            for i, original_req in enumerate(batch_requests):
                if original_req is None or i in processed_indices:
                    continue # Skip initially invalid or already processed as error

                # Try matching success by clientOrderId first
                matched = False
                cid = original_req.get('clientOrderId')
                if cid and str(cid) in success_by_cid:
                     raw_order = success_by_cid[str(cid)]
                     # Parse the raw order into CCXT format
                     try:
                         # Ensure exchange has markets loaded for parsing
                          if not exchange.markets: await market_cache.load_markets(exchange)
                          parsed_order = exchange.parse_order(raw_order)
                          final_success_orders[i] = parsed_order
                          logger.success(f"{Fore.GREEN}{log_prefix}: Order #{i+1} ({original_req.get('symbol')}, CID: {cid}) PLACED successfully. ID: ...{format_order_id(parsed_order.get('id'))}{Style.RESET_ALL}")
                          matched = True
                     except Exception as parse_err:
                          logger.error(f"{log_prefix}: Failed to parse successful order #{i+1} (CID: {cid}): {parse_err}. Storing raw.")
                          final_success_orders[i] = raw_order # Store raw if parse fails
                          matched = True # Still mark as matched success

                # Fallback: Assume order in success list corresponds if CID doesn't match
                # This is less reliable and should only be used if CIDs are inconsistent.
                if not matched and success_idx_counter < len(success_results_raw):
                    raw_order = success_results_raw[success_idx_counter]
                    # Double check symbol to improve chances
                    if raw_order.get('symbol') == original_req.get('symbol'):
                        try:
                             if not exchange.markets: await market_cache.load_markets(exchange)
                             parsed_order = exchange.parse_order(raw_order)
                             final_success_orders[i] = parsed_order
                             logger.success(f"{Fore.GREEN}{log_prefix}: Order #{i+1} ({original_req.get('symbol')}) PLACED successfully (matched by order). ID: ...{format_order_id(parsed_order.get('id'))}{Style.RESET_ALL}")
                             matched = True
                        except Exception as parse_err:
                             logger.error(f"{log_prefix}: Failed to parse successful order #{i+1} (matched by order): {parse_err}. Storing raw.")
                             final_success_orders[i] = raw_order
                             matched = True
                        success_idx_counter += 1 # Consume this success result

                if not matched:
                     # Should not happen if Bybit response is consistent
                     logger.warning(f"{Fore.YELLOW}{log_prefix}: Order #{i+1} ({original_req.get('symbol')}) was not found in success or error list mapping. Status uncertain.{Style.RESET_ALL}")
                     final_error_details[i] = {'code': -200, 'msg': 'Status uncertain, response mapping failed'}

            return final_success_orders, final_error_details

        else: # Batch request itself failed (e.g., auth, parameter error)
            logger.error(f"{Back.RED}{log_prefix}: Entire batch request FAILED. Code: {ret_code}, Msg: {ret_msg}{Style.RESET_ALL}")
            error_detail = {'code': ret_code, 'msg': f"Batch Request Failed: {ret_msg}"}
            # Populate errors, respecting initial validation failures
            for i in range(num_orders):
                 if final_error_details[i] is None: # Only overwrite if not already an initial error
                      final_error_details[i] = error_detail
            return final_success_orders, final_error_details

    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e:
        logger.error(f"{Back.RED}{log_prefix}: FAILED - API Communication Error: {type(e).__name__}: {e}{Style.RESET_ALL}")
        # Assume all orders failed if the batch request itself failed network-wise
        comm_error = {'code': -300, 'msg': f"API Communication Error: {type(e).__name__}"}
        for i in range(num_orders):
            if final_error_details[i] is None: final_error_details[i] = comm_error
        return final_success_orders, final_error_details
    except ExchangeError as e:
        logger.error(f"{Back.RED}{log_prefix}: FAILED - Exchange Error on Batch Request: {e}{Style.RESET_ALL}", exc_info=True)
        exc_error = {'code': -400, 'msg': f"ExchangeError: {str(e)}"}
        for i in range(num_orders):
            if final_error_details[i] is None: final_error_details[i] = exc_error
        return final_success_orders, final_error_details
    except Exception as e:
        logger.error(f"{Back.RED}{log_prefix}: FAILED - Unexpected Error: {e}{Style.RESET_ALL}", exc_info=True)
        unexp_error = {'code': -500, 'msg': f"Unexpected Error: {str(e)}"}
        for i in range(num_orders):
             if final_error_details[i] is None: final_error_details[i] = unexp_error
        return final_success_orders, final_error_details


@retry_api_call(max_retries=2, initial_delay=1.0)
async def cancel_all_orders(
    exchange: ccxt.bybit,
    symbol: Optional[str] = None,
    config: Optional[Config] = None, # For logging/context
    category: Optional[Category] = None,
    order_filter: Optional[OrderFilter] = None,
    reason: str = "General Cleanup"
) -> bool:
    """
    Cancels open orders using Bybit V5's cancelAll endpoint.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Optional: Market symbol filter.
        config: Optional configuration object.
        category: Optional: Explicitly specify category. Required if symbol is None.
        order_filter: Optional: Filter by order type (Order, StopOrder, tpslOrder).
        reason: Logging description for the cancellation.

    Returns:
        True if the cancellation request was accepted by the API (retCode=0).
        False if the request failed.

    WARNING: If `symbol` is None, this cancels ALL orders in the specified `category`
             that match the `order_filter`. Use with extreme caution.
    """
    func_name = "cancel_all_orders"
    log_prefix = f"[{func_name} ({reason})]"

    # --- Determine Category ---
    effective_category: Optional[str] = None
    if category:
        effective_category = category.value
        log_prefix += f" | Category: {effective_category}"
    elif symbol:
        cached_category = market_cache.get_category(symbol)
        if cached_category:
            effective_category = cached_category.value
            log_prefix += f" | Symbol: {symbol} (Cat: {effective_category})"
        else:
             logger.error(f"{Fore.RED}{log_prefix}: Cannot determine category for symbol '{symbol}'. Cancellation aborted.{Style.RESET_ALL}")
             return False
    else:
        logger.error(f"{Fore.RED}{log_prefix}: Must provide either 'symbol' or 'category'. Cancellation aborted.{Style.RESET_ALL}")
        return False

    # --- Prepare Parameters ---
    params: Dict[str, Any] = {'category': effective_category}
    target_desc = ""
    if symbol:
        params['symbol'] = symbol
        target_desc = f"for {symbol}"
    else:
        logger.warning(f"{Back.YELLOW}{Fore.BLACK}{log_prefix}: No symbol provided. Attempting to cancel ALL orders in category '{effective_category}'.{Style.RESET_ALL}")
        target_desc = f"ALL in category {effective_category}"

    if order_filter:
        params['orderFilter'] = order_filter.value
        log_prefix += f" | Filter: {order_filter.value}"
        target_desc += f" matching filter {order_filter.value}"
    # else: Bybit defaults to 'Order' if filter omitted

    logger.info(f"{Fore.CYAN}{log_prefix}: Sending cancelAll request {target_desc}...{Style.RESET_ALL}")

    # --- Execute Cancellation using V5 specific endpoint ---
    try:
        # Use private_post_v5_order_cancel_all for direct control over V5 features
        response = await exchange.private_post_v5_order_cancel_all(params=params)
        logger.debug(f"{log_prefix}: Raw response: {response}")

        ret_code = response.get('retCode')
        ret_msg = response.get('retMsg', 'N/A')

        if ret_code == 0:
            cancelled_list = response.get('result', {}).get('list', [])
            count = len(cancelled_list)
            if count > 0:
                 logger.success(f"{Fore.GREEN}{log_prefix}: Successfully cancelled {count} order(s) {target_desc}.{Style.RESET_ALL}")
            else:
                 logger.info(f"{Fore.YELLOW}{log_prefix}: Cancellation request successful, but no matching open orders found {target_desc}.{Style.RESET_ALL}")
            return True
        else:
            logger.error(f"{Fore.RED}{log_prefix}: Cancellation request FAILED {target_desc}. Code: {ret_code}, Msg: {ret_msg}{Style.RESET_ALL}")
            # Provide hints for common errors
            if ret_code == 10001: logger.error(f"{log_prefix}: Hint: Check parameters (category, symbol format, filter value).")
            elif ret_code == 170101: logger.error(f"{log_prefix}: Hint: Authentication error (check API keys/permissions).")
            return False

    except AuthenticationError as e:
         logger.error(f"{Fore.RED}{log_prefix}: Authentication error: {e}{Style.RESET_ALL}")
         return False # Don't retry auth errors usually
    except NotSupported as e:
        logger.error(f"{Fore.RED}{log_prefix}: CCXT method private_post_v5_order_cancel_all seems unsupported? Error: {e}{Style.RESET_ALL}")
        return False # Cannot proceed if method missing
    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e:
         logger.warning(f"{Fore.YELLOW}{log_prefix}: API communication error: {type(e).__name__}. Retry handled by decorator.{Style.RESET_ALL}")
         raise # Re-raise for retry
    except ExchangeError as e:
        logger.error(f"{Fore.RED}{log_prefix}: Exchange error during cancellation: {e}{Style.RESET_ALL}", exc_info=True)
        return False
    except Exception as e:
        logger.error(f"{Fore.RED}{log_prefix}: Unexpected error during cancellation: {e}{Style.RESET_ALL}", exc_info=True)
        return False


@retry_api_call(max_retries=2, initial_delay=0.5)
async def cancel_order(
    exchange: ccxt.bybit,
    symbol: str, # Required by CCXT method signature usually
    order_id: Optional[str] = None,
    client_order_id: Optional[str] = None,
    config: Optional[Config] = None,
    order_filter: Optional[OrderFilter] = None # Needed for conditional V5
) -> bool:
    """
    Cancels a single specific order by its exchange ID or client order ID.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Market symbol associated with the order.
        order_id: Exchange's unique order ID. Provide EITHER order_id OR client_order_id.
        client_order_id: Client-provided order ID.
        config: Optional configuration object.
        order_filter: Specify if cancelling conditional/stop (STOP_ORDER, TPSL_ORDER).

    Returns:
        True if successfully cancelled or already not found/closed. False on failure.
    """
    func_name = "cancel_order"

    if not order_id and not client_order_id:
        logger.error(f"{Fore.RED}[{func_name}] Must provide 'order_id' or 'client_order_id'.{Style.RESET_ALL}")
        return False
    # Prioritize order_id if both are given
    primary_id = order_id if order_id else client_order_id
    id_type = "Order ID" if order_id else "Client Order ID"
    id_value_log = format_order_id(order_id) if order_id else client_order_id # Log truncated ID
    log_prefix = f"[{func_name} ({symbol}, {id_type}: ...{id_value_log})]"

    category = market_cache.get_category(symbol)
    if not category:
        logger.error(f"{Fore.RED}{log_prefix}: Cannot determine category. Cancellation aborted.{Style.RESET_ALL}")
        return False

    # --- Prepare Parameters ---
    # Bybit V5 Cancel Order: POST /v5/order/cancel
    # Requires category, symbol, and EITHER orderId OR clientOrderId
    params: Dict[str, Any] = {
        'category': category.value,
        'symbol': symbol,
        # CCXT's cancel_order handles passing the ID argument to the correct parameter
        # 'orderId': order_id, # Let CCXT handle mapping `id` arg
        # 'clientOrderId': client_order_id, # Let CCXT handle mapping `id` arg if `order_id` is None
    }
    # V5 cancel endpoint might need orderFilter for conditional orders
    if order_filter:
        params['orderFilter'] = order_filter.value
        log_prefix += f" Filter:{order_filter.value}"

    logger.info(f"{Fore.CYAN}{log_prefix}: Sending cancel request...{Style.RESET_ALL}")

    # --- Execute Cancellation ---
    try:
        # Use CCXT's unified cancel_order method. It should map `id` to orderId/clientOrderId.
        response = await exchange.cancel_order(id=primary_id, symbol=symbol, params=params)

        logger.debug(f"{log_prefix}: Raw response: {response}") # Raw response varies by exchange/method
        # Successful cancellation often doesn't raise an exception, may return None or order data.
        logger.success(f"{Fore.GREEN}{log_prefix}: Cancellation request sent successfully.{Style.RESET_ALL}")
        return True

    except OrderNotFound as e:
        # This is often a success case - the order is already gone.
        logger.warning(f"{Fore.YELLOW}{log_prefix}: Order not found. Assumed already cancelled or filled. ({e}){Style.RESET_ALL}")
        return True
    except InvalidOrder as e: # e.g., trying to cancel a filled/rejected order
         logger.warning(f"{Fore.YELLOW}{log_prefix}: Invalid order state for cancellation (already filled/cancelled/rejected?). ({e}){Style.RESET_ALL}")
         # Check specific Bybit codes if InvalidOrder wraps them
         error_str = str(e).lower()
         # 170145: Order has been filled / 170146: Order has been cancelled / 170131: order not exists
         if "170145" in error_str or "170146" in error_str or "170131" in error_str or "order not exists" in error_str:
             return True # Treat as success
         else:
             logger.error(f"{Fore.RED}{log_prefix}: InvalidOrder encountered: {e}{Style.RESET_ALL}")
             return False # Treat other invalid states as failure
    except AuthenticationError as e:
         logger.error(f"{Fore.RED}{log_prefix}: Authentication error: {e}{Style.RESET_ALL}")
         return False
    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e:
         logger.warning(f"{Fore.YELLOW}{log_prefix}: API communication error: {type(e).__name__}. Retry handled by decorator.{Style.RESET_ALL}")
         raise # Re-raise for retry
    except ExchangeError as e:
         # Check for specific Bybit errors that mean "already gone"
         error_str = str(e).lower()
         if "170145" in error_str or "170146" in error_str or "170131" in error_str or "order not exists" in error_str:
              logger.warning(f"{Fore.YELLOW}{log_prefix}: ExchangeError indicates order already filled/cancelled/non-existent ({e}). Considered success.{Style.RESET_ALL}")
              return True
         else:
              logger.error(f"{Fore.RED}{log_prefix}: Exchange error during cancellation: {e}{Style.RESET_ALL}", exc_info=True)
              return False
    except Exception as e:
        logger.error(f"{Fore.RED}{log_prefix}: Unexpected error during cancellation: {e}{Style.RESET_ALL}", exc_info=True)
        return False


@retry_api_call()
async def fetch_order(
    exchange: ccxt.bybit,
    symbol: str, # Symbol often needed for context, esp. with clientOrderId
    order_id: Optional[str] = None,
    client_order_id: Optional[str] = None,
    config: Optional[Config] = None,
    order_filter: Optional[OrderFilter] = None # Needed for conditional V5
) -> Optional[Dict]:
    """
    Fetches a single order's details by its exchange ID or client order ID.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Market symbol (may provide context).
        order_id: Exchange's unique order ID. Provide EITHER order_id OR client_order_id.
        client_order_id: Client-provided order ID.
        config: Optional configuration object.
        order_filter: Specify if fetching conditional/stop (STOP_ORDER, TPSL_ORDER).

    Returns:
        CCXT order dictionary if found, None otherwise.
    """
    func_name = "fetch_order"
    if not order_id and not client_order_id:
        logger.error(f"{Fore.RED}[{func_name}] Must provide 'order_id' or 'client_order_id'.{Style.RESET_ALL}")
        return None
    primary_id = order_id if order_id else client_order_id
    id_type = "Order ID" if order_id else "Client Order ID"
    id_value_log = format_order_id(order_id) if order_id else client_order_id
    log_prefix = f"[{func_name} ({symbol}, {id_type}: ...{id_value_log})]"

    category = market_cache.get_category(symbol)
    if not category:
        logger.error(f"{Fore.RED}{log_prefix}: Cannot determine category. Fetch aborted.{Style.RESET_ALL}")
        return None

    # --- Prepare Parameters ---
    # Bybit V5 Fetch Order: GET /v5/order/history requires category
    # Can filter by orderId or clientOrderId. Needs orderFilter for conditional.
    params: Dict[str, Any] = {'category': category.value}
    # Let CCXT handle mapping ID to correct parameter in fetch_order
    # if order_id: params['orderId'] = order_id # CCXT should handle this
    # if client_order_id: params['clientOrderId'] = client_order_id # CCXT should handle this

    if order_filter:
        params['orderFilter'] = order_filter.value
        log_prefix += f" Filter:{order_filter.value}"

    logger.debug(f"{log_prefix}: Sending fetch request with params {params}...")

    # --- Execute Fetch ---
    try:
        # Use CCXT's unified fetch_order method.
        order_data = await exchange.fetch_order(id=primary_id, symbol=symbol, params=params)

        status = order_data.get('status', 'N/A')
        returned_id = order_data.get('id')
        log_color = Fore.GREEN if status in ['closed', 'filled', 'canceled'] else Fore.YELLOW if status == 'open' else Fore.CYAN
        logger.info(f"{log_color}{log_prefix}: Fetched successfully. Status: {status}, ID: ...{format_order_id(returned_id)}{Style.RESET_ALL}")
        return order_data

    except OrderNotFound as e:
        logger.warning(f"{Fore.YELLOW}{log_prefix}: Order not found. ({e}){Style.RESET_ALL}")
        return None
    except AuthenticationError as e:
         logger.error(f"{Fore.RED}{log_prefix}: Authentication error: {e}{Style.RESET_ALL}")
         return None
    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e:
         logger.warning(f"{Fore.YELLOW}{log_prefix}: API communication error: {type(e).__name__}. Retry handled by decorator.{Style.RESET_ALL}")
         raise # Re-raise for retry
    except ExchangeError as e:
         # Check if error indicates wrong orderFilter needed
         error_str = str(e).lower()
         # Bybit: 170131 Order does not exist / 170214 Order does not exist or status has been changed
         if "170131" in error_str or "170214" in error_str or "order does not exist" in error_str:
              logger.warning(f"{Fore.YELLOW}{log_prefix}: ExchangeError indicates Order not found ({e}).{Style.RESET_ALL}")
              return None
         elif "order_filter" in error_str: # Generic hint
              logger.warning(f"{log_prefix}: Fetch might require specific 'orderFilter' param (StopOrder, tpslOrder?). Error: {e}")
              return None # Don't retry if params likely wrong
         else:
              logger.error(f"{Fore.RED}{log_prefix}: Exchange error fetching order: {e}{Style.RESET_ALL}", exc_info=True)
              return None # Treat other exchange errors as failure
    except Exception as e:
        logger.error(f"{Fore.RED}{log_prefix}: Unexpected error fetching order: {e}{Style.RESET_ALL}", exc_info=True)
        return None


@retry_api_call()
async def fetch_open_orders_filtered(
    exchange: ccxt.bybit,
    symbol: Optional[str] = None,
    config: Optional[Config] = None,
    category: Optional[Category] = None,
    order_filter: Optional[OrderFilter] = None,
    limit: Optional[int] = None # V5 supports limit (default 50, max 50)
) -> List[Dict]:
    """
    Fetches open orders, allowing filtering by V5 parameters.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Optional: Filter by market symbol.
        config: Optional configuration object.
        category: Optional: Filter by category. Required if symbol is None.
        order_filter: Optional: Filter by order type (Order, StopOrder, tpslOrder).
        limit: Optional: Max number of orders to return (Bybit V5 default/max is 50).

    Returns:
        List of open order dictionaries (CCXT format), or empty list on failure/no orders.
    """
    func_name = "fetch_open_orders_filtered"
    log_prefix = f"[{func_name}]"

    # --- Determine Category ---
    effective_category: Optional[str] = None
    if category:
        effective_category = category.value
        log_prefix += f" | Category: {effective_category}"
    elif symbol:
        cached_category = market_cache.get_category(symbol)
        if cached_category:
            effective_category = cached_category.value
            log_prefix += f" | Symbol: {symbol} (Cat: {effective_category})"
        else:
             logger.error(f"{Fore.RED}{log_prefix}: Cannot determine category for symbol '{symbol}'. Fetch aborted.{Style.RESET_ALL}")
             return []
    else:
        # Attempt to get category from config if available, otherwise fail
        default_symbol = config.get('SYMBOL') if config else None
        if default_symbol:
             cached_category = market_cache.get_category(default_symbol)
             if cached_category:
                  effective_category = cached_category.value
                  logger.warning(f"{log_prefix}: No symbol/category provided, using category '{effective_category}' from default symbol '{default_symbol}'.")
             else:
                  logger.error(f"{Fore.RED}{log_prefix}: Cannot determine category from default symbol '{default_symbol}'. Provide symbol or category.{Style.RESET_ALL}")
                  return []
        else:
            logger.error(f"{Fore.RED}{log_prefix}: Must provide 'symbol' or 'category' (or have a usable default symbol in config). Fetch aborted.{Style.RESET_ALL}")
            return []


    # --- Prepare Parameters ---
    # Bybit V5: GET /v5/order/realtime requires category
    # Can filter by: symbol, baseCoin, orderId, clientOrderId, orderFilter, limit
    params: Dict[str, Any] = {'category': effective_category}
    target_desc = f"category {effective_category}"
    if symbol:
        params['symbol'] = symbol
        target_desc = f"symbol {symbol}"
    if order_filter:
        params['orderFilter'] = order_filter.value
        log_prefix += f" | Filter: {order_filter.value}"
        target_desc += f", filter {order_filter.value}"
    if limit:
        params['limit'] = min(limit, 50) # Clamp limit to V5 max
        target_desc += f", limit {params['limit']}"

    logger.info(f"{Fore.CYAN}{log_prefix}: Fetching open orders for {target_desc}...{Style.RESET_ALL}")

    # --- Execute Fetch ---
    try:
        # Use CCXT's fetch_open_orders, passing V5 params
        open_orders = await exchange.fetch_open_orders(symbol=symbol, params=params)
        logger.info(f"{Fore.GREEN}{log_prefix}: Found {len(open_orders)} open order(s).{Style.RESET_ALL}")
        return open_orders
    except AuthenticationError as e:
         logger.error(f"{Fore.RED}{log_prefix}: Authentication error: {e}{Style.RESET_ALL}")
         return []
    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e:
         logger.warning(f"{Fore.YELLOW}{log_prefix}: API communication error: {type(e).__name__}. Retry handled by decorator.{Style.RESET_ALL}")
         raise # Re-raise for retry
    except ExchangeError as e:
         logger.error(f"{Fore.RED}{log_prefix}: Exchange error fetching open orders: {e}{Style.RESET_ALL}", exc_info=True)
         return []
    except Exception as e:
         logger.error(f"{Fore.RED}{log_prefix}: Unexpected error fetching open orders: {e}{Style.RESET_ALL}", exc_info=True)
         return []


# --- Position Management Functions ---
# ============================
# MODULE: positions.py (Potential Split)
# ============================

@retry_api_call()
async def get_current_position_bybit_v5(
    exchange: ccxt.bybit,
    symbol: str,
    config: Config
) -> Optional[Union[Dict, List[Dict]]]:
    """
    Fetches the current position details for a specific symbol using Bybit V5 endpoint.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Market symbol.
        config: Configuration object.

    Returns:
        - A single CCXT-like position dictionary if in One-Way mode with an open position.
        - A list of CCXT-like position dictionaries if in Hedge mode with open position(s).
        - None if no position exists or the symbol is SPOT/OPTION (or fetch fails).
    """
    func_name = "get_current_position_bybit_v5"
    log_prefix = f"[{func_name} ({symbol})]"
    logger.debug(f"{log_prefix}: Fetching position...")

    category = market_cache.get_category(symbol)
    if not category or category in [Category.SPOT, Category.OPTION]:
        logger.debug(f"{log_prefix}: Positions not applicable for category '{category}'.")
        return None
    # if category == Category.OPTION: logger.warning(f"{log_prefix}: Option position structure might differ.")

    params = {'category': category.value, 'symbol': symbol}

    try:
        # Use V5 specific endpoint GET /v5/position/list
        response = await exchange.private_get_v5_position_list(params=params)
        # logger.debug(f"{log_prefix}: Raw response: {response}")

        ret_code = response.get('retCode')
        if ret_code != 0:
            ret_msg = response.get('retMsg', 'N/A')
            logger.error(f"{Fore.RED}{log_prefix}: API error. Code: {ret_code}, Msg: {ret_msg}{Style.RESET_ALL}")
            # Handle specific errors if needed (e.g., 170001: Internal error)
            return None

        position_list_raw = response.get('result', {}).get('list', [])

        if not position_list_raw:
            logger.info(f"{log_prefix}: No active position found.")
            return None

        # Filter out positions with zero size (within epsilon)
        epsilon = config.get('POSITION_QTY_EPSILON', Decimal('1E-8'))
        open_positions_raw = [
            p for p in position_list_raw
            if abs(safe_decimal_conversion(p.get('size', '0'), Decimal(0))) > epsilon
        ]

        if not open_positions_raw:
            logger.info(f"{log_prefix}: Position(s) found but size is zero.")
            return None

        # --- Parse and Format Positions ---
        parsed_positions = []
        for pos_data in open_positions_raw:
             try:
                 # Use CCXT's parser for consistency
                 # Ensure markets are loaded in the exchange instance for parsing
                  if not exchange.markets: await market_cache.load_markets(exchange)
                  parsed = exchange.parse_position(pos_data)
                  # Add V5 specific info not in standard parse_position
                  parsed['info'] = pos_data # Keep raw V5 data
                  parsed['misc'] = {
                      'positionIdx': pos_data.get('positionIdx'),
                      'riskId': pos_data.get('riskId'),
                      'riskLimitValue': pos_data.get('riskLimitValue'),
                      'takeProfit': pos_data.get('takeProfit'),
                      'stopLoss': pos_data.get('stopLoss'),
                      'trailingStop': pos_data.get('trailingStop'),
                      'tpslMode': pos_data.get('tpslMode'), # 'Full' or 'Partial'
                      'adlRankIndicator': pos_data.get('adlRankIndicator'),
                      'createdTime': pos_data.get('createdTime'),
                      'updatedTime': pos_data.get('updatedTime'),
                  }
                  parsed_positions.append(parsed)
             except Exception as parse_err:
                  logger.error(f"{log_prefix}: Failed to parse position data: {pos_data}. Error: {parse_err}", exc_info=True)
                  # Optionally return raw data or skip
                  # parsed_positions.append({'info': pos_data, 'error': str(parse_err)})


        if not parsed_positions:
             logger.error(f"{log_prefix}: Failed to parse any valid open positions from raw data.")
             return None

        # --- Determine Return Type (Single Dict or List) ---
        position_indices = {p['misc'].get('positionIdx') for p in parsed_positions}

        if len(parsed_positions) == 1:
             pos = parsed_positions[0]
             idx = pos['misc'].get('positionIdx')
             mode = "One-Way" if idx == PositionIdx.ONE_WAY else "Hedge" # Determine mode from index
             logger.info(f"{Fore.GREEN}{log_prefix}: Found position ({mode} Mode): Side: {pos.get('side')}, Size: {pos.get('contracts')}, Entry: {pos.get('entryPrice')}{Style.RESET_ALL}")
             return pos # Return single dict for one-way or single hedge side
        else:
             # Multiple entries usually mean Hedge Mode (Buy and Sell sides)
             logger.info(f"{Fore.GREEN}{log_prefix}: Found {len(parsed_positions)} position entries (Hedge Mode). Returning list.{Style.RESET_ALL}")
             for pos in parsed_positions:
                  logger.info(f"  - Side: {pos.get('side')}, Size: {pos.get('contracts')}, Entry: {pos.get('entryPrice')}, Idx: {pos['misc'].get('positionIdx')}")
             return parsed_positions # Return list for hedge mode

    except AuthenticationError as e:
         logger.error(f"{Fore.RED}{log_prefix}: Authentication error: {e}{Style.RESET_ALL}")
         return None
    except (NetworkError, ExchangeNotAvailable, RateLimitExceeded) as e:
         logger.warning(f"{Fore.YELLOW}{log_prefix}: API communication error: {type(e).__name__}. Retry handled by decorator.{Style.RESET_ALL}")
         raise # Re-raise for retry
    except ExchangeError as e:
         logger.error(f"{Fore.RED}{log_prefix}: Exchange error: {e}{Style.RESET_ALL}", exc_info=True)
         return None
    except Exception as e:
         logger.error(f"{Fore.RED}{log_prefix}: Unexpected error: {e}{Style.RESET_ALL}", exc_info=True)
         return None


async def close_position_reduce_only(exchange: ccxt.bybit, symbol: str, config: Config) -> bool:
    """
    Closes the entire current position(s) for a symbol using reduceOnly market order(s).
    Handles both One-Way and Hedge modes.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Market symbol.
        config: Configuration object.

    Returns:
        True if all open positions for the symbol were successfully closed (or none existed).
        False if fetching the position or placing closing orders failed.
    """
    func_name = "close_position_reduce_only"
    log_prefix = f"[{func_name} ({symbol})]"
    logger.info(f"{Fore.YELLOW}{log_prefix}: Attempting to close position(s) via reduceOnly market order...{Style.RESET_ALL}")

    # 1. Get current position details
    position_data = await get_current_position_bybit_v5(exchange, symbol, config)

    if position_data is None:
        logger.info(f"{log_prefix}: No open position found. Nothing to close.")
        return True # Success, no position existed

    # Ensure position_data is a list for consistent handling
    positions_to_close = position_data if isinstance(position_data, list) else [position_data]

    # 2. Prepare closing orders for each position entry
    close_orders_placed = []
    all_orders_successful = True

    for position in positions_to_close:
        position_size = position.get('contracts') # Size from formatted position
        entry_price = position.get('entryPrice')
        position_side = position.get('side') # 'buy' or 'sell'
        position_idx_val = position.get('misc', {}).get('positionIdx')
        position_idx_enum = PositionIdx(position_idx_val) if position_idx_val is not None else None

        if not position_size or not position_side:
            logger.error(f"{Fore.RED}{log_prefix}: Invalid position data entry: {position}. Cannot determine size/side. Skipping closure for this entry.{Style.RESET_ALL}")
            all_orders_successful = False
            continue

        close_side = Side.SELL if position_side == 'buy' else Side.BUY
        close_amount = Decimal(str(position_size)) # Ensure Decimal amount

        mode_desc = f"(Idx: {position_idx_val})" if position_idx_enum != PositionIdx.ONE_WAY else ""
        logger.info(f"{log_prefix}: Current Position {mode_desc}: {position_side} {close_amount} @ {entry_price}. Preparing {close_side.value} reduceOnly market order.")

        # 3. Place the reduceOnly market order for this position entry
        close_order = await place_market_order_slippage_check(
            exchange=exchange,
            symbol=symbol,
            side=close_side,
            amount=close_amount,
            config=config,
            is_reduce_only=True,
            client_order_id=f"close_{symbol}_{position_idx_val}_{int(time.time()*1000)}", # Unique ID per side
            position_idx=position_idx_enum # Pass the correct index for hedge mode
        )

        close_orders_placed.append(close_order)

        if close_order and close_order.get('status') in ['closed', 'filled']:
            logger.success(f"{Fore.GREEN}{log_prefix}: Position entry {mode_desc} successfully closed by order ID ...{format_order_id(close_order.get('id'))}.{Style.RESET_ALL}")
        elif close_order:
            logger.warning(f"{Fore.YELLOW}{log_prefix}: Close order placed for entry {mode_desc} (ID ...{format_order_id(close_order.get('id'))}) but status is '{close_order.get('status')}'. Position might not be fully closed.{Style.RESET_ALL}")
            all_orders_successful = False
        else:
            logger.error(f"{Fore.RED}{log_prefix}: Failed to place closing market order for position entry {mode_desc}.{Style.RESET_ALL}")
            all_orders_successful = False

        # Small delay between closing orders if in hedge mode might be prudent
        if len(positions_to_close) > 1:
            await asyncio.sleep(0.3)

    # 4. Final Verification (Optional but recommended)
    if all_orders_successful:
        logger.info(f"{log_prefix}: All closing orders sent successfully. Verifying position state...")
        await asyncio.sleep(config.get('DEFAULT_RECV_WINDOW', 5000) / 1000 + 1.0) # Wait for API to settle
        final_position = await get_current_position_bybit_v5(exchange, symbol, config)
        if final_position is None:
            logger.success(f"{Fore.GREEN}{log_prefix}: Position confirmed closed for {symbol}.{Style.RESET_ALL}")
            return True
        else:
            logger.warning(f"{Fore.YELLOW}{log_prefix}: Verification failed - position still shows open after closure attempt. Details: {final_position}{Style.RESET_ALL}")
            return False # Closure did not result in zero position
    else:
        logger.error(f"{Fore.RED}{log_prefix}: One or more closing orders failed or were not confirmed filled. Position closure failed.{Style.RESET_ALL}")
        return False


# --- WebSocket Functionality ---
# ============================
# MODULE: websocket.py (Potential Split)
# ============================

# Global dictionary to keep track of active WebSocket connections/subscriptions
# Key: Unique URL, Value: WebSocketClientProtocol instance
_active_websockets: Dict[str, Any] = {} # Use 'Any' due to websockets potentially being None
# Global dictionary to track background message handling tasks
# Key: Unique URL, Value: asyncio.Task instance
_websocket_tasks: Dict[str, asyncio.Task] = {}
# Lock for managing access to the global tracking dicts
_ws_manage_lock = asyncio.Lock()

async def _handle_websocket_message(
    ws: websockets.WebSocketClientProtocol, # Pass type hint directly
    url: str,
    callback: Callable[[Dict], Coroutine[Any, Any, None]], # Callback should be async
    ping_interval: Optional[float] = 20.0 # Bybit requires sending pings
):
    """ Internal handler to process messages, send pings, and manage connection state. """
    func_name = "_handle_websocket_message"
    logger.info(f"[{func_name}] Starting message handler for {url}")
    last_ping_time = time.monotonic()
    is_private = '/private' in url # Check if it's a private stream

    while not ws.closed:
        try:
            # Wait for message with a timeout to allow sending pings
            recv_timeout = ping_interval / 2 if ping_interval else 10.0
            message_str = await asyncio.wait_for(ws.recv(), timeout=recv_timeout)

            try:
                message_data = json.loads(message_str)
                # logger.debug(f"[{func_name} ({url})] Received: {message_data}") # Very verbose

                # Handle PING from server (Bybit public doesn't use server ping, but good practice)
                if message_data.get("op") == "ping":
                    pong_payload = {"op": "pong"}
                    if "req_id" in message_data: pong_payload["req_id"] = message_data["req_id"]
                    await ws.send(json.dumps(pong_payload))
                    logger.debug(f"[{func_name} ({url})] Sent PONG response.")
                    continue

                # Handle AUTH response for private streams
                if is_private and message_data.get("op") == "auth":
                    if message_data.get("success"):
                        logger.success(f"{Fore.GREEN}[{func_name} ({url})] WebSocket authentication successful.{Style.RESET_ALL}")
                    else:
                        auth_err_msg = message_data.get("ret_msg", "Unknown auth error")
                        logger.error(f"{Back.RED}[{func_name} ({url})] WebSocket authentication FAILED: {auth_err_msg}{Style.RESET_ALL}")
                        # Close connection on auth failure?
                        await ws.close(code=1008, reason="Authentication failed")
                        break # Exit handler loop
                    continue # Don't pass auth response to main callback

                 # Handle SUBSCRIBE response
                if message_data.get("op") == "subscribe":
                    if message_data.get("success"):
                         sub_args = message_data.get("req", {}).get("args", message_data.get("args", [])) # V5 response structure varies
                         logger.info(f"{Fore.GREEN}[{func_name} ({url})] Subscription successful for: {sub_args}{Style.RESET_ALL}")
                    else:
                         sub_err_msg = message_data.get("ret_msg", "Unknown subscription error")
                         logger.error(f"{Back.RED}[{func_name} ({url})] Subscription FAILED: {sub_err_msg}{Style.RESET_ALL}")
                    continue # Don't pass subscription response to main callback

                # Pass data message to the user's callback function
                # Ensure callback is awaited if it's an async function
                await callback(message_data)

            except json.JSONDecodeError:
                logger.warning(f"[{func_name} ({url})] Received non-JSON message: {message_str[:100]}...")
            except Exception as cb_err:
                logger.error(f"[{func_name} ({url})] Error in user callback function: {cb_err}", exc_info=True)
                # Continue processing other messages

        except asyncio.TimeoutError:
            # No message received within timeout, check if ping needed
            if ping_interval and (time.monotonic() - last_ping_time > ping_interval):
                 try:
                      ping_payload = {"req_id": f"ping_{int(time.time()*1000)}", "op": "ping"}
                      await ws.send(json.dumps(ping_payload))
                      last_ping_time = time.monotonic()
                      logger.debug(f"[{func_name} ({url})] Sent PING request.")
                 except ConnectionClosed:
                      logger.warning(f"[{func_name} ({url})] Connection closed while trying to send ping.")
                      break # Exit handler loop
                 except Exception as ping_err:
                      logger.error(f"[{func_name} ({url})] Error sending ping: {ping_err}")
                      # Decide whether to break or continue
            continue # Continue loop after timeout or ping
        except ConnectionClosedOK:
            logger.info(f"[{func_name} ({url})] Connection closed normally.")
            break
        except ConnectionClosedError as e:
            logger.warning(f"[{func_name} ({url})] Connection closed with error: {e}. Code: {e.code}, Reason: {e.reason}")
            break # Exit handler loop, reconnection handled elsewhere if needed
        except WebSocketException as e:
             logger.error(f"[{func_name} ({url})] WebSocket exception: {e}", exc_info=True)
             break # Exit on other WS errors
        except Exception as e:
            logger.error(f"[{func_name} ({url})] Unexpected error in message handler loop: {e}", exc_info=True)
            break # Exit on unexpected errors

    logger.info(f"[{func_name}] Message handler stopped for {url}.")
    # Clean up global tracking when handler exits
    async with _ws_manage_lock:
        if url in _active_websockets:
            del _active_websockets[url]
        if url in _websocket_tasks:
            # Check if task is already done to avoid errors cancelling a completed task
            if not _websocket_tasks[url].done():
                 _websocket_tasks[url].cancel() # Attempt cancellation
            del _websocket_tasks[url]
    logger.debug(f"[{func_name}] Cleaned up tracking for {url}.")


async def subscribe_to_websocket(
    topics: List[str],
    config: Config,
    callback: Callable[[Dict], Coroutine[Any, Any, None]], # Async callback expected
    endpoint_type: Literal['public', 'private'] = 'public',
    market_category: Category = Category.LINEAR,
    connect_timeout: float = 10.0, # Seconds
    ping_interval: Optional[float] = 20.0 # Seconds, None to disable client pings
) -> bool:
    """
    Subscribes to Bybit V5 WebSocket streams. Manages connection and message handling.

    Args:
        topics: List of subscription topic strings (e.g., "tickers.BTCUSDT").
        config: Configuration object (API keys needed for private).
        callback: Async function called with each received data message (dict).
        endpoint_type: 'public' or 'private'.
        market_category: Market category (linear, inverse, spot, option) for endpoint URL.
        connect_timeout: Timeout for establishing the connection.
        ping_interval: Interval in seconds to send PING messages to keep connection alive.
                       Set to None to disable client-side pings.

    Returns:
        True if subscription request was successfully sent, False otherwise.
    """
    func_name = "subscribe_to_websocket"
    log_prefix = f"[{func_name}]"

    if not websockets:
        logger.error(f"{Fore.RED}{log_prefix}: 'websockets' library not installed. Cannot subscribe.{Style.RESET_ALL}")
        return False
    if not topics:
        logger.warning(f"{Fore.YELLOW}{log_prefix}: No topics provided.{Style.RESET_ALL}")
        return False
    if endpoint_type == 'private' and (not config.get('API_KEY') or not config.get('API_SECRET')):
         logger.error(f"{Fore.RED}{log_prefix}: Private endpoint requires API_KEY and API_SECRET.{Style.RESET_ALL}")
         return False

    # Determine WebSocket URL
    base_url = "wss://stream-testnet.bybit.com/v5" if config['TESTNET_MODE'] else "wss://stream.bybit.com/v5"
    url = f"{base_url}/{endpoint_type}/{market_category.value}"

    logger.info(f"{Fore.CYAN}{log_prefix}: Initiating subscription to {url} for topics: {topics}{Style.RESET_ALL}")

    ws: Optional[Any] = None # Define ws variable

    async with _ws_manage_lock: # Ensure atomic check/creation of connection
        if url in _active_websockets and not _active_websockets[url].closed:
            ws = _active_websockets[url]
            logger.info(f"{log_prefix}: Reusing existing WebSocket connection to {url}")
        else:
            # Establish new connection
            logger.info(f"{log_prefix}: Establishing new connection to {url}...")
            try:
                # Add extra headers if needed (e.g., User-Agent)
                extra_headers = {"User-Agent": f"PyrmethusV3-Helper"}
                ws = await asyncio.wait_for(
                    websockets.connect(url, extra_headers=extra_headers, ping_interval=None), # Disable automatic pings if handling manually
                    timeout=connect_timeout
                )
                _active_websockets[url] = ws
                logger.info(f"{log_prefix}: Connection established to {url}. Starting message handler...")

                # Start background message handler task
                task = asyncio.create_task(
                    _handle_websocket_message(ws, url, callback, ping_interval=ping_interval)
                )
                _websocket_tasks[url] = task
                # Optional: Add callback for task completion/error
                task.add_done_callback(lambda t: logger.info(f"WS task for {url} finished. Result/Exception: {t.result() if not t.cancelled() else 'Cancelled'}"))

            except asyncio.TimeoutError:
                 logger.error(f"{Back.RED}{log_prefix}: Timed out connecting to WebSocket: {url}{Style.RESET_ALL}")
                 return False
            except (InvalidURI, WebSocketException) as e:
                 logger.error(f"{Back.RED}{log_prefix}: WebSocket connection failed: {e}{Style.RESET_ALL}")
                 return False
            except Exception as e:
                 logger.error(f"{Back.RED}{log_prefix}: Unexpected error during WebSocket connection: {e}{Style.RESET_ALL}", exc_info=True)
                 return False

        # --- Authenticate if Private ---
        if ws and endpoint_type == 'private':
            try:
                # Check if already authenticated (e.g., reusing connection) - requires state tracking if needed
                # For simplicity, re-authenticate if needed or assume handler manages state.
                logger.info(f"{log_prefix}: Sending authentication request for private stream...")
                # Use a temporary CCXT instance for signing if main exchange instance not readily available
                temp_exchange = ccxt.bybit({'apiKey': config['API_KEY'], 'secret': config['API_SECRET']})
                expires = int((time.time() + 10) * 1000) # Expires in 10 seconds
                signature = temp_exchange.hmac(f'GET/realtime{expires}'.encode(), config['API_SECRET'].encode(), 'sha256')
                auth_payload = {
                    "op": "auth",
                    "args": [config['API_KEY'], expires, signature]
                }
                await ws.send(json.dumps(auth_payload))
                # Auth success/failure is handled in the message handler loop
            except Exception as auth_err:
                 logger.error(f"{log_prefix}: Failed to send authentication payload: {auth_err}")
                 # Consider closing the connection if auth sending fails critically
                 # await unsubscribe_from_websocket(url) # Might be needed
                 return False

        # --- Send Subscription Request ---
        if ws:
            try:
                sub_payload = {
                    "req_id": f"sub_{int(time.time()*1000)}", # Add unique req_id
                    "op": "subscribe",
                    "args": topics
                }
                await ws.send(json.dumps(sub_payload))
                logger.info(f"{log_prefix}: Subscription request sent for topics: {topics}")
                # Success/failure handled in message handler loop
                return True
            except ConnectionClosed:
                 logger.error(f"{log_prefix}: Connection closed before subscription could be sent.")
                 return False
            except Exception as sub_err:
                logger.error(f"{log_prefix}: Failed to send subscription payload: {sub_err}")
                return False
        else:
            # Should not happen if logic above is correct
            logger.error(f"{log_prefix}: WebSocket connection not available for subscription.")
            return False


async def unsubscribe_from_websocket(url: str, topics: Optional[List[str]] = None) -> bool:
    """
    Unsubscribes from topics or closes a specific WebSocket connection managed by this helper.

    Args:
        url: The unique URL of the WebSocket connection (e.g., wss://stream.../public/linear).
        topics: Optional list of topics to unsubscribe from. If None, closes the entire connection for the URL.

    Returns:
        True if unsubscribe/close was successful or connection already closed, False otherwise.
    """
    func_name = "unsubscribe_from_websocket"
    log_prefix = f"[{func_name} ({url})]"

    if not websockets: return True # Nothing to do if websockets not installed

    async with _ws_manage_lock:
        if url not in _active_websockets:
            logger.warning(f"{Fore.YELLOW}{log_prefix}: No active WebSocket connection found to manage.{Style.RESET_ALL}")
            # Ensure task is also cleaned up if somehow orphaned
            if url in _websocket_tasks: del _websocket_tasks[url]
            return True # No connection exists, so it's effectively "unsubscribed"

        ws = _active_websockets[url]
        if ws.closed:
             logger.warning(f"{Fore.YELLOW}{log_prefix}: Connection was already closed.{Style.RESET_ALL}")
             del _active_websockets[url]
             if url in _websocket_tasks:
                  if not _websocket_tasks[url].done(): _websocket_tasks[url].cancel()
                  del _websocket_tasks[url]
             return True

        try:
            if topics:
                # Send unsubscribe message
                unsub_payload = {
                    "req_id": f"unsub_{int(time.time()*1000)}",
                    "op": "unsubscribe",
                    "args": topics
                }
                await ws.send(json.dumps(unsub_payload))
                logger.info(f"{log_prefix}: Unsubscribe request sent for topics: {topics}")
                # Note: We don't explicitly wait for confirmation here.
            else:
                # Close the entire connection
                logger.info(f"{log_prefix}: Closing WebSocket connection...")
                await ws.close(code=1000, reason="Client requested close")
                logger.info(f"{log_prefix}: WebSocket connection closed by request.")
                 # Task cancellation and dict cleanup happens in _handle_websocket_message finally block

            return True
        except ConnectionClosed:
             logger.warning(f"{log_prefix}: Connection closed unexpectedly during operation.")
             # Cleanup handled by the message handler task's finally block
             return True
        except WebSocketException as e:
             logger.error(f"{Fore.RED}{log_prefix}: WebSocket error during unsubscribe/close: {e}{Style.RESET_ALL}")
             return False
        except Exception as e:
            logger.error(f"{Fore.RED}{log_prefix}: Unexpected error during unsubscribe/close: {e}{Style.RESET_ALL}", exc_info=True)
            return False

# --- Placeholder Implementations for Less Common Functions ---
# These require careful reading of Bybit V5 docs and testing.

async def set_position_mode_bybit_v5(exchange: ccxt.bybit, config: Config, mode: Literal['one-way', 'hedge'], category: Optional[Category] = None, symbol: Optional[str] = None) -> bool:
    """ Sets account position mode (One-way or Hedge) per category. """
    func_name = "set_position_mode_bybit_v5"
    log_prefix = f"[{func_name}]"
    logger.warning(f"{Fore.YELLOW}{log_prefix}: Basic implementation. Verify category/symbol requirements from V5 docs.{Style.RESET_ALL}")

    # V5 endpoint: POST /v5/position/switch-mode
    # Requires category, mode (0 for One-Way, 3 for Hedge). Symbol might be optional or required.
    target_category: Optional[str] = None
    if category:
        target_category = category.value
    elif symbol:
        cat_enum = market_cache.get_category(symbol)
        if cat_enum: target_category = cat_enum.value
    elif config.get('SYMBOL'):
         cat_enum = market_cache.get_category(config['SYMBOL'])
         if cat_enum: target_category = cat_enum.value

    if not target_category or target_category == Category.SPOT.value: # Mode doesn't apply to Spot
         logger.error(f"{log_prefix}: Invalid or missing category for setting position mode. Category: {target_category}")
         return False

    bybit_mode = 3 if mode == 'hedge' else 0 # 0: Merged Single (One-Way), 3: Both Sides (Hedge)

    params = {
        'category': target_category,
        'mode': bybit_mode
    }
    # Symbol might be needed depending on API version/category, add if required by testing/docs
    # if symbol: params['symbol'] = symbol

    logger.info(f"{Fore.CYAN}{log_prefix}: Setting position mode to '{mode}' ({bybit_mode}) for category {target_category}...{Style.RESET_ALL}")

    try:
        response = await exchange.private_post_v5_position_switch_mode(params=params)
        logger.debug(f"{log_prefix}: Raw response: {response}")
        ret_code = response.get('retCode')
        if ret_code == 0:
             logger.success(f"{Fore.GREEN}{log_prefix}: Position mode successfully set to '{mode}'.{Style.RESET_ALL}")
             return True
        else:
             # Common errors: 170021 (Cannot switch mode if positions/orders exist)
             ret_msg = response.get('retMsg', 'N/A')
             logger.error(f"{Fore.RED}{log_prefix}: Failed to set position mode. Code: {ret_code}, Msg: {ret_msg}{Style.RESET_ALL}")
             return False
    except Exception as e:
         logger.error(f"{Fore.RED}{log_prefix}: Error setting position mode: {e}{Style.RESET_ALL}", exc_info=True)
         return False


async def place_native_stop_loss(
    exchange: ccxt.bybit, symbol: str, side: Side, amount: Decimal, stop_price: Decimal, config: Config,
    base_price: Optional[Decimal] = None, trigger_direction: Optional[TriggerDirection] = None,
    is_reduce_only: bool = True, order_type: Literal['Market', 'Limit'] = 'Market',
    limit_price: Optional[Decimal] = None, position_idx: Optional[PositionIdx] = None
) -> Optional[Dict]:
    """ Places a native stop-loss order using conditional order endpoint. (Basic Implementation) """
    func_name = "place_native_stop_loss"
    log_prefix = f"[{func_name} ({symbol}, {side.value}, SL:{stop_price})]"
    logger.warning(f"{Fore.YELLOW}{log_prefix}: Basic V5 conditional SL implementation. Verify all parameters and test carefully.{Style.RESET_ALL}")

    category = market_cache.get_category(symbol)
    if not category or category == Category.SPOT: # Conditional orders usually for derivatives
         logger.error(f"{Fore.RED}{log_prefix}: Invalid category '{category}'.{Style.RESET_ALL}")
         return None

    # Determine trigger direction if not specified
    if trigger_direction is None:
        # If placing a sell stop (for a long position), trigger on price FALL
        # If placing a buy stop (for a short position), trigger on price RISE
        trigger_direction = TriggerDirection.FALL if side == Side.SELL else TriggerDirection.RISE
        logger.debug(f"{log_prefix}: Auto-determined triggerDirection: {trigger_direction.name}")

    # Base price (mandatory for Bybit V5 conditional orders)
    # Usually use current mark or last price if not provided
    if base_price is None:
        ticker = await fetch_ticker_validated(exchange, symbol, config)
        if ticker and ticker.get('mark'): base_price = safe_decimal_conversion(ticker['mark'])
        elif ticker and ticker.get('last'): base_price = safe_decimal_conversion(ticker['last'])
        if base_price is None:
            logger.error(f"{Fore.RED}{log_prefix}: Cannot determine base_price automatically. Please provide it.{Style.RESET_ALL}")
            return None
        logger.debug(f"{log_prefix}: Using auto-determined base_price: {base_price}")

    # Format inputs
    amount_str = format_amount(exchange, symbol, amount)
    stop_price_str = format_price(exchange, symbol, stop_price)
    base_price_str = format_price(exchange, symbol, base_price)
    limit_price_str = format_price(exchange, symbol, limit_price) if order_type == 'Limit' else None

    if not all([amount_str, stop_price_str, base_price_str]):
        logger.error(f"{Fore.RED}{log_prefix}: Failed to format required inputs.{Style.RESET_ALL}")
        return None
    if order_type == 'Limit' and not limit_price_str:
        logger.error(f"{Fore.RED}{log_prefix}: Limit price required for Limit stop order.{Style.RESET_ALL}")
        return None

    # --- Prepare V5 Conditional Order Params ---
    params = {
        'category': category.value,
        'symbol': symbol,
        'side': side.value.capitalize(),
        'orderType': order_type.capitalize(),
        'qty': amount_str,
        'triggerPrice': stop_price_str,
        'triggerDirection': trigger_direction.value,
        'basePrice': base_price_str,
        'orderFilter': OrderFilter.STOP_ORDER.value, # Crucial: Identify as conditional
        'reduceOnly': is_reduce_only,
        'closeOnTrigger': False, # Usually false for SL, unless it's the only exit
        # 'slOrderType': 'Market', # Part of the main order TP/SL mechanism, not separate conditional
        # 'stopLoss': stop_price_str, # This is for TP/SL on main order, not separate conditional
    }
    if order_type == 'Limit' and limit_price_str:
        params['price'] = limit_price_str
    if position_idx is not None:
        params['positionIdx'] = position_idx.value

    logger.info(f"{Fore.CYAN}{log_prefix}: Placing conditional stop order with params: {params}...{Style.RESET_ALL}")

    try:
        # Use the standard create_order endpoint with specific params for conditional orders
        order = await exchange.create_order(
            symbol=symbol,
            type=order_type, # Market or Limit (type of triggered order)
            side=side.value, # Buy or Sell (direction of triggered order)
            amount=float(amount_str),
            price=float(limit_price_str) if order_type == 'Limit' and limit_price_str else None,
            params=params
        )
        logger.success(f"{Fore.GREEN}{log_prefix}: Successfully placed conditional stop order. ID: ...{format_order_id(order.get('id'))}, Status: {order.get('status')}{Style.RESET_ALL}")
        return order
    except Exception as e:
         logger.error(f"{Fore.RED}{log_prefix}: Failed to place conditional stop order: {e}{Style.RESET_ALL}", exc_info=True)
         return None


# --- Standalone Testing / Example Usage ---
# =======================================

if __name__ == "__main__":
    print(f"{Style.BRIGHT}{Fore.YELLOW}--- Bybit V5 Helpers v3.0 Standalone Execution ---{Style.RESET_ALL}")

    # --- Configuration ---
    # Load sensitive data from environment variables for security
    API_KEY = os.getenv("BYBIT_API_KEY")
    API_SECRET = os.getenv("BYBIT_API_SECRET")
    # Default to Testnet if variable not set or not 'false'
    USE_TESTNET = os.getenv("BYBIT_USE_TESTNET", "True").lower() != "false"

    if not API_KEY or not API_SECRET:
         print(f"{Fore.RED}------------------------------------------------------------")
         print(f" WARNING: API_KEY or API_SECRET environment variable not set.")
         print(f"          Using PLACEHOLDER values. Most functions WILL FAIL.")
         print(f"          Set environment variables for authenticated tests.")
         print(f"------------------------------------------------------------{Style.RESET_ALL}")
         API_KEY = "PLACEHOLDER_KEY"
         API_SECRET = "PLACEHOLDER_SECRET"

    # Example configuration using loaded variables
    example_config: Config = {
        'EXCHANGE_ID': 'bybit',
        'API_KEY': API_KEY,
        'API_SECRET': API_SECRET,
        'TESTNET_MODE': USE_TESTNET,
        'SYMBOL': 'BTC/USDT:USDT',       # Default linear perpetual
        'USDT_SYMBOL': 'USDT',
        'DEFAULT_MARGIN_MODE': 'isolated', # Or 'cross'
        'DEFAULT_RECV_WINDOW': 10000,    # Increased window can help with timing issues
        'DEFAULT_SLIPPAGE_PCT': Decimal('0.005'), # 0.5%
        'POSITION_QTY_EPSILON': Decimal('1E-8'), # Precision for comparing quantities
        'SHALLOW_OB_FETCH_DEPTH': 5,            # For quick spread check
        'ORDER_BOOK_FETCH_LIMIT': 50,           # Max depth for fetch_l2_order_book_validated
        'EXPECTED_MARKET_TYPE': 'swap',
        'EXPECTED_MARKET_LOGIC': 'linear',
        'RETRY_COUNT': 2 # Lower retry count for faster feedback in examples
    }

    # --- Logging Setup for Example ---
    # Configure root logger for captures from the helper and other libraries
    logging.basicConfig(level=logging.INFO, # Change to DEBUG for max detail
                        format="%(asctime)s [%(levelname)-5s] %(name)-20s | %(message)s",
                        datefmt="%H:%M:%S")
    # Optionally set specific level for the helper module's logger
    logging.getLogger(__name__).setLevel(logging.DEBUG)
    # Silence overly noisy libraries if needed
    logging.getLogger("websockets").setLevel(logging.INFO)
    logging.getLogger("ccxt").setLevel(logging.INFO) # CCXT can be very verbose on DEBUG


    # --- Main Async Execution Function ---
    async def run_example():
        print(f"\n{Style.BRIGHT}{Fore.CYAN}--- Running Example Usage (Testnet: {USE_TESTNET}) ---{Style.RESET_ALL}")
        exchange = await initialize_bybit(example_config)

        if not exchange:
            print(f"{Back.RED}{Fore.WHITE} FATAL: Failed to initialize exchange. Exiting example. {Style.RESET_ALL}")
            return

        # --- Example Calls ---
        try:
            print(f"\n{Fore.MAGENTA}--- 1. Basic Info & Validation ---{Style.RESET_ALL}")
            if API_KEY != "PLACEHOLDER_KEY":
                await fetch_usdt_balance(exchange, example_config)
            else:
                print(f"{Fore.YELLOW}Skipping balance check (API keys missing).{Style.RESET_ALL}")

            market_valid = await validate_market(exchange, example_config['SYMBOL'], example_config)
            if not market_valid: print(f"{Fore.RED}Default symbol validation failed!{Style.RESET_ALL}")

            await fetch_ticker_validated(exchange, example_config['SYMBOL'], example_config)
            await fetch_funding_rate(exchange, example_config['SYMBOL'], example_config)
            await fetch_funding_rate(exchange, example_config['SYMBOL'], example_config, fetch_next=True)
            await fetch_l2_order_book_validated(exchange, example_config['SYMBOL'], 5, example_config) # Shallow fetch
            await fetch_recent_trades(exchange, example_config['SYMBOL'], 10, example_config)

            # Example OHLCV Fetch (check if pandas installed)
            if pd:
                 print(f"\n{Fore.MAGENTA}--- 2. OHLCV Data ---{Style.RESET_ALL}")
                 ohlcv_df = await fetch_ohlcv_paginated(exchange, example_config['SYMBOL'], '1m', limit=100) # Fetch last 100 minutes
                 if ohlcv_df is not None and not ohlcv_df.empty:
                     print(f"Fetched {len(ohlcv_df)} 1m candles for {example_config['SYMBOL']}:")
                     print(ohlcv_df.tail())
                 else:
                     print(f"{Fore.YELLOW}Could not fetch OHLCV data.{Style.RESET_ALL}")
            else:
                 print(f"\n{Fore.YELLOW}--- Skipping OHLCV (pandas not installed) ---{Style.RESET_ALL}")


            # --- Authenticated Actions (Require API Keys) ---
            if API_KEY != "PLACEHOLDER_KEY":
                print(f"\n{Fore.MAGENTA}--- 3. Leverage & Position (Authenticated) ---{Style.RESET_ALL}")
                await set_leverage(exchange, example_config['SYMBOL'], 3, example_config) # Set 3x leverage
                await asyncio.sleep(1) # Allow propagation
                position = await get_current_position_bybit_v5(exchange, example_config['SYMBOL'], example_config)
                # Close existing position if any BEFORE placing new test orders
                if position:
                     print(f"{Fore.YELLOW}Existing position found - attempting to close before proceeding...{Style.RESET_ALL}")
                     await close_position_reduce_only(exchange, example_config['SYMBOL'], example_config)
                     await asyncio.sleep(2) # Wait after closing

                print(f"\n{Fore.MAGENTA}--- 4. Order Management (Authenticated - Use Testnet Carefully!) ---{Style.RESET_ALL}")
                if not USE_TESTNET:
                    print(f"{Back.RED} DANGER: Running order examples on MAINNET! Press Ctrl+C now to abort or Enter to continue... {Style.RESET_ALL}")
                    input() # Wait for user confirmation on mainnet

                # --- A. Limit Order Example ---
                ticker = await fetch_ticker_validated(exchange, example_config['SYMBOL'], example_config)
                if ticker and ticker.get('bid'):
                    limit_price = safe_decimal_conversion(ticker['bid']) * Decimal('0.8') # 20% below bid (unlikely to fill)
                    market_info = market_cache.get_market(example_config['SYMBOL'])
                    min_amount = safe_decimal_conversion(market_info.get('limits',{}).get('amount',{}).get('min'), Decimal('0.001'))
                    limit_amount = max(min_amount, Decimal('0.001')) # Use min amount or default

                    print(f"\nTesting Limit Order (BUY {limit_amount} @ {limit_price})...")
                    limit_order = await place_limit_order_tif(exchange, example_config['SYMBOL'], Side.BUY, limit_amount, limit_price, example_config, time_in_force=TimeInForce.GTC)
                    if limit_order:
                        order_id_to_manage = limit_order.get('id')
                        print(f"Placed Limit Order ID: ...{format_order_id(order_id_to_manage)}")
                        await asyncio.sleep(2)
                        await fetch_order(exchange, example_config['SYMBOL'], order_id=order_id_to_manage, config=example_config)
                        print(f"Cancelling order ...{format_order_id(order_id_to_manage)}...")
                        await cancel_order(exchange, example_config['SYMBOL'], order_id=order_id_to_manage, config=example_config)
                        await asyncio.sleep(1)
                        fetch_res = await fetch_order(exchange, example_config['SYMBOL'], order_id=order_id_to_manage, config=example_config)
                        print(f"Fetch after cancel: {'Not Found/Cancelled' if fetch_res is None or fetch_res.get('status') == 'canceled' else 'Still Found?'}")
                    else: print(f"{Fore.RED}Failed to place limit order.{Style.RESET_ALL}")
                else: print(f"{Fore.YELLOW}Skipping limit order test (could not get ticker bid price).{Style.RESET_ALL}")

                # --- B. Market Order Example ---
                # print("\nTesting Market Order (Small BUY)...")
                # market_order = await place_market_order_slippage_check(exchange, example_config['SYMBOL'], Side.BUY, limit_amount, example_config) # Use min amount
                # if market_order: print(f"Placed Market Order ID: ...{format_order_id(market_order.get('id'))}")
                # else: print(f"{Fore.RED}Failed to place market order.{Style.RESET_ALL}")
                # await asyncio.sleep(2) # Wait if order was placed

                # --- C. Batch Order Example ---
                print(f"\nTesting Batch Order (2 Limit Orders)...")
                if ticker and ticker.get('bid') and ticker.get('ask'):
                    batch_price1 = safe_decimal_conversion(ticker['bid']) * Decimal('0.7') # Far below
                    batch_price2 = safe_decimal_conversion(ticker['ask']) * Decimal('1.3') # Far above
                    batch = [
                        {'symbol': example_config['SYMBOL'], 'side': Side.BUY, 'type': 'Limit', 'amount': limit_amount, 'price': batch_price1, 'clientOrderId': f'batch_buy_{int(time.time()*1000)}'},
                        {'symbol': example_config['SYMBOL'], 'side': Side.SELL, 'type': 'Limit', 'amount': limit_amount, 'price': batch_price2, 'clientOrderId': f'batch_sell_{int(time.time()*1000)}'}
                    ]
                    success, errors = await place_batch_orders(exchange, batch, example_config)
                    print(f"Batch Results:")
                    for i in range(len(batch)):
                         if success[i]: print(f"  Order #{i+1}: SUCCESS, ID ...{format_order_id(success[i].get('id'))}")
                         elif errors[i]: print(f"  Order #{i+1}: FAILED, Code: {errors[i].get('code')}, Msg: {errors[i].get('msg')}")
                    # Cancel the batch orders if placed successfully
                    await asyncio.sleep(1)
                    print("Cancelling ALL orders for cleanup...")
                    await cancel_all_orders(exchange, symbol=example_config['SYMBOL'], config=example_config, reason="Batch Test Cleanup")

                else: print(f"{Fore.YELLOW}Skipping batch order test (could not get ticker prices).{Style.RESET_ALL}")


                # --- D. Position Closure Example ---
                # print("\nTesting Position Closure (if any position exists)...")
                # await close_position_reduce_only(exchange, example_config['SYMBOL'], example_config)


            else:
                print(f"\n{Fore.YELLOW}--- Skipping Authenticated Actions (API keys missing/placeholder) ---{Style.RESET_ALL}")


            # --- WebSocket Example ---
            if websockets:
                print(f"\n{Fore.MAGENTA}--- 5. WebSocket Subscription Example (Public Tickers) ---{Style.RESET_ALL}")
                ws_topics = [f"tickers.{example_config['SYMBOL']}"] # Add more topics if desired e.g. "tickers.ETHUSDT"

                # Define the async callback function
                async def handle_ws_message(data: Dict):
                    # This function will be called for every message received on the subscribed topics.
                    topic = data.get('topic', 'N/A')
                    data_content = data.get('data', {})
                    ts = data.get('ts', 'N/A') # Timestamp from Bybit message
                    if topic.startswith("tickers."):
                        symbol = topic.split('.')[-1]
                        last_price = data_content.get('lastPrice')
                        print(f"{Fore.CYAN} WS TICKER | {symbol:<15} | Last Price: {last_price:<15} | Time: {ts}{Style.RESET_ALL}")
                    elif topic.startswith("orderbook."):
                        # Process order book updates...
                        print(f"{Fore.BLUE} WS ORDERBOOK | {topic} | Bids: {len(data_content.get('b', []))} Asks: {len(data_content.get('a', []))} | Time: {ts}{Style.RESET_ALL}")
                    else:
                        # Handle other topics or message types
                        print(f"{Fore.WHITE} WS OTHER | Topic: {topic} | Data: {str(data_content)[:100]}...{Style.RESET_ALL}")

                # Construct the expected URL for this subscription
                ws_base = "wss://stream-testnet.bybit.com/v5" if USE_TESTNET else "wss://stream.bybit.com/v5"
                ws_url = f"{ws_base}/public/linear" # Assuming linear topics

                # Subscribe
                sub_success = await subscribe_to_websocket(
                    topics=ws_topics,
                    config=example_config,
                    callback=handle_ws_message,
                    endpoint_type='public', # Change to 'private' for orders/positions
                    market_category=Category.LINEAR # Match category to topics
                )

                if sub_success:
                    print(f"{Fore.GREEN}Subscribed to WebSocket topics: {ws_topics} on {ws_url}{Style.RESET_ALL}")
                    print("Waiting for messages for 15 seconds...")
                    await asyncio.sleep(15)
                    print("Unsubscribing and closing WebSocket...")
                    unsub_success = await unsubscribe_from_websocket(ws_url)
                    print(f"WebSocket unsubscribe/close {'successful' if unsub_success else 'failed'}.")
                else:
                    print(f"{Fore.RED}WebSocket subscription failed to initiate.{Style.RESET_ALL}")
            else:
                print(f"\n{Fore.YELLOW}--- Skipping WebSocket Example (websockets library not installed) ---{Style.RESET_ALL}")


        except Exception as e:
            logger.critical(f"{Back.RED}{Fore.WHITE} An unexpected error occurred during the example run: {e} {Style.RESET_ALL}", exc_info=True)
        finally:
            # --- Cleanup ---
            if exchange and not exchange.closed:
                print(f"\n{Fore.CYAN}--- Closing Exchange Connection ---{Style.RESET_ALL}")
                await exchange.close()
                print("Exchange connection closed.")
            # Ensure any remaining WS connections are closed (unsubscribe handles this but good failsafe)
            async with _ws_manage_lock:
                 for url, task in list(_websocket_tasks.items()): # Iterate over copy
                      if not task.done():
                           logger.warning(f"Force cancelling potentially orphaned WS task for {url}")
                           task.cancel()
                 for url, ws_conn in list(_active_websockets.items()):
                      if not ws_conn.closed:
                           logger.warning(f"Force closing potentially orphaned WS connection for {url}")
                           await ws_conn.close()


    # --- Run the Async Example ---
    try:
        # Use asyncio.run() for simple cases, or manage event loop explicitly if needed
        asyncio.run(run_example())
        print(f"\n{Style.BRIGHT}{Fore.GREEN}--- Standalone Example Finished ---{Style.RESET_ALL}")
    except KeyboardInterrupt:
        print(f"\n{Fore.YELLOW}--- Execution Interrupted by User ---{Style.RESET_ALL}")
    except Exception as main_err:
         print(f"\n{Back.RED}{Fore.WHITE}--- Top Level Error Caught ---{Style.RESET_ALL}")
         logger.critical(f"An error occurred outside the main example function: {main_err}", exc_info=True)

#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Bybit V5 CCXT Helper Functions (v2.8 - Corrected Syntax Fix in Position Risk Loop)

This module provides a collection of robust, reusable, and enhanced helper functions
designed for interacting with the Bybit exchange, specifically targeting the
V5 API (Unified Trading Account - UTA), using the CCXT library.

Core Functionality Includes:
- Exchange Initialization: Securely sets up the ccxt.bybit exchange instance,
  handling testnet mode, V5 defaults, and initial validation.
- Account Configuration: Functions to set leverage, margin mode (cross/isolated),
  and position mode (one-way/hedge) with V5 specific endpoints and validation.
- Market Data Retrieval: Validated fetching of tickers, OHLCV (with pagination
  and DataFrame conversion), L2 order books, funding rates, and recent trades,
  all using Decimals and V5 parameters.
- Order Management: Placing market, limit, native stop-loss (market), and native
  trailing-stop orders with V5 parameters. Includes options for Time-In-Force (TIF),
  reduce-only, post-only, client order IDs, and slippage checks for market orders.
  Also provides functions for cancelling single or all open orders, fetching open
  orders (filtered), and updating existing limit orders (edit).
- Position Management: Fetching detailed current position information (V5 specific),
  closing positions using reduce-only market orders, and retrieving detailed position
  risk metrics (IMR, MMR, Liq. Price, etc.) using V5 logic.
- Balance & Margin: Fetching USDT balances (equity/available) using V5 UNIFIED
  account logic, and calculating estimated margin requirements for potential orders.
- Utilities: Market validation against exchange data (type, logic, active status).

Key Enhancements in v2.8:
- Corrected the previously missed SyntaxError fix in fetch_position_risk_bybit_v5 loop processing.
- Previous Fixes from v2.1-v2.7.
- Explicitly imports necessary utility functions and decorator from bybit_utils.py.

Dependencies from Importing Script:
- This module now primarily relies on the importing script for:
    1. `logger`: A pre-configured `logging.Logger` object.
    2. `Config`: A configuration class/object instance containing API keys,
       settings, constants (e.g., Config.RETRY_COUNT, Config.SYMBOL, etc.).
       Passed explicitly to functions requiring it.
- Utility functions (`safe_decimal_conversion`, `format_*`, `send_sms_alert`,
  `retry_api_call`, `analyze_order_book`) are imported from `bybit_utils`.
- Ensure `bybit_utils.py` exists and is accessible.
"""

# Standard Library Imports
import logging
import os
import sys
import time
import random # Used in fetch_ohlcv_paginated retry delay jitter
from decimal import Decimal, ROUND_HALF_UP, DivisionByZero, InvalidOperation, getcontext
from typing import Optional, Dict, List, Tuple, Any, Literal, Union, Callable, TypeVar

# Third-party Libraries
try:
    import ccxt
except ImportError:
    print("Error: CCXT library not found. Please install it: pip install ccxt")
    sys.exit(1)
try:
    import pandas as pd
except ImportError:
    print("Error: pandas library not found. Please install it: pip install pandas")
    sys.exit(1)
try:
    from colorama import Fore, Style, Back
except ImportError:
    print("Warning: colorama library not found. Logs will not be colored. Install: pip install colorama")
    # Define dummy color constants if colorama is not available
    class DummyColor:
        def __getattr__(self, name: str) -> str: return ""
    Fore = Style = Back = DummyColor()

# --- Import Utilities from bybit_utils ---
try:
    from bybit_utils import (
        safe_decimal_conversion, format_price, format_amount,
        format_order_id, send_sms_alert, retry_api_call,
        analyze_order_book # Ensure analyze_order_book is defined in bybit_utils
    )
    print("Successfully imported utilities from bybit_utils.")
except ImportError as e:
    print(f"FATAL ERROR: Failed to import required functions/decorator from bybit_utils.py: {e}")
    print("Ensure bybit_utils.py is in the same directory or accessible via PYTHONPATH.")
    sys.exit(1)
except NameError as e:
    # This might happen if retry_api_call itself isn't defined correctly *within* bybit_utils
    print(f"FATAL ERROR: A required name (likely 'retry_api_call') is not defined in bybit_utils.py: {e}")
    sys.exit(1)

# Set Decimal context precision
getcontext().prec = 28

# --- Logger Placeholder (Actual logger MUST be provided by importing script) ---
if 'logger' not in globals():
    logger = logging.getLogger(__name__)
    if not logger.hasHandlers():
        handler = logging.StreamHandler(sys.stdout)
        formatter = logging.Formatter(
            "%(asctime)s [%(levelname)s] {%(filename)s:%(lineno)d:%(funcName)s} - %(message)s",
            datefmt="%Y-%m-%d %H:%M:%S"
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        logger.setLevel(logging.DEBUG)
    logger.info("Placeholder logger initialized for bybit_helpers module. Ensure a configured logger is provided by the importing script.")

# --- External Dependencies Placeholder Reminder ---
# The actual implementations MUST be provided by the importing script.
# ======================================================================
# class Config: pass # Must be defined in importing script/passed to functions
# ======================================================================


# --- Helper Function Implementations ---

def _get_v5_category(market: Dict[str, Any]) -> Optional[Literal['linear', 'inverse', 'spot', 'option']]:
    """Internal helper to determine the Bybit V5 category from a market object."""
    func_name = "_get_v5_category"
    if not market:
        logger.warning(f"[{func_name}] Received empty market data.")
        return None

    # Prefer explicit flags
    if market.get('linear'): return 'linear'
    if market.get('inverse'): return 'inverse'
    if market.get('spot'): return 'spot'
    if market.get('option'): return 'option'

    # Fallback based on market type if explicit flags aren't present
    market_type = market.get('type')
    logger.debug(f"[{func_name}] Market type: {market_type} for symbol {market.get('symbol')}")

    if market_type == 'swap':
        contract_type = market.get('contractType', '').lower()
        if contract_type == 'linear': return 'linear'
        if contract_type == 'inverse': return 'inverse'
        logger.warning(f"[{func_name}] Market type is 'swap' but couldn't determine linear/inverse from contractType '{contract_type}'. Assuming 'linear'.")
        return 'linear'
    elif market_type == 'future':
         logger.warning(f"[{func_name}] Market type is 'future'. Assuming 'linear'.")
         return 'linear'
    elif market_type == 'spot':
        return 'spot'
    elif market_type == 'option':
        return 'option'
    else:
        logger.warning(f"[{func_name}] Could not determine V5 category for market: {market.get('symbol')}, Type: {market_type}")
        return None

# Snippet 1 / Function 1: Initialize Bybit Exchange
@retry_api_call(max_retries=3, initial_delay=2.0) # Apply imported decorator
def initialize_bybit(config: 'Config') -> Optional[ccxt.bybit]:
    """
    Initializes and validates the Bybit CCXT exchange instance using V5 API settings.

    Sets sandbox mode, default order type, loads markets, performs an initial
    balance check, and attempts to set margin mode (logs warning on failure).

    Args:
        config: The configuration object containing API keys, testnet flag, etc.

    Returns:
        A configured and validated `ccxt.bybit` instance, or `None` if initialization fails.

    Raises:
        Catches and logs common CCXT exceptions during initialization attempts.
        Relies on the `retry_api_call` decorator for retries.
    """
    func_name = "initialize_bybit"
    logger.info(f"{Fore.BLUE}[{func_name}] Initializing Bybit (V5) exchange instance...{Style.RESET_ALL}")
    try:
        exchange_class = getattr(ccxt, config.EXCHANGE_ID)
        exchange = exchange_class({
            'apiKey': config.API_KEY,
            'secret': config.API_SECRET,
            'enableRateLimit': True,
            'options': {
                'defaultType': 'swap',
                'adjustForTimeDifference': True,
                'recvWindow': config.DEFAULT_RECV_WINDOW,
                'brokerId': 'PyrmethusV2.8', # Updated Broker ID
            }
        })

        if config.TESTNET_MODE:
            logger.info(f"[{func_name}] Enabling Bybit Sandbox (Testnet) mode.")
            exchange.set_sandbox_mode(True)

        logger.debug(f"[{func_name}] Loading markets...")
        exchange.load_markets(reload=True)
        if not exchange.markets:
             raise ccxt.ExchangeError(f"[{func_name}] Failed to load markets.")
        logger.debug(f"[{func_name}] Markets loaded successfully ({len(exchange.markets)} symbols).")

        logger.debug(f"[{func_name}] Performing initial balance fetch for validation...")
        exchange.fetch_balance({'accountType': 'UNIFIED'})
        logger.debug(f"[{func_name}] Initial balance check successful.")

        try:
            market = exchange.market(config.SYMBOL)
            category = _get_v5_category(market)
            if category and category in ['linear', 'inverse']:
                logger.debug(f"[{func_name}] Attempting to set initial margin mode '{config.DEFAULT_MARGIN_MODE}' for {config.SYMBOL} (Category: {category})...")
                params = {'category': category}
                exchange.set_margin_mode(config.DEFAULT_MARGIN_MODE, config.SYMBOL, params=params)
                logger.info(f"[{func_name}] Initial margin mode potentially set to '{config.DEFAULT_MARGIN_MODE}' for {config.SYMBOL}.")
            else:
                logger.warning(f"[{func_name}] Cannot determine contract category for {config.SYMBOL}. Skipping initial margin mode set.")
        except (ccxt.NotSupported, ccxt.ExchangeError, ccxt.ArgumentsRequired, ccxt.BadSymbol) as e_margin:
            logger.warning(f"{Fore.YELLOW}[{func_name}] Could not set initial margin mode for {config.SYMBOL}: {e_margin}. "
                           f"This might be expected (e.g., UTA Isolated accounts). Verify account settings.{Style.RESET_ALL}")

        logger.success(f"{Fore.GREEN}[{func_name}] Bybit exchange initialized successfully. Testnet: {config.TESTNET_MODE}.{Style.RESET_ALL}")
        return exchange

    except (ccxt.AuthenticationError, ccxt.NetworkError, ccxt.ExchangeNotAvailable, ccxt.ExchangeError) as e:
        logger.error(f"{Fore.RED}[{func_name}] Initialization attempt failed: {type(e).__name__} - {e}{Style.RESET_ALL}")
        raise
    except Exception as e:
        logger.critical(f"{Back.RED}[{func_name}] Unexpected critical error during Bybit initialization: {e}{Style.RESET_ALL}", exc_info=True)
        send_sms_alert(f"[BybitHelper] CRITICAL: Bybit init failed! Unexpected: {type(e).__name__}", config)
        return None

# Snippet 2 / Function 2: Set Leverage
@retry_api_call(max_retries=3, initial_delay=1.0)
def set_leverage(exchange: ccxt.bybit, symbol: str, leverage: int, config: 'Config') -> bool:
    """
    Sets the leverage for a specific symbol on Bybit V5 (Linear/Inverse).

    Validates the requested leverage against the market's limits. Handles the
    'leverage not modified' case gracefully. Applies to both buy and sell leverage.

    Args:
        exchange: The initialized ccxt.bybit exchange instance.
        symbol: The market symbol (e.g., 'BTC/USDT:USDT').
        leverage: The desired integer leverage level.
        config: The configuration object.

    Returns:
        True if leverage was set successfully or already set to the desired value, False otherwise.

    Raises:
        Reraises CCXT exceptions for the retry decorator. ValueError for invalid leverage input.
    """
    func_name = "set_leverage"
    logger.info(f"{Fore.CYAN}[{func_name}] Setting leverage to {leverage}x for {symbol}...{Style.RESET_ALL}")

    if leverage <= 0:
        logger.error(f"{Fore.RED}[{func_name}] Leverage must be positive. Received: {leverage}{Style.RESET_ALL}")
        return False # Invalid input, don't call API

    try:
        market = exchange.market(symbol)
        category = _get_v5_category(market)
        if not category or category not in ['linear', 'inverse']:
            logger.error(f"{Fore.RED}[{func_name}] Invalid market type for leverage setting: {symbol} (Category: {category}).{Style.RESET_ALL}")
            return False

        leverage_filter = market.get('info', {}).get('leverageFilter', {})
        max_leverage_str = leverage_filter.get('maxLeverage')
        min_leverage_str = leverage_filter.get('minLeverage', '1')
        # Use imported safe_decimal_conversion
        max_leverage = int(safe_decimal_conversion(max_leverage_str, default=Decimal('100')))
        min_leverage = int(safe_decimal_conversion(min_leverage_str, default=Decimal('1')))

        if not (min_leverage <= leverage <= max_leverage):
            logger.error(f"{Fore.RED}[{func_name}] Invalid leverage requested: {leverage}x. Allowed range for {symbol}: {min_leverage}x - {max_leverage}x.{Style.RESET_ALL}")
            return False

        params = {
            'category': category,
            'buyLeverage': str(leverage),
            'sellLeverage': str(leverage)
        }

        logger.debug(f"[{func_name}] Calling exchange.set_leverage with symbol='{symbol}', leverage={leverage}, params={params}")
        response = exchange.set_leverage(leverage, symbol, params=params)

        logger.debug(f"[{func_name}] Leverage API call response (raw): {response}")
        logger.success(f"{Fore.GREEN}[{func_name}] Leverage set/confirmed to {leverage}x for {symbol} (Category: {category}).{Style.RESET_ALL}")
        return True

    except ccxt.ExchangeError as e:
        error_str = str(e).lower()
        # 110044: Leverage not modified
        if "leverage not modified" in error_str or "same as input" in error_str or "110044" in str(e):
            logger.info(f"{Fore.CYAN}[{func_name}] Leverage for {symbol} is already set to {leverage}x.{Style.RESET_ALL}")
            return True
        else:
            logger.error(f"{Fore.RED}[{func_name}] ExchangeError setting leverage for {symbol} to {leverage}x: {e}{Style.RESET_ALL}")
            raise
    except (ccxt.NetworkError, ccxt.AuthenticationError, ccxt.BadSymbol) as e:
        logger.error(f"{Fore.RED}[{func_name}] API/Symbol error setting leverage for {symbol}: {e}{Style.RESET_ALL}")
        raise
    except Exception as e:
        logger.error(f"{Fore.RED}[{func_name}] Unexpected error setting leverage for {symbol} to {leverage}x: {e}{Style.RESET_ALL}", exc_info=True)
        # Use imported send_sms_alert
        send_sms_alert(f"[{symbol.split('/')[0]}] ERROR: Failed set leverage {leverage}x (Unexpected)", config)
        return False

# Snippet 3 / Function 3: Fetch USDT Balance (V5 UNIFIED)
@retry_api_call(max_retries=3, initial_delay=1.0)
def fetch_usdt_balance(exchange: ccxt.bybit, config: 'Config') -> Tuple[Optional[Decimal], Optional[Decimal]]:
    """
    Fetches the USDT balance (Total Equity and Available Balance) using Bybit V5 UNIFIED account logic.

    Args:
        exchange: The initialized ccxt.bybit exchange instance.
        config: The configuration object (used for USDT_SYMBOL).

    Returns:
        A tuple containing (total_equity, available_balance) as Decimals,
        or (None, None) if fetching fails or balance cannot be parsed.

    Raises:
        Reraises CCXT exceptions for the retry decorator.
    """
    func_name = "fetch_usdt_balance"
    logger.debug(f"[{func_name}] Fetching USDT balance (Bybit V5 UNIFIED Account)...")

    try:
        params = {'accountType': 'UNIFIED'}
        balance_data = exchange.fetch_balance(params=params)

        info = balance_data.get('info', {})
        result_list = info.get('result', {}).get('list', [])

        equity: Optional[Decimal] = None
        available: Optional[Decimal] = None
        account_type_found: str = "N/A"

        if result_list:
            unified_account_info = next((acc for acc in result_list if acc.get('accountType') == 'UNIFIED'), None)

            if unified_account_info:
                account_type_found = "UNIFIED"
                equity = safe_decimal_conversion(unified_account_info.get('totalEquity'))
                coin_list = unified_account_info.get('coin', [])
                usdt_coin_info = next((coin for coin in coin_list if coin.get('coin') == config.USDT_SYMBOL), None)

                if usdt_coin_info:
                    avail_val = usdt_coin_info.get('availableToWithdraw') or \
                                usdt_coin_info.get('availableBalance') or \
                                usdt_coin_info.get('walletBalance')
                    available = safe_decimal_conversion(avail_val, Decimal("0.0")) # Default to 0 if parsing fails
                else:
                    logger.warning(f"[{func_name}] USDT coin data not found within the UNIFIED account details. Assuming 0 available.")
                    available = Decimal("0.0")

            else:
                logger.warning(f"[{func_name}] 'UNIFIED' account type not found in V5 balance response list. Trying fallback to first account.")
                if len(result_list) >= 1:
                     first_account = result_list[0]; account_type_found = first_account.get('accountType', 'UNKNOWN')
                     logger.warning(f"[{func_name}] Using first account found: Type '{account_type_found}'")
                     equity = safe_decimal_conversion(first_account.get('totalEquity') or first_account.get('equity'))
                     coin_list = first_account.get('coin', [])
                     usdt_coin_info = next((coin for coin in coin_list if coin.get('coin') == config.USDT_SYMBOL), None)
                     if usdt_coin_info:
                         avail_val = usdt_coin_info.get('availableBalance') or usdt_coin_info.get('walletBalance')
                         available = safe_decimal_conversion(avail_val, Decimal("0.0"))
                     else: available = Decimal("0.0")
                else:
                     logger.error(f"[{func_name}] Balance response list is empty. Cannot determine balance.")

        if equity is None or available is None:
            logger.debug(f"[{func_name}] V5 structure parsing failed or incomplete. Trying standard CCXT balance keys...")
            usdt_balance_std = balance_data.get(config.USDT_SYMBOL, {})
            if equity is None: equity = safe_decimal_conversion(usdt_balance_std.get('total'))
            if available is None:
                available = safe_decimal_conversion(usdt_balance_std.get('free'))
                if available is None and equity is not None:
                     logger.warning(f"[{func_name}] CCXT 'free' balance missing, using 'total' ({equity:.4f}) as fallback for available.")
                     available = equity

            if equity is not None and available is not None:
                account_type_found = "CCXT Standard Fallback"
            else:
                 raise ValueError(f"Failed to parse balance from both V5 ({account_type_found}) and Standard structures.")

        final_equity = max(Decimal("0.0"), equity) if equity is not None else Decimal("0.0")
        final_available = max(Decimal("0.0"), available) if available is not None else Decimal("0.0")

        logger.info(f"[{func_name}] USDT Balance Fetched (Source: {account_type_found}): "
                    f"Equity = {final_equity:.4f}, Available = {final_available:.4f}")
        return final_equity, final_available

    except (ccxt.NetworkError, ccxt.ExchangeError, ValueError) as e:
        logger.warning(f"{Fore.YELLOW}[{func_name}] Error fetching/parsing balance: {e}{Style.RESET_ALL}")
        raise
    except Exception as e:
        logger.critical(f"{Back.RED}[{func_name}] Unexpected critical error fetching balance: {e}{Style.RESET_ALL}", exc_info=True)
        send_sms_alert("[BybitHelper] CRITICAL: Failed fetch USDT balance!", config)
        return None, None

# Snippet 4 / Function 4: Place Market Order with Slippage Check
@retry_api_call(max_retries=1, initial_delay=0) # Typically don't retry market orders automatically
def place_market_order_slippage_check(
    exchange: ccxt.bybit,
    symbol: str,
    side: Literal['buy', 'sell'],
    amount: Decimal,
    config: 'Config',
    max_slippage_pct: Optional[Decimal] = None,
    is_reduce_only: bool = False,
    client_order_id: Optional[str] = None
) -> Optional[Dict]:
    """
    Places a market order on Bybit V5 after checking the current spread against a slippage threshold.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Market symbol (e.g., 'BTC/USDT:USDT').
        side: 'buy' or 'sell'.
        amount: Order quantity in base currency (Decimal). Must be positive.
        config: Configuration object.
        max_slippage_pct: Maximum allowed spread percentage (e.g., Decimal('0.005') for 0.5%).
                          Uses `config.DEFAULT_SLIPPAGE_PCT` if None.
        is_reduce_only: If True, set the reduceOnly flag.
        client_order_id: Optional client order ID string (max length 36 for Bybit V5 linear).

    Returns:
        The order dictionary returned by ccxt, or None if the order failed or was aborted pre-flight.
    """
    func_name = "place_market_order_slippage_check"
    market_base = symbol.split('/')[0]
    action = "CLOSE" if is_reduce_only else "ENTRY"
    log_prefix = f"Market Order ({action} {side.upper()})"
    effective_max_slippage = max_slippage_pct if max_slippage_pct is not None else config.DEFAULT_SLIPPAGE_PCT

    logger.info(f"{Fore.BLUE}{log_prefix}: Init {format_amount(exchange, symbol, amount)} {symbol}. "
                f"Max Slippage: {effective_max_slippage:.4%}, ReduceOnly: {is_reduce_only}{Style.RESET_ALL}")

    if amount <= config.POSITION_QTY_EPSILON:
        logger.error(f"{Fore.RED}{log_prefix}: Amount is zero or negative ({amount}). Aborting.{Style.RESET_ALL}")
        return None

    try:
        market = exchange.market(symbol)
        category = _get_v5_category(market)
        if not category:
             logger.error(f"{Fore.RED}[{func_name}] Cannot determine market category for {symbol}. Aborting.{Style.RESET_ALL}")
             return None

        # 1. Perform Slippage Check using validated L2 OB fetch
        logger.debug(f"[{func_name}] Performing pre-order slippage check (Depth: {config.SHALLOW_OB_FETCH_DEPTH})...")
        # Use analyze_order_book imported from bybit_utils
        ob_analysis = analyze_order_book(exchange, symbol, config.SHALLOW_OB_FETCH_DEPTH, config.ORDER_BOOK_FETCH_LIMIT, config)
        best_ask = ob_analysis.get("best_ask")
        best_bid = ob_analysis.get("best_bid")

        if best_bid and best_ask and best_bid > Decimal("0"):
            spread = (best_ask - best_bid) / best_bid
            logger.debug(f"[{func_name}] Current shallow OB: Best Bid={format_price(exchange, symbol, best_bid)}, "
                          f"Best Ask={format_price(exchange, symbol, best_ask)}, Spread={spread:.4%}")
            if spread > effective_max_slippage:
                logger.error(f"{Fore.RED}{log_prefix}: Aborted due to high slippage. "
                             f"Current Spread {spread:.4%} > Max Allowed {effective_max_slippage:.4%}.{Style.RESET_ALL}")
                send_sms_alert(f"[{market_base}] ORDER ABORT ({side.upper()}): High Slippage {spread:.4%}", config)
                return None
        else:
            logger.warning(f"{Fore.YELLOW}{log_prefix}: Could not get valid L2 order book data to check slippage. Proceeding with caution.{Style.RESET_ALL}")

        # 2. Prepare and Place Order
        amount_str = format_amount(exchange, symbol, amount)
        amount_float = float(amount_str)
        params: Dict[str, Any] = {'category': category}
        if is_reduce_only:
            params['reduceOnly'] = True

        if client_order_id:
            max_coid_len = 36 # Max length for Bybit linear/inverse COID
            original_coid_len = len(client_order_id)
            valid_coid = client_order_id[:max_coid_len]
            params['clientOrderId'] = valid_coid
            if len(valid_coid) < original_coid_len:
                logger.warning(f"[{func_name}] Client Order ID truncated to {max_coid_len} chars: '{valid_coid}' (Original length: {original_coid_len})")

        bg = Back.GREEN if side == config.SIDE_BUY else Back.RED
        fg = Fore.BLACK
        logger.warning(f"{bg}{fg}{Style.BRIGHT}*** PLACING MARKET {side.upper()} {'REDUCE' if is_reduce_only else 'ENTRY'}: "
                       f"{amount_str} {symbol} (Params: {params}) ***{Style.RESET_ALL}")

        order = exchange.create_market_order(symbol, side, amount_float, params=params)

        # 3. Log Result
        order_id = order.get('id')
        client_oid_resp = order.get('clientOrderId', params.get('clientOrderId', 'N/A'))
        status = order.get('status', '?')
        filled_qty = safe_decimal_conversion(order.get('filled', '0.0'))
        avg_price = safe_decimal_conversion(order.get('average'))

        logger.success(f"{Fore.GREEN}{log_prefix}: Market order submitted successfully. "
                       f"ID: ...{format_order_id(order_id)}, ClientOID: {client_oid_resp}, Status: {status}, "
                       f"Target Qty: {amount_str}, Filled Qty: {format_amount(exchange, symbol, filled_qty)}, "
                       f"Avg Price: {format_price(exchange, symbol, avg_price)}{Style.RESET_ALL}")
        return order

    except (ccxt.InsufficientFunds, ccxt.InvalidOrder, ccxt.ExchangeError, ccxt.NetworkError) as e:
        logger.error(f"{Fore.RED}{log_prefix}: API Error placing market order: {type(e).__name__} - {e}{Style.RESET_ALL}")
        send_sms_alert(f"[{market_base}] ORDER FAIL ({side.upper()} {action}): {type(e).__name__}", config)
        return None
    except Exception as e:
        logger.critical(f"{Back.RED}[{func_name}] Unexpected critical error placing market order: {e}{Style.RESET_ALL}", exc_info=True)
        send_sms_alert(f"[{market_base}] ORDER FAIL ({side.upper()} {action}): Unexpected {type(e).__name__}.", config)
        return None

# Snippet 5 / Function 5: Cancel All Open Orders
@retry_api_call(max_retries=2, initial_delay=1.0) # Decorator for fetch/network issues
def cancel_all_orders(exchange: ccxt.bybit, symbol: str, config: 'Config', reason: str = "Cleanup") -> bool:
    """
    Cancels all open orders for a specific symbol on Bybit V5.

    Fetches open orders first (defaults to regular 'Order' filter) and attempts
    to cancel each one individually. Handles `OrderNotFound` gracefully.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Market symbol for which to cancel orders.
        config: Configuration object.
        reason: A short string indicating the reason for cancellation (for logging).

    Returns:
        True if all found open orders were successfully cancelled or confirmed gone,
        False if any cancellation failed (excluding OrderNotFound).

    Raises:
        Reraises CCXT exceptions from fetch_open_orders for the retry decorator.
        Does not re-raise OrderNotFound during cancellation.
    """
    func_name = "cancel_all_orders"
    market_base = symbol.split('/')[0]
    log_prefix = f"Cancel All ({reason})"
    logger.info(f"{Fore.CYAN}[{func_name}] {log_prefix}: Attempting for {symbol}...{Style.RESET_ALL}")

    try:
        market = exchange.market(symbol)
        category = _get_v5_category(market)
        if not category:
            logger.error(f"{Fore.RED}[{func_name}] Cannot determine market category for {symbol}. Aborting cancel all.{Style.RESET_ALL}")
            return False

        # Fetch open regular orders. Consider adding logic to cancel Stop/TP/SL orders too if needed.
        fetch_params = {'category': category, 'orderFilter': 'Order'}
        logger.debug(f"[{func_name}] Fetching open regular orders for {symbol} with params: {fetch_params}")
        open_orders = exchange.fetch_open_orders(symbol, params=fetch_params)

        if not open_orders:
            logger.info(f"{Fore.CYAN}[{func_name}] {log_prefix}: No open regular orders found for {symbol}.{Style.RESET_ALL}")
            return True

        logger.warning(f"{Fore.YELLOW}[{func_name}] {log_prefix}: Found {len(open_orders)} open order(s) for {symbol}. Attempting cancellation...{Style.RESET_ALL}")

        success_count = 0
        fail_count = 0
        cancel_delay = max(0.05, 1.0 / (exchange.rateLimit if exchange.rateLimit and exchange.rateLimit > 0 else 20))

        cancel_params = {'category': category} # Category needed for V5 cancel

        for order in open_orders:
            order_id = order.get('id')
            order_info_log = (f"ID: ...{format_order_id(order_id)} "
                              f"({order.get('type', '?').upper()} {order.get('side', '?').upper()} "
                              f"Amt: {format_amount(exchange, symbol, order.get('amount'))})")

            if not order_id:
                logger.warning(f"[{func_name}] Skipping order with missing ID in fetched data: {order}")
                continue

            try:
                logger.debug(f"[{func_name}] Cancelling order {order_info_log} with params: {cancel_params}")
                exchange.cancel_order(order_id, symbol, params=cancel_params)
                logger.info(f"{Fore.CYAN}[{func_name}] {log_prefix}: Successfully cancelled order {order_info_log}{Style.RESET_ALL}")
                success_count += 1
            except ccxt.OrderNotFound:
                logger.warning(f"{Fore.YELLOW}[{func_name}] {log_prefix}: Order {order_info_log} already cancelled or filled (Not Found). Considered OK.{Style.RESET_ALL}")
                success_count += 1
            except (ccxt.NetworkError, ccxt.RateLimitExceeded) as e_cancel:
                logger.warning(f"{Fore.YELLOW}[{func_name}] {log_prefix}: Network/RateLimit error cancelling {order_info_log}: {e_cancel}. Loop continues, outer retry might occur.{Style.RESET_ALL}")
                fail_count += 1 # Count as failure for this attempt
            except ccxt.ExchangeError as e_cancel:
                 logger.error(f"{Fore.RED}[{func_name}] {log_prefix}: FAILED to cancel order {order_info_log}: {e_cancel}{Style.RESET_ALL}")
                 fail_count += 1
            except Exception as e_cancel:
                logger.error(f"{Fore.RED}[{func_name}] {log_prefix}: Unexpected error cancelling order {order_info_log}: {e_cancel}{Style.RESET_ALL}", exc_info=True)
                fail_count += 1

            time.sleep(cancel_delay)

        total_attempted = len(open_orders)
        if fail_count > 0:
            try: # Re-check if orders still exist after potential transient errors
                 remaining_orders = exchange.fetch_open_orders(symbol, params=fetch_params)
                 if not remaining_orders:
                      logger.warning(f"{Fore.YELLOW}[{func_name}] {log_prefix}: Initial cancellation reported {fail_count} failures, but re-check shows no open orders remain. Likely transient errors.{Style.RESET_ALL}")
                      return True
                 else:
                      logger.error(f"{Fore.RED}[{func_name}] {log_prefix}: Finished cancellation attempt for {symbol}. "
                                   f"Failed: {fail_count}, Success/Gone: {success_count}. {len(remaining_orders)} order(s) might still remain.{Style.RESET_ALL}")
                      send_sms_alert(f"[{market_base}] ERROR: Failed to cancel {fail_count} orders ({reason}). Check logs.", config)
                      return False
            except Exception as e_recheck:
                 logger.error(f"[{func_name}] Error re-checking orders after failures: {e_recheck}. Assuming failures persist.")
                 send_sms_alert(f"[{market_base}] ERROR: Failed to cancel {fail_count} orders ({reason}). Check logs.", config)
                 return False
        else:
            logger.success(f"{Fore.GREEN}[{func_name}] {log_prefix}: Successfully cancelled or confirmed gone "
                           f"all {total_attempted} open orders found for {symbol}.{Style.RESET_ALL}")
            return True

    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.BadSymbol) as e:
        logger.error(f"{Fore.RED}[{func_name}] {log_prefix}: API error during 'cancel all' process for {symbol}: {e}{Style.RESET_ALL}")
        raise
    except Exception as e:
        logger.error(f"{Fore.RED}[{func_name}] {log_prefix}: Unexpected error during 'cancel all' for {symbol}: {e}{Style.RESET_ALL}", exc_info=True)
        return False

# Snippet 6 / Function 6: Fetch OHLCV with Pagination
def fetch_ohlcv_paginated(
    exchange: ccxt.bybit,
    symbol: str,
    timeframe: str,
    config: 'Config',
    since: Optional[int] = None,
    limit_per_req: int = 1000, # Bybit V5 max limit is 1000
    max_total_candles: Optional[int] = None,
) -> Optional[pd.DataFrame]:
    """
    Fetches historical OHLCV data for a symbol using pagination to handle limits.

    Converts the fetched data into a pandas DataFrame with proper indexing and
    data types, performing basic validation and cleaning (NaN handling).
    Uses internal retries for individual chunk fetches.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Market symbol (e.g., 'BTC/USDT:USDT').
        timeframe: CCXT timeframe string (e.g., '1m', '5m', '1h', '1d').
        config: Configuration object.
        since: Optional starting timestamp (milliseconds UTC) to fetch data from.
               If None, fetches the most recent data.
        limit_per_req: Number of candles to fetch per API request (max 1000 for Bybit V5).
        max_total_candles: Optional maximum number of candles to retrieve in total.

    Returns:
        A pandas DataFrame containing the OHLCV data, indexed by UTC timestamp,
        or None if fetching or processing fails completely. Returns an empty DataFrame
        if no data is available for the period.
    """
    func_name = "fetch_ohlcv_paginated"
    if not exchange.has.get("fetchOHLCV"):
        logger.error(f"{Fore.RED}[{func_name}] The exchange '{exchange.id}' does not support fetchOHLCV.{Style.RESET_ALL}")
        return None

    try:
        timeframe_ms = exchange.parse_timeframe(timeframe) * 1000
        if limit_per_req > 1000:
            logger.warning(f"[{func_name}] Requested limit_per_req ({limit_per_req}) exceeds Bybit V5 max (1000). Clamping to 1000.")
            limit_per_req = 1000

        market = exchange.market(symbol)
        category = _get_v5_category(market)
        if not category:
            logger.warning(f"[{func_name}] Could not determine category for {symbol}. Assuming 'linear'. This might fail for Spot/Inverse.")
            category = 'linear' # Default assumption

        params = {'category': category}

        logger.info(f"{Fore.BLUE}[{func_name}] Fetching {symbol} OHLCV ({timeframe}). "
                    f"Limit/Req: {limit_per_req}, Since: {pd.to_datetime(since, unit='ms', utc=True).strftime('%Y-%m-%d %H:%M:%S') if since else 'Recent'}. "
                    f"Max Total: {max_total_candles or 'Unlimited'}{Style.RESET_ALL}")

        all_candles: List[list] = []
        current_since = since
        request_count = 0
        max_requests = float('inf')
        if max_total_candles:
            max_requests = (max_total_candles + limit_per_req - 1) // limit_per_req

        while request_count < max_requests:
            if max_total_candles and len(all_candles) >= max_total_candles:
                logger.info(f"[{func_name}] Reached max_total_candles limit ({max_total_candles}). Fetch complete.")
                break

            request_count += 1
            fetch_limit = limit_per_req
            if max_total_candles:
                remaining_needed = max_total_candles - len(all_candles)
                fetch_limit = min(limit_per_req, remaining_needed)

            logger.debug(f"[{func_name}] Fetch Chunk #{request_count}: Since={current_since}, Limit={fetch_limit}, Params={params}")

            candles_chunk: Optional[List[list]] = None
            last_fetch_error: Optional[Exception] = None

            # Internal retry loop for fetching this specific chunk
            for attempt in range(config.RETRY_COUNT):
                try:
                    candles_chunk = exchange.fetch_ohlcv(symbol, timeframe, since=current_since, limit=fetch_limit, params=params)
                    last_fetch_error = None; break
                except (ccxt.NetworkError, ccxt.RequestTimeout, ccxt.ExchangeNotAvailable, ccxt.RateLimitExceeded) as e:
                    last_fetch_error = e
                    retry_delay = config.RETRY_DELAY_SECONDS * (attempt + 1) * (random.uniform(0.8, 1.2) if 'random' in globals() else 1.0)
                    logger.warning(f"{Fore.YELLOW}[{func_name}] API Error chunk #{request_count} (Try {attempt + 1}/{config.RETRY_COUNT}): {e}. Retrying in {retry_delay:.2f}s...{Style.RESET_ALL}")
                    time.sleep(retry_delay)
                except ccxt.ExchangeError as e: last_fetch_error = e; logger.error(f"{Fore.RED}[{func_name}] ExchangeError chunk #{request_count}: {e}. Aborting chunk.{Style.RESET_ALL}"); break
                except Exception as e: last_fetch_error = e; logger.error(f"[{func_name}] Unexpected fetch chunk #{request_count} err: {e}", exc_info=True); break

            if last_fetch_error:
                logger.error(f"{Fore.RED}[{func_name}] Failed to fetch chunk #{request_count} after {config.RETRY_COUNT} attempts. Last Error: {last_fetch_error}{Style.RESET_ALL}")
                logger.warning(f"[{func_name}] Returning potentially incomplete data ({len(all_candles)} candles) due to fetch failure.")
                break

            if not candles_chunk: logger.debug(f"[{func_name}] No more candles returned (Chunk #{request_count})."); break

            if all_candles and candles_chunk[0][0] <= all_candles[-1][0]:
                logger.warning(f"{Fore.YELLOW}[{func_name}] Overlap detected chunk #{request_count}. Filtering.{Style.RESET_ALL}")
                candles_chunk = [c for c in candles_chunk if c[0] > all_candles[-1][0]]
                if not candles_chunk: logger.debug(f"[{func_name}] Entire chunk was overlap."); break

            logger.debug(f"[{func_name}] Fetched {len(candles_chunk)} new candles (Chunk #{request_count}). Total: {len(all_candles) + len(candles_chunk)}")
            all_candles.extend(candles_chunk)

            if len(candles_chunk) < fetch_limit: logger.debug(f"[{func_name}] Received fewer candles than requested. End of data."); break

            current_since = candles_chunk[-1][0] + timeframe_ms
            time.sleep(exchange.rateLimit / 1000.0 if exchange.rateLimit and exchange.rateLimit > 0 else 0.1)

        return _process_ohlcv_list(all_candles, func_name, symbol, timeframe, max_total_candles)

    except (ccxt.BadSymbol, ccxt.ExchangeError) as e:
         logger.error(f"{Fore.RED}[{func_name}] Initial setup error for OHLCV fetch ({symbol}, {timeframe}): {e}{Style.RESET_ALL}")
         return None
    except Exception as e:
        logger.critical(f"{Back.RED}[{func_name}] Unexpected critical error during OHLCV pagination setup: {e}{Style.RESET_ALL}", exc_info=True)
        return None

def _process_ohlcv_list(
    candle_list: List[list], parent_func_name: str, symbol: str, timeframe: str, max_candles: Optional[int] = None
) -> Optional[pd.DataFrame]:
    """Internal helper to convert OHLCV list to validated pandas DataFrame."""
    func_name = f"{parent_func_name}._process_ohlcv_list"
    if not candle_list:
        logger.warning(f"{Fore.YELLOW}[{func_name}] No candles collected for {symbol} ({timeframe}). Returning empty DataFrame.{Style.RESET_ALL}")
        cols = ['open', 'high', 'low', 'close', 'volume']; empty_df = pd.DataFrame(columns=cols).astype({c: float for c in cols})
        empty_df.index = pd.to_datetime([]).tz_localize('UTC'); empty_df.index.name = 'timestamp'
        return empty_df
    logger.debug(f"[{func_name}] Processing {len(candle_list)} raw candles for {symbol} ({timeframe})...")
    try:
        df = pd.DataFrame(candle_list, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms', utc=True, errors='coerce'); df.dropna(subset=['timestamp'], inplace=True)
        if df.empty: raise ValueError("All timestamp conversions failed.")
        df.set_index('timestamp', inplace=True)
        for col in ['open', 'high', 'low', 'close', 'volume']: df[col] = pd.to_numeric(df[col], errors='coerce')
        initial_len = len(df); df = df[~df.index.duplicated(keep='first')]
        if len(df) < initial_len: logger.debug(f"[{func_name}] Removed {initial_len - len(df)} duplicate timestamp entries.")
        nan_counts = df.isnull().sum(); total_nans = nan_counts.sum()
        if total_nans > 0:
            logger.warning(f"{Fore.YELLOW}[{func_name}] Found {total_nans} NaNs. Ffilling... (Counts: {nan_counts.to_dict()}){Style.RESET_ALL}")
            df.ffill(inplace=True); df.dropna(inplace=True)
            if df.isnull().sum().sum() > 0: logger.error(f"{Fore.RED}[{func_name}] NaNs persisted after fill!{Style.RESET_ALL}")
        df.sort_index(inplace=True)
        if max_candles and len(df) > max_candles: logger.debug(f"[{func_name}] Trimming DF to last {max_candles}."); df = df.iloc[-max_candles:]
        if df.empty: logger.error(f"{Fore.RED}[{func_name}] Processed DF is empty after cleaning.{Style.RESET_ALL}"); return df
        logger.success(f"{Fore.GREEN}[{func_name}] Processed {len(df)} valid candles for {symbol} ({timeframe}).{Style.RESET_ALL}")
        return df
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Error processing OHLCV list: {e}{Style.RESET_ALL}", exc_info=True); return None

# Snippet 7 / Function 7: Place Limit Order with TIF/Flags
@retry_api_call(max_retries=1, initial_delay=0) # Typically don't auto-retry limit order placement automatically
def place_limit_order_tif(
    exchange: ccxt.bybit, symbol: str, side: Literal['buy', 'sell'], amount: Decimal, price: Decimal, config: 'Config',
    time_in_force: str = 'GTC', is_reduce_only: bool = False, is_post_only: bool = False, client_order_id: Optional[str] = None
) -> Optional[Dict]:
    """
    Places a limit order on Bybit V5 with options for Time-In-Force, Post-Only, and Reduce-Only.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Market symbol (e.g., 'BTC/USDT:USDT').
        side: 'buy' or 'sell'.
        amount: Order quantity in base currency (Decimal). Must be positive.
        price: Limit price for the order (Decimal). Must be positive.
        config: Configuration object.
        time_in_force: Time-In-Force policy ('GTC', 'IOC', 'FOK'). CCXT standard.
        is_reduce_only: If True, set the reduceOnly flag.
        is_post_only: If True, ensures the order is only accepted if it does not immediately match.
        client_order_id: Optional client order ID string (max length 36 for Bybit V5 linear).

    Returns:
        The order dictionary returned by ccxt, or None if the order placement failed.
    """
    func_name = "place_limit_order_tif"; log_prefix = f"Limit Order ({side.upper()})"
    logger.info(f"{Fore.BLUE}{log_prefix}: Init {format_amount(exchange, symbol, amount)} @ {format_price(exchange, symbol, price)} (TIF:{time_in_force}, Reduce:{is_reduce_only}, Post:{is_post_only})...{Style.RESET_ALL}")
    if amount <= config.POSITION_QTY_EPSILON or price <= Decimal("0"): logger.error(f"{Fore.RED}{log_prefix}: Invalid amount/price.{Style.RESET_ALL}"); return None
    try:
        market = exchange.market(symbol); category = _get_v5_category(market)
        if not category: logger.error(f"{Fore.RED}[{func_name}] Cannot determine category.{Style.RESET_ALL}"); return None
        amount_str = format_amount(exchange, symbol, amount); price_str = format_price(exchange, symbol, price); amount_float = float(amount_str); price_float = float(price_str)
        params: Dict[str, Any] = {'category': category}
        valid_tif = ['GTC', 'IOC', 'FOK']; tif_upper = time_in_force.upper()
        if tif_upper in valid_tif: params['timeInForce'] = tif_upper
        else: logger.warning(f"[{func_name}] Unsupported TIF '{time_in_force}'. Using GTC."); params['timeInForce'] = 'GTC'
        if is_post_only: params['postOnly'] = True
        if is_reduce_only: params['reduceOnly'] = True

        if client_order_id:
            max_coid_len = 36
            original_coid_len = len(client_order_id)
            valid_coid = client_order_id[:max_coid_len]
            params['clientOrderId'] = valid_coid
            if len(valid_coid) < original_coid_len:
                logger.warning(f"[{func_name}] Client Order ID truncated to {max_coid_len} chars: '{valid_coid}' (Original length: {original_coid_len})")

        logger.info(f"{Fore.CYAN}{log_prefix}: Placing -> Amt:{amount_float}, Px:{price_float}, Params:{params}{Style.RESET_ALL}")
        order = exchange.create_limit_order(symbol, side, amount_float, price_float, params=params)
        order_id = order.get('id'); client_oid_resp = order.get('clientOrderId', params.get('clientOrderId', 'N/A')); status = order.get('status', '?'); effective_tif = order.get('timeInForce', params.get('timeInForce', '?')); is_post_only_resp = order.get('postOnly', params.get('postOnly', False))
        logger.success(f"{Fore.GREEN}{log_prefix}: Limit order placed. ID:...{format_order_id(order_id)}, ClientOID:{client_oid_resp}, Status:{status}, TIF:{effective_tif}, Post:{is_post_only_resp}{Style.RESET_ALL}")
        return order
    except ccxt.OrderImmediatelyFillable as e:
         if params.get('postOnly'): logger.warning(f"{Fore.YELLOW}{log_prefix}: PostOnly failed (immediate match): {e}{Style.RESET_ALL}"); return None
         else: logger.error(f"{Fore.RED}{log_prefix}: Unexpected OrderImmediatelyFillable: {e}{Style.RESET_ALL}"); raise e
    except (ccxt.InsufficientFunds, ccxt.InvalidOrder, ccxt.ExchangeError, ccxt.NetworkError) as e: logger.error(f"{Fore.RED}{log_prefix}: API Error: {type(e).__name__} - {e}{Style.RESET_ALL}"); send_sms_alert(f"[{symbol.split('/')[0]}] ORDER FAIL (Limit {side.upper()}): {type(e).__name__}", config); return None
    except Exception as e: logger.critical(f"{Back.RED}[{func_name}] Unexpected error: {e}{Style.RESET_ALL}", exc_info=True); send_sms_alert(f"[{symbol.split('/')[0]}] ORDER FAIL (Limit {side.upper()}): Unexpected {type(e).__name__}.", config); return None

# Snippet 8 / Function 8: Fetch Current Position (Bybit V5 Specific)
@retry_api_call(max_retries=3, initial_delay=1.0)
def get_current_position_bybit_v5(exchange: ccxt.bybit, symbol: str, config: 'Config') -> Dict[str, Any]:
    """
    Fetches the current position details for a symbol using Bybit V5's fetchPositions logic.
    Focuses on One-Way position mode (positionIdx=0). Returns Decimals for numeric values.
    """
    func_name = "get_current_position_bybit_v5"; logger.debug(f"[{func_name}] Fetching position for {symbol} (V5)...")
    default_position: Dict[str, Any] = {'symbol': symbol, 'side': config.POS_NONE, 'qty': Decimal("0.0"), 'entry_price': Decimal("0.0"), 'liq_price': None, 'mark_price': None, 'pnl_unrealized': None, 'leverage': None, 'info': {}}
    try:
        market = exchange.market(symbol); market_id = market['id']
        category = _get_v5_category(market)
        if not category or category not in ['linear', 'inverse']: logger.error(f"{Fore.RED}[{func_name}] Not a contract symbol: {symbol}.{Style.RESET_ALL}"); return default_position
        if not exchange.has.get('fetchPositions'): logger.error(f"{Fore.RED}[{func_name}] fetchPositions not available.{Style.RESET_ALL}"); return default_position
        params = {'category': category, 'symbol': market_id}; logger.debug(f"[{func_name}] Calling fetch_positions with params: {params}")
        fetched_positions = exchange.fetch_positions(symbols=[symbol], params=params)
        active_position_data: Optional[Dict] = None
        for pos in fetched_positions:
            pos_info = pos.get('info', {}); pos_symbol = pos_info.get('symbol'); pos_v5_side = pos_info.get('side', 'None'); pos_size_str = pos_info.get('size'); pos_idx = int(pos_info.get('positionIdx', -1))
            if pos_symbol == market_id and pos_v5_side != 'None' and pos_idx == 0:
                pos_size = safe_decimal_conversion(pos_size_str, Decimal("0.0"));
                if abs(pos_size) > config.POSITION_QTY_EPSILON: active_position_data = pos; logger.debug(f"[{func_name}] Found active One-Way (idx 0) position."); break
        if active_position_data:
            try:
                info = active_position_data.get('info', {}); size = safe_decimal_conversion(info.get('size')); entry_price = safe_decimal_conversion(info.get('avgPrice')); liq_price = safe_decimal_conversion(info.get('liqPrice')); mark_price = safe_decimal_conversion(info.get('markPrice')); pnl = safe_decimal_conversion(info.get('unrealisedPnl')); leverage = safe_decimal_conversion(info.get('leverage'))
                pos_side_str = info.get('side'); position_side = config.POS_LONG if pos_side_str == 'Buy' else (config.POS_SHORT if pos_side_str == 'Sell' else config.POS_NONE); quantity = abs(size) if size is not None else Decimal("0.0")
                if position_side == config.POS_NONE or quantity <= config.POSITION_QTY_EPSILON: logger.info(f"[{func_name}] Pos {symbol} negligible size/side."); return default_position
                log_color = Fore.GREEN if position_side == config.POS_LONG else Fore.RED
                logger.info(f"{log_color}[{func_name}] ACTIVE {position_side} {symbol}: Qty={format_amount(exchange, symbol, quantity)}, Entry={format_price(exchange, symbol, entry_price)}, Mark={format_price(exchange, symbol, mark_price)}, Liq~{format_price(exchange, symbol, liq_price)}, uPNL={format_price(exchange, config.USDT_SYMBOL, pnl)}, Lev={leverage}x{Style.RESET_ALL}")
                return {'symbol': symbol, 'side': position_side, 'qty': quantity, 'entry_price': entry_price, 'liq_price': liq_price, 'mark_price': mark_price, 'pnl_unrealized': pnl, 'leverage': leverage, 'info': info }
            except Exception as parse_err: logger.warning(f"{Fore.YELLOW}[{func_name}] Error parsing active pos: {parse_err}. Data: {str(active_position_data)[:300]}{Style.RESET_ALL}"); return default_position
        else: logger.info(f"[{func_name}] No active One-Way position found for {symbol}."); return default_position
    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.BadSymbol) as e: logger.warning(f"{Fore.YELLOW}[{func_name}] API Error fetching pos: {e}{Style.RESET_ALL}"); raise
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error fetching pos: {e}{Style.RESET_ALL}", exc_info=True); return default_position

# Snippet 9 / Function 9: Close Position (Reduce-Only Market)
@retry_api_call(max_retries=2, initial_delay=1) # Allow retry for closure attempt
def close_position_reduce_only(
    exchange: ccxt.bybit, symbol: str, config: 'Config', position_to_close: Optional[Dict[str, Any]] = None, reason: str = "Signal Close"
) -> Optional[Dict[str, Any]]:
    """
    Closes the current position for the given symbol using a reduce-only market order.
    Handles specific "already closed" exchange errors gracefully.
    """
    func_name = "close_position_reduce_only"; market_base = symbol.split('/')[0]; log_prefix = f"Close Position ({reason})"
    logger.info(f"{Fore.YELLOW}{log_prefix}: Init for {symbol}...{Style.RESET_ALL}")
    live_position_data: Dict[str, Any]
    if position_to_close: logger.debug(f"[{func_name}] Using provided pos state."); live_position_data = position_to_close
    else: logger.debug(f"[{func_name}] Fetching current pos state..."); live_position_data = get_current_position_bybit_v5(exchange, symbol, config)
    live_side = live_position_data['side']; live_qty = live_position_data['qty']
    if live_side == config.POS_NONE or live_qty <= config.POSITION_QTY_EPSILON: logger.warning(f"{Fore.YELLOW}[{func_name}] No active position validated. Aborting close.{Style.RESET_ALL}"); return None
    close_order_side: Literal['buy', 'sell'] = config.SIDE_SELL if live_side == config.POS_LONG else config.SIDE_BUY
    try:
        market = exchange.market(symbol); category = _get_v5_category(market)
        if not category: raise ValueError("Cannot determine category for close order.")
        qty_str = format_amount(exchange, symbol, live_qty); qty_float = float(qty_str); params: Dict[str, Any] = {'category': category, 'reduceOnly': True}
        bg = Back.YELLOW; fg = Fore.BLACK
        logger.warning(f"{bg}{fg}{Style.BRIGHT}[{func_name}] Attempting CLOSE {live_side} ({reason}): Exec {close_order_side.upper()} MARKET {qty_str} {symbol} (ReduceOnly)...{Style.RESET_ALL}")
        close_order = exchange.create_market_order(symbol=symbol, side=close_order_side, amount=qty_float, params=params)
        if not close_order: raise ValueError("create_market_order returned None unexpectedly.")
        fill_price = safe_decimal_conversion(close_order.get('average')); fill_qty = safe_decimal_conversion(close_order.get('filled', '0.0')); order_cost = safe_decimal_conversion(close_order.get('cost', '0.0')); order_id = format_order_id(close_order.get('id')); status = close_order.get('status', '?')
        logger.success(f"{Fore.GREEN}{Style.BRIGHT}[{func_name}] Close Order ({reason}) submitted {symbol}. ID:...{order_id}, Status:{status}, Filled:{format_amount(exchange, symbol, fill_qty)}/{qty_str}, AvgFill:{format_price(exchange, symbol, fill_price)}, Cost:{order_cost:.4f}{Style.RESET_ALL}")
        send_sms_alert(f"[{market_base}] Closed {live_side} {qty_str} @ ~{format_price(exchange, symbol, fill_price)} ({reason}). ID:...{order_id}", config)
        return close_order
    except (ccxt.InsufficientFunds, ccxt.InvalidOrder) as e: logger.error(f"{Fore.RED}[{func_name}] Close Order Error ({reason}) for {symbol}: {type(e).__name__} - {e}{Style.RESET_ALL}"); send_sms_alert(f"[{market_base}] CLOSE FAIL ({live_side}): {type(e).__name__}", config); raise e
    except ccxt.ExchangeError as e:
        error_str = str(e).lower();
        # 110025: Position is closed | 110045: Order would not reduce position size
        # 30086: Order would not reduce position | Bybit may change codes
        if any(code in error_str for code in ["110025", "110045", "30086", "position is closed", "order would not reduce", "position size is zero", "qty is larger than position size"]):
            logger.warning(f"{Fore.YELLOW}[{func_name}] Close Order ({reason}): Exchange indicates already closed/zero or reduce fail: {e}. Assuming closed.{Style.RESET_ALL}"); return None
        else: logger.error(f"{Fore.RED}[{func_name}] Close Order ExchangeError ({reason}): {e}{Style.RESET_ALL}"); send_sms_alert(f"[{market_base}] CLOSE FAIL ({live_side}): ExchangeError", config); raise e
    except (ccxt.NetworkError, ValueError) as e: logger.error(f"{Fore.RED}[{func_name}] Close Order Network/Setup Error ({reason}): {e}{Style.RESET_ALL}"); raise e
    except Exception as e: logger.critical(f"{Back.RED}[{func_name}] Close Order Unexpected Error ({reason}): {e}{Style.RESET_ALL}", exc_info=True); send_sms_alert(f"[{market_base}] CLOSE FAIL ({live_side}): Unexpected Error", config); return None

# Snippet 11 / Function 11: Fetch Funding Rate
@retry_api_call(max_retries=3, initial_delay=1.0)
def fetch_funding_rate(exchange: ccxt.bybit, symbol: str, config: 'Config') -> Optional[Dict[str, Any]]:
    """
    Fetches the current funding rate details for a perpetual swap symbol on Bybit V5.
    Returns Decimals for rates/prices.
    """
    func_name = "fetch_funding_rate"; logger.debug(f"[{func_name}] Fetching funding rate for {symbol}...")
    try:
        market = exchange.market(symbol)
        if not market.get('swap', False): logger.error(f"{Fore.RED}[{func_name}] Not a swap market: {symbol}.{Style.RESET_ALL}"); return None
        category = _get_v5_category(market)
        if not category or category not in ['linear', 'inverse']: logger.error(f"{Fore.RED}[{func_name}] Invalid category '{category}' for funding rate ({symbol}).{Style.RESET_ALL}"); return None
        params = {'category': category}; logger.debug(f"[{func_name}] Calling fetch_funding_rate with params: {params}")
        funding_rate_info = exchange.fetch_funding_rate(symbol, params=params)
        processed_fr: Dict[str, Any] = { 'symbol': funding_rate_info.get('symbol'), 'fundingRate': safe_decimal_conversion(funding_rate_info.get('fundingRate')), 'fundingTimestamp': funding_rate_info.get('fundingTimestamp'), 'fundingDatetime': funding_rate_info.get('fundingDatetime'), 'markPrice': safe_decimal_conversion(funding_rate_info.get('markPrice')), 'indexPrice': safe_decimal_conversion(funding_rate_info.get('indexPrice')), 'nextFundingTime': funding_rate_info.get('nextFundingTimestamp'), 'nextFundingDatetime': None, 'info': funding_rate_info.get('info', {}) }
        if processed_fr['fundingRate'] is None: logger.warning(f"[{func_name}] Could not parse 'fundingRate' for {symbol}.")

        # Corrected multi-line try/except block
        if processed_fr['nextFundingTime']:
            try:
                processed_fr['nextFundingDatetime'] = pd.to_datetime(
                    processed_fr['nextFundingTime'], unit='ms', utc=True
                ).strftime('%Y-%m-%d %H:%M:%S %Z')
            except Exception as dt_err:
                logger.warning(f"[{func_name}] Could not format next funding datetime: {dt_err}")

        rate = processed_fr.get('fundingRate'); next_dt_str = processed_fr.get('nextFundingDatetime', "N/A"); rate_str = f"{rate:.6%}" if rate is not None else "N/A"
        logger.info(f"[{func_name}] Funding Rate {symbol}: {rate_str}. Next: {next_dt_str}")
        return processed_fr
    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.BadSymbol) as e: logger.warning(f"{Fore.YELLOW}[{func_name}] API Error fetching funding rate: {e}{Style.RESET_ALL}"); raise
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error fetching funding rate: {e}{Style.RESET_ALL}", exc_info=True); return None

# Snippet 12 / Function 12: Set Position Mode (One-Way / Hedge)
@retry_api_call(max_retries=2, initial_delay=1.0)
def set_position_mode_bybit_v5(exchange: ccxt.bybit, symbol_or_category: str, mode: Literal['one-way', 'hedge'], config: 'Config') -> bool:
    """
    Sets the position mode (One-Way or Hedge) for a specific category (Linear/Inverse) on Bybit V5.
    Uses the `private_post_v5_position_switch_mode` endpoint. Handles specific V5 errors.
    Note: Requires no positions/orders in the category.
    """
    func_name = "set_position_mode_bybit_v5"; logger.info(f"{Fore.CYAN}[{func_name}] Setting mode '{mode}' for category of '{symbol_or_category}'...{Style.RESET_ALL}")
    mode_map = {'one-way': '0', 'hedge': '3'}; target_mode_code = mode_map.get(mode.lower())
    if target_mode_code is None: logger.error(f"{Fore.RED}[{func_name}] Invalid mode '{mode}'.{Style.RESET_ALL}"); return False

    target_category: Optional[Literal['linear', 'inverse']] = None
    if symbol_or_category.lower() in ['linear', 'inverse']:
        target_category = symbol_or_category.lower() # type: ignore
    else:
        # Corrected multi-line try/except block
        try:
            market = exchange.market(symbol_or_category)
            target_category = _get_v5_category(market)
            # Ensure the category derived is valid for position mode setting
            if target_category not in ['linear', 'inverse']:
                target_category = None # Invalidate if not linear/inverse
        except Exception as e: # Catch broader exceptions like BadSymbol or other errors
            logger.warning(f"[{func_name}] Could not get market or category for '{symbol_or_category}': {e}")
            target_category = None # Ensure it's None if error occurred

    if not target_category: logger.error(f"{Fore.RED}[{func_name}] Could not determine contract category from '{symbol_or_category}'.{Style.RESET_ALL}"); return False
    logger.debug(f"[{func_name}] Target Category: {target_category}, Mode Code: {target_mode_code} ('{mode}')")
    try:
        # Prefer unified CCXT method if it works reliably for V5
        # try:
        #     logger.debug(f"[{func_name}] Attempting via unified exchange.set_position_mode...")
        #     response = exchange.set_position_mode(hedged=(mode == 'hedge'), symbol=symbol_or_category)
        #     logger.success(f"{Fore.GREEN}[{func_name}] Mode set/confirmed to '{mode}' for {target_category} via unified method.{Style.RESET_ALL}")
        #     return True
        # except ccxt.NotSupported:
        #     logger.debug(f"[{func_name}] Unified set_position_mode not supported/failed, trying private V5 endpoint...")
        # except Exception as e_unified:
        #      logger.warning(f"[{func_name}] Unified set_position_mode failed: {e_unified}. Trying private V5 endpoint...")

        if not hasattr(exchange, 'private_post_v5_position_switch_mode'): logger.error(f"{Fore.RED}[{func_name}] CCXT lacks 'private_post_v5_position_switch_mode'. Cannot set mode via private endpoint.{Style.RESET_ALL}"); return False
        params = {'category': target_category, 'mode': target_mode_code}; logger.debug(f"[{func_name}] Calling private V5 endpoint with params: {params}")
        response = exchange.private_post_v5_position_switch_mode(params); logger.debug(f"[{func_name}] Raw V5 endpoint response: {response}")
        ret_code = response.get('retCode'); ret_msg = response.get('retMsg', '').lower()
        if ret_code == 0: logger.success(f"{Fore.GREEN}[{func_name}] Mode set '{mode}' for {target_category} via V5 endpoint.{Style.RESET_ALL}"); return True
        # 110021: Position mode not modified | 34036 might also indicate already set
        elif ret_code in [110021, 34036] or "not modified" in ret_msg: logger.info(f"{Fore.CYAN}[{func_name}] Mode already '{mode}' for {target_category}.{Style.RESET_ALL}"); return True
        # 110020: Position/order exists, cannot switch mode
        elif ret_code == 110020 or "have position" in ret_msg or "active order" in ret_msg: logger.error(f"{Fore.RED}[{func_name}] Cannot switch mode: Active pos/orders exist. Msg: {response.get('retMsg')}{Style.RESET_ALL}"); return False
        else: raise ccxt.ExchangeError(f"Bybit API error setting mode: Code={ret_code}, Msg='{response.get('retMsg', 'N/A')}'")
    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.AuthenticationError, ccxt.BadSymbol) as e:
        # Avoid logging error again if it's the handled "position exists" case
        if not (isinstance(e, ccxt.ExchangeError) and "110020" in str(e)):
             logger.warning(f"{Fore.YELLOW}[{func_name}] API Error setting mode: {e}{Style.RESET_ALL}")
        if isinstance(e, (ccxt.NetworkError, ccxt.AuthenticationError)): raise e # Re-raise for retry decorator
        return False # Return False for handled errors like position exists or bad symbol
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error setting mode: {e}{Style.RESET_ALL}", exc_info=True); return False

# Snippet 13 / Function 13: Fetch L2 Order Book (Validated)
@retry_api_call(max_retries=2, initial_delay=0.5)
def fetch_l2_order_book_validated(
    exchange: ccxt.bybit, symbol: str, limit: int, config: 'Config'
) -> Optional[Dict[str, List[Tuple[Decimal, Decimal]]]]:
    """
    Fetches the Level 2 order book for a symbol using Bybit V5 fetchOrderBook and validates the data.
    Returns bids and asks as lists of [price, amount] tuples using Decimals.
    """
    func_name = "fetch_l2_order_book_validated"; logger.debug(f"[{func_name}] Fetching L2 OB {symbol} (Limit:{limit})...")
    if not exchange.has.get('fetchOrderBook'): logger.error(f"{Fore.RED}[{func_name}] fetchOrderBook not supported.{Style.RESET_ALL}"); return None
    try:
        market = exchange.market(symbol); category = _get_v5_category(market)
        params = {'category': category} if category else {}
        max_limit_map = {'spot': 50, 'linear': 200, 'inverse': 200, 'option': 25}
        max_limit = max_limit_map.get(category, 50) if category else 50 # Default max if category unknown
        if limit > max_limit: logger.warning(f"[{func_name}] Clamping limit {limit} to {max_limit} for category '{category}'."); limit = max_limit

        logger.debug(f"[{func_name}] Calling fetchOrderBook with limit={limit}, params={params}")
        order_book = exchange.fetch_order_book(symbol, limit=limit, params=params)
        if not isinstance(order_book, dict) or 'bids' not in order_book or 'asks' not in order_book: raise ValueError("Invalid OB structure")
        raw_bids=order_book['bids']; raw_asks=order_book['asks']
        if not isinstance(raw_bids, list) or not isinstance(raw_asks, list): raise ValueError("Bids/Asks not lists")
        validated_bids: List[Tuple[Decimal, Decimal]] = []; validated_asks: List[Tuple[Decimal, Decimal]] = []; conversion_errors = 0

        # Corrected multi-line loop for bids
        for p_str, a_str in raw_bids:
            p = safe_decimal_conversion(p_str)
            a = safe_decimal_conversion(a_str)
            if p is None or a is None or p <= 0 or a < 0:
                conversion_errors += 1
                continue
            validated_bids.append((p, a))

        # Corrected multi-line loop for asks
        for p_str, a_str in raw_asks:
            p = safe_decimal_conversion(p_str)
            a = safe_decimal_conversion(a_str)
            if p is None or a is None or p <= 0 or a < 0:
                conversion_errors += 1
                continue
            validated_asks.append((p, a))

        if conversion_errors > 0: logger.warning(f"[{func_name}] Skipped {conversion_errors} invalid OB entries for {symbol}.")
        if validated_bids and validated_asks and validated_bids[0][0] >= validated_asks[0][0]: logger.error(f"{Fore.RED}[{func_name}] OB crossed: Bid ({validated_bids[0][0]}) >= Ask ({validated_asks[0][0]}) for {symbol}.{Style.RESET_ALL}"); # Return potentially invalid data or None? return {'bids': validated_bids, 'asks': validated_asks}
        logger.debug(f"[{func_name}] Processed L2 OB {symbol}. Bids:{len(validated_bids)}, Asks:{len(validated_asks)}")
        return {'bids': validated_bids, 'asks': validated_asks}
    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.BadSymbol, ValueError) as e: logger.warning(f"{Fore.YELLOW}[{func_name}] API/Validation Error fetching L2 OB for {symbol}: {e}{Style.RESET_ALL}"); raise
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error fetching L2 OB for {symbol}: {e}{Style.RESET_ALL}", exc_info=True); return None

# Snippet 14 / Function 14: Place Native Stop Loss Order (Stop Market)
@retry_api_call(max_retries=1, initial_delay=0) # Don't auto-retry placing stops usually
def place_native_stop_loss(
    exchange: ccxt.bybit, symbol: str, side: Literal['buy', 'sell'], amount: Decimal, stop_price: Decimal, config: 'Config',
    trigger_by: Literal['LastPrice', 'MarkPrice', 'IndexPrice'] = 'MarkPrice', client_order_id: Optional[str] = None, position_idx: Literal[0, 1, 2] = 0
) -> Optional[Dict]:
    """
    Places a native Stop Market order on Bybit V5, intended as a Stop Loss (reduceOnly).
    Uses V5 specific parameters like 'slTriggerBy'.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Market symbol.
        side: Side of the STOP order ('buy' to close short, 'sell' to close long).
        amount: Amount to close (positive Decimal).
        stop_price: Trigger price for the stop (positive Decimal).
        config: Configuration object.
        trigger_by: Price type for trigger ('LastPrice', 'MarkPrice', 'IndexPrice').
        client_order_id: Optional client order ID.
        position_idx: Position index (0 for One-Way, 1/2 for Hedge).

    Returns:
        The order dictionary returned by ccxt, or None if placement failed.
    """
    func_name = "place_native_stop_loss"; log_prefix = f"Place Native SL ({side.upper()})"
    logger.info(f"{Fore.CYAN}{log_prefix}: Init {format_amount(exchange, symbol, amount)} {symbol}, Trigger @ {format_price(exchange, symbol, stop_price)} ({trigger_by}), PosIdx:{position_idx}...{Style.RESET_ALL}")
    if amount <= config.POSITION_QTY_EPSILON or stop_price <= Decimal("0"): logger.error(f"{Fore.RED}{log_prefix}: Invalid amount/stop price.{Style.RESET_ALL}"); return None
    try:
        market = exchange.market(symbol); category = _get_v5_category(market)
        if not category or category not in ['linear', 'inverse']: logger.error(f"{Fore.RED}[{func_name}] Not a contract symbol: {symbol}.{Style.RESET_ALL}"); return None
        amount_str = format_amount(exchange, symbol, amount); amount_float = float(amount_str); stop_price_str = format_price(exchange, symbol, stop_price); stop_price_float = float(stop_price_str)

        params: Dict[str, Any] = {
            'category': category,
            'stopLoss': stop_price_str, # V5 parameter for stop loss price
            'slTriggerBy': trigger_by,   # V5 parameter for trigger type
            'reduceOnly': True,
            'positionIdx': position_idx,
            'tpslMode': 'Full',          # Assumes full position TP/SL
            'slOrderType': 'Market'      # Execute as Market order when triggered
        }

        if client_order_id:
            max_coid_len = 36
            original_coid_len = len(client_order_id)
            valid_coid = client_order_id[:max_coid_len]
            params['clientOrderId'] = valid_coid
            if len(valid_coid) < original_coid_len:
                logger.warning(f"[{func_name}] Client Order ID truncated to {max_coid_len} chars: '{valid_coid}' (Original length: {original_coid_len})")

        bg = Back.YELLOW; fg = Fore.BLACK
        logger.warning(f"{bg}{fg}{Style.BRIGHT}{log_prefix}: Placing NATIVE Stop Loss (Market exec) -> Qty:{amount_float}, Side:{side}, TriggerPx:{stop_price_str}, TriggerBy:{trigger_by}, Reduce:True, PosIdx:{position_idx}, Params:{params}{Style.RESET_ALL}")

        # Use create_order with 'market' type and stop-loss params
        sl_order = exchange.create_order(symbol=symbol, type='market', side=side, amount=amount_float, params=params)

        order_id = sl_order.get('id'); client_oid_resp = sl_order.get('clientOrderId', params.get('clientOrderId', 'N/A')); status = sl_order.get('status', '?')
        # Check V5 response structure for stopLoss and slTriggerBy confirmation
        returned_stop_price = safe_decimal_conversion(sl_order.get('info', {}).get('stopLoss', sl_order.get('stopPrice')), None)
        returned_trigger = sl_order.get('info', {}).get('slTriggerBy', trigger_by)
        logger.success(f"{Fore.GREEN}{log_prefix}: Native SL order placed. ID:...{format_order_id(order_id)}, ClientOID:{client_oid_resp}, Status:{status}, Trigger:{format_price(exchange, symbol, returned_stop_price)} (by {returned_trigger}){Style.RESET_ALL}")
        return sl_order
    except (ccxt.InsufficientFunds, ccxt.InvalidOrder, ccxt.ExchangeError, ccxt.NetworkError, ccxt.BadSymbol) as e: logger.error(f"{Fore.RED}{log_prefix}: API Error placing SL: {type(e).__name__} - {e}{Style.RESET_ALL}"); return None
    except Exception as e: logger.critical(f"{Back.RED}[{func_name}] Unexpected error placing SL: {e}{Style.RESET_ALL}", exc_info=True); send_sms_alert(f"[{symbol.split('/')[0]}] SL PLACE FAIL ({side.upper()}): Unexpected {type(e).__name__}", config); return None

# Snippet 15 / Function 15: Fetch Open Orders (Filtered)
@retry_api_call(max_retries=2, initial_delay=1.0)
def fetch_open_orders_filtered(
    exchange: ccxt.bybit, symbol: str, config: 'Config', side: Optional[Literal['buy', 'sell']] = None,
    order_type: Optional[str] = None, order_filter: Optional[Literal['Order', 'StopOrder', 'tpslOrder']] = None
) -> Optional[List[Dict]]:
    """
    Fetches open orders for a specific symbol on Bybit V5, with optional filtering
    by side, CCXT order type, and/or Bybit V5 `orderFilter`. Defaults to fetching 'Order'.
    """
    func_name = "fetch_open_orders_filtered"; filter_log = f"(Side:{side or 'Any'}, Type:{order_type or 'Any'}, V5Filter:{order_filter or 'Default'})"
    logger.debug(f"[{func_name}] Fetching open orders {symbol} {filter_log}...")
    try:
        market = exchange.market(symbol); category = _get_v5_category(market)
        if not category: logger.error(f"{Fore.RED}[{func_name}] Cannot determine category for {symbol}.{Style.RESET_ALL}"); return None
        params: Dict[str, Any] = {'category': category}
        if order_filter: params['orderFilter'] = order_filter
        elif order_type: # Infer filter from type if filter not explicitly set
            norm_type_filter = order_type.lower().replace('_', '').replace('-', '')
            if 'stop' in norm_type_filter or 'trigger' in norm_type_filter or 'take' in norm_type_filter or 'tpsl' in norm_type_filter:
                params['orderFilter'] = 'StopOrder' # Or maybe tpslOrder? Check V5 docs. Defaulting to StopOrder.
            else: params['orderFilter'] = 'Order'
        else: params['orderFilter'] = 'Order' # Default if nothing specified

        logger.debug(f"[{func_name}] Calling fetch_open_orders with params: {params}")
        open_orders = exchange.fetch_open_orders(symbol=symbol, params=params)
        if not open_orders: logger.debug(f"[{func_name}] No open orders found matching {params}."); return []
        filtered_orders = open_orders; initial_count = len(filtered_orders)
        if side: side_lower = side.lower(); filtered_orders = [o for o in filtered_orders if o.get('side', '').lower() == side_lower]; logger.debug(f"[{func_name}] Filtered by side='{side}'. Count: {initial_count} -> {len(filtered_orders)}.")
        if order_type: # Apply type filter client-side as well for precision
            norm_type_filter = order_type.lower().replace('_', '').replace('-', ''); count_before = len(filtered_orders)
            def check_type(order): # More robust type check
                o_type = order.get('type', '').lower().replace('_', '').replace('-', '')
                info = order.get('info', {})
                # Check standard type first
                if o_type == norm_type_filter: return True
                # Check V5 specific types if available in info
                if info.get('orderType', '').lower() == norm_type_filter: return True
                # Check if it's a conditional order matching the filter type
                is_stop = info.get('stopLoss') or info.get('takeProfit') or info.get('stopOrderType') or info.get('triggerPrice')
                if 'market' in norm_type_filter and ('stop' in norm_type_filter or 'takeprofit' in norm_type_filter) and is_stop and o_type == 'market': return True
                return False
            filtered_orders = [o for o in filtered_orders if check_type(o)]; logger.debug(f"[{func_name}] Filtered by type='{order_type}'. Count: {count_before} -> {len(filtered_orders)}.")
        logger.info(f"[{func_name}] Fetched/filtered {len(filtered_orders)} open orders for {symbol} {filter_log}.")
        return filtered_orders
    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.BadSymbol) as e: logger.warning(f"{Fore.YELLOW}[{func_name}] API Error fetching open orders: {e}{Style.RESET_ALL}"); raise
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error fetching open orders: {e}{Style.RESET_ALL}", exc_info=True); return None

# Snippet 16 / Function 16: Calculate Margin Requirement
def calculate_margin_requirement(
    exchange: ccxt.bybit, symbol: str, amount: Decimal, price: Decimal, leverage: Decimal, config: 'Config',
    order_side: Literal['buy', 'sell'], is_maker: bool = False
) -> Tuple[Optional[Decimal], Optional[Decimal]]:
    """
    Calculates the estimated Initial Margin (IM) requirement for placing an order on Bybit V5.
    MM estimate is basic/placeholder.
    """
    func_name = "calculate_margin_requirement"; logger.debug(f"[{func_name}] Calc margin: {order_side} {format_amount(exchange, symbol, amount)} @ {format_price(exchange, symbol, price)}, Lev:{leverage}x, Maker:{is_maker}")
    if amount <= 0 or price <= 0 or leverage <= 0: logger.error(f"{Fore.RED}[{func_name}] Invalid inputs.{Style.RESET_ALL}"); return None, None
    try:
        market = exchange.market(symbol); quote_currency = market.get('quote', config.USDT_SYMBOL)
        if not market.get('contract'): logger.error(f"{Fore.RED}[{func_name}] Not a contract symbol: {symbol}.{Style.RESET_ALL}"); return None, None
        position_value = amount * price; logger.debug(f"[{func_name}] Est Order Value: {format_price(exchange, quote_currency, position_value)} {quote_currency}")
        if leverage == Decimal("0"): raise DivisionByZero("Leverage cannot be zero.")
        initial_margin_base = position_value / leverage; logger.debug(f"[{func_name}] Base IM: {format_price(exchange, quote_currency, initial_margin_base)} {quote_currency}")
        fee_rate = config.MAKER_FEE_RATE if is_maker else config.TAKER_FEE_RATE; estimated_fee = position_value * fee_rate; logger.debug(f"[{func_name}] Est Fee ({fee_rate:.4%}): {format_price(exchange, quote_currency, estimated_fee)} {quote_currency}")
        total_initial_margin_estimate = initial_margin_base + estimated_fee
        logger.info(f"[{func_name}] Est TOTAL Initial Margin Req (incl. fee): {format_price(exchange, quote_currency, total_initial_margin_estimate)} {quote_currency}")
        maintenance_margin_estimate: Optional[Decimal] = None
        try:
            # Look for MMR in market info (might be base rate only)
            mmr_keys = ['maintenanceMarginRate', 'mmr'] # Common keys in market['info'] or market itself
            mmr_rate_str = None
            # Corrected multi-line loop
            for key in mmr_keys:
                value_from_info = market.get('info', {}).get(key)
                value_from_root = market.get(key)
                mmr_rate_str = value_from_info or value_from_root
                if mmr_rate_str:
                    break

            if mmr_rate_str:
                mmr_rate = safe_decimal_conversion(mmr_rate_str)
                if mmr_rate and mmr_rate > 0:
                    maintenance_margin_estimate = position_value * mmr_rate
                    logger.debug(f"[{func_name}] Basic MM Estimate (Base MMR {mmr_rate:.4%}): {format_price(exchange, quote_currency, maintenance_margin_estimate)} {quote_currency}")
                else:
                    logger.debug(f"[{func_name}] Could not parse MMR rate '{mmr_rate_str}' from market info.")
            else:
                logger.debug(f"[{func_name}] MMR key not found in market info.")
        except Exception as mm_err:
            logger.warning(f"[{func_name}] Could not estimate MM: {mm_err}")

        return total_initial_margin_estimate, maintenance_margin_estimate
    except (DivisionByZero, KeyError, ValueError) as e: logger.error(f"{Fore.RED}[{func_name}] Calculation error: {e}{Style.RESET_ALL}"); return None, None
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error during margin calculation: {e}{Style.RESET_ALL}", exc_info=True); return None, None

# Snippet 17 / Function 17: Fetch Ticker (Validated)
@retry_api_call(max_retries=2, initial_delay=0.5)
def fetch_ticker_validated(
    exchange: ccxt.bybit, symbol: str, config: 'Config', max_age_seconds: int = 30
) -> Optional[Dict[str, Any]]:
    """
    Fetches the ticker for a symbol from Bybit V5, validates its freshness and key values.
    Returns a dictionary with Decimal values.
    """
    func_name = "fetch_ticker_validated"; logger.debug(f"[{func_name}] Fetching/Validating ticker {symbol}...")
    try:
        market = exchange.market(symbol); category = _get_v5_category(market)
        params = {'category': category} if category else {}
        logger.debug(f"[{func_name}] Calling fetch_ticker with params: {params}")
        ticker = exchange.fetch_ticker(symbol, params=params)
        timestamp_ms = ticker.get('timestamp'); age_seconds = (time.time() * 1000 - timestamp_ms) / 1000.0 if timestamp_ms else float('inf')
        if timestamp_ms is None or age_seconds > max_age_seconds or age_seconds < -10: raise ValueError(f"Ticker timestamp invalid/stale (Age: {age_seconds:.1f}s)")
        last_price = safe_decimal_conversion(ticker.get('last')); bid_price = safe_decimal_conversion(ticker.get('bid')); ask_price = safe_decimal_conversion(ticker.get('ask'))
        if last_price is None or last_price <= 0: raise ValueError(f"Invalid 'last' price: {ticker.get('last')}")
        if bid_price is None or bid_price <= 0: logger.warning(f"[{func_name}] Invalid/missing 'bid': {ticker.get('bid')}")
        if ask_price is None or ask_price <= 0: logger.warning(f"[{func_name}] Invalid/missing 'ask': {ticker.get('ask')}")
        spread, spread_pct = None, None
        if bid_price and ask_price:
             if bid_price >= ask_price: raise ValueError(f"Bid ({bid_price}) >= Ask ({ask_price})")
             spread = ask_price - bid_price; spread_pct = (spread / bid_price) * 100 if bid_price > 0 else Decimal("inf")
        base_volume = safe_decimal_conversion(ticker.get('baseVolume')); quote_volume = safe_decimal_conversion(ticker.get('quoteVolume'))
        if base_volume is not None and base_volume < 0: logger.warning(f"Negative baseVol: {base_volume}"); base_volume = Decimal("0.0")
        if quote_volume is not None and quote_volume < 0: logger.warning(f"Negative quoteVol: {quote_volume}"); quote_volume = Decimal("0.0")
        validated_ticker = { 'symbol': ticker.get('symbol', symbol), 'timestamp': timestamp_ms, 'datetime': ticker.get('datetime'), 'last': last_price, 'bid': bid_price, 'ask': ask_price, 'bidVolume': safe_decimal_conversion(ticker.get('bidVolume')), 'askVolume': safe_decimal_conversion(ticker.get('askVolume')), 'baseVolume': base_volume, 'quoteVolume': quote_volume, 'high': safe_decimal_conversion(ticker.get('high')), 'low': safe_decimal_conversion(ticker.get('low')), 'open': safe_decimal_conversion(ticker.get('open')), 'close': last_price, 'change': safe_decimal_conversion(ticker.get('change')), 'percentage': safe_decimal_conversion(ticker.get('percentage')), 'average': safe_decimal_conversion(ticker.get('average')), 'spread': spread, 'spread_pct': spread_pct, 'info': ticker.get('info', {}) }
        logger.debug(f"[{func_name}] Ticker OK: {symbol} Last={format_price(exchange, symbol, last_price)}, Spread={spread_pct:.4f}% (Age:{age_seconds:.1f}s)")
        return validated_ticker
    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.BadSymbol, ValueError) as e: logger.warning(f"{Fore.YELLOW}[{func_name}] Fetch/Validate ticker failed for {symbol}: {e}{Style.RESET_ALL}"); raise
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected ticker error for {symbol}: {e}{Style.RESET_ALL}", exc_info=True); return None

# Snippet 18 / Function 18: Place Native Trailing Stop Order
@retry_api_call(max_retries=1, initial_delay=0) # Don't auto-retry placing stops usually
def place_native_trailing_stop(
    exchange: ccxt.bybit, symbol: str, side: Literal['buy', 'sell'], amount: Decimal, trailing_offset: Union[Decimal, str], config: 'Config',
    activation_price: Optional[Decimal] = None, trigger_by: Literal['LastPrice', 'MarkPrice', 'IndexPrice'] = 'MarkPrice',
    client_order_id: Optional[str] = None, position_idx: Literal[0, 1, 2] = 0
) -> Optional[Dict]:
    """
    Places a native Trailing Stop Market order on Bybit V5 (reduceOnly).
    Uses V5 specific parameters like 'trailingStop' (for %) or potentially 'trailingMove' (for abs).
    """
    func_name = "place_native_trailing_stop"; log_prefix = f"Place Native TSL ({side.upper()})"
    params: Dict[str, Any] = {}; trail_log_str = ""; is_percent_trail = False;

    # Validate and parse trailing_offset
    if isinstance(trailing_offset, str) and trailing_offset.endswith('%'):
        try:
            percent_val = Decimal(trailing_offset.rstrip('%'));
            # Bybit range typically 0.1% to 10% for trailingStop
            if not (Decimal("0.1") <= percent_val <= Decimal("10.0")): raise ValueError(f"Percentage {percent_val}% out of Bybit's typical range (0.1% - 10%).")
            params['trailingStop'] = str(percent_val.quantize(Decimal("0.01"))); # V5 takes percentage value as string
            trail_log_str = f"{percent_val}%"; is_percent_trail = True
        except (ValueError, InvalidOperation) as e: logger.error(f"{Fore.RED}{log_prefix}: Invalid trailing '%': {e}{Style.RESET_ALL}"); return None
    elif isinstance(trailing_offset, Decimal):
        if trailing_offset <= Decimal("0"): logger.error(f"{Fore.RED}{log_prefix}: Trailing delta must be positive: {trailing_offset}{Style.RESET_ALL}"); return None
        try:
             # Check Bybit V5 docs for absolute trailing stop parameter (e.g., 'trailingMove'?)
             # Assuming 'trailingMove' takes string representation of the price offset
             delta_str = format_price(exchange, symbol, trailing_offset) # Format delta like a price
             params['trailingMove'] = delta_str # Using potential V5 param name
             trail_log_str = f"{delta_str} (abs)"
        except Exception as fmt_e: logger.error(f"{Fore.RED}{log_prefix}: Cannot format trail offset {trailing_offset}: {fmt_e}{Style.RESET_ALL}"); return None
    else: logger.error(f"{Fore.RED}{log_prefix}: Invalid trailing_offset type: {type(trailing_offset)}{Style.RESET_ALL}"); return None

    if activation_price is not None and activation_price <= Decimal("0"): logger.error(f"{Fore.RED}{log_prefix}: Activation price must be positive.{Style.RESET_ALL}"); return None
    logger.info(f"{Fore.CYAN}{log_prefix}: Init {format_amount(exchange, symbol, amount)} {symbol}, Trail:{trail_log_str}, ActPx:{format_price(exchange, symbol, activation_price) or 'Immediate'}, Trigger:{trigger_by}, PosIdx:{position_idx}{Style.RESET_ALL}")

    try:
        market = exchange.market(symbol); category = _get_v5_category(market)
        if not category or category not in ['linear', 'inverse']: logger.error(f"{Fore.RED}[{func_name}] Not a contract symbol: {symbol}.{Style.RESET_ALL}"); return None
        amount_str = format_amount(exchange, symbol, amount); amount_float = float(amount_str); activation_price_str = format_price(exchange, symbol, activation_price) if activation_price else None

        params.update({'category': category, 'reduceOnly': True, 'positionIdx': position_idx, 'tpslMode': 'Full', 'triggerBy': trigger_by, 'tsOrderType': 'Market'}) # Use Market execution
        if activation_price_str is not None: params['activePrice'] = activation_price_str # V5 param for activation price

        if client_order_id:
            max_coid_len = 36
            original_coid_len = len(client_order_id)
            valid_coid = client_order_id[:max_coid_len]
            params['clientOrderId'] = valid_coid
            if len(valid_coid) < original_coid_len:
                logger.warning(f"[{func_name}] Client Order ID truncated to {max_coid_len} chars: '{valid_coid}' (Original length: {original_coid_len})")

        bg = Back.YELLOW; fg = Fore.BLACK
        logger.warning(f"{bg}{fg}{Style.BRIGHT}{log_prefix}: Placing NATIVE TSL (Market exec) -> Qty:{amount_float}, Side:{side}, Trail:{trail_log_str}, ActPx:{activation_price_str or 'Immediate'}, Trigger:{trigger_by}, Reduce:True, PosIdx:{position_idx}, Params:{params}{Style.RESET_ALL}")

        # Use create_order with type='market' and trailing params
        tsl_order = exchange.create_order(symbol=symbol, type='market', side=side, amount=amount_float, params=params)

        order_id = tsl_order.get('id'); client_oid_resp = tsl_order.get('clientOrderId', params.get('clientOrderId', 'N/A')); status = tsl_order.get('status', '?')
        returned_trail_value = tsl_order.get('info', {}).get('trailingStop') or tsl_order.get('info', {}).get('trailingMove')
        returned_act_price = safe_decimal_conversion(tsl_order.get('info', {}).get('activePrice', tsl_order.get('activationPrice')), None)
        returned_trigger = tsl_order.get('info', {}).get('triggerBy', trigger_by)
        logger.success(f"{Fore.GREEN}{log_prefix}: Native TSL order placed. ID:...{format_order_id(order_id)}, ClientOID:{client_oid_resp}, Status:{status}, Trail:{returned_trail_value}, ActPx:{format_price(exchange, symbol, returned_act_price)}, TriggerBy:{returned_trigger}{Style.RESET_ALL}")
        return tsl_order
    except (ccxt.InsufficientFunds, ccxt.InvalidOrder, ccxt.ExchangeError, ccxt.NetworkError, ccxt.BadSymbol, ValueError) as e: logger.error(f"{Fore.RED}{log_prefix}: API/Input Error placing TSL: {type(e).__name__} - {e}{Style.RESET_ALL}"); return None
    except Exception as e: logger.critical(f"{Back.RED}[{func_name}] Unexpected error placing TSL: {e}{Style.RESET_ALL}", exc_info=True); send_sms_alert(f"[{symbol.split('/')[0]}] TSL PLACE FAIL ({side.upper()}): Unexpected {type(e).__name__}", config); return None

# Snippet 19 / Function 19: Fetch Account Info (UTA Status, Margin Mode)
@retry_api_call(max_retries=2, initial_delay=1.0)
def fetch_account_info_bybit_v5(exchange: ccxt.bybit, config: 'Config') -> Optional[Dict[str, Any]]:
    """
    Fetches general account information from Bybit V5 API (`/v5/account/info`).
    Provides insights into UTA status, margin mode settings, etc.
    """
    func_name = "fetch_account_info_bybit_v5"; logger.debug(f"[{func_name}] Fetching Bybit V5 account info...")
    try:
        if hasattr(exchange, 'private_get_v5_account_info'):
            logger.debug(f"[{func_name}] Using private_get_v5_account_info endpoint.")
            account_info_raw = exchange.private_get_v5_account_info(); logger.debug(f"[{func_name}] Raw Account Info response: {str(account_info_raw)[:400]}...")
            ret_code = account_info_raw.get('retCode'); ret_msg = account_info_raw.get('retMsg')
            if ret_code == 0 and 'result' in account_info_raw:
                result = account_info_raw['result']
                parsed_info = { 'unifiedMarginStatus': result.get('unifiedMarginStatus'), 'marginMode': result.get('marginMode'), 'dcpStatus': result.get('dcpStatus'), 'timeWindow': result.get('timeWindow'), 'smtCode': result.get('smtCode'), 'isMasterTrader': result.get('isMasterTrader'), 'updateTime': result.get('updateTime'), 'rawInfo': result }
                logger.info(f"[{func_name}] Account Info: UTA Status={parsed_info.get('unifiedMarginStatus', 'N/A')}, MarginMode={parsed_info.get('marginMode', 'N/A')}, DCP Status={parsed_info.get('dcpStatus', 'N/A')}")
                return parsed_info
            else: raise ccxt.ExchangeError(f"Failed fetch/parse account info. Code={ret_code}, Msg='{ret_msg}'")
        else:
            logger.warning(f"[{func_name}] CCXT lacks 'private_get_v5_account_info'. Using fallback fetch_accounts() (less detail).")
            accounts = exchange.fetch_accounts()
            if accounts: logger.info(f"[{func_name}] Fallback fetch_accounts(): {str(accounts[0])[:200]}..."); return accounts[0]
            else: logger.error(f"{Fore.RED}[{func_name}] Fallback fetch_accounts() returned no data.{Style.RESET_ALL}"); return None
    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.AuthenticationError) as e: logger.warning(f"{Fore.YELLOW}[{func_name}] API Error fetching account info: {e}{Style.RESET_ALL}"); raise
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error fetching account info: {e}{Style.RESET_ALL}", exc_info=True); return None

# Snippet 20 / Function 20: Validate Symbol/Market
def validate_market(
    exchange: ccxt.bybit, symbol: str, config: 'Config', expected_type: Optional[Literal['swap', 'future', 'spot', 'option']] = None,
    expected_logic: Optional[Literal['linear', 'inverse']] = None, check_active: bool = True, require_contract: bool = True
) -> Optional[Dict]:
    """
    Validates if a symbol exists on the exchange, is active, and optionally matches
    expected type (swap, spot, etc.) and logic (linear, inverse). Loads markets if needed.
    """
    func_name = "validate_market"; eff_expected_type = expected_type if expected_type is not None else config.EXPECTED_MARKET_TYPE; eff_expected_logic = expected_logic if expected_logic is not None else config.EXPECTED_MARKET_LOGIC
    logger.debug(f"[{func_name}] Validating '{symbol}'. Checks: Type='{eff_expected_type or 'Any'}', Logic='{eff_expected_logic or 'Any'}', Active={check_active}, Contract={require_contract}")
    try:
        if not exchange.markets: logger.info(f"[{func_name}] Loading markets..."); exchange.load_markets(reload=True)
        if not exchange.markets: logger.error(f"{Fore.RED}[{func_name}] Failed to load markets.{Style.RESET_ALL}"); return None
        market = exchange.market(symbol) # Raises BadSymbol if not found
        is_active = market.get('active', False);
        if check_active and not is_active: logger.warning(f"{Fore.YELLOW}[{func_name}] Validation Warning: '{symbol}' inactive.{Style.RESET_ALL}") # Allow inactive? return None
        actual_type = market.get('type');
        if eff_expected_type and actual_type != eff_expected_type: logger.error(f"{Fore.RED}[{func_name}] Validation Failed: '{symbol}' type mismatch. Expected '{eff_expected_type}', Got '{actual_type}'.{Style.RESET_ALL}"); return None
        is_contract = market.get('contract', False);
        if require_contract and not is_contract: logger.error(f"{Fore.RED}[{func_name}] Validation Failed: '{symbol}' not a contract, but required.{Style.RESET_ALL}"); return None
        actual_logic_str: Optional[str] = None
        if is_contract:
            actual_logic_str = _get_v5_category(market); # Use helper to determine logic
            if eff_expected_logic and actual_logic_str != eff_expected_logic: logger.error(f"{Fore.RED}[{func_name}] Validation Failed: '{symbol}' logic mismatch. Expected '{eff_expected_logic}', Got '{actual_logic_str}'.{Style.RESET_ALL}"); return None
        logger.info(f"{Fore.GREEN}[{func_name}] Market OK: '{symbol}' (Type:{actual_type}, Logic:{actual_logic_str or 'N/A'}, Active:{is_active}).{Style.RESET_ALL}"); return market
    except ccxt.BadSymbol as e: logger.error(f"{Fore.RED}[{func_name}] Validation Failed: Symbol '{symbol}' not found. Error: {e}{Style.RESET_ALL}"); return None
    except ccxt.NetworkError as e: logger.error(f"{Fore.RED}[{func_name}] Network error during market validation for '{symbol}': {e}{Style.RESET_ALL}"); return None # Consider retry?
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error validating '{symbol}': {e}{Style.RESET_ALL}", exc_info=True); return None

# Snippet 21 / Function 21: Fetch Recent Trades
@retry_api_call(max_retries=2, initial_delay=0.5)
def fetch_recent_trades(
    exchange: ccxt.bybit, symbol: str, config: 'Config', limit: int = 100, min_size_filter: Optional[Decimal] = None
) -> Optional[List[Dict]]:
    """
    Fetches recent public trades for a symbol from Bybit V5, validates data,
    and returns a list of trade dictionaries with Decimal values, sorted recent first.
    """
    func_name = "fetch_recent_trades"; filter_log = f"(MinSize:{format_amount(exchange, symbol, min_size_filter) if min_size_filter else 'N/A'})"
    logger.debug(f"[{func_name}] Fetching {limit} trades for {symbol} {filter_log}...")
    if limit > 1000: logger.warning(f"[{func_name}] Clamping limit {limit} to 1000."); limit = 1000
    if limit <= 0: logger.warning(f"[{func_name}] Invalid limit {limit}. Using 100."); limit = 100
    try:
        market = exchange.market(symbol); category = _get_v5_category(market)
        params = {'category': category} if category else {}
        # params['execType'] = 'Trade' # Filter only trades? Check V5 docs.
        logger.debug(f"[{func_name}] Calling fetch_trades with limit={limit}, params={params}")
        trades_raw = exchange.fetch_trades(symbol, limit=limit, params=params)
        if not trades_raw: logger.debug(f"[{func_name}] No recent trades found."); return []
        processed_trades: List[Dict] = []; conversion_errors = 0; filtered_out_count = 0
        for trade in trades_raw:
            try:
                amount = safe_decimal_conversion(trade.get('amount'))
                price = safe_decimal_conversion(trade.get('price'))

                if not all([trade.get('id'), trade.get('timestamp'), trade.get('side'), price, amount]) or price <= 0 or amount <= 0:
                    conversion_errors += 1
                    continue

                if min_size_filter is not None and amount < min_size_filter:
                    filtered_out_count += 1
                    continue

                # Corrected cost calculation/validation (Multi-line)
                cost = safe_decimal_conversion(trade.get('cost'))
                if cost is None or (price and amount and abs(cost - (price * amount)) > config.POSITION_QTY_EPSILON * price):
                    if price and amount:
                         # logger.debug(f"[{func_name}] Recalculating cost for trade {trade.get('id')}")
                         cost = price * amount
                    else:
                         # Should not happen if previous check passed, but handle defensively
                         logger.warning(f"[{func_name}] Cannot calculate cost for trade {trade.get('id')}, price or amount invalid after initial check.")
                         cost = None # Keep cost as None

                processed_trades.append({'id': trade.get('id'), 'timestamp': trade.get('timestamp'), 'datetime': trade.get('datetime'), 'symbol': trade.get('symbol', symbol), 'side': trade.get('side'), 'price': price, 'amount': amount, 'cost': cost, 'takerOrMaker': trade.get('takerOrMaker'), 'info': trade.get('info', {})})
            except Exception as proc_err:
                conversion_errors += 1
                logger.warning(f"{Fore.YELLOW}Error processing single trade: {proc_err}. Data: {trade}{Style.RESET_ALL}")

        if conversion_errors > 0: logger.warning(f"{Fore.YELLOW}Skipped {conversion_errors} trades due to processing errors for {symbol}.{Style.RESET_ALL}")
        if filtered_out_count > 0: logger.debug(f"[{func_name}] Filtered {filtered_out_count} trades smaller than {min_size_filter}.")
        processed_trades.sort(key=lambda x: x['timestamp'], reverse=True)
        logger.info(f"[{func_name}] Fetched/processed {len(processed_trades)} trades for {symbol} {filter_log}.")
        return processed_trades
    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.BadSymbol) as e: logger.warning(f"{Fore.YELLOW}[{func_name}] API Error fetching trades: {e}{Style.RESET_ALL}"); raise
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error fetching trades: {e}{Style.RESET_ALL}", exc_info=True); return None

# Snippet 22 / Function 22: Update Limit Order (Edit Order)
@retry_api_call(max_retries=1, initial_delay=0) # Typically don't auto-retry modifications
def update_limit_order(
    exchange: ccxt.bybit, symbol: str, order_id: str, config: 'Config', new_amount: Optional[Decimal] = None,
    new_price: Optional[Decimal] = None, new_client_order_id: Optional[str] = None
) -> Optional[Dict]:
    """
    Attempts to modify the amount and/or price of an existing open limit order on Bybit V5.
    Requires `edit_order` support. Disallows modifying partially filled orders by default.
    """
    func_name = "update_limit_order"; log_prefix = f"Update Order ...{format_order_id(order_id)}"
    if new_amount is None and new_price is None: logger.warning(f"[{func_name}] {log_prefix}: No new amount or price provided."); return None
    if new_amount is not None and new_amount <= config.POSITION_QTY_EPSILON: logger.error(f"{Fore.RED}[{func_name}] {log_prefix}: Invalid new amount ({new_amount})."); return None
    if new_price is not None and new_price <= Decimal("0"): logger.error(f"{Fore.RED}[{func_name}] {log_prefix}: Invalid new price ({new_price})."); return None
    logger.info(f"{Fore.CYAN}{log_prefix}: Update {symbol} (Amt:{format_amount(exchange,symbol,new_amount) or 'NC'}, Px:{format_price(exchange,symbol,new_price) or 'NC'})...{Style.RESET_ALL}")
    try:
        if not exchange.has.get('editOrder'): logger.error(f"{Fore.RED}{log_prefix}: editOrder not supported.{Style.RESET_ALL}"); return None
        logger.debug(f"[{func_name}] Fetching current order state..."); market = exchange.market(symbol); category = _get_v5_category(market);
        if not category: raise ValueError(f"Cannot determine category for {symbol}")
        fetch_params = {'category': category}
        current_order = exchange.fetch_order(order_id, symbol, params=fetch_params)
        status = current_order.get('status'); order_type = current_order.get('type'); filled_qty = safe_decimal_conversion(current_order.get('filled', '0.0'))
        if status != 'open': raise ccxt.InvalidOrder(f"{log_prefix}: Status is '{status}' (not 'open').")
        if order_type != 'limit': raise ccxt.InvalidOrder(f"{log_prefix}: Type is '{order_type}' (not 'limit').")
        allow_partial_fill_update = False;
        if not allow_partial_fill_update and filled_qty > config.POSITION_QTY_EPSILON: logger.warning(f"{Fore.YELLOW}[{func_name}] Update aborted: partially filled ({format_amount(exchange, symbol, filled_qty)}).{Style.RESET_ALL}"); return None
        final_amount_dec = new_amount if new_amount is not None else safe_decimal_conversion(current_order.get('amount')); final_price_dec = new_price if new_price is not None else safe_decimal_conversion(current_order.get('price'))
        if final_amount_dec is None or final_price_dec is None or final_amount_dec <= config.POSITION_QTY_EPSILON or final_price_dec <= 0: raise ValueError("Invalid final amount/price.")
        edit_params: Dict[str, Any] = {'category': category}

        if new_client_order_id:
            max_coid_len = 36
            original_coid_len = len(new_client_order_id)
            valid_coid = new_client_order_id[:max_coid_len]
            # Check Bybit V5 param name for client OID on edit (e.g., 'clientOrderId' or 'newClientOrderId')
            edit_params['clientOrderId'] = valid_coid # Assuming 'clientOrderId' works
            if len(valid_coid) < original_coid_len:
                logger.warning(f"[{func_name}] New Client Order ID truncated to {max_coid_len} chars: '{valid_coid}' (Original length: {original_coid_len})")

        final_amount_float = float(format_amount(exchange, symbol, final_amount_dec)); final_price_float = float(format_price(exchange, symbol, final_price_dec))
        logger.info(f"{Fore.CYAN}[{func_name}] Submitting update -> Amt:{final_amount_float}, Px:{final_price_float}, Side:{current_order['side']}, Params:{edit_params}{Style.RESET_ALL}")
        updated_order = exchange.edit_order(id=order_id, symbol=symbol, type='limit', side=current_order['side'], amount=final_amount_float, price=final_price_float, params=edit_params)
        if updated_order: new_id = updated_order.get('id', order_id); status_after = updated_order.get('status', '?'); new_client_oid_resp = updated_order.get('clientOrderId', edit_params.get('clientOrderId', 'N/A')); logger.success(f"{Fore.GREEN}[{func_name}] Update OK. NewID:...{format_order_id(new_id)}, Status:{status_after}, ClientOID:{new_client_oid_resp}{Style.RESET_ALL}"); return updated_order
        else: logger.warning(f"{Fore.YELLOW}[{func_name}] edit_order returned no data. Check status manually.{Style.RESET_ALL}"); return None
    except (ccxt.OrderNotFound, ccxt.InvalidOrder, ccxt.NotSupported, ccxt.ExchangeError, ccxt.NetworkError, ccxt.BadSymbol, ValueError) as e: logger.error(f"{Fore.RED}[{func_name}] Failed update: {type(e).__name__} - {e}{Style.RESET_ALL}"); return None # Avoid retry for most of these
    except Exception as e: logger.critical(f"{Back.RED}[{func_name}] Unexpected update error: {e}{Style.RESET_ALL}", exc_info=True); return None

# Snippet 23 / Function 23: Fetch Position Risk (Bybit V5 Specific)
@retry_api_call(max_retries=3, initial_delay=1.0)
def fetch_position_risk_bybit_v5(exchange: ccxt.bybit, symbol: str, config: 'Config') -> Optional[Dict[str, Any]]:
    """
    Fetches detailed risk metrics for the current position of a specific symbol using Bybit V5 logic.
    Uses `fetch_positions_risk` or falls back to `fetch_positions`. Focuses on One-Way mode.
    Returns detailed dictionary with Decimals, or None if no position/error.
    """
    func_name = "fetch_position_risk_bybit_v5"; logger.debug(f"[{func_name}] Fetching position risk {symbol} (V5)...")
    default_risk = { 'symbol': symbol, 'side': config.POS_NONE, 'qty': Decimal("0.0"), 'entry_price': Decimal("0.0"), 'mark_price': None, 'liq_price': None, 'leverage': None, 'initial_margin': None, 'maint_margin': None, 'unrealized_pnl': None, 'imr': None, 'mmr': None, 'position_value': None, 'risk_limit_value': None, 'info': {} }
    try:
        market = exchange.market(symbol); market_id = market['id']; category = _get_v5_category(market)
        if not category or category not in ['linear', 'inverse']: logger.error(f"{Fore.RED}[{func_name}] Not a contract symbol: {symbol}.{Style.RESET_ALL}"); return default_risk
        params = {'category': category, 'symbol': market_id}; position_data: Optional[List[Dict]] = None; fetch_method_used = "N/A"
        if exchange.has.get('fetchPositionsRisk'):
            try: logger.debug(f"[{func_name}] Using fetch_positions_risk..."); position_data = exchange.fetch_positions_risk(symbols=[symbol], params=params); fetch_method_used = "fetchPositionsRisk"
            except Exception as e: logger.warning(f"[{func_name}] fetch_positions_risk failed ({type(e).__name__}). Falling back."); position_data = None
        if position_data is None:
             if exchange.has.get('fetchPositions'): logger.debug(f"[{func_name}] Falling back to fetch_positions..."); position_data = exchange.fetch_positions(symbols=[symbol], params=params); fetch_method_used = "fetchPositions (Fallback)"
             else: logger.error(f"{Fore.RED}[{func_name}] No position fetch methods available.{Style.RESET_ALL}"); return default_risk
        if position_data is None: logger.error(f"{Fore.RED}[{func_name}] Failed fetch position data ({fetch_method_used}).{Style.RESET_ALL}"); return default_risk
        active_pos_risk: Optional[Dict] = None

        # Corrected multi-line nested if block
        for pos in position_data:
            pos_info = pos.get('info', {})
            pos_symbol = pos_info.get('symbol')
            pos_v5_side = pos_info.get('side', 'None')
            pos_size_str = pos_info.get('size')
            pos_idx = int(pos_info.get('positionIdx', -1))

            if pos_symbol == market_id and pos_v5_side != 'None' and pos_idx == 0:
                pos_size = safe_decimal_conversion(pos_size_str, Decimal("0.0"))
                if pos_size is not None and abs(pos_size) > config.POSITION_QTY_EPSILON:
                    active_pos_risk = pos
                    logger.debug(f"[{func_name}] Found active One-Way pos risk data ({fetch_method_used}).")
                    break # Found the position, exit loop

        if not active_pos_risk: logger.info(f"[{func_name}] No active One-Way position found for {symbol}."); return default_risk
        try:
            info = active_pos_risk.get('info', {}); size = safe_decimal_conversion(active_pos_risk.get('contracts', info.get('size'))); entry_price = safe_decimal_conversion(active_pos_risk.get('entryPrice', info.get('avgPrice'))); mark_price = safe_decimal_conversion(active_pos_risk.get('markPrice', info.get('markPrice'))); liq_price = safe_decimal_conversion(active_pos_risk.get('liquidationPrice', info.get('liqPrice'))); leverage = safe_decimal_conversion(active_pos_risk.get('leverage', info.get('leverage'))); initial_margin = safe_decimal_conversion(active_pos_risk.get('initialMargin', info.get('positionIM'))); maint_margin = safe_decimal_conversion(active_pos_risk.get('maintenanceMargin', info.get('positionMM'))); pnl = safe_decimal_conversion(active_pos_risk.get('unrealizedPnl', info.get('unrealisedPnl'))); imr = safe_decimal_conversion(active_pos_risk.get('initialMarginPercentage', info.get('imr'))); mmr = safe_decimal_conversion(active_pos_risk.get('maintenanceMarginPercentage', info.get('mmr'))); pos_value = safe_decimal_conversion(active_pos_risk.get('contractsValue', info.get('positionValue'))); risk_limit = safe_decimal_conversion(info.get('riskLimitValue'))
            pos_side_str = info.get('side'); position_side = config.POS_LONG if pos_side_str == 'Buy' else (config.POS_SHORT if pos_side_str == 'Sell' else config.POS_NONE); quantity = abs(size) if size is not None else Decimal("0.0")
            if position_side == config.POS_NONE or quantity <= config.POSITION_QTY_EPSILON: logger.info(f"[{func_name}] Parsed pos {symbol} negligible."); return default_risk
            log_color = Fore.GREEN if position_side == config.POS_LONG else Fore.RED
            logger.info(f"{log_color}[{func_name}] Position Risk {symbol} ({position_side}):{Style.RESET_ALL}")
            logger.info(f"  Qty:{format_amount(exchange, symbol, quantity)}, Entry:{format_price(exchange, symbol, entry_price)}, Mark:{format_price(exchange, symbol, mark_price)}")
            logger.info(f"  Liq:{format_price(exchange, symbol, liq_price)}, Lev:{leverage}x, uPNL:{format_price(exchange, market['quote'], pnl)}")
            logger.info(f"  IM:{format_price(exchange, market['quote'], initial_margin)}, MM:{format_price(exchange, market['quote'], maint_margin)}")
            logger.info(f"  IMR:{imr:.4% if imr else 'N/A'}, MMR:{mmr:.4% if mmr else 'N/A'}, Value:{format_price(exchange, market['quote'], pos_value)}")
            logger.info(f"  RiskLimitValue:{risk_limit or 'N/A'}")
            return { 'symbol': symbol, 'side': position_side, 'qty': quantity, 'entry_price': entry_price, 'mark_price': mark_price, 'liq_price': liq_price, 'leverage': leverage, 'initial_margin': initial_margin, 'maint_margin': maint_margin, 'unrealized_pnl': pnl, 'imr': imr, 'mmr': mmr, 'position_value': pos_value, 'risk_limit_value': risk_limit, 'info': info }
        except Exception as parse_err: logger.warning(f"{Fore.YELLOW}[{func_name}] Error parsing pos risk: {parse_err}. Data: {str(active_pos_risk)[:300]}{Style.RESET_ALL}"); return default_risk
    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.BadSymbol) as e: logger.warning(f"{Fore.YELLOW}[{func_name}] API Error fetching pos risk: {e}{Style.RESET_ALL}"); raise
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error fetching pos risk: {e}{Style.RESET_ALL}", exc_info=True); return default_risk

# Snippet 24 / Function 24: Set Isolated Margin (Bybit V5 Specific)
@retry_api_call(max_retries=2, initial_delay=1.0)
def set_isolated_margin_bybit_v5(exchange: ccxt.bybit, symbol: str, leverage: int, config: 'Config') -> bool:
    """
    Sets margin mode to ISOLATED for a specific symbol on Bybit V5 and sets leverage for it.

    Uses V5 endpoint 'private_post_v5_position_switch_isolated'. Cannot be done if there's
    an existing position or active orders for the symbol.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Market symbol (e.g., 'BTC/USDT:USDT') to set isolated margin for.
        leverage: The desired leverage (buy and sell) to set for the isolated position.
        config: Configuration object.

    Returns:
        True if isolated mode was set successfully (or already set) and leverage was applied,
        False otherwise.

    Raises:
        Reraises CCXT exceptions for the retry decorator. Handles specific V5 errors internally.
        ValueError for invalid leverage.
    """
    func_name = "set_isolated_margin_bybit_v5"
    logger.info(f"{Fore.CYAN}[{func_name}] Attempting to set ISOLATED margin mode for {symbol} with {leverage}x leverage...{Style.RESET_ALL}")
    ret_code = -1 # Initialize ret_code to handle potential early exit

    if leverage <= 0: logger.error(f"{Fore.RED}[{func_name}] Leverage must be positive.{Style.RESET_ALL}"); return False

    try:
        market = exchange.market(symbol)
        category = _get_v5_category(market)
        if not category or category not in ['linear', 'inverse']:
            logger.error(f"{Fore.RED}[{func_name}] Cannot set isolated margin for non-contract symbol: {symbol} (Category: {category}).{Style.RESET_ALL}")
            return False

        # Prefer unified method if available and works
        try:
            logger.debug(f"[{func_name}] Attempting via unified exchange.set_margin_mode...")
            # This might also set leverage implicitly or require separate call
            response = exchange.set_margin_mode(marginMode='isolated', symbol=symbol, params={'category': category, 'leverage': leverage})
            logger.info(f"[{func_name}] Unified set_margin_mode call executed for isolated. Response: {response}")
            # Check if leverage needs separate setting
            logger.info(f"[{func_name}] Verifying leverage after unified set_margin_mode call...")
            leverage_set_success = set_leverage(exchange, symbol, leverage, config)
            if leverage_set_success:
                logger.success(f"{Fore.GREEN}[{func_name}] Isolated mode & leverage {leverage}x set/confirmed via unified method for {symbol}.{Style.RESET_ALL}")
                return True
            else:
                 logger.error(f"{Fore.RED}[{func_name}] Failed to set leverage after unified isolated mode attempt for {symbol}.{Style.RESET_ALL}")
                 return False # Fallback to private endpoint? Maybe not, indicate failure.

        except (ccxt.NotSupported, ccxt.ExchangeError, ccxt.ArgumentsRequired) as e_unified:
            logger.warning(f"[{func_name}] Unified set_margin_mode failed for isolated: {e_unified}. Trying private V5 endpoint...")
        # Proceed to private endpoint if unified method failed/not supported

        # Check if the required V5 method exists
        if not hasattr(exchange, 'private_post_v5_position_switch_isolated'):
            logger.error(f"{Fore.RED}[{func_name}] CCXT lacks 'private_post_v5_position_switch_isolated'. Cannot set isolated margin via private endpoint.{Style.RESET_ALL}")
            return False

        params_switch = { 'category': category, 'symbol': market['id'], 'tradeMode': 1, 'buyLeverage': str(leverage), 'sellLeverage': str(leverage) }
        logger.debug(f"[{func_name}] Calling private_post_v5_position_switch_isolated with params: {params_switch}")
        response = exchange.private_post_v5_position_switch_isolated(params_switch)
        logger.debug(f"[{func_name}] Raw response from switch_isolated endpoint: {response}")

        ret_code = response.get('retCode'); ret_msg = response.get('retMsg', '').lower()
        already_isolated_or_ok = False

        if ret_code == 0: logger.success(f"{Fore.GREEN}[{func_name}] Switched {symbol} to ISOLATED with {leverage}x leverage via V5 endpoint.{Style.RESET_ALL}"); already_isolated_or_ok = True
        # 110026: Margin mode is not modified | 34036 maybe?
        elif ret_code in [110026, 34036] or "margin mode is not modified" in ret_msg: logger.info(f"{Fore.CYAN}[{func_name}] {symbol} already ISOLATED via V5 check. Verifying leverage...{Style.RESET_ALL}"); already_isolated_or_ok = True
        # 110020: Position/order exists
        elif ret_code == 110020 or "have position" in ret_msg or "active order" in ret_msg: logger.error(f"{Fore.RED}[{func_name}] Cannot switch {symbol} to ISOLATED: active pos/orders exist. Msg: {response.get('retMsg')}{Style.RESET_ALL}"); return False
        else: raise ccxt.ExchangeError(f"Bybit API error switching isolated mode via V5 endpoint: Code={ret_code}, Msg='{response.get('retMsg', 'N/A')}'")

        # If mode is now isolated (or was already), explicitly ensure leverage is set correctly
        if already_isolated_or_ok:
            logger.debug(f"[{func_name}] Explicitly setting/confirming leverage {leverage}x for ISOLATED {symbol}...")
            leverage_set_success = set_leverage(exchange, symbol, leverage, config) # Use validated function
            if leverage_set_success: logger.success(f"{Fore.GREEN}[{func_name}] Leverage confirmed/set {leverage}x for ISOLATED {symbol}.{Style.RESET_ALL}"); return True
            else: logger.error(f"{Fore.RED}[{func_name}] Failed set/confirm leverage {leverage}x after ISOLATED mode switch/check.{Style.RESET_ALL}"); return False

        return False

    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.AuthenticationError, ccxt.BadSymbol, ValueError) as e:
        # Avoid raising again if it's an error code handled explicitly above (e.g., 110020)
        if not (isinstance(e, ccxt.ExchangeError) and ret_code in [110020]):
             logger.warning(f"{Fore.YELLOW}[{func_name}] API/Input Error setting isolated margin: {e}{Style.RESET_ALL}")
             if isinstance(e, (ccxt.NetworkError, ccxt.AuthenticationError)): raise e # Re-raise for retry decorator
        return False
    except Exception as e:
        logger.error(f"{Fore.RED}[{func_name}] Unexpected error setting isolated margin: {e}{Style.RESET_ALL}", exc_info=True)
        return False

# Snippet 25: Monitor API Rate Limit - REMOVED
# Rate limit monitoring relies EXCLUSIVELY on the external `retry_api_call` decorator.

# --- END OF HELPER FUNCTION IMPLEMENTATIONS ---


# --- Example Standalone Testing Block ---
if __name__ == "__main__":
    print(f"{Fore.YELLOW}{Style.BRIGHT}--- Bybit V5 Helpers Module Standalone Execution ---{Style.RESET_ALL}")
    print("This block is for basic syntax checks ONLY.")
    print("It CANNOT run live tests because it depends on functions and configuration")
    print("(Config, logger, etc.) imported from the main script, and utilities")
    print("imported from 'bybit_utils.py'.")
    print("-" * 60)

    # --- Basic Syntax Check ---
    print("Checking basic syntax and function definitions...")
    all_funcs = [
        initialize_bybit, set_leverage, fetch_usdt_balance, place_market_order_slippage_check,
        cancel_all_orders, fetch_ohlcv_paginated, _process_ohlcv_list, place_limit_order_tif,
        get_current_position_bybit_v5, close_position_reduce_only, fetch_funding_rate,
        set_position_mode_bybit_v5, fetch_l2_order_book_validated, place_native_stop_loss,
        fetch_open_orders_filtered, calculate_margin_requirement, fetch_ticker_validated,
        place_native_trailing_stop, fetch_account_info_bybit_v5, validate_market,
        fetch_recent_trades, update_limit_order, fetch_position_risk_bybit_v5,
        set_isolated_margin_bybit_v5
    ]
    print(f"Found {len(all_funcs)} function definitions.")

    print(f"\n{Fore.GREEN}Basic syntax check passed.{Style.RESET_ALL}")
    print("To test functionality, import this module into your main script")
    print("which provides the required 'Config' object and 'logger', and ensure")
    print("'bybit_utils.py' is present and contains the necessary helper functions.")
    print("-" * 60)
    print(f"{Fore.YELLOW}Finished standalone check execution.{Style.RESET_ALL}")
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Bybit V5 CCXT Helper Functions (v2.7 - Syntax Fix in Position Risk Loop)

This module provides a collection of robust, reusable, and enhanced helper functions
designed for interacting with the Bybit exchange, specifically targeting the
V5 API (Unified Trading Account - UTA), using the CCXT library.

Core Functionality Includes:
- Exchange Initialization: Securely sets up the ccxt.bybit exchange instance,
  handling testnet mode, V5 defaults, and initial validation.
- Account Configuration: Functions to set leverage, margin mode (cross/isolated),
  and position mode (one-way/hedge) with V5 specific endpoints and validation.
- Market Data Retrieval: Validated fetching of tickers, OHLCV (with pagination
  and DataFrame conversion), L2 order books, funding rates, and recent trades,
  all using Decimals and V5 parameters.
- Order Management: Placing market, limit, native stop-loss (market), and native
  trailing-stop orders with V5 parameters. Includes options for Time-In-Force (TIF),
  reduce-only, post-only, client order IDs, and slippage checks for market orders.
  Also provides functions for cancelling single or all open orders, fetching open
  orders (filtered), and updating existing limit orders (edit).
- Position Management: Fetching detailed current position information (V5 specific),
  closing positions using reduce-only market orders, and retrieving detailed position
  risk metrics (IMR, MMR, Liq. Price, etc.) using V5 logic.
- Balance & Margin: Fetching USDT balances (equity/available) using V5 UNIFIED
  account logic, and calculating estimated margin requirements for potential orders.
- Utilities: Market validation against exchange data (type, logic, active status).

Key Enhancements in v2.7:
- Fixed SyntaxError in fetch_position_risk_bybit_v5 loop processing.
- Previous Fixes from v2.1-v2.6.
- Relies exclusively on external helpers/decorator as documented.

Dependencies from Importing Script:
- This module RELIES on the script importing it (e.g., your strategy script)
  to have already initialized and made available the following:
    1. `logger`: A pre-configured `logging.Logger` object.
    2. `Config`: A configuration class/object instance containing API keys,
       settings, constants (e.g., Config.RETRY_COUNT, Config.SYMBOL, etc.).
       Passed explicitly to functions requiring it.
    3. `safe_decimal_conversion`: Function `(Any, Optional[Decimal]) -> Optional[Decimal]`.
    4. `format_price`: Function `(ccxt.Exchange, str, Any) -> str`.
    5. `format_amount`: Function `(ccxt.Exchange, str, Any) -> str`.
    6. `format_order_id`: Function `(Any) -> str`.
    7. `send_sms_alert`: Function `(str, Optional[Config]) -> bool` (Optional).
    8. `retry_api_call`: Decorator for handling API call retries and rate limits.
    9. `analyze_order_book`: Function `(ccxt.Exchange, str, int, int, Config) -> Dict[str, Optional[Decimal]]`.
- Ensure these are defined and accessible BEFORE using functions from this module.
"""

# Standard Library Imports
import logging
import os
import sys
import time
import random # Used in fetch_ohlcv_paginated retry delay jitter
from decimal import Decimal, ROUND_HALF_UP, DivisionByZero, InvalidOperation, getcontext
from typing import Optional, Dict, List, Tuple, Any, Literal, Union, Callable, TypeVar

# Third-party Libraries
try:
    import ccxt
except ImportError:
    print("Error: CCXT library not found. Please install it: pip install ccxt")
    sys.exit(1)
try:
    import pandas as pd
except ImportError:
    print("Error: pandas library not found. Please install it: pip install pandas")
    sys.exit(1)
try:
    from colorama import Fore, Style, Back
except ImportError:
    print("Warning: colorama library not found. Logs will not be colored. Install: pip install colorama")
    # Define dummy color constants if colorama is not available
    class DummyColor:
        def __getattr__(self, name: str) -> str: return ""
    Fore = Style = Back = DummyColor()

# Set Decimal context precision
getcontext().prec = 28

# --- Logger Placeholder (Actual logger MUST be provided by importing script) ---
if 'logger' not in globals():
    logger = logging.getLogger(__name__)
    if not logger.hasHandlers():
        handler = logging.StreamHandler(sys.stdout)
        formatter = logging.Formatter(
            "%(asctime)s [%(levelname)s] {%(filename)s:%(lineno)d:%(funcName)s} - %(message)s",
            datefmt="%Y-%m-%d %H:%M:%S"
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        logger.setLevel(logging.DEBUG)
    logger.info("Placeholder logger initialized for bybit_helpers module. Ensure a configured logger is provided by the importing script.")

# --- External Dependencies Placeholder Reminder ---
# The actual implementations MUST be provided by the importing script.
# ======================================================================
# class Config: pass
# def safe_decimal_conversion(value: Any, default: Optional[Decimal] = None) -> Optional[Decimal]: raise NotImplementedError("Must be provided by importer")
# def format_price(exchange: ccxt.Exchange, symbol: str, price: Any) -> str: raise NotImplementedError("Must be provided by importer")
# def format_amount(exchange: ccxt.Exchange, symbol: str, amount: Any) -> str: raise NotImplementedError("Must be provided by importer")
# def format_order_id(order_id: Any) -> str: raise NotImplementedError("Must be provided by importer")
# def send_sms_alert(message: str, config: Optional['Config'] = None) -> bool: raise NotImplementedError("Must be provided by importer (Optional)")
# def retry_api_call(*args, **kwargs): raise NotImplementedError("Decorator Must be provided by importer")
# def analyze_order_book(*args, **kwargs) -> Dict: raise NotImplementedError("Must be provided by importer")
# ======================================================================

# Define TypeVar for retry_api_call decorator placeholder (if used directly)
T = TypeVar('T')

# If retry_api_call decorator is NOT provided by the importer, define a dummy one
# to prevent NameErrors, but it won't provide retry functionality.
if 'retry_api_call' not in globals():
    print("WARNING: 'retry_api_call' decorator not found in global scope. Defining a dummy decorator. API calls will NOT be retried automatically.")
    def retry_api_call(max_retries: int = 1, initial_delay: float = 0) -> Callable[[Callable[..., T]], Callable[..., T]]:
        def decorator(func: Callable[..., T]) -> Callable[..., T]:
            def wrapper(*args: Any, **kwargs: Any) -> T:
                # Dummy wrapper just calls the function
                return func(*args, **kwargs)
            return wrapper
        return decorator


# --- Helper Function Implementations ---

def _get_v5_category(market: Dict[str, Any]) -> Optional[Literal['linear', 'inverse', 'spot', 'option']]:
    """Internal helper to determine the Bybit V5 category from a market object."""
    func_name = "_get_v5_category"
    if not market:
        logger.warning(f"[{func_name}] Received empty market data.")
        return None

    # Prefer explicit flags
    if market.get('linear'): return 'linear'
    if market.get('inverse'): return 'inverse'
    if market.get('spot'): return 'spot'
    if market.get('option'): return 'option'

    # Fallback based on market type if explicit flags aren't present
    market_type = market.get('type')
    logger.debug(f"[{func_name}] Market type: {market_type} for symbol {market.get('symbol')}")

    if market_type == 'swap':
        contract_type = market.get('contractType', '').lower()
        if contract_type == 'linear': return 'linear'
        if contract_type == 'inverse': return 'inverse'
        logger.warning(f"[{func_name}] Market type is 'swap' but couldn't determine linear/inverse from contractType '{contract_type}'. Assuming 'linear'.")
        return 'linear'
    elif market_type == 'future':
         logger.warning(f"[{func_name}] Market type is 'future'. Assuming 'linear'.")
         return 'linear'
    elif market_type == 'spot':
        return 'spot'
    elif market_type == 'option':
        return 'option'
    else:
        logger.warning(f"[{func_name}] Could not determine V5 category for market: {market.get('symbol')}, Type: {market_type}")
        return None

# Snippet 1 / Function 1: Initialize Bybit Exchange
@retry_api_call(max_retries=3, initial_delay=2.0) # Apply retry decorator
def initialize_bybit(config: 'Config') -> Optional[ccxt.bybit]:
    """
    Initializes and validates the Bybit CCXT exchange instance using V5 API settings.

    Sets sandbox mode, default order type, loads markets, performs an initial
    balance check, and attempts to set margin mode (logs warning on failure).

    Args:
        config: The configuration object containing API keys, testnet flag, etc.

    Returns:
        A configured and validated `ccxt.bybit` instance, or `None` if initialization fails.

    Raises:
        Catches and logs common CCXT exceptions during initialization attempts.
        Relies on the `retry_api_call` decorator for retries.
    """
    func_name = "initialize_bybit"
    logger.info(f"{Fore.BLUE}[{func_name}] Initializing Bybit (V5) exchange instance...{Style.RESET_ALL}")
    try:
        exchange_class = getattr(ccxt, config.EXCHANGE_ID)
        exchange = exchange_class({
            'apiKey': config.API_KEY,
            'secret': config.API_SECRET,
            'enableRateLimit': True,
            'options': {
                'defaultType': 'swap',
                'adjustForTimeDifference': True,
                'recvWindow': config.DEFAULT_RECV_WINDOW,
                'brokerId': 'PyrmethusV2.7', # Updated Broker ID
            }
        })

        if config.TESTNET_MODE:
            logger.info(f"[{func_name}] Enabling Bybit Sandbox (Testnet) mode.")
            exchange.set_sandbox_mode(True)

        logger.debug(f"[{func_name}] Loading markets...")
        exchange.load_markets(reload=True)
        if not exchange.markets:
             raise ccxt.ExchangeError(f"[{func_name}] Failed to load markets.")
        logger.debug(f"[{func_name}] Markets loaded successfully ({len(exchange.markets)} symbols).")

        logger.debug(f"[{func_name}] Performing initial balance fetch for validation...")
        exchange.fetch_balance({'accountType': 'UNIFIED'})
        logger.debug(f"[{func_name}] Initial balance check successful.")

        try:
            market = exchange.market(config.SYMBOL)
            category = _get_v5_category(market)
            if category and category in ['linear', 'inverse']:
                logger.debug(f"[{func_name}] Attempting to set initial margin mode '{config.DEFAULT_MARGIN_MODE}' for {config.SYMBOL} (Category: {category})...")
                params = {'category': category}
                exchange.set_margin_mode(config.DEFAULT_MARGIN_MODE, config.SYMBOL, params=params)
                logger.info(f"[{func_name}] Initial margin mode potentially set to '{config.DEFAULT_MARGIN_MODE}' for {config.SYMBOL}.")
            else:
                logger.warning(f"[{func_name}] Cannot determine contract category for {config.SYMBOL}. Skipping initial margin mode set.")
        except (ccxt.NotSupported, ccxt.ExchangeError, ccxt.ArgumentsRequired, ccxt.BadSymbol) as e_margin:
            logger.warning(f"{Fore.YELLOW}[{func_name}] Could not set initial margin mode for {config.SYMBOL}: {e_margin}. "
                           f"This might be expected (e.g., UTA Isolated accounts). Verify account settings.{Style.RESET_ALL}")

        logger.success(f"{Fore.GREEN}[{func_name}] Bybit exchange initialized successfully. Testnet: {config.TESTNET_MODE}.{Style.RESET_ALL}")
        return exchange

    except (ccxt.AuthenticationError, ccxt.NetworkError, ccxt.ExchangeNotAvailable, ccxt.ExchangeError) as e:
        logger.error(f"{Fore.RED}[{func_name}] Initialization attempt failed: {type(e).__name__} - {e}{Style.RESET_ALL}")
        raise
    except Exception as e:
        logger.critical(f"{Back.RED}[{func_name}] Unexpected critical error during Bybit initialization: {e}{Style.RESET_ALL}", exc_info=True)
        send_sms_alert(f"[BybitHelper] CRITICAL: Bybit init failed! Unexpected: {type(e).__name__}", config)
        return None

# Snippet 2 / Function 2: Set Leverage
@retry_api_call(max_retries=3, initial_delay=1.0)
def set_leverage(exchange: ccxt.bybit, symbol: str, leverage: int, config: 'Config') -> bool:
    """
    Sets the leverage for a specific symbol on Bybit V5 (Linear/Inverse).

    Validates the requested leverage against the market's limits. Handles the
    'leverage not modified' case gracefully. Applies to both buy and sell leverage.

    Args:
        exchange: The initialized ccxt.bybit exchange instance.
        symbol: The market symbol (e.g., 'BTC/USDT:USDT').
        leverage: The desired integer leverage level.
        config: The configuration object.

    Returns:
        True if leverage was set successfully or already set to the desired value, False otherwise.

    Raises:
        Reraises CCXT exceptions for the retry decorator. ValueError for invalid leverage input.
    """
    func_name = "set_leverage"
    logger.info(f"{Fore.CYAN}[{func_name}] Setting leverage to {leverage}x for {symbol}...{Style.RESET_ALL}")

    if leverage <= 0:
        logger.error(f"{Fore.RED}[{func_name}] Leverage must be positive. Received: {leverage}{Style.RESET_ALL}")
        return False # Invalid input, don't call API

    try:
        market = exchange.market(symbol)
        category = _get_v5_category(market)
        if not category or category not in ['linear', 'inverse']:
            logger.error(f"{Fore.RED}[{func_name}] Invalid market type for leverage setting: {symbol} (Category: {category}).{Style.RESET_ALL}")
            return False

        leverage_filter = market.get('info', {}).get('leverageFilter', {})
        max_leverage_str = leverage_filter.get('maxLeverage')
        min_leverage_str = leverage_filter.get('minLeverage', '1')
        max_leverage = int(safe_decimal_conversion(max_leverage_str, default=Decimal('100')))
        min_leverage = int(safe_decimal_conversion(min_leverage_str, default=Decimal('1')))

        if not (min_leverage <= leverage <= max_leverage):
            logger.error(f"{Fore.RED}[{func_name}] Invalid leverage requested: {leverage}x. Allowed range for {symbol}: {min_leverage}x - {max_leverage}x.{Style.RESET_ALL}")
            return False

        params = {
            'category': category,
            'buyLeverage': str(leverage),
            'sellLeverage': str(leverage)
        }

        logger.debug(f"[{func_name}] Calling exchange.set_leverage with symbol='{symbol}', leverage={leverage}, params={params}")
        response = exchange.set_leverage(leverage, symbol, params=params)

        logger.debug(f"[{func_name}] Leverage API call response (raw): {response}")
        logger.success(f"{Fore.GREEN}[{func_name}] Leverage set/confirmed to {leverage}x for {symbol} (Category: {category}).{Style.RESET_ALL}")
        return True

    except ccxt.ExchangeError as e:
        error_str = str(e).lower()
        # 110044: Leverage not modified
        if "leverage not modified" in error_str or "same as input" in error_str or "110044" in str(e):
            logger.info(f"{Fore.CYAN}[{func_name}] Leverage for {symbol} is already set to {leverage}x.{Style.RESET_ALL}")
            return True
        else:
            logger.error(f"{Fore.RED}[{func_name}] ExchangeError setting leverage for {symbol} to {leverage}x: {e}{Style.RESET_ALL}")
            raise
    except (ccxt.NetworkError, ccxt.AuthenticationError, ccxt.BadSymbol) as e:
        logger.error(f"{Fore.RED}[{func_name}] API/Symbol error setting leverage for {symbol}: {e}{Style.RESET_ALL}")
        raise
    except Exception as e:
        logger.error(f"{Fore.RED}[{func_name}] Unexpected error setting leverage for {symbol} to {leverage}x: {e}{Style.RESET_ALL}", exc_info=True)
        send_sms_alert(f"[{symbol.split('/')[0]}] ERROR: Failed set leverage {leverage}x (Unexpected)", config)
        return False

# Snippet 3 / Function 3: Fetch USDT Balance (V5 UNIFIED)
@retry_api_call(max_retries=3, initial_delay=1.0)
def fetch_usdt_balance(exchange: ccxt.bybit, config: 'Config') -> Tuple[Optional[Decimal], Optional[Decimal]]:
    """
    Fetches the USDT balance (Total Equity and Available Balance) using Bybit V5 UNIFIED account logic.

    Args:
        exchange: The initialized ccxt.bybit exchange instance.
        config: The configuration object (used for USDT_SYMBOL).

    Returns:
        A tuple containing (total_equity, available_balance) as Decimals,
        or (None, None) if fetching fails or balance cannot be parsed.

    Raises:
        Reraises CCXT exceptions for the retry decorator.
    """
    func_name = "fetch_usdt_balance"
    logger.debug(f"[{func_name}] Fetching USDT balance (Bybit V5 UNIFIED Account)...")

    try:
        params = {'accountType': 'UNIFIED'}
        balance_data = exchange.fetch_balance(params=params)

        info = balance_data.get('info', {})
        result_list = info.get('result', {}).get('list', [])

        equity: Optional[Decimal] = None
        available: Optional[Decimal] = None
        account_type_found: str = "N/A"

        if result_list:
            unified_account_info = next((acc for acc in result_list if acc.get('accountType') == 'UNIFIED'), None)

            if unified_account_info:
                account_type_found = "UNIFIED"
                equity = safe_decimal_conversion(unified_account_info.get('totalEquity'))
                coin_list = unified_account_info.get('coin', [])
                usdt_coin_info = next((coin for coin in coin_list if coin.get('coin') == config.USDT_SYMBOL), None)

                if usdt_coin_info:
                    avail_val = usdt_coin_info.get('availableToWithdraw') or \
                                usdt_coin_info.get('availableBalance') or \
                                usdt_coin_info.get('walletBalance')
                    available = safe_decimal_conversion(avail_val, Decimal("0.0")) # Default to 0 if parsing fails
                else:
                    logger.warning(f"[{func_name}] USDT coin data not found within the UNIFIED account details. Assuming 0 available.")
                    available = Decimal("0.0")

            else:
                logger.warning(f"[{func_name}] 'UNIFIED' account type not found in V5 balance response list. Trying fallback to first account.")
                if len(result_list) >= 1:
                     first_account = result_list[0]; account_type_found = first_account.get('accountType', 'UNKNOWN')
                     logger.warning(f"[{func_name}] Using first account found: Type '{account_type_found}'")
                     equity = safe_decimal_conversion(first_account.get('totalEquity') or first_account.get('equity'))
                     coin_list = first_account.get('coin', [])
                     usdt_coin_info = next((coin for coin in coin_list if coin.get('coin') == config.USDT_SYMBOL), None)
                     if usdt_coin_info:
                         avail_val = usdt_coin_info.get('availableBalance') or usdt_coin_info.get('walletBalance')
                         available = safe_decimal_conversion(avail_val, Decimal("0.0"))
                     else: available = Decimal("0.0")
                else:
                     logger.error(f"[{func_name}] Balance response list is empty. Cannot determine balance.")

        if equity is None or available is None:
            logger.debug(f"[{func_name}] V5 structure parsing failed or incomplete. Trying standard CCXT balance keys...")
            usdt_balance_std = balance_data.get(config.USDT_SYMBOL, {})
            if equity is None: equity = safe_decimal_conversion(usdt_balance_std.get('total'))
            if available is None:
                available = safe_decimal_conversion(usdt_balance_std.get('free'))
                if available is None and equity is not None:
                     logger.warning(f"[{func_name}] CCXT 'free' balance missing, using 'total' ({equity:.4f}) as fallback for available.")
                     available = equity

            if equity is not None and available is not None:
                account_type_found = "CCXT Standard Fallback"
            else:
                 raise ValueError(f"Failed to parse balance from both V5 ({account_type_found}) and Standard structures.")

        final_equity = max(Decimal("0.0"), equity) if equity is not None else Decimal("0.0")
        final_available = max(Decimal("0.0"), available) if available is not None else Decimal("0.0")

        logger.info(f"[{func_name}] USDT Balance Fetched (Source: {account_type_found}): "
                    f"Equity = {final_equity:.4f}, Available = {final_available:.4f}")
        return final_equity, final_available

    except (ccxt.NetworkError, ccxt.ExchangeError, ValueError) as e:
        logger.warning(f"{Fore.YELLOW}[{func_name}] Error fetching/parsing balance: {e}{Style.RESET_ALL}")
        raise
    except Exception as e:
        logger.critical(f"{Back.RED}[{func_name}] Unexpected critical error fetching balance: {e}{Style.RESET_ALL}", exc_info=True)
        send_sms_alert("[BybitHelper] CRITICAL: Failed fetch USDT balance!", config)
        return None, None

# Snippet 4 / Function 4: Place Market Order with Slippage Check
@retry_api_call(max_retries=1, initial_delay=0) # Typically don't retry market orders automatically
def place_market_order_slippage_check(
    exchange: ccxt.bybit,
    symbol: str,
    side: Literal['buy', 'sell'],
    amount: Decimal,
    config: 'Config',
    max_slippage_pct: Optional[Decimal] = None,
    is_reduce_only: bool = False,
    client_order_id: Optional[str] = None
) -> Optional[Dict]:
    """
    Places a market order on Bybit V5 after checking the current spread against a slippage threshold.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Market symbol (e.g., 'BTC/USDT:USDT').
        side: 'buy' or 'sell'.
        amount: Order quantity in base currency (Decimal). Must be positive.
        config: Configuration object.
        max_slippage_pct: Maximum allowed spread percentage (e.g., Decimal('0.005') for 0.5%).
                          Uses `config.DEFAULT_SLIPPAGE_PCT` if None.
        is_reduce_only: If True, set the reduceOnly flag.
        client_order_id: Optional client order ID string (max length 36 for Bybit V5 linear).

    Returns:
        The order dictionary returned by ccxt, or None if the order failed or was aborted pre-flight.
    """
    func_name = "place_market_order_slippage_check"
    market_base = symbol.split('/')[0]
    action = "CLOSE" if is_reduce_only else "ENTRY"
    log_prefix = f"Market Order ({action} {side.upper()})"
    effective_max_slippage = max_slippage_pct if max_slippage_pct is not None else config.DEFAULT_SLIPPAGE_PCT

    logger.info(f"{Fore.BLUE}{log_prefix}: Init {format_amount(exchange, symbol, amount)} {symbol}. "
                f"Max Slippage: {effective_max_slippage:.4%}, ReduceOnly: {is_reduce_only}{Style.RESET_ALL}")

    if amount <= config.POSITION_QTY_EPSILON:
        logger.error(f"{Fore.RED}{log_prefix}: Amount is zero or negative ({amount}). Aborting.{Style.RESET_ALL}")
        return None

    try:
        market = exchange.market(symbol)
        category = _get_v5_category(market)
        if not category:
             logger.error(f"{Fore.RED}[{func_name}] Cannot determine market category for {symbol}. Aborting.{Style.RESET_ALL}")
             return None

        # 1. Perform Slippage Check using validated L2 OB fetch
        logger.debug(f"[{func_name}] Performing pre-order slippage check (Depth: {config.SHALLOW_OB_FETCH_DEPTH})...")
        ob_analysis = analyze_order_book(exchange, symbol, config.SHALLOW_OB_FETCH_DEPTH, config.ORDER_BOOK_FETCH_LIMIT, config)
        best_ask = ob_analysis.get("best_ask")
        best_bid = ob_analysis.get("best_bid")

        if best_bid and best_ask and best_bid > Decimal("0"):
            spread = (best_ask - best_bid) / best_bid
            logger.debug(f"[{func_name}] Current shallow OB: Best Bid={format_price(exchange, symbol, best_bid)}, "
                          f"Best Ask={format_price(exchange, symbol, best_ask)}, Spread={spread:.4%}")
            if spread > effective_max_slippage:
                logger.error(f"{Fore.RED}{log_prefix}: Aborted due to high slippage. "
                             f"Current Spread {spread:.4%} > Max Allowed {effective_max_slippage:.4%}.{Style.RESET_ALL}")
                send_sms_alert(f"[{market_base}] ORDER ABORT ({side.upper()}): High Slippage {spread:.4%}", config)
                return None
        else:
            logger.warning(f"{Fore.YELLOW}{log_prefix}: Could not get valid L2 order book data to check slippage. Proceeding with caution.{Style.RESET_ALL}")

        # 2. Prepare and Place Order
        amount_str = format_amount(exchange, symbol, amount)
        amount_float = float(amount_str)
        params: Dict[str, Any] = {'category': category}
        if is_reduce_only:
            params['reduceOnly'] = True

        if client_order_id:
            max_coid_len = 36 # Max length for Bybit linear/inverse COID
            original_coid_len = len(client_order_id)
            valid_coid = client_order_id[:max_coid_len]
            params['clientOrderId'] = valid_coid
            if len(valid_coid) < original_coid_len:
                logger.warning(f"[{func_name}] Client Order ID truncated to {max_coid_len} chars: '{valid_coid}' (Original length: {original_coid_len})")

        bg = Back.GREEN if side == config.SIDE_BUY else Back.RED
        fg = Fore.BLACK
        logger.warning(f"{bg}{fg}{Style.BRIGHT}*** PLACING MARKET {side.upper()} {'REDUCE' if is_reduce_only else 'ENTRY'}: "
                       f"{amount_str} {symbol} (Params: {params}) ***{Style.RESET_ALL}")

        order = exchange.create_market_order(symbol, side, amount_float, params=params)

        # 3. Log Result
        order_id = order.get('id')
        client_oid_resp = order.get('clientOrderId', params.get('clientOrderId', 'N/A'))
        status = order.get('status', '?')
        filled_qty = safe_decimal_conversion(order.get('filled', '0.0'))
        avg_price = safe_decimal_conversion(order.get('average'))

        logger.success(f"{Fore.GREEN}{log_prefix}: Market order submitted successfully. "
                       f"ID: ...{format_order_id(order_id)}, ClientOID: {client_oid_resp}, Status: {status}, "
                       f"Target Qty: {amount_str}, Filled Qty: {format_amount(exchange, symbol, filled_qty)}, "
                       f"Avg Price: {format_price(exchange, symbol, avg_price)}{Style.RESET_ALL}")
        return order

    except (ccxt.InsufficientFunds, ccxt.InvalidOrder, ccxt.ExchangeError, ccxt.NetworkError) as e:
        logger.error(f"{Fore.RED}{log_prefix}: API Error placing market order: {type(e).__name__} - {e}{Style.RESET_ALL}")
        send_sms_alert(f"[{market_base}] ORDER FAIL ({side.upper()} {action}): {type(e).__name__}", config)
        return None
    except Exception as e:
        logger.critical(f"{Back.RED}[{func_name}] Unexpected critical error placing market order: {e}{Style.RESET_ALL}", exc_info=True)
        send_sms_alert(f"[{market_base}] ORDER FAIL ({side.upper()} {action}): Unexpected {type(e).__name__}.", config)
        return None

# Snippet 5 / Function 5: Cancel All Open Orders
@retry_api_call(max_retries=2, initial_delay=1.0) # Decorator for fetch/network issues
def cancel_all_orders(exchange: ccxt.bybit, symbol: str, config: 'Config', reason: str = "Cleanup") -> bool:
    """
    Cancels all open orders for a specific symbol on Bybit V5.

    Fetches open orders first (defaults to regular 'Order' filter) and attempts
    to cancel each one individually. Handles `OrderNotFound` gracefully.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Market symbol for which to cancel orders.
        config: Configuration object.
        reason: A short string indicating the reason for cancellation (for logging).

    Returns:
        True if all found open orders were successfully cancelled or confirmed gone,
        False if any cancellation failed (excluding OrderNotFound).

    Raises:
        Reraises CCXT exceptions from fetch_open_orders for the retry decorator.
        Does not re-raise OrderNotFound during cancellation.
    """
    func_name = "cancel_all_orders"
    market_base = symbol.split('/')[0]
    log_prefix = f"Cancel All ({reason})"
    logger.info(f"{Fore.CYAN}[{func_name}] {log_prefix}: Attempting for {symbol}...{Style.RESET_ALL}")

    try:
        market = exchange.market(symbol)
        category = _get_v5_category(market)
        if not category:
            logger.error(f"{Fore.RED}[{func_name}] Cannot determine market category for {symbol}. Aborting cancel all.{Style.RESET_ALL}")
            return False

        # Fetch open regular orders. Consider adding logic to cancel Stop/TP/SL orders too if needed.
        fetch_params = {'category': category, 'orderFilter': 'Order'}
        logger.debug(f"[{func_name}] Fetching open regular orders for {symbol} with params: {fetch_params}")
        open_orders = exchange.fetch_open_orders(symbol, params=fetch_params)

        if not open_orders:
            logger.info(f"{Fore.CYAN}[{func_name}] {log_prefix}: No open regular orders found for {symbol}.{Style.RESET_ALL}")
            return True

        logger.warning(f"{Fore.YELLOW}[{func_name}] {log_prefix}: Found {len(open_orders)} open order(s) for {symbol}. Attempting cancellation...{Style.RESET_ALL}")

        success_count = 0
        fail_count = 0
        cancel_delay = max(0.05, 1.0 / (exchange.rateLimit if exchange.rateLimit and exchange.rateLimit > 0 else 20))

        cancel_params = {'category': category} # Category needed for V5 cancel

        for order in open_orders:
            order_id = order.get('id')
            order_info_log = (f"ID: ...{format_order_id(order_id)} "
                              f"({order.get('type', '?').upper()} {order.get('side', '?').upper()} "
                              f"Amt: {format_amount(exchange, symbol, order.get('amount'))})")

            if not order_id:
                logger.warning(f"[{func_name}] Skipping order with missing ID in fetched data: {order}")
                continue

            try:
                logger.debug(f"[{func_name}] Cancelling order {order_info_log} with params: {cancel_params}")
                exchange.cancel_order(order_id, symbol, params=cancel_params)
                logger.info(f"{Fore.CYAN}[{func_name}] {log_prefix}: Successfully cancelled order {order_info_log}{Style.RESET_ALL}")
                success_count += 1
            except ccxt.OrderNotFound:
                logger.warning(f"{Fore.YELLOW}[{func_name}] {log_prefix}: Order {order_info_log} already cancelled or filled (Not Found). Considered OK.{Style.RESET_ALL}")
                success_count += 1
            except (ccxt.NetworkError, ccxt.RateLimitExceeded) as e_cancel:
                logger.warning(f"{Fore.YELLOW}[{func_name}] {log_prefix}: Network/RateLimit error cancelling {order_info_log}: {e_cancel}. Loop continues, outer retry might occur.{Style.RESET_ALL}")
                fail_count += 1 # Count as failure for this attempt
            except ccxt.ExchangeError as e_cancel:
                 logger.error(f"{Fore.RED}[{func_name}] {log_prefix}: FAILED to cancel order {order_info_log}: {e_cancel}{Style.RESET_ALL}")
                 fail_count += 1
            except Exception as e_cancel:
                logger.error(f"{Fore.RED}[{func_name}] {log_prefix}: Unexpected error cancelling order {order_info_log}: {e_cancel}{Style.RESET_ALL}", exc_info=True)
                fail_count += 1

            time.sleep(cancel_delay)

        total_attempted = len(open_orders)
        if fail_count > 0:
            try: # Re-check if orders still exist after potential transient errors
                 remaining_orders = exchange.fetch_open_orders(symbol, params=fetch_params)
                 if not remaining_orders:
                      logger.warning(f"{Fore.YELLOW}[{func_name}] {log_prefix}: Initial cancellation reported {fail_count} failures, but re-check shows no open orders remain. Likely transient errors.{Style.RESET_ALL}")
                      return True
                 else:
                      logger.error(f"{Fore.RED}[{func_name}] {log_prefix}: Finished cancellation attempt for {symbol}. "
                                   f"Failed: {fail_count}, Success/Gone: {success_count}. {len(remaining_orders)} order(s) might still remain.{Style.RESET_ALL}")
                      send_sms_alert(f"[{market_base}] ERROR: Failed to cancel {fail_count} orders ({reason}). Check logs.", config)
                      return False
            except Exception as e_recheck:
                 logger.error(f"[{func_name}] Error re-checking orders after failures: {e_recheck}. Assuming failures persist.")
                 send_sms_alert(f"[{market_base}] ERROR: Failed to cancel {fail_count} orders ({reason}). Check logs.", config)
                 return False
        else:
            logger.success(f"{Fore.GREEN}[{func_name}] {log_prefix}: Successfully cancelled or confirmed gone "
                           f"all {total_attempted} open orders found for {symbol}.{Style.RESET_ALL}")
            return True

    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.BadSymbol) as e:
        logger.error(f"{Fore.RED}[{func_name}] {log_prefix}: API error during 'cancel all' process for {symbol}: {e}{Style.RESET_ALL}")
        raise
    except Exception as e:
        logger.error(f"{Fore.RED}[{func_name}] {log_prefix}: Unexpected error during 'cancel all' for {symbol}: {e}{Style.RESET_ALL}", exc_info=True)
        return False

# Snippet 6 / Function 6: Fetch OHLCV with Pagination
def fetch_ohlcv_paginated(
    exchange: ccxt.bybit,
    symbol: str,
    timeframe: str,
    config: 'Config',
    since: Optional[int] = None,
    limit_per_req: int = 1000, # Bybit V5 max limit is 1000
    max_total_candles: Optional[int] = None,
) -> Optional[pd.DataFrame]:
    """
    Fetches historical OHLCV data for a symbol using pagination to handle limits.

    Converts the fetched data into a pandas DataFrame with proper indexing and
    data types, performing basic validation and cleaning (NaN handling).
    Uses internal retries for individual chunk fetches.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Market symbol (e.g., 'BTC/USDT:USDT').
        timeframe: CCXT timeframe string (e.g., '1m', '5m', '1h', '1d').
        config: Configuration object.
        since: Optional starting timestamp (milliseconds UTC) to fetch data from.
               If None, fetches the most recent data.
        limit_per_req: Number of candles to fetch per API request (max 1000 for Bybit V5).
        max_total_candles: Optional maximum number of candles to retrieve in total.

    Returns:
        A pandas DataFrame containing the OHLCV data, indexed by UTC timestamp,
        or None if fetching or processing fails completely. Returns an empty DataFrame
        if no data is available for the period.
    """
    func_name = "fetch_ohlcv_paginated"
    if not exchange.has.get("fetchOHLCV"):
        logger.error(f"{Fore.RED}[{func_name}] The exchange '{exchange.id}' does not support fetchOHLCV.{Style.RESET_ALL}")
        return None

    try:
        timeframe_ms = exchange.parse_timeframe(timeframe) * 1000
        if limit_per_req > 1000:
            logger.warning(f"[{func_name}] Requested limit_per_req ({limit_per_req}) exceeds Bybit V5 max (1000). Clamping to 1000.")
            limit_per_req = 1000

        market = exchange.market(symbol)
        category = _get_v5_category(market)
        if not category:
            logger.warning(f"[{func_name}] Could not determine category for {symbol}. Assuming 'linear'. This might fail for Spot/Inverse.")
            category = 'linear' # Default assumption

        params = {'category': category}

        logger.info(f"{Fore.BLUE}[{func_name}] Fetching {symbol} OHLCV ({timeframe}). "
                    f"Limit/Req: {limit_per_req}, Since: {pd.to_datetime(since, unit='ms', utc=True).strftime('%Y-%m-%d %H:%M:%S') if since else 'Recent'}. "
                    f"Max Total: {max_total_candles or 'Unlimited'}{Style.RESET_ALL}")

        all_candles: List[list] = []
        current_since = since
        request_count = 0
        max_requests = float('inf')
        if max_total_candles:
            max_requests = (max_total_candles + limit_per_req - 1) // limit_per_req

        while request_count < max_requests:
            if max_total_candles and len(all_candles) >= max_total_candles:
                logger.info(f"[{func_name}] Reached max_total_candles limit ({max_total_candles}). Fetch complete.")
                break

            request_count += 1
            fetch_limit = limit_per_req
            if max_total_candles:
                remaining_needed = max_total_candles - len(all_candles)
                fetch_limit = min(limit_per_req, remaining_needed)

            logger.debug(f"[{func_name}] Fetch Chunk #{request_count}: Since={current_since}, Limit={fetch_limit}, Params={params}")

            candles_chunk: Optional[List[list]] = None
            last_fetch_error: Optional[Exception] = None

            # Internal retry loop for fetching this specific chunk
            for attempt in range(config.RETRY_COUNT):
                try:
                    candles_chunk = exchange.fetch_ohlcv(symbol, timeframe, since=current_since, limit=fetch_limit, params=params)
                    last_fetch_error = None; break
                except (ccxt.NetworkError, ccxt.RequestTimeout, ccxt.ExchangeNotAvailable, ccxt.RateLimitExceeded) as e:
                    last_fetch_error = e
                    retry_delay = config.RETRY_DELAY_SECONDS * (attempt + 1) * (random.uniform(0.8, 1.2) if 'random' in globals() else 1.0)
                    logger.warning(f"{Fore.YELLOW}[{func_name}] API Error chunk #{request_count} (Try {attempt + 1}/{config.RETRY_COUNT}): {e}. Retrying in {retry_delay:.2f}s...{Style.RESET_ALL}")
                    time.sleep(retry_delay)
                except ccxt.ExchangeError as e: last_fetch_error = e; logger.error(f"{Fore.RED}[{func_name}] ExchangeError chunk #{request_count}: {e}. Aborting chunk.{Style.RESET_ALL}"); break
                except Exception as e: last_fetch_error = e; logger.error(f"[{func_name}] Unexpected fetch chunk #{request_count} err: {e}", exc_info=True); break

            if last_fetch_error:
                logger.error(f"{Fore.RED}[{func_name}] Failed to fetch chunk #{request_count} after {config.RETRY_COUNT} attempts. Last Error: {last_fetch_error}{Style.RESET_ALL}")
                logger.warning(f"[{func_name}] Returning potentially incomplete data ({len(all_candles)} candles) due to fetch failure.")
                break

            if not candles_chunk: logger.debug(f"[{func_name}] No more candles returned (Chunk #{request_count})."); break

            if all_candles and candles_chunk[0][0] <= all_candles[-1][0]:
                logger.warning(f"{Fore.YELLOW}[{func_name}] Overlap detected chunk #{request_count}. Filtering.{Style.RESET_ALL}")
                candles_chunk = [c for c in candles_chunk if c[0] > all_candles[-1][0]]
                if not candles_chunk: logger.debug(f"[{func_name}] Entire chunk was overlap."); break

            logger.debug(f"[{func_name}] Fetched {len(candles_chunk)} new candles (Chunk #{request_count}). Total: {len(all_candles) + len(candles_chunk)}")
            all_candles.extend(candles_chunk)

            if len(candles_chunk) < fetch_limit: logger.debug(f"[{func_name}] Received fewer candles than requested. End of data."); break

            current_since = candles_chunk[-1][0] + timeframe_ms
            time.sleep(exchange.rateLimit / 1000.0 if exchange.rateLimit and exchange.rateLimit > 0 else 0.1)

        return _process_ohlcv_list(all_candles, func_name, symbol, timeframe, max_total_candles)

    except (ccxt.BadSymbol, ccxt.ExchangeError) as e:
         logger.error(f"{Fore.RED}[{func_name}] Initial setup error for OHLCV fetch ({symbol}, {timeframe}): {e}{Style.RESET_ALL}")
         return None
    except Exception as e:
        logger.critical(f"{Back.RED}[{func_name}] Unexpected critical error during OHLCV pagination setup: {e}{Style.RESET_ALL}", exc_info=True)
        return None

def _process_ohlcv_list(
    candle_list: List[list], parent_func_name: str, symbol: str, timeframe: str, max_candles: Optional[int] = None
) -> Optional[pd.DataFrame]:
    """Internal helper to convert OHLCV list to validated pandas DataFrame."""
    func_name = f"{parent_func_name}._process_ohlcv_list"
    if not candle_list:
        logger.warning(f"{Fore.YELLOW}[{func_name}] No candles collected for {symbol} ({timeframe}). Returning empty DataFrame.{Style.RESET_ALL}")
        cols = ['open', 'high', 'low', 'close', 'volume']; empty_df = pd.DataFrame(columns=cols).astype({c: float for c in cols})
        empty_df.index = pd.to_datetime([]).tz_localize('UTC'); empty_df.index.name = 'timestamp'
        return empty_df
    logger.debug(f"[{func_name}] Processing {len(candle_list)} raw candles for {symbol} ({timeframe})...")
    try:
        df = pd.DataFrame(candle_list, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms', utc=True, errors='coerce'); df.dropna(subset=['timestamp'], inplace=True)
        if df.empty: raise ValueError("All timestamp conversions failed.")
        df.set_index('timestamp', inplace=True)
        for col in ['open', 'high', 'low', 'close', 'volume']: df[col] = pd.to_numeric(df[col], errors='coerce')
        initial_len = len(df); df = df[~df.index.duplicated(keep='first')]
        if len(df) < initial_len: logger.debug(f"[{func_name}] Removed {initial_len - len(df)} duplicate timestamp entries.")
        nan_counts = df.isnull().sum(); total_nans = nan_counts.sum()
        if total_nans > 0:
            logger.warning(f"{Fore.YELLOW}[{func_name}] Found {total_nans} NaNs. Ffilling... (Counts: {nan_counts.to_dict()}){Style.RESET_ALL}")
            df.ffill(inplace=True); df.dropna(inplace=True)
            if df.isnull().sum().sum() > 0: logger.error(f"{Fore.RED}[{func_name}] NaNs persisted after fill!{Style.RESET_ALL}")
        df.sort_index(inplace=True)
        if max_candles and len(df) > max_candles: logger.debug(f"[{func_name}] Trimming DF to last {max_candles}."); df = df.iloc[-max_candles:]
        if df.empty: logger.error(f"{Fore.RED}[{func_name}] Processed DF is empty after cleaning.{Style.RESET_ALL}"); return df
        logger.success(f"{Fore.GREEN}[{func_name}] Processed {len(df)} valid candles for {symbol} ({timeframe}).{Style.RESET_ALL}")
        return df
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Error processing OHLCV list: {e}{Style.RESET_ALL}", exc_info=True); return None

# Snippet 7 / Function 7: Place Limit Order with TIF/Flags
@retry_api_call(max_retries=1, initial_delay=0) # Typically don't auto-retry limit order placement automatically
def place_limit_order_tif(
    exchange: ccxt.bybit, symbol: str, side: Literal['buy', 'sell'], amount: Decimal, price: Decimal, config: 'Config',
    time_in_force: str = 'GTC', is_reduce_only: bool = False, is_post_only: bool = False, client_order_id: Optional[str] = None
) -> Optional[Dict]:
    """
    Places a limit order on Bybit V5 with options for Time-In-Force, Post-Only, and Reduce-Only.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Market symbol (e.g., 'BTC/USDT:USDT').
        side: 'buy' or 'sell'.
        amount: Order quantity in base currency (Decimal). Must be positive.
        price: Limit price for the order (Decimal). Must be positive.
        config: Configuration object.
        time_in_force: Time-In-Force policy ('GTC', 'IOC', 'FOK'). CCXT standard.
        is_reduce_only: If True, set the reduceOnly flag.
        is_post_only: If True, ensures the order is only accepted if it does not immediately match.
        client_order_id: Optional client order ID string (max length 36 for Bybit V5 linear).

    Returns:
        The order dictionary returned by ccxt, or None if the order placement failed.
    """
    func_name = "place_limit_order_tif"; log_prefix = f"Limit Order ({side.upper()})"
    logger.info(f"{Fore.BLUE}{log_prefix}: Init {format_amount(exchange, symbol, amount)} @ {format_price(exchange, symbol, price)} (TIF:{time_in_force}, Reduce:{is_reduce_only}, Post:{is_post_only})...{Style.RESET_ALL}")
    if amount <= config.POSITION_QTY_EPSILON or price <= Decimal("0"): logger.error(f"{Fore.RED}{log_prefix}: Invalid amount/price.{Style.RESET_ALL}"); return None
    try:
        market = exchange.market(symbol); category = _get_v5_category(market)
        if not category: logger.error(f"{Fore.RED}[{func_name}] Cannot determine category.{Style.RESET_ALL}"); return None
        amount_str = format_amount(exchange, symbol, amount); price_str = format_price(exchange, symbol, price); amount_float = float(amount_str); price_float = float(price_str)
        params: Dict[str, Any] = {'category': category}
        valid_tif = ['GTC', 'IOC', 'FOK']; tif_upper = time_in_force.upper()
        if tif_upper in valid_tif: params['timeInForce'] = tif_upper
        else: logger.warning(f"[{func_name}] Unsupported TIF '{time_in_force}'. Using GTC."); params['timeInForce'] = 'GTC'
        if is_post_only: params['postOnly'] = True
        if is_reduce_only: params['reduceOnly'] = True

        if client_order_id:
            max_coid_len = 36
            original_coid_len = len(client_order_id)
            valid_coid = client_order_id[:max_coid_len]
            params['clientOrderId'] = valid_coid
            if len(valid_coid) < original_coid_len:
                logger.warning(f"[{func_name}] Client Order ID truncated to {max_coid_len} chars: '{valid_coid}' (Original length: {original_coid_len})")

        logger.info(f"{Fore.CYAN}{log_prefix}: Placing -> Amt:{amount_float}, Px:{price_float}, Params:{params}{Style.RESET_ALL}")
        order = exchange.create_limit_order(symbol, side, amount_float, price_float, params=params)
        order_id = order.get('id'); client_oid_resp = order.get('clientOrderId', params.get('clientOrderId', 'N/A')); status = order.get('status', '?'); effective_tif = order.get('timeInForce', params.get('timeInForce', '?')); is_post_only_resp = order.get('postOnly', params.get('postOnly', False))
        logger.success(f"{Fore.GREEN}{log_prefix}: Limit order placed. ID:...{format_order_id(order_id)}, ClientOID:{client_oid_resp}, Status:{status}, TIF:{effective_tif}, Post:{is_post_only_resp}{Style.RESET_ALL}")
        return order
    except ccxt.OrderImmediatelyFillable as e:
         if params.get('postOnly'): logger.warning(f"{Fore.YELLOW}{log_prefix}: PostOnly failed (immediate match): {e}{Style.RESET_ALL}"); return None
         else: logger.error(f"{Fore.RED}{log_prefix}: Unexpected OrderImmediatelyFillable: {e}{Style.RESET_ALL}"); raise e
    except (ccxt.InsufficientFunds, ccxt.InvalidOrder, ccxt.ExchangeError, ccxt.NetworkError) as e: logger.error(f"{Fore.RED}{log_prefix}: API Error: {type(e).__name__} - {e}{Style.RESET_ALL}"); send_sms_alert(f"[{symbol.split('/')[0]}] ORDER FAIL (Limit {side.upper()}): {type(e).__name__}", config); return None
    except Exception as e: logger.critical(f"{Back.RED}[{func_name}] Unexpected error: {e}{Style.RESET_ALL}", exc_info=True); send_sms_alert(f"[{symbol.split('/')[0]}] ORDER FAIL (Limit {side.upper()}): Unexpected {type(e).__name__}.", config); return None

# Snippet 8 / Function 8: Fetch Current Position (Bybit V5 Specific)
@retry_api_call(max_retries=3, initial_delay=1.0)
def get_current_position_bybit_v5(exchange: ccxt.bybit, symbol: str, config: 'Config') -> Dict[str, Any]:
    """
    Fetches the current position details for a symbol using Bybit V5's fetchPositions logic.
    Focuses on One-Way position mode (positionIdx=0). Returns Decimals for numeric values.
    """
    func_name = "get_current_position_bybit_v5"; logger.debug(f"[{func_name}] Fetching position for {symbol} (V5)...")
    default_position: Dict[str, Any] = {'symbol': symbol, 'side': config.POS_NONE, 'qty': Decimal("0.0"), 'entry_price': Decimal("0.0"), 'liq_price': None, 'mark_price': None, 'pnl_unrealized': None, 'leverage': None, 'info': {}}
    try:
        market = exchange.market(symbol); market_id = market['id']
        category = _get_v5_category(market)
        if not category or category not in ['linear', 'inverse']: logger.error(f"{Fore.RED}[{func_name}] Not a contract symbol: {symbol}.{Style.RESET_ALL}"); return default_position
        if not exchange.has.get('fetchPositions'): logger.error(f"{Fore.RED}[{func_name}] fetchPositions not available.{Style.RESET_ALL}"); return default_position
        params = {'category': category, 'symbol': market_id}; logger.debug(f"[{func_name}] Calling fetch_positions with params: {params}")
        fetched_positions = exchange.fetch_positions(symbols=[symbol], params=params)
        active_position_data: Optional[Dict] = None
        for pos in fetched_positions:
            pos_info = pos.get('info', {}); pos_symbol = pos_info.get('symbol'); pos_v5_side = pos_info.get('side', 'None'); pos_size_str = pos_info.get('size'); pos_idx = int(pos_info.get('positionIdx', -1))
            if pos_symbol == market_id and pos_v5_side != 'None' and pos_idx == 0:
                pos_size = safe_decimal_conversion(pos_size_str, Decimal("0.0"));
                if abs(pos_size) > config.POSITION_QTY_EPSILON: active_position_data = pos; logger.debug(f"[{func_name}] Found active One-Way (idx 0) position."); break
        if active_position_data:
            try:
                info = active_position_data.get('info', {}); size = safe_decimal_conversion(info.get('size')); entry_price = safe_decimal_conversion(info.get('avgPrice')); liq_price = safe_decimal_conversion(info.get('liqPrice')); mark_price = safe_decimal_conversion(info.get('markPrice')); pnl = safe_decimal_conversion(info.get('unrealisedPnl')); leverage = safe_decimal_conversion(info.get('leverage'))
                pos_side_str = info.get('side'); position_side = config.POS_LONG if pos_side_str == 'Buy' else (config.POS_SHORT if pos_side_str == 'Sell' else config.POS_NONE); quantity = abs(size) if size is not None else Decimal("0.0")
                if position_side == config.POS_NONE or quantity <= config.POSITION_QTY_EPSILON: logger.info(f"[{func_name}] Pos {symbol} negligible size/side."); return default_position
                log_color = Fore.GREEN if position_side == config.POS_LONG else Fore.RED
                logger.info(f"{log_color}[{func_name}] ACTIVE {position_side} {symbol}: Qty={format_amount(exchange, symbol, quantity)}, Entry={format_price(exchange, symbol, entry_price)}, Mark={format_price(exchange, symbol, mark_price)}, Liq~{format_price(exchange, symbol, liq_price)}, uPNL={format_price(exchange, config.USDT_SYMBOL, pnl)}, Lev={leverage}x{Style.RESET_ALL}")
                return {'symbol': symbol, 'side': position_side, 'qty': quantity, 'entry_price': entry_price, 'liq_price': liq_price, 'mark_price': mark_price, 'pnl_unrealized': pnl, 'leverage': leverage, 'info': info }
            except Exception as parse_err: logger.warning(f"{Fore.YELLOW}[{func_name}] Error parsing active pos: {parse_err}. Data: {str(active_position_data)[:300]}{Style.RESET_ALL}"); return default_position
        else: logger.info(f"[{func_name}] No active One-Way position found for {symbol}."); return default_position
    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.BadSymbol) as e: logger.warning(f"{Fore.YELLOW}[{func_name}] API Error fetching pos: {e}{Style.RESET_ALL}"); raise
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error fetching pos: {e}{Style.RESET_ALL}", exc_info=True); return default_position

# Snippet 9 / Function 9: Close Position (Reduce-Only Market)
@retry_api_call(max_retries=2, initial_delay=1) # Allow retry for closure attempt
def close_position_reduce_only(
    exchange: ccxt.bybit, symbol: str, config: 'Config', position_to_close: Optional[Dict[str, Any]] = None, reason: str = "Signal Close"
) -> Optional[Dict[str, Any]]:
    """
    Closes the current position for the given symbol using a reduce-only market order.
    Handles specific "already closed" exchange errors gracefully.
    """
    func_name = "close_position_reduce_only"; market_base = symbol.split('/')[0]; log_prefix = f"Close Position ({reason})"
    logger.info(f"{Fore.YELLOW}{log_prefix}: Init for {symbol}...{Style.RESET_ALL}")
    live_position_data: Dict[str, Any]
    if position_to_close: logger.debug(f"[{func_name}] Using provided pos state."); live_position_data = position_to_close
    else: logger.debug(f"[{func_name}] Fetching current pos state..."); live_position_data = get_current_position_bybit_v5(exchange, symbol, config)
    live_side = live_position_data['side']; live_qty = live_position_data['qty']
    if live_side == config.POS_NONE or live_qty <= config.POSITION_QTY_EPSILON: logger.warning(f"{Fore.YELLOW}[{func_name}] No active position validated. Aborting close.{Style.RESET_ALL}"); return None
    close_order_side: Literal['buy', 'sell'] = config.SIDE_SELL if live_side == config.POS_LONG else config.SIDE_BUY
    try:
        market = exchange.market(symbol); category = _get_v5_category(market)
        if not category: raise ValueError("Cannot determine category for close order.")
        qty_str = format_amount(exchange, symbol, live_qty); qty_float = float(qty_str); params: Dict[str, Any] = {'category': category, 'reduceOnly': True}
        bg = Back.YELLOW; fg = Fore.BLACK
        logger.warning(f"{bg}{fg}{Style.BRIGHT}[{func_name}] Attempting CLOSE {live_side} ({reason}): Exec {close_order_side.upper()} MARKET {qty_str} {symbol} (ReduceOnly)...{Style.RESET_ALL}")
        close_order = exchange.create_market_order(symbol=symbol, side=close_order_side, amount=qty_float, params=params)
        if not close_order: raise ValueError("create_market_order returned None unexpectedly.")
        fill_price = safe_decimal_conversion(close_order.get('average')); fill_qty = safe_decimal_conversion(close_order.get('filled', '0.0')); order_cost = safe_decimal_conversion(close_order.get('cost', '0.0')); order_id = format_order_id(close_order.get('id')); status = close_order.get('status', '?')
        logger.success(f"{Fore.GREEN}{Style.BRIGHT}[{func_name}] Close Order ({reason}) submitted {symbol}. ID:...{order_id}, Status:{status}, Filled:{format_amount(exchange, symbol, fill_qty)}/{qty_str}, AvgFill:{format_price(exchange, symbol, fill_price)}, Cost:{order_cost:.4f}{Style.RESET_ALL}")
        send_sms_alert(f"[{market_base}] Closed {live_side} {qty_str} @ ~{format_price(exchange, symbol, fill_price)} ({reason}). ID:...{order_id}", config)
        return close_order
    except (ccxt.InsufficientFunds, ccxt.InvalidOrder) as e: logger.error(f"{Fore.RED}[{func_name}] Close Order Error ({reason}) for {symbol}: {type(e).__name__} - {e}{Style.RESET_ALL}"); send_sms_alert(f"[{market_base}] CLOSE FAIL ({live_side}): {type(e).__name__}", config); raise e
    except ccxt.ExchangeError as e:
        error_str = str(e).lower();
        # 110025: Position is closed | 110045: Order would not reduce position size
        # 30086: Order would not reduce position | Bybit may change codes
        if any(code in error_str for code in ["110025", "110045", "30086", "position is closed", "order would not reduce", "position size is zero", "qty is larger than position size"]):
            logger.warning(f"{Fore.YELLOW}[{func_name}] Close Order ({reason}): Exchange indicates already closed/zero or reduce fail: {e}. Assuming closed.{Style.RESET_ALL}"); return None
        else: logger.error(f"{Fore.RED}[{func_name}] Close Order ExchangeError ({reason}): {e}{Style.RESET_ALL}"); send_sms_alert(f"[{market_base}] CLOSE FAIL ({live_side}): ExchangeError", config); raise e
    except (ccxt.NetworkError, ValueError) as e: logger.error(f"{Fore.RED}[{func_name}] Close Order Network/Setup Error ({reason}): {e}{Style.RESET_ALL}"); raise e
    except Exception as e: logger.critical(f"{Back.RED}[{func_name}] Close Order Unexpected Error ({reason}): {e}{Style.RESET_ALL}", exc_info=True); send_sms_alert(f"[{market_base}] CLOSE FAIL ({live_side}): Unexpected Error", config); return None

# Snippet 11 / Function 11: Fetch Funding Rate
@retry_api_call(max_retries=3, initial_delay=1.0)
def fetch_funding_rate(exchange: ccxt.bybit, symbol: str, config: 'Config') -> Optional[Dict[str, Any]]:
    """
    Fetches the current funding rate details for a perpetual swap symbol on Bybit V5.
    Returns Decimals for rates/prices.
    """
    func_name = "fetch_funding_rate"; logger.debug(f"[{func_name}] Fetching funding rate for {symbol}...")
    try:
        market = exchange.market(symbol)
        if not market.get('swap', False): logger.error(f"{Fore.RED}[{func_name}] Not a swap market: {symbol}.{Style.RESET_ALL}"); return None
        category = _get_v5_category(market)
        if not category or category not in ['linear', 'inverse']: logger.error(f"{Fore.RED}[{func_name}] Invalid category '{category}' for funding rate ({symbol}).{Style.RESET_ALL}"); return None
        params = {'category': category}; logger.debug(f"[{func_name}] Calling fetch_funding_rate with params: {params}")
        funding_rate_info = exchange.fetch_funding_rate(symbol, params=params)
        processed_fr: Dict[str, Any] = { 'symbol': funding_rate_info.get('symbol'), 'fundingRate': safe_decimal_conversion(funding_rate_info.get('fundingRate')), 'fundingTimestamp': funding_rate_info.get('fundingTimestamp'), 'fundingDatetime': funding_rate_info.get('fundingDatetime'), 'markPrice': safe_decimal_conversion(funding_rate_info.get('markPrice')), 'indexPrice': safe_decimal_conversion(funding_rate_info.get('indexPrice')), 'nextFundingTime': funding_rate_info.get('nextFundingTimestamp'), 'nextFundingDatetime': None, 'info': funding_rate_info.get('info', {}) }
        if processed_fr['fundingRate'] is None: logger.warning(f"[{func_name}] Could not parse 'fundingRate' for {symbol}.")

        # Corrected multi-line try/except block
        if processed_fr['nextFundingTime']:
            try:
                processed_fr['nextFundingDatetime'] = pd.to_datetime(
                    processed_fr['nextFundingTime'], unit='ms', utc=True
                ).strftime('%Y-%m-%d %H:%M:%S %Z')
            except Exception as dt_err:
                logger.warning(f"[{func_name}] Could not format next funding datetime: {dt_err}")

        rate = processed_fr.get('fundingRate'); next_dt_str = processed_fr.get('nextFundingDatetime', "N/A"); rate_str = f"{rate:.6%}" if rate is not None else "N/A"
        logger.info(f"[{func_name}] Funding Rate {symbol}: {rate_str}. Next: {next_dt_str}")
        return processed_fr
    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.BadSymbol) as e: logger.warning(f"{Fore.YELLOW}[{func_name}] API Error fetching funding rate: {e}{Style.RESET_ALL}"); raise
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error fetching funding rate: {e}{Style.RESET_ALL}", exc_info=True); return None

# Snippet 12 / Function 12: Set Position Mode (One-Way / Hedge)
@retry_api_call(max_retries=2, initial_delay=1.0)
def set_position_mode_bybit_v5(exchange: ccxt.bybit, symbol_or_category: str, mode: Literal['one-way', 'hedge'], config: 'Config') -> bool:
    """
    Sets the position mode (One-Way or Hedge) for a specific category (Linear/Inverse) on Bybit V5.
    Uses the `private_post_v5_position_switch_mode` endpoint. Handles specific V5 errors.
    Note: Requires no positions/orders in the category.
    """
    func_name = "set_position_mode_bybit_v5"; logger.info(f"{Fore.CYAN}[{func_name}] Setting mode '{mode}' for category of '{symbol_or_category}'...{Style.RESET_ALL}")
    mode_map = {'one-way': '0', 'hedge': '3'}; target_mode_code = mode_map.get(mode.lower())
    if target_mode_code is None: logger.error(f"{Fore.RED}[{func_name}] Invalid mode '{mode}'.{Style.RESET_ALL}"); return False

    target_category: Optional[Literal['linear', 'inverse']] = None
    if symbol_or_category.lower() in ['linear', 'inverse']:
        target_category = symbol_or_category.lower() # type: ignore
    else:
        # Corrected multi-line try/except block
        try:
            market = exchange.market(symbol_or_category)
            target_category = _get_v5_category(market)
            # Ensure the category derived is valid for position mode setting
            if target_category not in ['linear', 'inverse']:
                target_category = None # Invalidate if not linear/inverse
        except Exception as e: # Catch broader exceptions like BadSymbol or other errors
            logger.warning(f"[{func_name}] Could not get market or category for '{symbol_or_category}': {e}")
            target_category = None # Ensure it's None if error occurred

    if not target_category: logger.error(f"{Fore.RED}[{func_name}] Could not determine contract category from '{symbol_or_category}'.{Style.RESET_ALL}"); return False
    logger.debug(f"[{func_name}] Target Category: {target_category}, Mode Code: {target_mode_code} ('{mode}')")
    try:
        # Prefer unified CCXT method if it works reliably for V5
        # try:
        #     logger.debug(f"[{func_name}] Attempting via unified exchange.set_position_mode...")
        #     response = exchange.set_position_mode(hedged=(mode == 'hedge'), symbol=symbol_or_category)
        #     logger.success(f"{Fore.GREEN}[{func_name}] Mode set/confirmed to '{mode}' for {target_category} via unified method.{Style.RESET_ALL}")
        #     return True
        # except ccxt.NotSupported:
        #     logger.debug(f"[{func_name}] Unified set_position_mode not supported/failed, trying private V5 endpoint...")
        # except Exception as e_unified:
        #      logger.warning(f"[{func_name}] Unified set_position_mode failed: {e_unified}. Trying private V5 endpoint...")

        if not hasattr(exchange, 'private_post_v5_position_switch_mode'): logger.error(f"{Fore.RED}[{func_name}] CCXT lacks 'private_post_v5_position_switch_mode'. Cannot set mode via private endpoint.{Style.RESET_ALL}"); return False
        params = {'category': target_category, 'mode': target_mode_code}; logger.debug(f"[{func_name}] Calling private V5 endpoint with params: {params}")
        response = exchange.private_post_v5_position_switch_mode(params); logger.debug(f"[{func_name}] Raw V5 endpoint response: {response}")
        ret_code = response.get('retCode'); ret_msg = response.get('retMsg', '').lower()
        if ret_code == 0: logger.success(f"{Fore.GREEN}[{func_name}] Mode set '{mode}' for {target_category} via V5 endpoint.{Style.RESET_ALL}"); return True
        # 110021: Position mode not modified | 34036 might also indicate already set
        elif ret_code in [110021, 34036] or "not modified" in ret_msg: logger.info(f"{Fore.CYAN}[{func_name}] Mode already '{mode}' for {target_category}.{Style.RESET_ALL}"); return True
        # 110020: Position/order exists, cannot switch mode
        elif ret_code == 110020 or "have position" in ret_msg or "active order" in ret_msg: logger.error(f"{Fore.RED}[{func_name}] Cannot switch mode: Active pos/orders exist. Msg: {response.get('retMsg')}{Style.RESET_ALL}"); return False
        else: raise ccxt.ExchangeError(f"Bybit API error setting mode: Code={ret_code}, Msg='{response.get('retMsg', 'N/A')}'")
    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.AuthenticationError, ccxt.BadSymbol) as e:
        # Avoid logging error again if it's the handled "position exists" case
        if not (isinstance(e, ccxt.ExchangeError) and "110020" in str(e)):
             logger.warning(f"{Fore.YELLOW}[{func_name}] API Error setting mode: {e}{Style.RESET_ALL}")
        if isinstance(e, (ccxt.NetworkError, ccxt.AuthenticationError)): raise e # Re-raise for retry decorator
        return False # Return False for handled errors like position exists or bad symbol
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error setting mode: {e}{Style.RESET_ALL}", exc_info=True); return False

# Snippet 13 / Function 13: Fetch L2 Order Book (Validated)
@retry_api_call(max_retries=2, initial_delay=0.5)
def fetch_l2_order_book_validated(
    exchange: ccxt.bybit, symbol: str, limit: int, config: 'Config'
) -> Optional[Dict[str, List[Tuple[Decimal, Decimal]]]]:
    """
    Fetches the Level 2 order book for a symbol using Bybit V5 fetchOrderBook and validates the data.
    Returns bids and asks as lists of [price, amount] tuples using Decimals.
    """
    func_name = "fetch_l2_order_book_validated"; logger.debug(f"[{func_name}] Fetching L2 OB {symbol} (Limit:{limit})...")
    if not exchange.has.get('fetchOrderBook'): logger.error(f"{Fore.RED}[{func_name}] fetchOrderBook not supported.{Style.RESET_ALL}"); return None
    try:
        market = exchange.market(symbol); category = _get_v5_category(market)
        params = {'category': category} if category else {}
        max_limit_map = {'spot': 50, 'linear': 200, 'inverse': 200, 'option': 25}
        max_limit = max_limit_map.get(category, 50) if category else 50 # Default max if category unknown
        if limit > max_limit: logger.warning(f"[{func_name}] Clamping limit {limit} to {max_limit} for category '{category}'."); limit = max_limit

        logger.debug(f"[{func_name}] Calling fetchOrderBook with limit={limit}, params={params}")
        order_book = exchange.fetch_order_book(symbol, limit=limit, params=params)
        if not isinstance(order_book, dict) or 'bids' not in order_book or 'asks' not in order_book: raise ValueError("Invalid OB structure")
        raw_bids=order_book['bids']; raw_asks=order_book['asks']
        if not isinstance(raw_bids, list) or not isinstance(raw_asks, list): raise ValueError("Bids/Asks not lists")
        validated_bids: List[Tuple[Decimal, Decimal]] = []; validated_asks: List[Tuple[Decimal, Decimal]] = []; conversion_errors = 0

        # Corrected multi-line loop for bids
        for p_str, a_str in raw_bids:
            p = safe_decimal_conversion(p_str)
            a = safe_decimal_conversion(a_str)
            if p is None or a is None or p <= 0 or a < 0:
                conversion_errors += 1
                continue
            validated_bids.append((p, a))

        # Corrected multi-line loop for asks
        for p_str, a_str in raw_asks:
            p = safe_decimal_conversion(p_str)
            a = safe_decimal_conversion(a_str)
            if p is None or a is None or p <= 0 or a < 0:
                conversion_errors += 1
                continue
            validated_asks.append((p, a))

        if conversion_errors > 0: logger.warning(f"[{func_name}] Skipped {conversion_errors} invalid OB entries for {symbol}.")
        if validated_bids and validated_asks and validated_bids[0][0] >= validated_asks[0][0]: logger.error(f"{Fore.RED}[{func_name}] OB crossed: Bid ({validated_bids[0][0]}) >= Ask ({validated_asks[0][0]}) for {symbol}.{Style.RESET_ALL}"); # Return potentially invalid data or None? return {'bids': validated_bids, 'asks': validated_asks}
        logger.debug(f"[{func_name}] Processed L2 OB {symbol}. Bids:{len(validated_bids)}, Asks:{len(validated_asks)}")
        return {'bids': validated_bids, 'asks': validated_asks}
    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.BadSymbol, ValueError) as e: logger.warning(f"{Fore.YELLOW}[{func_name}] API/Validation Error fetching L2 OB for {symbol}: {e}{Style.RESET_ALL}"); raise
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error fetching L2 OB for {symbol}: {e}{Style.RESET_ALL}", exc_info=True); return None

# Snippet 14 / Function 14: Place Native Stop Loss Order (Stop Market)
@retry_api_call(max_retries=1, initial_delay=0) # Don't auto-retry placing stops usually
def place_native_stop_loss(
    exchange: ccxt.bybit, symbol: str, side: Literal['buy', 'sell'], amount: Decimal, stop_price: Decimal, config: 'Config',
    trigger_by: Literal['LastPrice', 'MarkPrice', 'IndexPrice'] = 'MarkPrice', client_order_id: Optional[str] = None, position_idx: Literal[0, 1, 2] = 0
) -> Optional[Dict]:
    """
    Places a native Stop Market order on Bybit V5, intended as a Stop Loss (reduceOnly).
    Uses V5 specific parameters like 'slTriggerBy'.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Market symbol.
        side: Side of the STOP order ('buy' to close short, 'sell' to close long).
        amount: Amount to close (positive Decimal).
        stop_price: Trigger price for the stop (positive Decimal).
        config: Configuration object.
        trigger_by: Price type for trigger ('LastPrice', 'MarkPrice', 'IndexPrice').
        client_order_id: Optional client order ID.
        position_idx: Position index (0 for One-Way, 1/2 for Hedge).

    Returns:
        The order dictionary returned by ccxt, or None if placement failed.
    """
    func_name = "place_native_stop_loss"; log_prefix = f"Place Native SL ({side.upper()})"
    logger.info(f"{Fore.CYAN}{log_prefix}: Init {format_amount(exchange, symbol, amount)} {symbol}, Trigger @ {format_price(exchange, symbol, stop_price)} ({trigger_by}), PosIdx:{position_idx}...{Style.RESET_ALL}")
    if amount <= config.POSITION_QTY_EPSILON or stop_price <= Decimal("0"): logger.error(f"{Fore.RED}{log_prefix}: Invalid amount/stop price.{Style.RESET_ALL}"); return None
    try:
        market = exchange.market(symbol); category = _get_v5_category(market)
        if not category or category not in ['linear', 'inverse']: logger.error(f"{Fore.RED}[{func_name}] Not a contract symbol: {symbol}.{Style.RESET_ALL}"); return None
        amount_str = format_amount(exchange, symbol, amount); amount_float = float(amount_str); stop_price_str = format_price(exchange, symbol, stop_price); stop_price_float = float(stop_price_str)

        params: Dict[str, Any] = {
            'category': category,
            'stopLoss': stop_price_str, # V5 parameter for stop loss price
            'slTriggerBy': trigger_by,   # V5 parameter for trigger type
            'reduceOnly': True,
            'positionIdx': position_idx,
            'tpslMode': 'Full',          # Assumes full position TP/SL
            'slOrderType': 'Market'      # Execute as Market order when triggered
        }

        if client_order_id:
            max_coid_len = 36
            original_coid_len = len(client_order_id)
            valid_coid = client_order_id[:max_coid_len]
            params['clientOrderId'] = valid_coid
            if len(valid_coid) < original_coid_len:
                logger.warning(f"[{func_name}] Client Order ID truncated to {max_coid_len} chars: '{valid_coid}' (Original length: {original_coid_len})")

        bg = Back.YELLOW; fg = Fore.BLACK
        logger.warning(f"{bg}{fg}{Style.BRIGHT}{log_prefix}: Placing NATIVE Stop Loss (Market exec) -> Qty:{amount_float}, Side:{side}, TriggerPx:{stop_price_str}, TriggerBy:{trigger_by}, Reduce:True, PosIdx:{position_idx}, Params:{params}{Style.RESET_ALL}")

        # Use create_order with 'market' type and stop-loss params
        sl_order = exchange.create_order(symbol=symbol, type='market', side=side, amount=amount_float, params=params)

        order_id = sl_order.get('id'); client_oid_resp = sl_order.get('clientOrderId', params.get('clientOrderId', 'N/A')); status = sl_order.get('status', '?')
        # Check V5 response structure for stopLoss and slTriggerBy confirmation
        returned_stop_price = safe_decimal_conversion(sl_order.get('info', {}).get('stopLoss', sl_order.get('stopPrice')), None)
        returned_trigger = sl_order.get('info', {}).get('slTriggerBy', trigger_by)
        logger.success(f"{Fore.GREEN}{log_prefix}: Native SL order placed. ID:...{format_order_id(order_id)}, ClientOID:{client_oid_resp}, Status:{status}, Trigger:{format_price(exchange, symbol, returned_stop_price)} (by {returned_trigger}){Style.RESET_ALL}")
        return sl_order
    except (ccxt.InsufficientFunds, ccxt.InvalidOrder, ccxt.ExchangeError, ccxt.NetworkError, ccxt.BadSymbol) as e: logger.error(f"{Fore.RED}{log_prefix}: API Error placing SL: {type(e).__name__} - {e}{Style.RESET_ALL}"); return None
    except Exception as e: logger.critical(f"{Back.RED}[{func_name}] Unexpected error placing SL: {e}{Style.RESET_ALL}", exc_info=True); send_sms_alert(f"[{symbol.split('/')[0]}] SL PLACE FAIL ({side.upper()}): Unexpected {type(e).__name__}", config); return None

# Snippet 15 / Function 15: Fetch Open Orders (Filtered)
@retry_api_call(max_retries=2, initial_delay=1.0)
def fetch_open_orders_filtered(
    exchange: ccxt.bybit, symbol: str, config: 'Config', side: Optional[Literal['buy', 'sell']] = None,
    order_type: Optional[str] = None, order_filter: Optional[Literal['Order', 'StopOrder', 'tpslOrder']] = None
) -> Optional[List[Dict]]:
    """
    Fetches open orders for a specific symbol on Bybit V5, with optional filtering
    by side, CCXT order type, and/or Bybit V5 `orderFilter`. Defaults to fetching 'Order'.
    """
    func_name = "fetch_open_orders_filtered"; filter_log = f"(Side:{side or 'Any'}, Type:{order_type or 'Any'}, V5Filter:{order_filter or 'Default'})"
    logger.debug(f"[{func_name}] Fetching open orders {symbol} {filter_log}...")
    try:
        market = exchange.market(symbol); category = _get_v5_category(market)
        if not category: logger.error(f"{Fore.RED}[{func_name}] Cannot determine category for {symbol}.{Style.RESET_ALL}"); return None
        params: Dict[str, Any] = {'category': category}
        if order_filter: params['orderFilter'] = order_filter
        elif order_type: # Infer filter from type if filter not explicitly set
            norm_type_filter = order_type.lower().replace('_', '').replace('-', '')
            if 'stop' in norm_type_filter or 'trigger' in norm_type_filter or 'take' in norm_type_filter or 'tpsl' in norm_type_filter:
                params['orderFilter'] = 'StopOrder' # Or maybe tpslOrder? Check V5 docs. Defaulting to StopOrder.
            else: params['orderFilter'] = 'Order'
        else: params['orderFilter'] = 'Order' # Default if nothing specified

        logger.debug(f"[{func_name}] Calling fetch_open_orders with params: {params}")
        open_orders = exchange.fetch_open_orders(symbol=symbol, params=params)
        if not open_orders: logger.debug(f"[{func_name}] No open orders found matching {params}."); return []
        filtered_orders = open_orders; initial_count = len(filtered_orders)
        if side: side_lower = side.lower(); filtered_orders = [o for o in filtered_orders if o.get('side', '').lower() == side_lower]; logger.debug(f"[{func_name}] Filtered by side='{side}'. Count: {initial_count} -> {len(filtered_orders)}.")
        if order_type: # Apply type filter client-side as well for precision
            norm_type_filter = order_type.lower().replace('_', '').replace('-', ''); count_before = len(filtered_orders)
            def check_type(order): # More robust type check
                o_type = order.get('type', '').lower().replace('_', '').replace('-', '')
                info = order.get('info', {})
                # Check standard type first
                if o_type == norm_type_filter: return True
                # Check V5 specific types if available in info
                if info.get('orderType', '').lower() == norm_type_filter: return True
                # Check if it's a conditional order matching the filter type
                is_stop = info.get('stopLoss') or info.get('takeProfit') or info.get('stopOrderType') or info.get('triggerPrice')
                if 'market' in norm_type_filter and ('stop' in norm_type_filter or 'takeprofit' in norm_type_filter) and is_stop and o_type == 'market': return True
                return False
            filtered_orders = [o for o in filtered_orders if check_type(o)]; logger.debug(f"[{func_name}] Filtered by type='{order_type}'. Count: {count_before} -> {len(filtered_orders)}.")
        logger.info(f"[{func_name}] Fetched/filtered {len(filtered_orders)} open orders for {symbol} {filter_log}.")
        return filtered_orders
    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.BadSymbol) as e: logger.warning(f"{Fore.YELLOW}[{func_name}] API Error fetching open orders: {e}{Style.RESET_ALL}"); raise
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error fetching open orders: {e}{Style.RESET_ALL}", exc_info=True); return None

# Snippet 16 / Function 16: Calculate Margin Requirement
def calculate_margin_requirement(
    exchange: ccxt.bybit, symbol: str, amount: Decimal, price: Decimal, leverage: Decimal, config: 'Config',
    order_side: Literal['buy', 'sell'], is_maker: bool = False
) -> Tuple[Optional[Decimal], Optional[Decimal]]:
    """
    Calculates the estimated Initial Margin (IM) requirement for placing an order on Bybit V5.
    MM estimate is basic/placeholder.
    """
    func_name = "calculate_margin_requirement"; logger.debug(f"[{func_name}] Calc margin: {order_side} {format_amount(exchange, symbol, amount)} @ {format_price(exchange, symbol, price)}, Lev:{leverage}x, Maker:{is_maker}")
    if amount <= 0 or price <= 0 or leverage <= 0: logger.error(f"{Fore.RED}[{func_name}] Invalid inputs.{Style.RESET_ALL}"); return None, None
    try:
        market = exchange.market(symbol); quote_currency = market.get('quote', config.USDT_SYMBOL)
        if not market.get('contract'): logger.error(f"{Fore.RED}[{func_name}] Not a contract symbol: {symbol}.{Style.RESET_ALL}"); return None, None
        position_value = amount * price; logger.debug(f"[{func_name}] Est Order Value: {format_price(exchange, quote_currency, position_value)} {quote_currency}")
        if leverage == Decimal("0"): raise DivisionByZero("Leverage cannot be zero.")
        initial_margin_base = position_value / leverage; logger.debug(f"[{func_name}] Base IM: {format_price(exchange, quote_currency, initial_margin_base)} {quote_currency}")
        fee_rate = config.MAKER_FEE_RATE if is_maker else config.TAKER_FEE_RATE; estimated_fee = position_value * fee_rate; logger.debug(f"[{func_name}] Est Fee ({fee_rate:.4%}): {format_price(exchange, quote_currency, estimated_fee)} {quote_currency}")
        total_initial_margin_estimate = initial_margin_base + estimated_fee
        logger.info(f"[{func_name}] Est TOTAL Initial Margin Req (incl. fee): {format_price(exchange, quote_currency, total_initial_margin_estimate)} {quote_currency}")
        maintenance_margin_estimate: Optional[Decimal] = None
        try:
            # Look for MMR in market info (might be base rate only)
            mmr_keys = ['maintenanceMarginRate', 'mmr'] # Common keys in market['info'] or market itself
            mmr_rate_str = None
            # Corrected multi-line loop
            for key in mmr_keys:
                value_from_info = market.get('info', {}).get(key)
                value_from_root = market.get(key)
                mmr_rate_str = value_from_info or value_from_root
                if mmr_rate_str:
                    break

            if mmr_rate_str:
                mmr_rate = safe_decimal_conversion(mmr_rate_str)
                if mmr_rate and mmr_rate > 0:
                    maintenance_margin_estimate = position_value * mmr_rate
                    logger.debug(f"[{func_name}] Basic MM Estimate (Base MMR {mmr_rate:.4%}): {format_price(exchange, quote_currency, maintenance_margin_estimate)} {quote_currency}")
                else:
                    logger.debug(f"[{func_name}] Could not parse MMR rate '{mmr_rate_str}' from market info.")
            else:
                logger.debug(f"[{func_name}] MMR key not found in market info.")
        except Exception as mm_err:
            logger.warning(f"[{func_name}] Could not estimate MM: {mm_err}")

        return total_initial_margin_estimate, maintenance_margin_estimate
    except (DivisionByZero, KeyError, ValueError) as e: logger.error(f"{Fore.RED}[{func_name}] Calculation error: {e}{Style.RESET_ALL}"); return None, None
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error during margin calculation: {e}{Style.RESET_ALL}", exc_info=True); return None, None

# Snippet 17 / Function 17: Fetch Ticker (Validated)
@retry_api_call(max_retries=2, initial_delay=0.5)
def fetch_ticker_validated(
    exchange: ccxt.bybit, symbol: str, config: 'Config', max_age_seconds: int = 30
) -> Optional[Dict[str, Any]]:
    """
    Fetches the ticker for a symbol from Bybit V5, validates its freshness and key values.
    Returns a dictionary with Decimal values.
    """
    func_name = "fetch_ticker_validated"; logger.debug(f"[{func_name}] Fetching/Validating ticker {symbol}...")
    try:
        market = exchange.market(symbol); category = _get_v5_category(market)
        params = {'category': category} if category else {}
        logger.debug(f"[{func_name}] Calling fetch_ticker with params: {params}")
        ticker = exchange.fetch_ticker(symbol, params=params)
        timestamp_ms = ticker.get('timestamp'); age_seconds = (time.time() * 1000 - timestamp_ms) / 1000.0 if timestamp_ms else float('inf')
        if timestamp_ms is None or age_seconds > max_age_seconds or age_seconds < -10: raise ValueError(f"Ticker timestamp invalid/stale (Age: {age_seconds:.1f}s)")
        last_price = safe_decimal_conversion(ticker.get('last')); bid_price = safe_decimal_conversion(ticker.get('bid')); ask_price = safe_decimal_conversion(ticker.get('ask'))
        if last_price is None or last_price <= 0: raise ValueError(f"Invalid 'last' price: {ticker.get('last')}")
        if bid_price is None or bid_price <= 0: logger.warning(f"[{func_name}] Invalid/missing 'bid': {ticker.get('bid')}")
        if ask_price is None or ask_price <= 0: logger.warning(f"[{func_name}] Invalid/missing 'ask': {ticker.get('ask')}")
        spread, spread_pct = None, None
        if bid_price and ask_price:
             if bid_price >= ask_price: raise ValueError(f"Bid ({bid_price}) >= Ask ({ask_price})")
             spread = ask_price - bid_price; spread_pct = (spread / bid_price) * 100 if bid_price > 0 else Decimal("inf")
        base_volume = safe_decimal_conversion(ticker.get('baseVolume')); quote_volume = safe_decimal_conversion(ticker.get('quoteVolume'))
        if base_volume is not None and base_volume < 0: logger.warning(f"Negative baseVol: {base_volume}"); base_volume = Decimal("0.0")
        if quote_volume is not None and quote_volume < 0: logger.warning(f"Negative quoteVol: {quote_volume}"); quote_volume = Decimal("0.0")
        validated_ticker = { 'symbol': ticker.get('symbol', symbol), 'timestamp': timestamp_ms, 'datetime': ticker.get('datetime'), 'last': last_price, 'bid': bid_price, 'ask': ask_price, 'bidVolume': safe_decimal_conversion(ticker.get('bidVolume')), 'askVolume': safe_decimal_conversion(ticker.get('askVolume')), 'baseVolume': base_volume, 'quoteVolume': quote_volume, 'high': safe_decimal_conversion(ticker.get('high')), 'low': safe_decimal_conversion(ticker.get('low')), 'open': safe_decimal_conversion(ticker.get('open')), 'close': last_price, 'change': safe_decimal_conversion(ticker.get('change')), 'percentage': safe_decimal_conversion(ticker.get('percentage')), 'average': safe_decimal_conversion(ticker.get('average')), 'spread': spread, 'spread_pct': spread_pct, 'info': ticker.get('info', {}) }
        logger.debug(f"[{func_name}] Ticker OK: {symbol} Last={format_price(exchange, symbol, last_price)}, Spread={spread_pct:.4f}% (Age:{age_seconds:.1f}s)")
        return validated_ticker
    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.BadSymbol, ValueError) as e: logger.warning(f"{Fore.YELLOW}[{func_name}] Fetch/Validate ticker failed for {symbol}: {e}{Style.RESET_ALL}"); raise
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected ticker error for {symbol}: {e}{Style.RESET_ALL}", exc_info=True); return None

# Snippet 18 / Function 18: Place Native Trailing Stop Order
@retry_api_call(max_retries=1, initial_delay=0) # Don't auto-retry placing stops usually
def place_native_trailing_stop(
    exchange: ccxt.bybit, symbol: str, side: Literal['buy', 'sell'], amount: Decimal, trailing_offset: Union[Decimal, str], config: 'Config',
    activation_price: Optional[Decimal] = None, trigger_by: Literal['LastPrice', 'MarkPrice', 'IndexPrice'] = 'MarkPrice',
    client_order_id: Optional[str] = None, position_idx: Literal[0, 1, 2] = 0
) -> Optional[Dict]:
    """
    Places a native Trailing Stop Market order on Bybit V5 (reduceOnly).
    Uses V5 specific parameters like 'trailingStop' (for %) or potentially 'trailingMove' (for abs).
    """
    func_name = "place_native_trailing_stop"; log_prefix = f"Place Native TSL ({side.upper()})"
    params: Dict[str, Any] = {}; trail_log_str = ""; is_percent_trail = False;

    # Validate and parse trailing_offset
    if isinstance(trailing_offset, str) and trailing_offset.endswith('%'):
        try:
            percent_val = Decimal(trailing_offset.rstrip('%'));
            # Bybit range typically 0.1% to 10% for trailingStop
            if not (Decimal("0.1") <= percent_val <= Decimal("10.0")): raise ValueError(f"Percentage {percent_val}% out of Bybit's typical range (0.1% - 10%).")
            params['trailingStop'] = str(percent_val.quantize(Decimal("0.01"))); # V5 takes percentage value as string
            trail_log_str = f"{percent_val}%"; is_percent_trail = True
        except (ValueError, InvalidOperation) as e: logger.error(f"{Fore.RED}{log_prefix}: Invalid trailing '%': {e}{Style.RESET_ALL}"); return None
    elif isinstance(trailing_offset, Decimal):
        if trailing_offset <= Decimal("0"): logger.error(f"{Fore.RED}{log_prefix}: Trailing delta must be positive: {trailing_offset}{Style.RESET_ALL}"); return None
        try:
             # Check Bybit V5 docs for absolute trailing stop parameter (e.g., 'trailingMove'?)
             # Assuming 'trailingMove' takes string representation of the price offset
             delta_str = format_price(exchange, symbol, trailing_offset) # Format delta like a price
             params['trailingMove'] = delta_str # Using potential V5 param name
             trail_log_str = f"{delta_str} (abs)"
        except Exception as fmt_e: logger.error(f"{Fore.RED}{log_prefix}: Cannot format trail offset {trailing_offset}: {fmt_e}{Style.RESET_ALL}"); return None
    else: logger.error(f"{Fore.RED}{log_prefix}: Invalid trailing_offset type: {type(trailing_offset)}{Style.RESET_ALL}"); return None

    if activation_price is not None and activation_price <= Decimal("0"): logger.error(f"{Fore.RED}{log_prefix}: Activation price must be positive.{Style.RESET_ALL}"); return None
    logger.info(f"{Fore.CYAN}{log_prefix}: Init {format_amount(exchange, symbol, amount)} {symbol}, Trail:{trail_log_str}, ActPx:{format_price(exchange, symbol, activation_price) or 'Immediate'}, Trigger:{trigger_by}, PosIdx:{position_idx}{Style.RESET_ALL}")

    try:
        market = exchange.market(symbol); category = _get_v5_category(market)
        if not category or category not in ['linear', 'inverse']: logger.error(f"{Fore.RED}[{func_name}] Not a contract symbol: {symbol}.{Style.RESET_ALL}"); return None
        amount_str = format_amount(exchange, symbol, amount); amount_float = float(amount_str); activation_price_str = format_price(exchange, symbol, activation_price) if activation_price else None

        params.update({'category': category, 'reduceOnly': True, 'positionIdx': position_idx, 'tpslMode': 'Full', 'triggerBy': trigger_by, 'tsOrderType': 'Market'}) # Use Market execution
        if activation_price_str is not None: params['activePrice'] = activation_price_str # V5 param for activation price

        if client_order_id:
            max_coid_len = 36
            original_coid_len = len(client_order_id)
            valid_coid = client_order_id[:max_coid_len]
            params['clientOrderId'] = valid_coid
            if len(valid_coid) < original_coid_len:
                logger.warning(f"[{func_name}] Client Order ID truncated to {max_coid_len} chars: '{valid_coid}' (Original length: {original_coid_len})")

        bg = Back.YELLOW; fg = Fore.BLACK
        logger.warning(f"{bg}{fg}{Style.BRIGHT}{log_prefix}: Placing NATIVE TSL (Market exec) -> Qty:{amount_float}, Side:{side}, Trail:{trail_log_str}, ActPx:{activation_price_str or 'Immediate'}, Trigger:{trigger_by}, Reduce:True, PosIdx:{position_idx}, Params:{params}{Style.RESET_ALL}")

        # Use create_order with type='market' and trailing params
        tsl_order = exchange.create_order(symbol=symbol, type='market', side=side, amount=amount_float, params=params)

        order_id = tsl_order.get('id'); client_oid_resp = tsl_order.get('clientOrderId', params.get('clientOrderId', 'N/A')); status = tsl_order.get('status', '?')
        returned_trail_value = tsl_order.get('info', {}).get('trailingStop') or tsl_order.get('info', {}).get('trailingMove')
        returned_act_price = safe_decimal_conversion(tsl_order.get('info', {}).get('activePrice', tsl_order.get('activationPrice')), None)
        returned_trigger = tsl_order.get('info', {}).get('triggerBy', trigger_by)
        logger.success(f"{Fore.GREEN}{log_prefix}: Native TSL order placed. ID:...{format_order_id(order_id)}, ClientOID:{client_oid_resp}, Status:{status}, Trail:{returned_trail_value}, ActPx:{format_price(exchange, symbol, returned_act_price)}, TriggerBy:{returned_trigger}{Style.RESET_ALL}")
        return tsl_order
    except (ccxt.InsufficientFunds, ccxt.InvalidOrder, ccxt.ExchangeError, ccxt.NetworkError, ccxt.BadSymbol, ValueError) as e: logger.error(f"{Fore.RED}{log_prefix}: API/Input Error placing TSL: {type(e).__name__} - {e}{Style.RESET_ALL}"); return None
    except Exception as e: logger.critical(f"{Back.RED}[{func_name}] Unexpected error placing TSL: {e}{Style.RESET_ALL}", exc_info=True); send_sms_alert(f"[{symbol.split('/')[0]}] TSL PLACE FAIL ({side.upper()}): Unexpected {type(e).__name__}", config); return None

# Snippet 19 / Function 19: Fetch Account Info (UTA Status, Margin Mode)
@retry_api_call(max_retries=2, initial_delay=1.0)
def fetch_account_info_bybit_v5(exchange: ccxt.bybit, config: 'Config') -> Optional[Dict[str, Any]]:
    """
    Fetches general account information from Bybit V5 API (`/v5/account/info`).
    Provides insights into UTA status, margin mode settings, etc.
    """
    func_name = "fetch_account_info_bybit_v5"; logger.debug(f"[{func_name}] Fetching Bybit V5 account info...")
    try:
        if hasattr(exchange, 'private_get_v5_account_info'):
            logger.debug(f"[{func_name}] Using private_get_v5_account_info endpoint.")
            account_info_raw = exchange.private_get_v5_account_info(); logger.debug(f"[{func_name}] Raw Account Info response: {str(account_info_raw)[:400]}...")
            ret_code = account_info_raw.get('retCode'); ret_msg = account_info_raw.get('retMsg')
            if ret_code == 0 and 'result' in account_info_raw:
                result = account_info_raw['result']
                parsed_info = { 'unifiedMarginStatus': result.get('unifiedMarginStatus'), 'marginMode': result.get('marginMode'), 'dcpStatus': result.get('dcpStatus'), 'timeWindow': result.get('timeWindow'), 'smtCode': result.get('smtCode'), 'isMasterTrader': result.get('isMasterTrader'), 'updateTime': result.get('updateTime'), 'rawInfo': result }
                logger.info(f"[{func_name}] Account Info: UTA Status={parsed_info.get('unifiedMarginStatus', 'N/A')}, MarginMode={parsed_info.get('marginMode', 'N/A')}, DCP Status={parsed_info.get('dcpStatus', 'N/A')}")
                return parsed_info
            else: raise ccxt.ExchangeError(f"Failed fetch/parse account info. Code={ret_code}, Msg='{ret_msg}'")
        else:
            logger.warning(f"[{func_name}] CCXT lacks 'private_get_v5_account_info'. Using fallback fetch_accounts() (less detail).")
            accounts = exchange.fetch_accounts()
            if accounts: logger.info(f"[{func_name}] Fallback fetch_accounts(): {str(accounts[0])[:200]}..."); return accounts[0]
            else: logger.error(f"{Fore.RED}[{func_name}] Fallback fetch_accounts() returned no data.{Style.RESET_ALL}"); return None
    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.AuthenticationError) as e: logger.warning(f"{Fore.YELLOW}[{func_name}] API Error fetching account info: {e}{Style.RESET_ALL}"); raise
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error fetching account info: {e}{Style.RESET_ALL}", exc_info=True); return None

# Snippet 20 / Function 20: Validate Symbol/Market
def validate_market(
    exchange: ccxt.bybit, symbol: str, config: 'Config', expected_type: Optional[Literal['swap', 'future', 'spot', 'option']] = None,
    expected_logic: Optional[Literal['linear', 'inverse']] = None, check_active: bool = True, require_contract: bool = True
) -> Optional[Dict]:
    """
    Validates if a symbol exists on the exchange, is active, and optionally matches
    expected type (swap, spot, etc.) and logic (linear, inverse). Loads markets if needed.
    """
    func_name = "validate_market"; eff_expected_type = expected_type if expected_type is not None else config.EXPECTED_MARKET_TYPE; eff_expected_logic = expected_logic if expected_logic is not None else config.EXPECTED_MARKET_LOGIC
    logger.debug(f"[{func_name}] Validating '{symbol}'. Checks: Type='{eff_expected_type or 'Any'}', Logic='{eff_expected_logic or 'Any'}', Active={check_active}, Contract={require_contract}")
    try:
        if not exchange.markets: logger.info(f"[{func_name}] Loading markets..."); exchange.load_markets(reload=True)
        if not exchange.markets: logger.error(f"{Fore.RED}[{func_name}] Failed to load markets.{Style.RESET_ALL}"); return None
        market = exchange.market(symbol) # Raises BadSymbol if not found
        is_active = market.get('active', False);
        if check_active and not is_active: logger.warning(f"{Fore.YELLOW}[{func_name}] Validation Warning: '{symbol}' inactive.{Style.RESET_ALL}") # Allow inactive? return None
        actual_type = market.get('type');
        if eff_expected_type and actual_type != eff_expected_type: logger.error(f"{Fore.RED}[{func_name}] Validation Failed: '{symbol}' type mismatch. Expected '{eff_expected_type}', Got '{actual_type}'.{Style.RESET_ALL}"); return None
        is_contract = market.get('contract', False);
        if require_contract and not is_contract: logger.error(f"{Fore.RED}[{func_name}] Validation Failed: '{symbol}' not a contract, but required.{Style.RESET_ALL}"); return None
        actual_logic_str: Optional[str] = None
        if is_contract:
            actual_logic_str = _get_v5_category(market); # Use helper to determine logic
            if eff_expected_logic and actual_logic_str != eff_expected_logic: logger.error(f"{Fore.RED}[{func_name}] Validation Failed: '{symbol}' logic mismatch. Expected '{eff_expected_logic}', Got '{actual_logic_str}'.{Style.RESET_ALL}"); return None
        logger.info(f"{Fore.GREEN}[{func_name}] Market OK: '{symbol}' (Type:{actual_type}, Logic:{actual_logic_str or 'N/A'}, Active:{is_active}).{Style.RESET_ALL}"); return market
    except ccxt.BadSymbol as e: logger.error(f"{Fore.RED}[{func_name}] Validation Failed: Symbol '{symbol}' not found. Error: {e}{Style.RESET_ALL}"); return None
    except ccxt.NetworkError as e: logger.error(f"{Fore.RED}[{func_name}] Network error during market validation for '{symbol}': {e}{Style.RESET_ALL}"); return None # Consider retry?
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error validating '{symbol}': {e}{Style.RESET_ALL}", exc_info=True); return None

# Snippet 21 / Function 21: Fetch Recent Trades
@retry_api_call(max_retries=2, initial_delay=0.5)
def fetch_recent_trades(
    exchange: ccxt.bybit, symbol: str, config: 'Config', limit: int = 100, min_size_filter: Optional[Decimal] = None
) -> Optional[List[Dict]]:
    """
    Fetches recent public trades for a symbol from Bybit V5, validates data,
    and returns a list of trade dictionaries with Decimal values, sorted recent first.
    """
    func_name = "fetch_recent_trades"; filter_log = f"(MinSize:{format_amount(exchange, symbol, min_size_filter) if min_size_filter else 'N/A'})"
    logger.debug(f"[{func_name}] Fetching {limit} trades for {symbol} {filter_log}...")
    if limit > 1000: logger.warning(f"[{func_name}] Clamping limit {limit} to 1000."); limit = 1000
    if limit <= 0: logger.warning(f"[{func_name}] Invalid limit {limit}. Using 100."); limit = 100
    try:
        market = exchange.market(symbol); category = _get_v5_category(market)
        params = {'category': category} if category else {}
        # params['execType'] = 'Trade' # Filter only trades? Check V5 docs.
        logger.debug(f"[{func_name}] Calling fetch_trades with limit={limit}, params={params}")
        trades_raw = exchange.fetch_trades(symbol, limit=limit, params=params)
        if not trades_raw: logger.debug(f"[{func_name}] No recent trades found."); return []
        processed_trades: List[Dict] = []; conversion_errors = 0; filtered_out_count = 0
        for trade in trades_raw:
            try:
                amount = safe_decimal_conversion(trade.get('amount'))
                price = safe_decimal_conversion(trade.get('price'))

                if not all([trade.get('id'), trade.get('timestamp'), trade.get('side'), price, amount]) or price <= 0 or amount <= 0:
                    conversion_errors += 1
                    continue

                if min_size_filter is not None and amount < min_size_filter:
                    filtered_out_count += 1
                    continue

                # Corrected cost calculation/validation (Multi-line)
                cost = safe_decimal_conversion(trade.get('cost'))
                if cost is None or (price and amount and abs(cost - (price * amount)) > config.POSITION_QTY_EPSILON * price):
                    if price and amount:
                         # logger.debug(f"[{func_name}] Recalculating cost for trade {trade.get('id')}")
                         cost = price * amount
                    else:
                         # Should not happen if previous check passed, but handle defensively
                         logger.warning(f"[{func_name}] Cannot calculate cost for trade {trade.get('id')}, price or amount invalid after initial check.")
                         cost = None # Keep cost as None

                processed_trades.append({'id': trade.get('id'), 'timestamp': trade.get('timestamp'), 'datetime': trade.get('datetime'), 'symbol': trade.get('symbol', symbol), 'side': trade.get('side'), 'price': price, 'amount': amount, 'cost': cost, 'takerOrMaker': trade.get('takerOrMaker'), 'info': trade.get('info', {})})
            except Exception as proc_err:
                conversion_errors += 1
                logger.warning(f"{Fore.YELLOW}Error processing single trade: {proc_err}. Data: {trade}{Style.RESET_ALL}")

        if conversion_errors > 0: logger.warning(f"{Fore.YELLOW}Skipped {conversion_errors} trades due to processing errors for {symbol}.{Style.RESET_ALL}")
        if filtered_out_count > 0: logger.debug(f"[{func_name}] Filtered {filtered_out_count} trades smaller than {min_size_filter}.")
        processed_trades.sort(key=lambda x: x['timestamp'], reverse=True)
        logger.info(f"[{func_name}] Fetched/processed {len(processed_trades)} trades for {symbol} {filter_log}.")
        return processed_trades
    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.BadSymbol) as e: logger.warning(f"{Fore.YELLOW}[{func_name}] API Error fetching trades: {e}{Style.RESET_ALL}"); raise
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error fetching trades: {e}{Style.RESET_ALL}", exc_info=True); return None

# Snippet 22 / Function 22: Update Limit Order (Edit Order)
@retry_api_call(max_retries=1, initial_delay=0) # Typically don't auto-retry modifications
def update_limit_order(
    exchange: ccxt.bybit, symbol: str, order_id: str, config: 'Config', new_amount: Optional[Decimal] = None,
    new_price: Optional[Decimal] = None, new_client_order_id: Optional[str] = None
) -> Optional[Dict]:
    """
    Attempts to modify the amount and/or price of an existing open limit order on Bybit V5.
    Requires `edit_order` support. Disallows modifying partially filled orders by default.
    """
    func_name = "update_limit_order"; log_prefix = f"Update Order ...{format_order_id(order_id)}"
    if new_amount is None and new_price is None: logger.warning(f"[{func_name}] {log_prefix}: No new amount or price provided."); return None
    if new_amount is not None and new_amount <= config.POSITION_QTY_EPSILON: logger.error(f"{Fore.RED}[{func_name}] {log_prefix}: Invalid new amount ({new_amount})."); return None
    if new_price is not None and new_price <= Decimal("0"): logger.error(f"{Fore.RED}[{func_name}] {log_prefix}: Invalid new price ({new_price})."); return None
    logger.info(f"{Fore.CYAN}{log_prefix}: Update {symbol} (Amt:{format_amount(exchange,symbol,new_amount) or 'NC'}, Px:{format_price(exchange,symbol,new_price) or 'NC'})...{Style.RESET_ALL}")
    try:
        if not exchange.has.get('editOrder'): logger.error(f"{Fore.RED}{log_prefix}: editOrder not supported.{Style.RESET_ALL}"); return None
        logger.debug(f"[{func_name}] Fetching current order state..."); market = exchange.market(symbol); category = _get_v5_category(market);
        if not category: raise ValueError(f"Cannot determine category for {symbol}")
        fetch_params = {'category': category}
        current_order = exchange.fetch_order(order_id, symbol, params=fetch_params)
        status = current_order.get('status'); order_type = current_order.get('type'); filled_qty = safe_decimal_conversion(current_order.get('filled', '0.0'))
        if status != 'open': raise ccxt.InvalidOrder(f"{log_prefix}: Status is '{status}' (not 'open').")
        if order_type != 'limit': raise ccxt.InvalidOrder(f"{log_prefix}: Type is '{order_type}' (not 'limit').")
        allow_partial_fill_update = False;
        if not allow_partial_fill_update and filled_qty > config.POSITION_QTY_EPSILON: logger.warning(f"{Fore.YELLOW}[{func_name}] Update aborted: partially filled ({format_amount(exchange, symbol, filled_qty)}).{Style.RESET_ALL}"); return None
        final_amount_dec = new_amount if new_amount is not None else safe_decimal_conversion(current_order.get('amount')); final_price_dec = new_price if new_price is not None else safe_decimal_conversion(current_order.get('price'))
        if final_amount_dec is None or final_price_dec is None or final_amount_dec <= config.POSITION_QTY_EPSILON or final_price_dec <= 0: raise ValueError("Invalid final amount/price.")
        edit_params: Dict[str, Any] = {'category': category}

        if new_client_order_id:
            max_coid_len = 36
            original_coid_len = len(new_client_order_id)
            valid_coid = new_client_order_id[:max_coid_len]
            # Check Bybit V5 param name for client OID on edit (e.g., 'clientOrderId' or 'newClientOrderId')
            edit_params['clientOrderId'] = valid_coid # Assuming 'clientOrderId' works
            if len(valid_coid) < original_coid_len:
                logger.warning(f"[{func_name}] New Client Order ID truncated to {max_coid_len} chars: '{valid_coid}' (Original length: {original_coid_len})")

        final_amount_float = float(format_amount(exchange, symbol, final_amount_dec)); final_price_float = float(format_price(exchange, symbol, final_price_dec))
        logger.info(f"{Fore.CYAN}[{func_name}] Submitting update -> Amt:{final_amount_float}, Px:{final_price_float}, Side:{current_order['side']}, Params:{edit_params}{Style.RESET_ALL}")
        updated_order = exchange.edit_order(id=order_id, symbol=symbol, type='limit', side=current_order['side'], amount=final_amount_float, price=final_price_float, params=edit_params)
        if updated_order: new_id = updated_order.get('id', order_id); status_after = updated_order.get('status', '?'); new_client_oid_resp = updated_order.get('clientOrderId', edit_params.get('clientOrderId', 'N/A')); logger.success(f"{Fore.GREEN}[{func_name}] Update OK. NewID:...{format_order_id(new_id)}, Status:{status_after}, ClientOID:{new_client_oid_resp}{Style.RESET_ALL}"); return updated_order
        else: logger.warning(f"{Fore.YELLOW}[{func_name}] edit_order returned no data. Check status manually.{Style.RESET_ALL}"); return None
    except (ccxt.OrderNotFound, ccxt.InvalidOrder, ccxt.NotSupported, ccxt.ExchangeError, ccxt.NetworkError, ccxt.BadSymbol, ValueError) as e: logger.error(f"{Fore.RED}[{func_name}] Failed update: {type(e).__name__} - {e}{Style.RESET_ALL}"); return None # Avoid retry for most of these
    except Exception as e: logger.critical(f"{Back.RED}[{func_name}] Unexpected update error: {e}{Style.RESET_ALL}", exc_info=True); return None

# Snippet 23 / Function 23: Fetch Position Risk (Bybit V5 Specific)
@retry_api_call(max_retries=3, initial_delay=1.0)
def fetch_position_risk_bybit_v5(exchange: ccxt.bybit, symbol: str, config: 'Config') -> Optional[Dict[str, Any]]:
    """
    Fetches detailed risk metrics for the current position of a specific symbol using Bybit V5 logic.
    Uses `fetch_positions_risk` or falls back to `fetch_positions`. Focuses on One-Way mode.
    Returns detailed dictionary with Decimals, or None if no position/error.
    """
    func_name = "fetch_position_risk_bybit_v5"; logger.debug(f"[{func_name}] Fetching position risk {symbol} (V5)...")
    default_risk = { 'symbol': symbol, 'side': config.POS_NONE, 'qty': Decimal("0.0"), 'entry_price': Decimal("0.0"), 'mark_price': None, 'liq_price': None, 'leverage': None, 'initial_margin': None, 'maint_margin': None, 'unrealized_pnl': None, 'imr': None, 'mmr': None, 'position_value': None, 'risk_limit_value': None, 'info': {} }
    try:
        market = exchange.market(symbol); market_id = market['id']; category = _get_v5_category(market)
        if not category or category not in ['linear', 'inverse']: logger.error(f"{Fore.RED}[{func_name}] Not a contract symbol: {symbol}.{Style.RESET_ALL}"); return default_risk
        params = {'category': category, 'symbol': market_id}; position_data: Optional[List[Dict]] = None; fetch_method_used = "N/A"
        if exchange.has.get('fetchPositionsRisk'):
            try: logger.debug(f"[{func_name}] Using fetch_positions_risk..."); position_data = exchange.fetch_positions_risk(symbols=[symbol], params=params); fetch_method_used = "fetchPositionsRisk"
            except Exception as e: logger.warning(f"[{func_name}] fetch_positions_risk failed ({type(e).__name__}). Falling back."); position_data = None
        if position_data is None:
             if exchange.has.get('fetchPositions'): logger.debug(f"[{func_name}] Falling back to fetch_positions..."); position_data = exchange.fetch_positions(symbols=[symbol], params=params); fetch_method_used = "fetchPositions (Fallback)"
             else: logger.error(f"{Fore.RED}[{func_name}] No position fetch methods available.{Style.RESET_ALL}"); return default_risk
        if position_data is None: logger.error(f"{Fore.RED}[{func_name}] Failed fetch position data ({fetch_method_used}).{Style.RESET_ALL}"); return default_risk
        active_pos_risk: Optional[Dict] = None

        # Corrected multi-line nested if block
        for pos in position_data:
            pos_info = pos.get('info', {})
            pos_symbol = pos_info.get('symbol')
            pos_v5_side = pos_info.get('side', 'None')
            pos_size_str = pos_info.get('size')
            pos_idx = int(pos_info.get('positionIdx', -1))

            if pos_symbol == market_id and pos_v5_side != 'None' and pos_idx == 0:
                pos_size = safe_decimal_conversion(pos_size_str, Decimal("0.0"))
                if abs(pos_size) > config.POSITION_QTY_EPSILON:
                    active_pos_risk = pos
                    logger.debug(f"[{func_name}] Found active One-Way pos risk data ({fetch_method_used}).")
                    break # Found the position, exit loop

        if not active_pos_risk: logger.info(f"[{func_name}] No active One-Way position found for {symbol}."); return default_risk
        try:
            info = active_pos_risk.get('info', {}); size = safe_decimal_conversion(active_pos_risk.get('contracts', info.get('size'))); entry_price = safe_decimal_conversion(active_pos_risk.get('entryPrice', info.get('avgPrice'))); mark_price = safe_decimal_conversion(active_pos_risk.get('markPrice', info.get('markPrice'))); liq_price = safe_decimal_conversion(active_pos_risk.get('liquidationPrice', info.get('liqPrice'))); leverage = safe_decimal_conversion(active_pos_risk.get('leverage', info.get('leverage'))); initial_margin = safe_decimal_conversion(active_pos_risk.get('initialMargin', info.get('positionIM'))); maint_margin = safe_decimal_conversion(active_pos_risk.get('maintenanceMargin', info.get('positionMM'))); pnl = safe_decimal_conversion(active_pos_risk.get('unrealizedPnl', info.get('unrealisedPnl'))); imr = safe_decimal_conversion(active_pos_risk.get('initialMarginPercentage', info.get('imr'))); mmr = safe_decimal_conversion(active_pos_risk.get('maintenanceMarginPercentage', info.get('mmr'))); pos_value = safe_decimal_conversion(active_pos_risk.get('contractsValue', info.get('positionValue'))); risk_limit = safe_decimal_conversion(info.get('riskLimitValue'))
            pos_side_str = info.get('side'); position_side = config.POS_LONG if pos_side_str == 'Buy' else (config.POS_SHORT if pos_side_str == 'Sell' else config.POS_NONE); quantity = abs(size) if size is not None else Decimal("0.0")
            if position_side == config.POS_NONE or quantity <= config.POSITION_QTY_EPSILON: logger.info(f"[{func_name}] Parsed pos {symbol} negligible."); return default_risk
            log_color = Fore.GREEN if position_side == config.POS_LONG else Fore.RED
            logger.info(f"{log_color}[{func_name}] Position Risk {symbol} ({position_side}):{Style.RESET_ALL}")
            logger.info(f"  Qty:{format_amount(exchange, symbol, quantity)}, Entry:{format_price(exchange, symbol, entry_price)}, Mark:{format_price(exchange, symbol, mark_price)}")
            logger.info(f"  Liq:{format_price(exchange, symbol, liq_price)}, Lev:{leverage}x, uPNL:{format_price(exchange, market['quote'], pnl)}")
            logger.info(f"  IM:{format_price(exchange, market['quote'], initial_margin)}, MM:{format_price(exchange, market['quote'], maint_margin)}")
            logger.info(f"  IMR:{imr:.4% if imr else 'N/A'}, MMR:{mmr:.4% if mmr else 'N/A'}, Value:{format_price(exchange, market['quote'], pos_value)}")
            logger.info(f"  RiskLimitValue:{risk_limit or 'N/A'}")
            return { 'symbol': symbol, 'side': position_side, 'qty': quantity, 'entry_price': entry_price, 'mark_price': mark_price, 'liq_price': liq_price, 'leverage': leverage, 'initial_margin': initial_margin, 'maint_margin': maint_margin, 'unrealized_pnl': pnl, 'imr': imr, 'mmr': mmr, 'position_value': pos_value, 'risk_limit_value': risk_limit, 'info': info }
        except Exception as parse_err: logger.warning(f"{Fore.YELLOW}[{func_name}] Error parsing pos risk: {parse_err}. Data: {str(active_pos_risk)[:300]}{Style.RESET_ALL}"); return default_risk
    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.BadSymbol) as e: logger.warning(f"{Fore.YELLOW}[{func_name}] API Error fetching pos risk: {e}{Style.RESET_ALL}"); raise
    except Exception as e: logger.error(f"{Fore.RED}[{func_name}] Unexpected error fetching pos risk: {e}{Style.RESET_ALL}", exc_info=True); return default_risk

# Snippet 24 / Function 24: Set Isolated Margin (Bybit V5 Specific)
@retry_api_call(max_retries=2, initial_delay=1.0)
def set_isolated_margin_bybit_v5(exchange: ccxt.bybit, symbol: str, leverage: int, config: 'Config') -> bool:
    """
    Sets margin mode to ISOLATED for a specific symbol on Bybit V5 and sets leverage for it.

    Uses V5 endpoint 'private_post_v5_position_switch_isolated'. Cannot be done if there's
    an existing position or active orders for the symbol.

    Args:
        exchange: Initialized ccxt.bybit instance.
        symbol: Market symbol (e.g., 'BTC/USDT:USDT') to set isolated margin for.
        leverage: The desired leverage (buy and sell) to set for the isolated position.
        config: Configuration object.

    Returns:
        True if isolated mode was set successfully (or already set) and leverage was applied,
        False otherwise.

    Raises:
        Reraises CCXT exceptions for the retry decorator. Handles specific V5 errors internally.
        ValueError for invalid leverage.
    """
    func_name = "set_isolated_margin_bybit_v5"
    logger.info(f"{Fore.CYAN}[{func_name}] Attempting to set ISOLATED margin mode for {symbol} with {leverage}x leverage...{Style.RESET_ALL}")
    ret_code = -1 # Initialize ret_code to handle potential early exit

    if leverage <= 0: logger.error(f"{Fore.RED}[{func_name}] Leverage must be positive.{Style.RESET_ALL}"); return False

    try:
        market = exchange.market(symbol)
        category = _get_v5_category(market)
        if not category or category not in ['linear', 'inverse']:
            logger.error(f"{Fore.RED}[{func_name}] Cannot set isolated margin for non-contract symbol: {symbol} (Category: {category}).{Style.RESET_ALL}")
            return False

        # Prefer unified method if available and works
        try:
            logger.debug(f"[{func_name}] Attempting via unified exchange.set_margin_mode...")
            # This might also set leverage implicitly or require separate call
            response = exchange.set_margin_mode(marginMode='isolated', symbol=symbol, params={'category': category, 'leverage': leverage})
            logger.info(f"[{func_name}] Unified set_margin_mode call executed for isolated. Response: {response}")
            # Check if leverage needs separate setting
            logger.info(f"[{func_name}] Verifying leverage after unified set_margin_mode call...")
            leverage_set_success = set_leverage(exchange, symbol, leverage, config)
            if leverage_set_success:
                logger.success(f"{Fore.GREEN}[{func_name}] Isolated mode & leverage {leverage}x set/confirmed via unified method for {symbol}.{Style.RESET_ALL}")
                return True
            else:
                 logger.error(f"{Fore.RED}[{func_name}] Failed to set leverage after unified isolated mode attempt for {symbol}.{Style.RESET_ALL}")
                 return False # Fallback to private endpoint? Maybe not, indicate failure.

        except (ccxt.NotSupported, ccxt.ExchangeError, ccxt.ArgumentsRequired) as e_unified:
            logger.warning(f"[{func_name}] Unified set_margin_mode failed for isolated: {e_unified}. Trying private V5 endpoint...")
        # Proceed to private endpoint if unified method failed/not supported

        # Check if the required V5 method exists
        if not hasattr(exchange, 'private_post_v5_position_switch_isolated'):
            logger.error(f"{Fore.RED}[{func_name}] CCXT lacks 'private_post_v5_position_switch_isolated'. Cannot set isolated margin via private endpoint.{Style.RESET_ALL}")
            return False

        params_switch = { 'category': category, 'symbol': market['id'], 'tradeMode': 1, 'buyLeverage': str(leverage), 'sellLeverage': str(leverage) }
        logger.debug(f"[{func_name}] Calling private_post_v5_position_switch_isolated with params: {params_switch}")
        response = exchange.private_post_v5_position_switch_isolated(params_switch)
        logger.debug(f"[{func_name}] Raw response from switch_isolated endpoint: {response}")

        ret_code = response.get('retCode'); ret_msg = response.get('retMsg', '').lower()
        already_isolated_or_ok = False

        if ret_code == 0: logger.success(f"{Fore.GREEN}[{func_name}] Switched {symbol} to ISOLATED with {leverage}x leverage via V5 endpoint.{Style.RESET_ALL}"); already_isolated_or_ok = True
        # 110026: Margin mode is not modified | 34036 maybe?
        elif ret_code in [110026, 34036] or "margin mode is not modified" in ret_msg: logger.info(f"{Fore.CYAN}[{func_name}] {symbol} already ISOLATED via V5 check. Verifying leverage...{Style.RESET_ALL}"); already_isolated_or_ok = True
        # 110020: Position/order exists
        elif ret_code == 110020 or "have position" in ret_msg or "active order" in ret_msg: logger.error(f"{Fore.RED}[{func_name}] Cannot switch {symbol} to ISOLATED: active pos/orders exist. Msg: {response.get('retMsg')}{Style.RESET_ALL}"); return False
        else: raise ccxt.ExchangeError(f"Bybit API error switching isolated mode via V5 endpoint: Code={ret_code}, Msg='{response.get('retMsg', 'N/A')}'")

        # If mode is now isolated (or was already), explicitly ensure leverage is set correctly
        if already_isolated_or_ok:
            logger.debug(f"[{func_name}] Explicitly setting/confirming leverage {leverage}x for ISOLATED {symbol}...")
            leverage_set_success = set_leverage(exchange, symbol, leverage, config) # Use validated function
            if leverage_set_success: logger.success(f"{Fore.GREEN}[{func_name}] Leverage confirmed/set {leverage}x for ISOLATED {symbol}.{Style.RESET_ALL}"); return True
            else: logger.error(f"{Fore.RED}[{func_name}] Failed set/confirm leverage {leverage}x after ISOLATED mode switch/check.{Style.RESET_ALL}"); return False

        return False

    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.AuthenticationError, ccxt.BadSymbol, ValueError) as e:
        # Avoid raising again if it's an error code handled explicitly above (e.g., 110020)
        if not (isinstance(e, ccxt.ExchangeError) and ret_code in [110020]):
             logger.warning(f"{Fore.YELLOW}[{func_name}] API/Input Error setting isolated margin: {e}{Style.RESET_ALL}")
             if isinstance(e, (ccxt.NetworkError, ccxt.AuthenticationError)): raise e # Re-raise for retry decorator
        return False
    except Exception as e:
        logger.error(f"{Fore.RED}[{func_name}] Unexpected error setting isolated margin: {e}{Style.RESET_ALL}", exc_info=True)
        return False

# Snippet 25: Monitor API Rate Limit - REMOVED
# Rate limit monitoring relies EXCLUSIVELY on the external `retry_api_call` decorator.

# --- END OF HELPER FUNCTION IMPLEMENTATIONS ---


# --- Example Standalone Testing Block ---
if __name__ == "__main__":
    print(f"{Fore.YELLOW}{Style.BRIGHT}--- Bybit V5 Helpers Module Standalone Execution ---{Style.RESET_ALL}")
    print("This block is for basic syntax checks ONLY.")
    print("It CANNOT run live tests because it depends on functions and configuration")
    print("(safe_decimal_conversion, format_*, retry_api_call, Config, logger, etc.)")
    print("that MUST be provided by the script importing this module.")
    print("-" * 60)

    # --- Basic Syntax Check ---
    print("Checking basic syntax and function definitions...")
    all_funcs = [
        initialize_bybit, set_leverage, fetch_usdt_balance, place_market_order_slippage_check,
        cancel_all_orders, fetch_ohlcv_paginated, _process_ohlcv_list, place_limit_order_tif,
        get_current_position_bybit_v5, close_position_reduce_only, fetch_funding_rate,
        set_position_mode_bybit_v5, fetch_l2_order_book_validated, place_native_stop_loss,
        fetch_open_orders_filtered, calculate_margin_requirement, fetch_ticker_validated,
        place_native_trailing_stop, fetch_account_info_bybit_v5, validate_market,
        fetch_recent_trades, update_limit_order, fetch_position_risk_bybit_v5,
        set_isolated_margin_bybit_v5
    ]
    print(f"Found {len(all_funcs)} function definitions.")

    print(f"\n{Fore.GREEN}Basic syntax check passed.{Style.RESET_ALL}")
    print("To test functionality, import this module into your main script")
    print("which provides the required external dependencies (Config, logger, helpers, decorator).")
    print("-" * 60)
    print(f"{Fore.YELLOW}Finished standalone check execution.{Style.RESET_ALL}")

