
Score: -2
2025-04-25 16:28:45,441 - ScalpingBot - INFO -  -> -1: Order book shows sell pressure (Imb: 2.65)
2025-04-25 16:28:45,441 - ScalpingBot - INFO -  -> -1: Price (4.26) below EMA (4.26) (bearish trend)
2025-04-25 16:28:45,442 - ScalpingBot - INFO -  -> 0: RSI (36.85) is neutral (30-70)
2025-04-25 16:28:45,442 - ScalpingBot - INFO -  -> 0: Stoch RSI K (31.06) & D (19.94) neutral
2025-04-25 16:28:45,442 - ScalpingBot - INFO - Potential SHORT entry signal detected (Score: -2)
2025-04-25 16:28:45,921 - ScalpingBot - INFO - Attempting to place LIVE LIMIT SELL order...
2025-04-25 16:28:47,137 - ScalpingBot - ERROR - LIVE Order Failed (Unexpected Error): Failed to place sell order. Error: 'NoneType' object has no attribute 'upper'
Traceback (most recent call last):
  File "/data/data/com.termux/files/home/worldguide/trade_v3.py", line 953, in place_order
    f"ID: {order['id']}, Type: {order['type']}, Side: {order['side'].upper()}, "
                                                       ^^^^^^^^^^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'upper'
2025-04-25 16:28:57,148 - ScalpingBot - INFO -
===== Iteration 46 =====
2025-04-25 16:28:58,916 - ScalpingBot - INFO - Market State: Price=4.25, Volatility=0.00078
2025-04-25 16:28:58,917 - ScalpingBot - INFO - Indicators: EMA=4.26, RSI=34.81, MACD=N/A, StochK=29.24
2025-04-25 16:28:58,917 - ScalpingBot - INFO - Order Book Imbalance: 1.23 (Threshold: 1.5)
2025-04-25 16:28:59,834 - ScalpingBot - INFO - Volatility (0.00078) adjusted order size factor: 1.000
2025-04-25 16:28:59,835 - ScalpingBot - INFO - Calculated order size: 0.5110 USDT (Balance: 10.22 USDT)
2025-04-25 16:28:59,835 - ScalpingBot - INFO - Trade Signal Score: -1
2025-04-25 16:28:59,835 - ScalpingBot - INFO -  -> 0: Order book relatively balanced (Imb: 1.23)
2025-04-25 16:28:59,835 - ScalpingBot - INFO -  -> -1: Price (4.25) below EMA (4.26) (bearish trend)
2025-04-25 16:28:59,836 - ScalpingBot - INFO -  -> 0: RSI (34.81) is neutral (30-70)
2025-04-25 16:28:59,836 - ScalpingBot - INFO -  -> 0: Stoch RSI K (29.24) & D (19.34) neutral
2025-04-25 16:28:59,836 - ScalpingBot - INFO - Neutral signal score (-1). No trade entry signal.
2025-04-25 16:29:09,837 - ScalpingBot - INFO -
===== Iteration 47 =====
2025-04-25 16:29:11,460 - ScalpingBot - INFO - Market State: Price=4.25, Volatility=0.00078
2025-04-25 16:29:11,460 - ScalpingBot - INFO - Indicators: EMA=4.26, RSI=34.43, MACD=N/A, StochK=34.07
2025-04-25 16:29:11,460 - ScalpingBot - INFO - Order Book Imbalance: 1.24 (Threshold: 1.5)
2025-04-25 16:29:12,766 - ScalpingBot - INFO - Volatility (0.00078) adjusted order size factor: 1.000
2025-04-25 16:29:12,766 - ScalpingBot - INFO - Calculated order size: 0.5110 USDT (Balance: 10.22 USDT)
2025-04-25 16:29:12,767 - ScalpingBot - INFO - Trade Signal Score: -1
2025-04-25 16:29:12,767 - ScalpingBot - INFO -  -> 0: Order book relatively balanced (Imb: 1.24)
2025-04-25 16:29:12,767 - ScalpingBot - INFO -  -> -1: Price (4.25) below EMA (4.26) (bearish trend)
2025-04-25 16:29:12,767 - ScalpingBot - INFO -  -> 0: RSI (34.43) is neutral (30-70)
2025-04-25 16:29:12,768 - ScalpingBot - INFO -  -> 0: Stoch RSI K (34.07) & D (27.84) neutral
2025-04-25 16:29:12,768 - ScalpingBot - INFO - Neutral signal score (-1). No trade entry signal.
2025-04-25 16:29:22,768 - ScalpingBot - INFO -
===== Iteration 48 =====
2025-04-25 16:29:24,112 - ScalpingBot - INFO - Market State: Price=4.25, Volatility=0.00078
2025-04-25 16:29:24,112 - ScalpingBot - INFO - Indicators: EMA=4.26, RSI=33.83, MACD=N/A, StochK=33.41
2025-04-25 16:29:24,112 - ScalpingBot - INFO - Order Book Imbalance: 0.84 (Threshold: 1.5)
2025-04-25 16:29:25,064 - ScalpingBot - INFO - Volatility (0.00078) adjusted order size factor: 1.000
2025-04-25 16:29:25,065 - ScalpingBot - INFO - Calculated order size: 0.5110 USDT (Balance: 10.22 USDT)
2025-04-25 16:29:25,065 - ScalpingBot - INFO - Trade Signal Score: -1
2025-04-25 16:29:25,065 - ScalpingBot - INFO -  -> 0: Order book relatively balanced (Imb: 0.84)
2025-04-25 16:29:25,066 - ScalpingBot - INFO -  -> -1: Price (4.25) below EMA (4.26) (bearish trend)
2025-04-25 16:29:25,066 - ScalpingBot - INFO -  -> 0: RSI (33.83) is neutral (30-70)
2025-04-25 16:29:25,066 - ScalpingBot - INFO -  -> 0: Stoch RSI K (33.41) & D (27.62) neutral
2025-04-25 16:29:25,067 - ScalpingBot - INFO - Neutral signal score (-1). No trade entry signal.
2025-04-25 16:29:35,067 - ScalpingBot - INFO -
===== Iteration 49 =====
2025-04-25 16:29:36,564 - ScalpingBot - INFO - Market State: Price=4.25, Volatility=0.00077
2025-04-25 16:29:36,565 - ScalpingBot - INFO - Indicators: EMA=4.26, RSI=33.25, MACD=N/A, StochK=32.78
2025-04-25 16:29:36,565 - ScalpingBot - INFO - Order Book Imbalance: 2.82 (Threshold: 1.5)
2025-04-25 16:29:37,546 - ScalpingBot - INFO - Volatility (0.00077) adjusted order size factor: 1.000
2025-04-25 16:29:37,547 - ScalpingBot - INFO - Calculated order size: 0.5110 USDT (Balance: 10.22 USDT)
2025-04-25 16:29:37,548 - ScalpingBot - INFO - Trade Signal Score: -2
2025-04-25 16:29:37,548 - ScalpingBot - INFO -  -> -1: Order book shows sell pressure (Imb: 2.82)
2025-04-25 16:29:37,548 - ScalpingBot - INFO -  -> -1: Price (4.25) below EMA (4.26) (bearish trend)
2025-04-25 16:29:37,549 - ScalpingBot - INFO -  -> 0: RSI (33.25) is neutral (30-70)
2025-04-25 16:29:37,549 - ScalpingBot - INFO -  -> 0: Stoch RSI K (32.78) & D (27.41) neutral
2025-04-25 16:29:37,550 - ScalpingBot - INFO - Potential SHORT entry signal detected (Score: -2)
2025-04-25 16:29:38,194 - ScalpingBot - INFO - Attempting to place LIVE LIMIT SELL order...
2025-04-25 16:29:38,998 - ScalpingBot - ERROR - LIVE Order Failed (Unexpected Error): Failed to place sell order. Error: 'NoneType' object has no attribute 'upper'
Traceback (most recent call last):
  File "/data/data/com.termux/files/home/worldguide/trade_v3.py", line 953, in place_order
    f"ID: {order['id']}, Type: {order['type']}, Side: {order['side'].upper()}, "
                                                       ^^^^^^^^^^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'upper'
2025-04-25 16:29:49,007 - ScalpingBot - INFO -
===== Iteration 50 =====
2025-04-25 16:29:50,745 - ScalpingBot - INFO - Market State: Price=4.25, Volatility=0.00077
2025-04-25 16:29:50,746 - ScalpingBot - INFO - Indicators: EMA=4.26, RSI=32.69, MACD=N/A, StochK=32.16
2025-04-25 16:29:50,748 - ScalpingBot - INFO - Order Book Imbalance: 2.55 (Threshold: 1.5)
2025-04-25 16:29:51,614 - ScalpingBot - INFO - Volatility (0.00077) adjusted order size factor: 1.000
2025-04-25 16:29:51,615 - ScalpingBot - INFO - Calculated order size: 0.5099 USDT (Balance: 10.20 USDT)
2025-04-25 16:29:51,615 - ScalpingBot - INFO - Trade Signal Score: -2
2025-04-25 16:29:51,615 - ScalpingBot - INFO -  -> -1: Order book shows sell pressure (Imb: 2.55)
2025-04-25 16:29:51,616 - ScalpingBot - INFO -  -> -1: Price (4.25) below EMA (4.26) (bearish trend)
2025-04-25 16:29:51,616 - ScalpingBot - INFO -  -> 0: RSI (32.69) is neutral (30-70)
2025-04-25 16:29:51,616 - ScalpingBot - INFO -  -> 0: Stoch RSI K (32.16) & D (27.20) neutral
2025-04-25 16:29:51,616 - ScalpingBot - INFO - Potential SHORT entry signal detected (Score: -2)
2025-04-25 16:29:52,050 - ScalpingBot - INFO - Attempting to place LIVE LIMIT SELL order...
2025-04-25 16:29:52,452 - ScalpingBot - ERROR - LIVE Order Failed (Unexpected Error): Failed to place sell order. Error: 'NoneType' object has no attribute 'upper'
Traceback (most recent call last):
  File "/data/data/com.termux/files/home/worldguide/trade_v3.py", line 953, in place_order
    f"ID: {order['id']}, Type: {order['type']}, Side: {order['side'].upper()}, "
                                                       ^^^^^^^^^^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'upper'
2025-04-25 16:30:02,470

```python
# -*- coding: utf-8 -*-
"""
Scalping Bot v2 - Enhanced Version

This script implements a cryptocurrency scalping bot using the ccxt library.
It connects to an exchange (default: Bybit Futures), fetches market data,
calculates various technical indicators, determines trade signals based on a scoring system,
places orders, and manages open positions with stop-loss, take-profit, trailing stops,
and time-based exits. It includes configuration validation, default config generation,
robust error handling with retries, and detailed logging.
"""

import logging
import os
import sys
import time
from functools import wraps
from typing import Any, Callable, Dict, List, Optional, Tuple, Union

import ccxt
import numpy as np
import pandas as pd
import yaml
from colorama import Fore, Style
from colorama import init as colorama_init
from dotenv import load_dotenv

# Initialize colorama for cross-platform colored terminal output
colorama_init(autoreset=True)

# --- Constants ---
CONFIG_FILE_NAME = "config.yaml"
LOG_FILE_NAME = "scalping_bot_v2.log"
DEFAULT_EXCHANGE_ID = "bybit" # Ensure this matches your desired default
DEFAULT_TIMEFRAME = "1m"
DEFAULT_RETRY_MAX = 3
DEFAULT_RETRY_DELAY_SECONDS = 2 # Slightly increased default delay
DEFAULT_SLEEP_INTERVAL_SECONDS = 10
STRONG_SIGNAL_THRESHOLD_ABS = 3 # Absolute value for strong buy/sell signal score
ENTRY_SIGNAL_THRESHOLD_ABS = 2  # Absolute value for standard buy/sell signal score

# --- Logger Setup ---
# Configure a logger for detailed operational insights
logger = logging.getLogger("ScalpingBot")
logger.setLevel(logging.DEBUG)  # Set base level to DEBUG; actual level controlled by config/handler

# Formatter for log messages
log_formatter = logging.Formatter(
    "%(asctime)s - %(name)s - %(levelname)s - %(threadName)s - %(message)s" # Added threadName
)

# Console Handler (prints logs to the terminal)
console_handler = logging.StreamHandler(sys.stdout)
console_handler.setFormatter(log_formatter)
console_handler.setLevel(logging.INFO) # Default console level, can be overridden by config
logger.addHandler(console_handler)

# File Handler (writes logs to a file)
try:
    # Use 'a' mode to append to the log file across restarts
    file_handler = logging.FileHandler(LOG_FILE_NAME, mode='a', encoding='utf-8')
    file_handler.setFormatter(log_formatter)
    file_handler.setLevel(logging.DEBUG) # Log everything to the file by default
    logger.addHandler(file_handler)
except IOError as e:
    logger.error(f"{Fore.RED}Failed to open log file {LOG_FILE_NAME}: {e}{Style.RESET_ALL}")
    # Continue without file logging if it fails

# Load environment variables from .env file (if it exists)
if load_dotenv():
    logger.info("Loaded environment variables from .env file.")
else:
    logger.debug("No .env file found or unable to load.")


# --- API Retry Decorator ---
def retry_api_call(max_retries: int = DEFAULT_RETRY_MAX, initial_delay: int = DEFAULT_RETRY_DELAY_SECONDS) -> Callable:
    """
    Decorator to automatically retry API calls with exponential backoff
    upon encountering specific ccxt network or rate limit errors.

    Args:
        max_retries: Maximum number of retry attempts.
        initial_delay: Initial delay in seconds before the first retry.

    Returns:
        The decorated function.
    """
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args: Any, **kwargs: Any) -> Optional[Any]:
            retries = 0
            delay = initial_delay
            while retries <= max_retries:
                try:
                    return func(*args, **kwargs)
                except ccxt.RateLimitExceeded as e:
                    logger.warning(
                        f"{Fore.YELLOW}Rate limit exceeded for {func.__name__}. Retrying in {delay}s... "
                        f"(Attempt {retries + 1}/{max_retries}) Error: {e}{Style.RESET_ALL}"
                    )
                except (ccxt.NetworkError, ccxt.RequestTimeout, ccxt.ExchangeNotAvailable) as e:
                    # Group common network/availability issues
                    logger.error(
                        f"{Fore.RED}Network/Exchange connection error during {func.__name__}: {type(e).__name__} - {e}. "
                        f"Retrying in {delay}s... (Attempt {retries + 1}/{max_retries}){Style.RESET_ALL}"
                    )
                except ccxt.ExchangeError as e:
                    # Handle specific non-retryable or informative exchange errors
                    err_str = str(e).lower()
                    if "order not found" in err_str or "order does not exist" in err_str:
                        logger.warning(f"{Fore.YELLOW}Exchange error indicates order not found for {func.__name__}: {e}. Returning None (no retry needed).{Style.RESET_ALL}")
                        return None # Don't retry if the order simply isn't there
                    elif "insufficient balance" in err_str or "insufficient margin" in err_str:
                         logger.error(f"{Fore.RED}Exchange error indicates insufficient funds for {func.__name__}: {e}. Aborting operation (no retry).{Style.RESET_ALL}")
                         return None # Don't retry fund errors for this specific call
                    else:
                        # Log other exchange errors and retry
                        logger.error(
                            f"{Fore.RED}Exchange error during {func.__name__}: {e}. Retrying in {delay}s... "
                            f"(Attempt {retries + 1}/{max_retries}){Style.RESET_ALL}"
                        )
                except Exception as e:
                    # Catch unexpected errors and log them before retrying
                    logger.error(
                        f"{Fore.RED}Unexpected error during {func.__name__}: {type(e).__name__} - {e}. Retrying in {delay}s... "
                        f"(Attempt {retries + 1}/{max_retries}){Style.RESET_ALL}",
                        exc_info=True # Include stack trace for unexpected errors
                    )

                # If we are here, an exception occurred and we need to retry
                if retries < max_retries:
                    time.sleep(delay)
                    delay = min(delay * 2, 60) # Exponential backoff with a cap (e.g., 60s)
                    retries += 1
                else:
                    # Max retries reached
                    logger.error(
                        f"{Fore.RED}Max retries ({max_retries}) reached for {func.__name__}. Aborting operation.{Style.RESET_ALL}"
                    )
                    return None # Indicate failure after all retries

            # Should not be reached if max_retries >= 0, but added for safety
            return None
        return wrapper
    return decorator


# --- Scalping Bot Class ---
class ScalpingBot:
    """
    A cryptocurrency scalping bot designed to execute trades based on
    technical indicators and order book analysis. Provides features like
    configuration management, simulation mode, robust error handling,
    dynamic stop-loss/take-profit, trailing stops, and time-based exits.
    """

    def __init__(self, config_file: str = CONFIG_FILE_NAME) -> None:
        """
        Initializes the ScalpingBot instance by loading and validating configuration,
        setting up the exchange connection, and initializing bot state.

        Args:
            config_file: Path to the configuration YAML file.
        """
        logger.info(f"{Fore.CYAN}--- Initializing Scalping Bot v2 ---{Style.RESET_ALL}")
        self.config: Dict[str, Any] = {}
        self.load_config(config_file) # Load or create default config
        self.validate_config()      # Validate the loaded config

        # --- Set Attributes from Config/Env ---
        # Sensitive keys from environment variables
        self.api_key: Optional[str] = os.getenv("BYBIT_API_KEY") # Example, adjust prefix if needed
        self.api_secret: Optional[str] = os.getenv("BYBIT_API_SECRET")

        # Exchange and Trading settings
        self.exchange_id: str = self.config["exchange"]["exchange_id"]
        self.symbol: str = self.config["trading"]["symbol"]
        self.simulation_mode: bool = self.config["trading"]["simulation_mode"]
        self.entry_order_type: str = self.config["trading"]["entry_order_type"]
        self.limit_order_entry_offset_pct_buy: float = self.config["trading"]["limit_order_offset_buy"]
        self.limit_order_entry_offset_pct_sell: float = self.config["trading"]["limit_order_offset_sell"]
        self.timeframe: str = self.config["trading"].get("timeframe", DEFAULT_TIMEFRAME) # Allow overriding timeframe

        # Order Book parameters
        self.order_book_depth: int = self.config["order_book"]["depth"]
        self.imbalance_threshold: float = self.config["order_book"]["imbalance_threshold"]

        # Indicator parameters
        self.volatility_window: int = self.config["indicators"]["volatility_window"]
        self.volatility_multiplier: float = self.config["indicators"]["volatility_multiplier"]
        self.ema_period: int = self.config["indicators"]["ema_period"]
        self.rsi_period: int = self.config["indicators"]["rsi_period"]
        self.macd_short_period: int = self.config["indicators"]["macd_short_period"]
        self.macd_long_period: int = self.config["indicators"]["macd_long_period"]
        self.macd_signal_period: int = self.config["indicators"]["macd_signal_period"]
        self.stoch_rsi_period: int = self.config["indicators"]["stoch_rsi_period"]
        self.stoch_rsi_k_period: int = self.config["indicators"]["stoch_rsi_k_period"]
        self.stoch_rsi_d_period: int = self.config["indicators"]["stoch_rsi_d_period"]

        # Risk Management parameters
        self.base_stop_loss_pct: float = self.config["risk_management"]["stop_loss_percentage"]
        self.base_take_profit_pct: float = self.config["risk_management"]["take_profit_percentage"]
        self.max_open_positions: int = self.config["risk_management"]["max_open_positions"]
        self.time_based_exit_minutes: Optional[int] = self.config["risk_management"].get("time_based_exit_minutes") # Optional
        self.trailing_stop_loss_percentage: Optional[float] = self.config["risk_management"].get("trailing_stop_loss_percentage") # Optional
        self.order_size_percentage: float = self.config["risk_management"]["order_size_percentage"]
        self.strong_signal_adjustment_factor: float = self.config["risk_management"]["strong_signal_adjustment_factor"]
        self.weak_signal_adjustment_factor: float = self.config["risk_management"]["weak_signal_adjustment_factor"]

        # --- Bot State ---
        self.iteration: int = 0
        self.daily_pnl: float = 0.0 # Placeholder for potential future PnL tracking
        self.open_positions: List[Dict[str, Any]] = [] # Stores details of active positions

        # --- Configure Logging Level from Config ---
        self._configure_logging_level()

        # --- Initialize Exchange ---
        self.exchange: ccxt.Exchange = self._initialize_exchange()

        if self.simulation_mode:
            logger.warning(f"{Fore.YELLOW}--- RUNNING IN SIMULATION MODE (No real orders will be placed) ---{Style.RESET_ALL}")
        else:
             logger.warning(f"{Fore.GREEN}--- RUNNING IN LIVE TRADING MODE (Real orders will be placed) ---{Style.RESET_ALL}")

        logger.info(f"{Fore.CYAN}Scalping Bot initialization complete. Trading Symbol: {self.symbol}{Style.RESET_ALL}")

    def _configure_logging_level(self):
        """Sets the logger and console handler level based on the config file."""
        log_level_str = self.config.get("logging_level", "INFO").upper()
        log_level = getattr(logging, log_level_str, None)

        if isinstance(log_level, int):
            logger.setLevel(log_level) # Set overall logger level
            # Set console handler level separately if you want different verbosity
            console_handler.setLevel(log_level)
            # File handler usually stays at DEBUG unless specified otherwise
            if file_handler: file_handler.setLevel(logging.DEBUG)

            logger.info(f"Logging level set to {log_level_str} from config.")
            # Log handlers for debugging setup
            logger.debug(f"Logger level: {logging.getLevelName(logger.level)}")
            logger.debug(f"Console handler level: {logging.getLevelName(console_handler.level)}")
            if file_handler: logger.debug(f"File handler level: {logging.getLevelName(file_handler.level)}")
        else:
            logger.warning(
                f"{Fore.YELLOW}Invalid logging level '{self.config.get('logging_level')}' in config. "
                f"Using default console level ({logging.getLevelName(console_handler.level)}).{Style.RESET_ALL}"
            )

    def load_config(self, config_file: str) -> None:
        """Loads configuration settings from a YAML file or creates a default one."""
        try:
            with open(config_file, 'r', encoding='utf-8') as f:
                self.config = yaml.safe_load(f)
            if not isinstance(self.config, dict): # Handle empty or invalid YAML structure
                 logger.error(f"{Fore.RED}Configuration file {config_file} is empty or invalid. Exiting.{Style.RESET_ALL}")
                 sys.exit(1)
            logger.info(f"{Fore.GREEN}Configuration loaded successfully from {config_file}{Style.RESET_ALL}")
        except FileNotFoundError:
            logger.warning(f"{Fore.YELLOW}Configuration file '{config_file}' not found.{Style.RESET_ALL}")
            try:
                self.create_default_config(config_file)
                logger.info(f"{Fore.YELLOW}Created a default configuration file: '{config_file}'. "
                            f"Please review and modify it (especially API keys in .env and symbol in config), then restart the bot.{Style.RESET_ALL}")
            except Exception as e:
                logger.error(f"{Fore.RED}Failed to create default config file: {e}{Style.RESET_ALL}")
            sys.exit(1) # Exit after creating default or failing
        except yaml.YAMLError as e:
            logger.error(f"{Fore.RED}Error parsing configuration file {config_file}: {e}. Check YAML syntax. Exiting.{Style.RESET_ALL}")
            sys.exit(1)
        except Exception as e:
            logger.error(f"{Fore.RED}An unexpected error occurred while loading config: {e}{Style.RESET_ALL}", exc_info=True)
            sys.exit(1)

    def create_default_config(self, config_file: str) -> None:
        """Creates a default configuration file with common settings and placeholders."""
        default_config = {
            "logging_level": "INFO", # Options: DEBUG, INFO, WARNING, ERROR, CRITICAL
            "exchange": {
                "exchange_id": os.getenv("EXCHANGE_ID", DEFAULT_EXCHANGE_ID),
            },
            "trading": {
                # --- IMPORTANT: Set your trading symbol appropriate for the exchange ---
                "symbol": os.getenv("TRADING_SYMBOL", "BTC/USDT:USDT"), # Example for Bybit USDT Perpetual
                "timeframe": os.getenv("TIMEFRAME", DEFAULT_TIMEFRAME), # e.g., 1m, 3m, 5m, 15m, 1h
                "simulation_mode": os.getenv("SIMULATION_MODE", "True").lower() in ("true", "1", "yes"),
                "entry_order_type": os.getenv("ENTRY_ORDER_TYPE", "limit").lower(), # 'limit' or 'market'
                 # Percentage offset from market price for placing limit orders (e.g., 0.001 = 0.1%)
                 # Buy limit placed slightly BELOW current price: Price * (1 - offset)
                "limit_order_offset_buy": float(os.getenv("LIMIT_ORDER_OFFSET_BUY", 0.0005)),
                 # Sell limit placed slightly ABOVE current price: Price * (1 + offset)
                "limit_order_offset_sell": float(os.getenv("LIMIT_ORDER_OFFSET_SELL", 0.0005)),
            },
            "order_book": {
                "depth": int(os.getenv("ORDER_BOOK_DEPTH", 10)), # Number of bids/asks levels to analyze
                "imbalance_threshold": float(os.getenv("IMBALANCE_THRESHOLD", 1.5)), # Ratio of AskVol/BidVol (or BidVol/AskVol) to trigger signal
            },
            "indicators": {
                "volatility_window": int(os.getenv("VOLATILITY_WINDOW", 20)), # Lookback period for volatility calc
                "volatility_multiplier": float(os.getenv("VOLATILITY_MULTIPLIER", 0.0)), # Set > 0 to enable volatility-based order size adjustment (use cautiously)
                "ema_period": int(os.getenv("EMA_PERIOD", 10)),
                "rsi_period": int(os.getenv("RSI_PERIOD", 14)),
                "macd_short_period": int(os.getenv("MACD_SHORT_PERIOD", 12)),
                "macd_long_period": int(os.getenv("MACD_LONG_PERIOD", 26)),
                "macd_signal_period": int(os.getenv("MACD_SIGNAL_PERIOD", 9)),
                "stoch_rsi_period": int(os.getenv("STOCH_RSI_PERIOD", 14)), # Period for underlying RSI
                "stoch_rsi_k_period": int(os.getenv("STOCH_RSI_K_PERIOD", 3)), # Smoothing for Stoch RSI %K
                "stoch_rsi_d_period": int(os.getenv("STOCH_RSI_D_PERIOD", 3)), # Smoothing for Stoch RSI %D
            },
            "risk_management": {
                 # Percentage of FREE QUOTE currency balance (e.g., USDT) to risk per trade
                "order_size_percentage": float(os.getenv("ORDER_SIZE_PERCENTAGE", 0.01)), # e.g., 0.01 = 1% of free balance
                 # Base stop loss percentage from entry price
                "stop_loss_percentage": float(os.getenv("STOP_LOSS_PERCENTAGE", 0.005)), # e.g., 0.005 = 0.5%
                 # Base take profit percentage from entry price
                "take_profit_percentage": float(os.getenv("TAKE_PROFIT_PERCENTAGE", 0.01)), # e.g., 0.01 = 1%
                 # Trailing stop loss activation and trail percentage (set to 0 or remove to disable)
                "trailing_stop_loss_percentage": float(os.getenv("TRAILING_STOP_LOSS_PERCENTAGE", 0.003)), # e.g., 0.003 = 0.3% trail
                "max_open_positions": int(os.getenv("MAX_OPEN_POSITIONS", 1)),
                 # Max duration for a position before forced exit (in minutes) (set to 0 or remove to disable)
                "time_based_exit_minutes": int(os.getenv("TIME_BASED_EXIT_MINUTES", 60)),
                 # Adjustment factors for SL/TP based on signal strength (1.0 = no adjustment)
                "strong_signal_adjustment_factor": float(os.getenv("STRONG_SIGNAL_ADJ", 1.1)), # Increase TP/SL range slightly for strong signals
                "weak_signal_adjustment_factor": float(os.getenv("WEAK_SIGNAL_ADJ", 0.9)),   # Decrease TP/SL range slightly for weaker signals
            },
        }
        try:
            with open(config_file, "w", encoding='utf-8') as f:
                yaml.dump(default_config, f, indent=4, sort_keys=False, default_flow_style=False)
            logger.info(f"Default configuration file '{config_file}' created.")
        except IOError as e:
            logger.error(f"{Fore.RED}Could not write default config file {config_file}: {e}{Style.RESET_ALL}")
            raise # Re-raise the exception to be caught by the caller

    def validate_config(self) -> None:
        """Validates the loaded configuration dictionary for required keys, types, and reasonable values."""
        logger.debug("Validating configuration...")
        try:
            # Helper for checking positive numbers (int or float)
            def is_positive_number(val):
                return isinstance(val, (int, float)) and val > 0

            # Helper for checking non-negative numbers (int or float)
            def is_non_negative_number(val):
                 return isinstance(val, (int, float)) and val >= 0

            # Helper for checking percentage values (0 to 1)
            def is_percentage(val):
                 return isinstance(val, (int, float)) and 0 <= val <= 1

            # Validate top-level sections
            required_sections = ["exchange", "trading", "order_book", "indicators", "risk_management"]
            for section in required_sections:
                if section not in self.config or not isinstance(self.config[section], dict):
                    raise ValueError(f"Missing or invalid section '{section}' in config file.")

            # --- Validate 'exchange' section ---
            exch_cfg = self.config["exchange"]
            if not isinstance(exch_cfg.get("exchange_id"), str) or not exch_cfg["exchange_id"]:
                raise ValueError("'exchange.exchange_id' must be a non-empty string.")
            # Check if the exchange ID is supported by ccxt
            if exch_cfg["exchange_id"] not in ccxt.exchanges:
                 raise ValueError(f"Exchange ID '{exch_cfg['exchange_id']}' is not recognized by ccxt.")

            # --- Validate 'trading' section ---
            trading_cfg = self.config["trading"]
            if not isinstance(trading_cfg.get("symbol"), str) or not trading_cfg["symbol"]:
                raise ValueError("'trading.symbol' must be a non-empty string.")
            if not isinstance(trading_cfg.get("simulation_mode"), bool):
                raise ValueError("'trading.simulation_mode' must be a boolean (true/false).")
            if trading_cfg.get("entry_order_type") not in ["market", "limit"]:
                raise ValueError("'trading.entry_order_type' must be 'market' or 'limit'.")
            if not is_non_negative_number(trading_cfg.get("limit_order_offset_buy")):
                raise ValueError("'trading.limit_order_offset_buy' must be a non-negative number.")
            if not is_non_negative_number(trading_cfg.get("limit_order_offset_sell")):
                raise ValueError("'trading.limit_order_offset_sell' must be a non-negative number.")
            if not isinstance(trading_cfg.get("timeframe", DEFAULT_TIMEFRAME), str) or not trading_cfg.get("timeframe", DEFAULT_TIMEFRAME):
                 raise ValueError("'trading.timeframe' must be a non-empty string.")

            # --- Validate 'order_book' section ---
            ob_cfg = self.config["order_book"]
            if not isinstance(ob_cfg.get("depth"), int) or ob_cfg["depth"] <= 0:
                raise ValueError("'order_book.depth' must be a positive integer.")
            if not is_positive_number(ob_cfg.get("imbalance_threshold")):
                 raise ValueError("'order_book.imbalance_threshold' must be a positive number.")

            # --- Validate 'indicators' section ---
            ind_cfg = self.config["indicators"]
            for key, type_, positive in [
                ("volatility_window", int, True), ("ema_period", int, True), ("rsi_period", int, True),
                ("macd_short_period", int, True), ("macd_long_period", int, True), ("macd_signal_period", int, True),
                ("stoch_rsi_period", int, True), ("stoch_rsi_k_period", int, True), ("stoch_rsi_d_period", int, True),
                ("volatility_multiplier", (int, float), False) # Can be zero or positive
            ]:
                 val = ind_cfg.get(key)
                 if val is None:
                      raise ValueError(f"Missing 'indicators.{key}' in config.")
                 if not isinstance(val, type_):
                      raise ValueError(f"'indicators.{key}' must be of type {type_}.")
                 if positive and not (isinstance(val, int) and val > 0 or isinstance(val, float) and val > 0):
                     raise ValueError(f"'indicators.{key}' must be a positive number.")
                 if not positive and not is_non_negative_number(val):
                      raise ValueError(f"'indicators.{key}' must be a non-negative number.")
            if ind_cfg['macd_short_period'] >= ind_cfg['macd_long_period']:
                raise ValueError("'indicators.macd_short_period' must be less than 'macd_long_period'.")

            # --- Validate 'risk_management' section ---
            risk_cfg = self.config["risk_management"]
            for key, check_func, name in [
                ("order_size_percentage", is_percentage, "percentage (0 to 1)"),
                ("stop_loss_percentage", is_percentage, "percentage (0 to 1)"),
                ("take_profit_percentage", is_percentage, "percentage (0 to 1)"),
                ("trailing_stop_loss_percentage", lambda x: x is None or is_percentage(x), "None or percentage (0 to 1)"),
                ("strong_signal_adjustment_factor", is_positive_number, "positive number"),
                ("weak_signal_adjustment_factor", is_positive_number, "positive number"),
            ]:
                val = risk_cfg.get(key)
                # Allow optional trailing stop loss
                if key == "trailing_stop_loss_percentage" and val is None:
                    risk_cfg[key] = 0.0 # Set to 0 if None for easier checks later
                    continue
                if val is None and key != "trailing_stop_loss_percentage": # Check required fields
                    raise ValueError(f"Missing 'risk_management.{key}' in config.")
                if not check_func(val):
                     raise ValueError(f"'risk_management.{key}' must be a {name}. Found: {val}")

            for key, min_val in [("max_open_positions", 1), ("time_based_exit_minutes", 0)]: # Allow 0 to disable time exit
                 val = risk_cfg.get(key)
                 # Allow optional time based exit
                 if key == "time_based_exit_minutes" and val is None:
                    risk_cfg[key] = 0 # Set to 0 if None
                    continue
                 if val is None and key != "time_based_exit_minutes":
                     raise ValueError(f"Missing 'risk_management.{key}' in config.")
                 if not isinstance(val, int) or val < min_val:
                     raise ValueError(f"'risk_management.{key}' must be an integer >= {min_val}.")

            logger.info(f"{Fore.GREEN}Configuration validated successfully.{Style.RESET_ALL}")

        except ValueError as e:
            logger.critical(f"{Fore.RED}Configuration validation failed: {e}. Please correct the '{CONFIG_FILE_NAME}' file. Exiting.{Style.RESET_ALL}")
            sys.exit(1)
        except Exception as e:
            logger.critical(f"{Fore.RED}An unexpected error occurred during config validation: {e}{Style.RESET_ALL}", exc_info=True)
            sys.exit(1)

    def _initialize_exchange(self) -> ccxt.Exchange:
        """Initializes and connects to the specified exchange using ccxt."""
        logger.info(f"Initializing connection to {self.exchange_id.upper()}...")

        # Check for API keys ONLY if not in simulation mode
        if not self.simulation_mode:
            if not self.api_key or not self.api_secret:
                 logger.critical(f"{Fore.RED}API Key or Secret not found in environment variables (e.g., BYBIT_API_KEY, BYBIT_API_SECRET). "
                              f"Cannot run in live mode. Please set them in your environment or a .env file. Exiting.{Style.RESET_ALL}")
                 sys.exit(1)
            else:
                 logger.info("API keys found for live trading mode.")
        else:
             if not self.api_key or not self.api_secret:
                 logger.warning(f"{Fore.YELLOW}API Key/Secret not found. Running in simulation mode only.{Style.RESET_ALL}")
             else:
                 logger.info("API keys found, but running in simulation mode as configured.")


        try:
            exchange_class = getattr(ccxt, self.exchange_id)
            exchange_config = {
                # Pass keys only if not in simulation mode AND they exist
                'apiKey': self.api_key if not self.simulation_mode and self.api_key else None,
                'secret': self.api_secret if not self.simulation_mode and self.api_secret else None,
                'enableRateLimit': True, # Enable ccxt's built-in rate limiter
                 # Add options common for futures/derivatives if applicable
                'options': {
                    'defaultType': 'future', # Adjust as needed: 'spot', 'margin', 'swap'
                     # 'adjustForTimeDifference': True, # May help with timestamp errors
                }
            }
            # Remove None values from config to avoid issues with some exchanges
            exchange_config = {k: v for k, v in exchange_config.items() if v is not None}

            exchange = exchange_class(exchange_config)

            # Set sandbox/testnet mode if available and in simulation
            # Note: This method and its availability varies greatly between exchanges
            if self.simulation_mode and hasattr(exchange, 'set_sandbox_mode'):
                try:
                    exchange.set_sandbox_mode(True)
                    logger.info("Attempting to enable Sandbox/Testnet Mode for simulation.")
                except Exception as e:
                     logger.warning(f"{Fore.YELLOW}Could not explicitly enable sandbox mode (might not be supported or required): {e}{Style.RESET_ALL}")

            # --- Load Markets (Crucial Step) ---
            logger.debug("Loading markets from exchange...")
            exchange.load_markets()
            logger.debug(f"Markets loaded successfully for {self.exchange_id.upper()}.")

            # --- Verify Timeframe ---
            if self.timeframe not in exchange.timeframes:
                logger.critical(f"{Fore.RED}Timeframe '{self.timeframe}' not supported by {self.exchange_id.upper()}. "
                             f"Available timeframes: {list(exchange.timeframes.keys())}. Exiting.{Style.RESET_ALL}")
                sys.exit(1)
            else:
                 logger.info(f"Timeframe '{self.timeframe}' confirmed available on exchange.")


            # --- Verify the trading symbol exists ---
            if self.symbol not in exchange.markets:
                available_symbols = list(exchange.markets.keys())
                hint = f"Available symbols: {available_symbols[:10]}..." if available_symbols else "No symbols found."
                logger.critical(f"{Fore.RED}Symbol '{self.symbol}' not found on {self.exchange_id.upper()}. "
                             f"{hint} Check your config file. Exiting.{Style.RESET_ALL}")
                sys.exit(1)
            else:
                logger.info(f"Trading symbol '{self.symbol}' confirmed available on exchange.")
                # Log market details for debugging
                # market_info = exchange.market(self.symbol)
                # logger.debug(f"Market details for {self.symbol}: {market_info}")


            # --- Final Connection Check (Optional but Recommended) ---
            # Try a simple, non-authenticated call like fetch_time or fetch_status
            try:
                server_time = exchange.fetch_time()
                logger.debug(f"Exchange server time: {pd.to_datetime(server_time, unit='ms')}")
            except Exception as e:
                logger.warning(f"{Fore.YELLOW}Optional check: Failed to fetch server time, but proceeding: {e}{Style.RESET_ALL}")


            logger.info(f"{Fore.GREEN}Successfully connected to {self.exchange_id.upper()} "
                        f"({Fore.YELLOW}SIMULATION MODE{Style.RESET_ALL}" if self.simulation_mode else f"{Fore.GREEN}LIVE MODE{Style.RESET_ALL}).")
            return exchange

        except AttributeError:
            logger.critical(f"{Fore.RED}Exchange ID '{self.exchange_id}' not found in ccxt library. Is it spelled correctly? Exiting.{Style.RESET_ALL}")
            sys.exit(1)
        except ccxt.AuthenticationError as e:
            mode = "simulation" if self.simulation_mode else "live"
            logger.critical(f"{Fore.RED}Authentication failed for {self.exchange_id.upper()} ({mode} mode): {e}. Check API keys/permissions. Exiting.{Style.RESET_ALL}")
            sys.exit(1)
        except (ccxt.ExchangeNotAvailable, ccxt.RequestTimeout, ccxt.NetworkError) as e:
             logger.critical(f"{Fore.RED}Could not connect to {self.exchange_id.upper()} ({type(e).__name__}): {e}. Check network or exchange status. Exiting.{Style.RESET_ALL}")
             sys.exit(1)
        except Exception as e:
            logger.critical(f"{Fore.RED}Unexpected error initializing exchange {self.exchange_id.upper()}: {e}{Style.RESET_ALL}", exc_info=True)
            sys.exit(1)

    # --- Data Fetching Methods ---

    @retry_api_call()
    def fetch_market_price(self) -> Optional[float]:
        """Fetches the last traded price for the trading symbol."""
        logger.debug(f"Fetching ticker for {self.symbol}...")
        ticker = self.exchange.fetch_ticker(self.symbol)
        if ticker and 'last' in ticker and ticker['last'] is not None:
            price = float(ticker['last'])
            logger.debug(f"Fetched last market price for {self.symbol}: {price}")
            return price
        else:
            logger.warning(f"{Fore.YELLOW}Could not fetch valid 'last' price from ticker for {self.symbol}. Ticker data: {ticker}{Style.RESET_ALL}")
            # Fallback: try fetching OHLCV and getting the last close price
            logger.debug(f"Attempting fallback: Fetching last OHLCV close for {self.symbol}...")
            ohlcv = self.fetch_historical_data(limit=1) # Fetch just the last candle
            if ohlcv is not None and not ohlcv.empty and 'close' in ohlcv.columns:
                last_close = ohlcv['close'].iloc[-1]
                logger.warning(f"{Fore.YELLOW}Using last candle close price as fallback: {last_close}{Style.RESET_ALL}")
                return float(last_close)
            else:
                logger.error(f"{Fore.RED}Fallback failed. Unable to determine current price for {self.symbol}.{Style.RESET_ALL}")
                return None


    @retry_api_call()
    def fetch_order_book(self) -> Optional[float]:
        """
        Fetches the order book and calculates the volume imbalance ratio
        (Total Ask Volume / Total Bid Volume) within the specified depth.
        Returns None on failure or if data is insufficient.
        """
        logger.debug(f"Fetching order book for {self.symbol} (depth: {self.order_book_depth})...")
        orderbook = self.exchange.fetch_order_book(self.symbol, limit=self.order_book_depth)
        bids = orderbook.get('bids', []) # List of [price, volume]
        asks = orderbook.get('asks', []) # List of [price, volume]

        if bids and asks:
            # Calculate total volume within the specified depth
            # Ensure data is float, handle potential None values defensively
            try:
                bid_volume = sum(float(bid[1]) for bid in bids if bid and len(bid) > 1 and bid[1] is not None)
                ask_volume = sum(float(ask[1]) for ask in asks if ask and len(ask) > 1 and ask[1] is not None)
            except (TypeError, ValueError) as e:
                 logger.error(f"{Fore.RED}Error converting order book volumes to float for {self.symbol}: {e}. Bids: {bids}, Asks: {asks}{Style.RESET_ALL}")
                 return None

            if bid_volume > 1e-9: # Use a small threshold instead of zero check for floating point safety
                imbalance_ratio = ask_volume / bid_volume
                logger.debug(
                    f"Order Book ({self.symbol}) - Top Bid: {bids[0][0]}, Top Ask: {asks[0][0]}, "
                    f"Bid Vol (Depth {self.order_book_depth}): {bid_volume:.4f}, Ask Vol (Depth {self.order_book_depth}): {ask_volume:.4f}, "
                    f"Imbalance (Ask/Bid): {imbalance_ratio:.3f}"
                )
                return imbalance_ratio
            elif ask_volume > 1e-9:
                # Handle zero bid volume - indicates extreme sell pressure or thin market
                logger.warning(f"{Fore.YELLOW}No significant bid volume found in the top {self.order_book_depth} levels for {self.symbol}. Ask Vol: {ask_volume:.4f}{Style.RESET_ALL}")
                return float('inf') # Return infinity to signify extreme ask dominance
            else:
                 # Handle zero bid AND ask volume
                logger.warning(f"{Fore.YELLOW}No significant bid or ask volume found in the top {self.order_book_depth} levels for {self.symbol}. Market may be inactive.{Style.RESET_ALL}")
                return None # Cannot calculate imbalance
        else:
            logger.warning(f"{Fore.YELLOW}Order book data incomplete or unavailable for {self.symbol}. Bids found: {len(bids)}, Asks found: {len(asks)}{Style.RESET_ALL}")
            return None

    @retry_api_call(max_retries=2, initial_delay=1) # Less aggressive retry for historical data
    def fetch_historical_data(self, limit: Optional[int] = None) -> Optional[pd.DataFrame]:
        """
        Fetches historical OHLCV data and returns it as a Pandas DataFrame,
        indexed by timestamp, with numeric columns.

        Args:
            limit: The number of candles to fetch. Defaults to a value sufficient
                   for the longest indicator calculation.

        Returns:
            A Pandas DataFrame with columns ['timestamp', 'open', 'high', 'low', 'close', 'volume'],
            indexed by 'timestamp', or None if fetching fails or data is insufficient.
        """
        required_limit = limit
        if required_limit is None:
             # Calculate required limit based on longest indicator period + buffer
             # Add 1 for diff/shift operations, add smoothing periods, add buffer
             required_limit = max(
                 self.volatility_window + 1,
                 self.ema_period,
                 self.rsi_period + 1, # RSI needs n+1 periods
                 self.macd_long_period + self.macd_signal_period, # MACD needs long EMA + signal EMA lookback
                 self.stoch_rsi_period + self.stoch_rsi_k_period + self.stoch_rsi_d_period + 1 # Stoch RSI needs underlying RSI + stochastic lookback + smoothing
             ) + 10 # Add a buffer

        logger.debug(f"Fetching {required_limit} historical OHLCV candles for {self.symbol} ({self.timeframe})...")
        try:
            # Fetch OHLCV data: [timestamp, open, high, low, close, volume]
            ohlcv = self.exchange.fetch_ohlcv(self.symbol, timeframe=self.timeframe, limit=required_limit)

            if not ohlcv or len(ohlcv) == 0:
                logger.warning(f"{Fore.YELLOW}No historical OHLCV data returned for {self.symbol} ({self.timeframe}).{Style.RESET_ALL}")
                return None

            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

            # --- Data Cleaning and Preparation ---
            # Convert timestamp to datetime and set as index
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            df.set_index('timestamp', inplace=True)

            # Convert OHLCV columns to numeric types, coercing errors to NaN
            for col in ['open', 'high', 'low', 'close', 'volume']:
                df[col] = pd.to_numeric(df[col], errors='coerce')

            # Drop rows with any NaN values that might have occurred during conversion or from exchange data
            initial_len = len(df)
            df.dropna(inplace=True)
            if len(df) < initial_len:
                logger.debug(f"Dropped {initial_len - len(df)} rows with NaN values from historical data.")

            # Check if sufficient data remains after cleaning
            if len(df) < required_limit // 2: # Check if we have at least roughly half the requested data
                 logger.warning(
                     f"{Fore.YELLOW}Insufficient historical data returned or remaining after cleaning for {self.symbol}. "
                     f"Fetched {len(ohlcv)} raw, {len(df)} clean candles, needed ~{required_limit}. Indicator results may be inaccurate or fail.{Style.RESET_ALL}"
                 )
                 # Return None if critically low data, otherwise proceed with caution
                 if len(df) < max(self.rsi_period + 1, self.macd_long_period): # Bare minimum for some calcs
                     return None


            logger.debug(f"Successfully fetched and processed {len(df)} historical candles for {self.symbol}.")
            return df

        except ccxt.BadSymbol as e:
             logger.error(f"{Fore.RED}Bad symbol error fetching historical data for {self.symbol}: {e}. Is the symbol format correct for {self.exchange_id}?{Style.RESET_ALL}")
             return None
        except Exception as e:
            logger.error(f"{Fore.RED}Error fetching or processing historical data for {self.symbol}: {e}{Style.RESET_ALL}", exc_info=True)
            return None

    @retry_api_call()
    def fetch_balance(self, currency_code: Optional[str] = None) -> float:
        """
        Fetches the free balance for a specific currency.
        Defaults to the quote currency of the trading symbol if not specified.

        Args:
            currency_code: The currency symbol (e.g., 'USDT', 'BTC'). If None, uses quote currency.

        Returns:
            The free balance as a float, or 0.0 if unavailable or error occurs.
        """
        if currency_code is None:
            try:
                market_info = self.exchange.market(self.symbol)
                currency_code = market_info['quote'] # e.g., 'USDT' for 'BTC/USDT:USDT'
            except Exception as e:
                 logger.error(f"{Fore.RED}Could not determine quote currency for symbol {self.symbol}: {e}. Cannot fetch balance.{Style.RESET_ALL}")
                 return 0.0

        logger.debug(f"Fetching balance for {currency_code}...")
        try:
            # Use fetch_balance with params if needed for specific account types (e.g., futures)
            # params = {'type': 'future'} # Example, adjust based on exchange needs
            balance_data = self.exchange.fetch_balance() # params=params

            # Accessing free balance safely using .get() with defaults
            # Structure can vary: {'free': {'USDT': 100}}, {'USDT': {'free': 100}}, etc.
            free_balance = 0.0
            if currency_code in balance_data:
                free_balance = balance_data[currency_code].get('free', 0.0)
            elif 'free' in balance_data:
                free_balance = balance_data['free'].get(currency_code, 0.0)
            elif 'info' in balance_data and isinstance(balance_data['info'], dict): # Check info dict for some exchanges
                 # This part is highly exchange-specific, example for Bybit USDT Perpetual Wallet Balance
                 if self.exchange_id == 'bybit' and 'result' in balance_data['info'] and currency_code in balance_data['info']['result']:
                     free_balance = balance_data['info']['result'][currency_code].get('available_balance', 0.0)
                 else: # Generic fallback within 'info' if structure is unknown
                     info_balance = balance_data['info'].get(currency_code, {})
                     free_balance = info_balance.get('free', info_balance.get('available', 0.0)) # Check common keys


            if free_balance is None: free_balance = 0.0 # Handle potential None value explicitly

            free_balance_float = float(free_balance)
            logger.info(f"Fetched free balance for {currency_code}: {free_balance_float}")
            return free_balance_float

        except ccxt.AuthenticationError:
             # If balance requires auth and we are in sim mode without keys, return dummy value
             if self.simulation_mode:
                 logger.warning(f"{Fore.YELLOW}Simulation mode: Returning dummy balance of 10000 {currency_code} as API keys might be missing.{Style.RESET_ALL}")
                 return 10000.0
             else:
                  logger.error(f"{Fore.RED}Authentication required to fetch balance for {currency_code}, but failed.{Style.RESET_ALL}")
                  return 0.0
        except Exception as e:
            logger.error(f"{Fore.RED}Could not fetch balance for {currency_code}: {e}{Style.RESET_ALL}", exc_info=True)
            return 0.0 # Return 0 on error to prevent issues downstream

    # --- Indicator Calculation Methods ---
    # Made static as they don't depend on instance state directly

    @staticmethod
    def calculate_volatility(close_prices: pd.Series, window: int) -> Optional[float]:
        """Calculates historical volatility (standard deviation of log returns)."""
        if close_prices is None or len(close_prices) < window + 1: # Need N+1 for N periods of returns
            logger.debug(f"Insufficient data for volatility calculation (need {window + 1}, got {len(close_prices) if close_prices is not None else 0}).")
            return None
        try:
            # Use log returns for volatility calculation (more stable for % changes)
            log_returns = np.log(close_prices / close_prices.shift(1))
            # Calculate rolling standard deviation of log returns
            volatility = log_returns.rolling(window=window, min_periods=window).std().iloc[-1]
            # Optional: Annualize volatility (depends heavily on timeframe interpretation)
            # volatility *= np.sqrt(periods_per_year) # e.g., sqrt(365*24*60) for 1m timeframe
            if pd.isna(volatility):
                logger.debug(f"Volatility calculation resulted in NaN (window={window}).")
                return None
            logger.debug(f"Calculated volatility ({window}-period): {volatility:.6f}")
            return float(volatility)
        except Exception as e:
            logger.error(f"Error calculating volatility: {e}", exc_info=True)
            return None

    @staticmethod
    def calculate_ema(close_prices: pd.Series, period: int) -> Optional[float]:
        """Calculates the Exponential Moving Average (EMA)."""
        if close_prices is None or len(close_prices) < period:
            logger.debug(f"Insufficient data for EMA calculation (need {period}, got {len(close_prices) if close_prices is not None else 0}).")
            return None
        try:
            ema = close_prices.ewm(span=period, adjust=False, min_periods=period).mean().iloc[-1]
            if pd.isna(ema):
                logger.debug(f"EMA calculation resulted in NaN (period={period}).")
                return None
            logger.debug(f"Calculated EMA ({period}-period): {ema:.4f}")
            return float(ema)
        except Exception as e:
            logger.error(f"Error calculating EMA: {e}", exc_info=True)
            return None

    @staticmethod
    def calculate_rsi(close_prices: pd.Series, period: int) -> Optional[float]:
        """Calculates the Relative Strength Index (RSI)."""
        if close_prices is None or len(close_prices) < period + 1: # Needs N+1 for initial diff
            logger.debug(f"Insufficient data for RSI calculation (need {period + 1}, got {len(close_prices) if close_prices is not None else 0}).")
            return None
        try:
            delta = close_prices.diff(1)
            gain = delta.where(delta > 0, 0.0).ewm(alpha=1/period, adjust=False, min_periods=period).mean()
            loss = -delta.where(delta < 0, 0.0).ewm(alpha=1/period, adjust=False, min_periods=period).mean()

            # Avoid division by zero
            rs = gain / loss.replace(0, 1e-9) # Replace 0 loss with tiny number

            rsi = 100.0 - (100.0 / (1.0 + rs))
            rsi_value = rsi.iloc[-1]

            if pd.isna(rsi_value):
                 logger.debug(f"RSI calculation resulted in NaN (period={period}). Gain={gain.iloc[-1]}, Loss={loss.iloc[-1]}")
                 return None

            logger.debug(f"Calculated RSI ({period}-period): {rsi_value:.2f}")
            return float(rsi_value)
        except Exception as e:
            logger.error(f"Error calculating RSI: {e}", exc_info=True)
            return None

    @staticmethod
    def calculate_macd(close_prices: pd.Series, short_period: int, long_period: int, signal_period: int) -> Tuple[Optional[float], Optional[float], Optional[float]]:
        """Calculates Moving Average Convergence Divergence (MACD), Signal line, and Histogram."""
        # Need enough data for the longest EMA plus the signal line smoothing
        min_len = long_period + signal_period -1 # Approximation
        if close_prices is None or len(close_prices) < min_len:
            logger.debug(f"Insufficient data for MACD calculation (need ~{min_len}, got {len(close_prices) if close_prices is not None else 0}).")
            return None, None, None
        try:
            ema_short = close_prices.ewm(span=short_period, adjust=False, min_periods=short_period).mean()
            ema_long = close_prices.ewm(span=long_period, adjust=False, min_periods=long_period).mean()
            macd_line = ema_short - ema_long
            signal_line = macd_line.ewm(span=signal_period, adjust=False, min_periods=signal_period).mean()
            histogram = macd_line - signal_line

            # Get the latest values
            macd_val = macd_line.iloc[-1]
            signal_val = signal_line.iloc[-1]
            hist_val = histogram.iloc[-1]

            # Check for NaNs
            if pd.isna(macd_val) or pd.isna(signal_val) or pd.isna(hist_val):
                logger.debug(f"MACD calculation resulted in NaN(s) ({short_period},{long_period},{signal_period}).")
                return None, None, None

            logger.debug(f"Calculated MACD ({short_period},{long_period},{signal_period}): MACD={macd_val:.4f}, Signal={signal_val:.4f}, Hist={hist_val:.4f}")
            return float(macd_val), float(signal_val), float(hist_val)
        except Exception as e:
            logger.error(f"Error calculating MACD: {e}", exc_info=True)
            return None, None, None

    @staticmethod
    def calculate_stoch_rsi(close_prices: pd.Series, rsi_period: int, stoch_period: int, k_period: int, d_period: int) -> Tuple[Optional[float], Optional[float]]:
        """Calculates Stochastic RSI %K and %D lines."""
        # Estimate minimum length needed: RSI lookback + Stoch lookback + K smoothing + D smoothing
        min_len = rsi_period + stoch_period + max(k_period, d_period) - 2 # Rough estimate
        if close_prices is None or len(close_prices) < min_len:
             logger.debug(f"Insufficient data for Stoch RSI calculation (need ~{min_len}, got {len(close_prices) if close_prices is not None else 0}).")
             return None, None
        try:
            # Calculate RSI first
            delta = close_prices.diff(1)
            gain = delta.where(delta > 0, 0.0).ewm(alpha=1/rsi_period, adjust=False).mean()
            loss = -delta.where(delta < 0, 0.0).ewm(alpha=1/rsi_period, adjust=False).mean()
            rs = gain / loss.replace(0, 1e-9)
            rsi = 100.0 - (100.0 / (1.0 + rs))
            rsi = rsi.dropna() # Drop initial NaNs from RSI calculation

            if len(rsi) < stoch_period:
                logger.debug(f"Insufficient RSI values for Stoch RSI calculation (need {stoch_period}, got {len(rsi)}).")
                return None, None

            # Calculate Stoch RSI (%K before smoothing)
            min_rsi = rsi.rolling(window=stoch_period, min_periods=stoch_period).min()
            max_rsi = rsi.rolling(window=stoch_period, min_periods=stoch_period).max()
            stoch_rsi = 100.0 * (rsi - min_rsi) / (max_rsi - min_rsi).replace(0, 1e-9) # Avoid division by zero if max=min
            stoch_rsi = stoch_rsi.dropna() # Drop NaNs from rolling window

            if len(stoch_rsi) < max(k_period, d_period):
                 logger.debug(f"Insufficient Stoch RSI values for smoothing (need {max(k_period, d_period)}, got {len(stoch_rsi)}).")
                 return None, None

            # Calculate %K (smoothed Stoch RSI) and %D (smoothed %K)
            stoch_k = stoch_rsi.rolling(window=k_period, min_periods=k_period).mean()
            stoch_d = stoch_k.rolling(window=d_period, min_periods=d_period).mean()

            k_val = stoch_k.iloc[-1]
            d_val = stoch_d.iloc[-1]

            if pd.isna(k_val) or pd.isna(d_val):
                logger.debug(f"Stoch RSI K or D calculation resulted in NaN ({rsi_period},{stoch_period},{k_period},{d_period}). K={k_val}, D={d_val}")
                return None, None

            logger.debug(f"Calculated Stoch RSI ({rsi_period},{stoch_period},{k_period},{d_period}): %K={k_val:.2f}, %D={d_val:.2f}")
            return float(k_val), float(d_val)
        except Exception as e:
             logger.error(f"Error calculating Stochastic RSI: {e}", exc_info=True)
             return None, None

    # --- Trading Logic Methods ---

    def calculate_order_size(self, base_currency: Optional[str] = None) -> float:
        """
        Calculates the order size in the quote currency (e.g., USDT),
        based on a percentage of free balance and potentially adjusted by volatility.

        Args:
            base_currency: The currency to calculate the size in (usually the quote currency).
                           Defaults to the symbol's quote currency.

        Returns:
            The calculated order size in the quote currency, or 0.0 if balance is too low,
            calculation fails, or size is below minimum.
        """
        quote_currency = base_currency
        if quote_currency is None:
             try:
                 market_info = self.exchange.market(self.symbol)
                 quote_currency = market_info['quote']
             except Exception as e:
                 logger.error(f"{Fore.RED}Could not determine quote currency for symbol {self.symbol}: {e}. Cannot calculate order size.{Style.RESET_ALL}")
                 return 0.0

        balance = self.fetch_balance(currency_code=quote_currency)
        if balance <= 0:
            logger.warning(f"{Fore.YELLOW}Insufficient balance ({balance:.4f} {quote_currency}) to calculate order size.{Style.RESET_ALL}")
            return 0.0

        # --- Base Size Calculation ---
        base_order_size_quote = balance * self.order_size_percentage
        logger.debug(f"Base order size (based on {self.order_size_percentage*100:.2f}% of balance): {base_order_size_quote:.4f} {quote_currency}")

        # --- Adjust size based on volatility (optional) ---
        final_size_quote = base_order_size_quote
        if self.volatility_multiplier > 0:
            # Fetch recent close prices for volatility calculation
            # Use a slightly larger window for potentially more stable volatility reading
            hist_data_vol = self.fetch_historical_data(limit=self.volatility_window + 5)
            volatility = None
            if hist_data_vol is not None and not hist_data_vol.empty:
                 volatility = self.calculate_volatility(hist_data_vol['close'], self.volatility_window)

            if volatility is not None and volatility > 1e-9: # Check if volatility is meaningful
                # Example adjustment: Decrease size in high vol, slightly increase in low vol. NEEDS CAREFUL TUNING.
                # Simple inverse relationship example:
                size_factor = 1 / (1 + volatility * self.volatility_multiplier * 100) # Multiplier scales the effect
                size_factor = max(0.5, min(1.5, size_factor)) # Clamp the factor to avoid extreme sizes

                final_size_quote = base_order_size_quote * size_factor
                logger.info(f"Volatility ({volatility:.5f}) adjustment factor: {size_factor:.3f}. Adjusted size: {final_size_quote:.4f} {quote_currency}")
            elif volatility is None:
                 logger.warning(f"{Fore.YELLOW}Could not calculate volatility, using base order size.{Style.RESET_ALL}")
            else:
                 logger.info(f"Volatility ({volatility:.5f}) is very low, using base order size.")
        else:
             logger.debug("Volatility adjustment disabled (multiplier is 0).")


        # --- Check Minimum Order Cost ---
        try:
            market_info = self.exchange.market(self.symbol)
            min_cost = market_info.get('limits', {}).get('cost', {}).get('min')

            if min_cost is not None and final_size_quote < min_cost:
                 logger.warning(f"{Fore.YELLOW}Calculated order size {final_size_quote:.4f} {quote_currency} is below exchange minimum cost {min_cost} {quote_currency}. Cannot place order. (Balance: {balance:.2f}){Style.RESET_ALL}")
                 return 0.0
            elif min_cost is not None:
                 logger.debug(f"Order size {final_size_quote:.4f} {quote_currency} meets minimum cost requirement ({min_cost} {quote_currency}).")

        except Exception as e:
             logger.error(f"{Fore.RED}Error checking market limits for {self.symbol}: {e}{Style.RESET_ALL}")
             # Proceed cautiously, place_order might still fail if size is too small
             pass


        # Log final calculated size
        logger.info(f"{Fore.CYAN}Calculated final order size: {final_size_quote:.4f} {quote_currency} (Balance: {balance:.2f} {quote_currency}){Style.RESET_ALL}")
        return final_size_quote


    def compute_trade_signal_score(self, price: float, indicators: Dict[str, Optional[Union[float, Tuple[Optional[float], ...]]]], orderbook_imbalance: Optional[float]) -> Tuple[int, List[str]]:
        """
        Computes a trade signal score based on various technical indicators and order book imbalance.
        Positive score suggests LONG, negative suggests SHORT. Higher absolute value indicates stronger signal.

        Args:
            price: The current market price.
            indicators: A dictionary containing calculated indicator values (ema, rsi, macd_line, etc.).
            orderbook_imbalance: The calculated order book imbalance ratio (AskVol / BidVol).

        Returns:
            A tuple containing the integer signal score and a list of strings explaining the score components.
        """
        score = 0.0 # Use float for intermediate calculations
        reasons = []

        # --- Indicator Availability Check ---
        # Ensure we have the necessary indicators before proceeding
        required_inds = ['ema', 'rsi', 'macd_line', 'macd_signal', 'stoch_k', 'stoch_d']
        missing_inds = [ind for ind in required_inds if ind not in indicators or indicators[ind] is None]
        if missing_inds:
            logger.warning(f"{Fore.YELLOW}Cannot compute full signal score, missing indicators: {missing_inds}{Style.RESET_ALL}")
            # Optionally return 0 or compute partial score
            # return 0, ["Signal calculation skipped due to missing indicators."]

        # 1. Order Book Imbalance (Score: +/- 1)
        # Note: High imbalance (>> 1) means more ASKS (sell pressure)
        # Note: Low imbalance (<< 1) means more BIDS (buy pressure)
        if orderbook_imbalance is not None:
            if orderbook_imbalance < (1.0 / self.imbalance_threshold): # Significantly more bid volume
                score += 1.0
                reasons.append(f"{Fore.GREEN}[+1.0] OB Buy Pressure (Imb: {orderbook_imbalance:.2f} < {1.0/self.imbalance_threshold:.2f}){Style.RESET_ALL}")
            elif orderbook_imbalance > self.imbalance_threshold: # Significantly more ask volume
                score -= 1.0
                reasons.append(f"{Fore.RED}[-1.0] OB Sell Pressure (Imb: {orderbook_imbalance:.2f} > {self.imbalance_threshold:.2f}){Style.RESET_ALL}")
            else:
                 reasons.append(f"{Fore.WHITE}[ 0.0] OB Balanced (Imb: {orderbook_imbalance:.2f}){Style.RESET_ALL}")
        else:
             reasons.append(f"{Fore.WHITE}[ 0.0] OB Data N/A{Style.RESET_ALL}")


        # 2. EMA Trend (Score: +/- 1)
        ema = indicators.get('ema')
        if ema is not None:
            if price > ema * 1.0002: # Price significantly above EMA (added small buffer)
                score += 1.0
                reasons.append(f"{Fore.GREEN}[+1.0] Price > EMA ({price:.2f} > {ema:.2f}){Style.RESET_ALL}")
            elif price < ema * 0.9998: # Price significantly below EMA
                score -= 1.0
                reasons.append(f"{Fore.RED}[-1.0] Price < EMA ({price:.2f} < {ema:.2f}){Style.RESET_ALL}")
            else:
                 reasons.append(f"{Fore.WHITE}[ 0.0] Price near EMA ({price:.2f} ~ {ema:.2f}){Style.RESET_ALL}")
        else:
            reasons.append(f"{Fore.WHITE}[ 0.0] EMA N/A{Style.RESET_ALL}")

        # 3. RSI Momentum/Overbought/Oversold (Score: +/- 1)
        rsi = indicators.get('rsi')
        rsi_oversold = 35 # Adjusted levels for more sensitivity in scalping
        rsi_overbought = 65
        if rsi is not None:
            if rsi < rsi_oversold:
                score += 1.0 # Oversold condition, potential reversal up
                reasons.append(f"{Fore.GREEN}[+1.0] RSI Oversold ({rsi:.1f} < {rsi_oversold}){Style.RESET_ALL}")
            elif rsi > rsi_overbought:
                score -= 1.0 # Overbought condition, potential reversal down
                reasons.append(f"{Fore.RED}[-1.0] RSI Overbought ({rsi:.1f} > {rsi_overbought}){Style.RESET_ALL}")
            # Optional: Mid-range momentum (e.g., score based on crossing 50)
            # elif rsi > 52: score += 0.2
            # elif rsi < 48: score -= 0.2
            else:
                reasons.append(f"{Fore.WHITE}[ 0.0] RSI Neutral ({rsi:.1f}){Style.RESET_ALL}")
        else:
            reasons.append(f"{Fore.WHITE}[ 0.0] RSI N/A{Style.RESET_ALL}")


        # 4. MACD Momentum/Cross (Score: +/- 1 based on cross, +/- 0.5 based on histogram)
        macd_line = indicators.get('macd_line')
        macd_signal = indicators.get('macd_signal')
        macd_hist = indicators.get('macd_hist') # Calculated as macd_line - macd_signal
        if macd_line is not None and macd_signal is not None and macd_hist is not None:
            # Bullish Crossover / Positive Momentum
            if macd_line > macd_signal:
                score += 1.0
                reasons.append(f"{Fore.GREEN}[+1.0] MACD Line > Signal ({macd_line:.4f} > {macd_signal:.4f}){Style.RESET_ALL}")
                # Add score for positive histogram (momentum strengthening)
                if macd_hist > 0: # Add check for increasing histogram?
                     # score += 0.5
                     # reasons.append(f"{Fore.GREEN}[+0.5] MACD Hist > 0 ({macd_hist:.4f}){Style.RESET_ALL}")
                     pass # Keep it simple for now
            # Bearish Crossover / Negative Momentum
            else: # macd_line <= macd_signal
                score -= 1.0
                reasons.append(f"{Fore.RED}[-1.0] MACD Line <= Signal ({macd_line:.4f} <= {macd_signal:.4f}){Style.RESET_ALL}")
                 # Add score for negative histogram (momentum strengthening)
                if macd_hist < 0:
                     # score -= 0.5
                     # reasons.append(f"{Fore.RED}[-0.5] MACD Hist < 0 ({macd_hist:.4f}){Style.RESET_ALL}")
                    pass
        else:
            reasons.append(f"{Fore.WHITE}[ 0.0] MACD N/A{Style.RESET_ALL}")


        # 5. Stochastic RSI Overbought/Oversold & Cross (Score: +/- 1)
        stoch_k = indicators.get('stoch_k')
        stoch_d = indicators.get('stoch_d')
        stoch_oversold = 25 # Adjusted levels
        stoch_overbought = 75
        if stoch_k is not None and stoch_d is not None:
            # Oversold condition (both lines low)
            if stoch_k < stoch_oversold and stoch_d < stoch_oversold:
                score += 1.0
                reasons.append(f"{Fore.GREEN}[+1.0] StochRSI Oversold (K={stoch_k:.1f}, D={stoch_d:.1f} < {stoch_oversold}){Style.RESET_ALL}")
            # Overbought condition (both lines high)
            elif stoch_k > stoch_overbought and stoch_d > stoch_overbought:
                score -= 1.0
                reasons.append(f"{Fore.RED}[-1.0] StochRSI Overbought (K={stoch_k:.1f}, D={stoch_d:.1f} > {stoch_overbought}){Style.RESET_ALL}")
            # Bullish Crossover (K crosses above D, ideally below overbought)
            # elif stoch_k > stoch_d and stoch_d < stoch_overbought: # Add previous state check for cleaner signal?
            #    score += 0.5
            #    reasons.append(f"{Fore.GREEN}[+0.5] StochRSI K > D (K={stoch_k:.1f}, D={stoch_d:.1f}){Style.RESET_ALL}")
            # Bearish Crossover (K crosses below D, ideally above oversold)
            # elif stoch_k < stoch_d and stoch_d > stoch_oversold:
            #    score -= 0.5
            #    reasons.append(f"{Fore.RED}[-0.5] StochRSI K < D (K={stoch_k:.1f}, D={stoch_d:.1f}){Style.RESET_ALL}")
            else:
                 reasons.append(f"{Fore.WHITE}[ 0.0] StochRSI Neutral (K={stoch_k:.1f}, D={stoch_d:.1f}){Style.RESET_ALL}")
        else:
            reasons.append(f"{Fore.WHITE}[ 0.0] StochRSI N/A{Style.RESET_ALL}")


        # --- Final Score ---
        final_score = int(round(score)) # Round to nearest integer
        logger.debug(f"Signal score calculated: {final_score} (Raw: {score:.2f})")
        return final_score, reasons


    # Use retry decorator for placing orders as well
    @retry_api_call(max_retries=2, initial_delay=2)
    def place_order(
        self,
        side: str,
        order_size_quote: float, # Size in quote currency (e.g., USDT)
        confidence_level: int, # The signal score
        order_type: str,
        limit_price: Optional[float] = None, # Required for limit orders
        stop_loss_price: Optional[float] = None,
        take_profit_price: Optional[float] = None,
        reduce_only: bool = False, # Parameter for closing orders
    ) -> Optional[Dict[str, Any]]:
        """
        Places a trade order on the exchange or simulates it. Includes precision handling
        and minimum order size checks based on market data.

        Args:
            side: 'buy' or 'sell'.
            order_size_quote: The desired order size in the quote currency (e.g., USDT).
            confidence_level: The signal score associated with this order.
            order_type: 'market' or 'limit'.
            limit_price: The price for a limit order. Must be provided if order_type is 'limit'.
            stop_loss_price: The stop-loss trigger price (syntax may vary by exchange).
            take_profit_price: The take-profit trigger price (syntax may vary by exchange).
            reduce_only: If True, mark the order as reduce-only (for closing positions).

        Returns:
            A dictionary representing the order (simulated or actual ccxt order structure)
            or None if placement fails validation or API call fails.
        """
        # --- Pre-computation and Validation ---
        try:
            market_info = self.exchange.market(self.symbol)
            base_currency = market_info['base']   # e.g., BTC
            quote_currency = market_info['quote'] # e.g., USDT
            limits = market_info.get('limits', {})
            amount_limits = limits.get('amount', {})
            cost_limits = limits.get('cost', {})
            price_limits = limits.get('price', {})
            precision = market_info.get('precision', {})
            amount_precision = precision.get('amount')
            price_precision = precision.get('price')

            # Ensure precision values are usable (e.g., integer for decimal places)
            # CCXT often provides precision as 10**(-decimals) or number of decimals directly
            # This needs careful handling based on how ccxt structures it for the specific exchange.
            # Assuming `amount_to_precision` and `price_to_precision` handle this.

        except Exception as e:
             logger.error(f"{Fore.RED}Failed to get market info/limits for {self.symbol}: {e}. Cannot place order.{Style.RESET_ALL}")
             return None

        current_price = self.fetch_market_price()
        if current_price is None:
            logger.error(f"{Fore.RED}Cannot place {side} order: Failed to fetch current market price.{Style.RESET_ALL}")
            return None

        # --- Calculate order size in BASE currency ---
        if current_price <= 1e-9: # Avoid division by zero/tiny numbers
             logger.error(f"{Fore.RED}Current price ({current_price}) is near zero. Cannot calculate base amount.{Style.RESET_ALL}")
             return None
        order_size_base = order_size_quote / current_price # Size in base currency (e.g., BTC)

        # --- Apply Precision ---
        try:
            amount_precise_str = self.exchange.amount_to_precision(self.symbol, order_size_base)
            amount_precise = float(amount_precise_str)

            limit_price_precise = None
            if order_type == "limit":
                if limit_price is None:
                    logger.error(f"{Fore.RED}Limit price is required for limit orders.{Style.RESET_ALL}")
                    return None
                limit_price_precise_str = self.exchange.price_to_precision(self.symbol, limit_price)
                limit_price_precise = float(limit_price_precise_str)

            stop_loss_price_precise = None
            if stop_loss_price is not None:
                stop_loss_price_precise_str = self.exchange.price_to_precision(self.symbol, stop_loss_price)
                stop_loss_price_precise = float(stop_loss_price_precise_str)

            take_profit_price_precise = None
            if take_profit_price is not None:
                take_profit_price_precise_str = self.exchange.price_to_precision(self.symbol, take_profit_price)
                take_profit_price_precise = float(take_profit_price_precise_str)

        except Exception as e:
            logger.error(f"{Fore.RED}Error applying precision to order values: {e}. Order values: Amount={order_size_base}, Limit={limit_price}, SL={stop_loss_price}, TP={take_profit_price}{Style.RESET_ALL}")
            return None

        # --- Check Minimum Order Amount ---
        min_amount = amount_limits.get('min')
        if min_amount is not None and amount_precise < min_amount:
             logger.warning(f"{Fore.YELLOW}Calculated precise order amount {amount_precise:.8f} {base_currency} "
                            f"is below exchange minimum amount {min_amount} {base_currency}. Cannot place order.{Style.RESET_ALL}")
             return None

        # --- Prepare SL/TP Parameters (Highly Exchange Specific!) ---
        params = {}
        # Example for Bybit USDT perpetuals (check ccxt docs for your exchange)
        # These might need to be trigger prices, or they might be automatically converted
        if stop_loss_price_precise is not None:
             # Bybit uses 'stopLoss', expects a string representation of the price
            params['stopLoss'] = self.exchange.price_to_precision(self.symbol, stop_loss_price_precise)
        if take_profit_price_precise is not None:
             # Bybit uses 'takeProfit', expects a string representation of the price
            params['takeProfit'] = self.exchange.price_to_precision(self.symbol, take_profit_price_precise)
        if reduce_only:
            params['reduce_only'] = True # Common parameter name, but check exchange docs
            params['close_on_trigger'] = True # Some exchanges might use this for SL/TP on reduce_only orders

        # Log prepared parameters for debugging
        logger.debug(f"Prepared order params: Side={side}, Type={order_type}, Amount={amount_precise}, LimitPrice={limit_price_precise}, Params={params}")


        # --- Simulation Mode ---
        if self.simulation_mode:
            sim_id = f"sim_{int(time.time() * 1000)}_{side[:1]}"
            sim_entry_price = limit_price_precise if order_type == "limit" else current_price # Simulate fill at current price for market
            sim_cost = amount_precise * sim_entry_price
            sim_status = 'open' if order_type == 'limit' else 'closed' # Simulate market fill instantly
            simulated_order = {
                "id": sim_id,
                "clientOrderId": sim_id, # Simulate client order ID
                "timestamp": int(time.time() * 1000),
                "datetime": pd.to_datetime('now', utc=True).isoformat(),
                "symbol": self.symbol,
                "type": order_type,
                "side": side,
                "amount": amount_precise,
                "price": limit_price_precise if order_type == "limit" else None, # CCXT standard: price is None for market orders
                "average": sim_entry_price if sim_status == 'closed' else None, # Avg price only if filled
                "cost": sim_cost if sim_status == 'closed' else 0.0,
                "status": sim_status,
                "filled": amount_precise if sim_status == 'closed' else 0.0,
                "remaining": 0.0 if sim_status == 'closed' else amount_precise,
                "reduceOnly": reduce_only, # Store reduceOnly flag
                "info": { # Add custom info useful for the bot
                     "simulated": True,
                     "stopLoss": stop_loss_price_precise,
                     "takeProfit": take_profit_price_precise,
                     "confidence": confidence_level,
                     "initial_quote_size": order_size_quote,
                     "entry_price_estimate": sim_entry_price # Store the estimated entry/fill price
                 }
            }
            log_color = Fore.GREEN if side == 'buy' else Fore.RED
            action = "Closing" if reduce_only else "Entry"
            logger.info(
                f"{log_color}[SIMULATION] Placing {'Limit' if order_type == 'limit' else 'Market'} {side.upper()} {action} Order: "
                f"ID: {simulated_order['id']}, Size: {simulated_order['amount']:.6f} {base_currency}, "
                f"Price: {simulated_order['price'] or '~'+str(current_price):.2f}, "
                f"Est. Value: {sim_cost:.2f} {quote_currency}, "
                f"SL: {simulated_order['info']['stopLoss']}, TP: {simulated_order['info']['takeProfit']}, "
                f"Confidence: {confidence_level}, ReduceOnly: {reduce_only}{Style.RESET_ALL}"
            )
            # Simulate potential fill for limit orders after a short delay in simulation
            # if order_type == 'limit': time.sleep(0.1) # Tiny sleep
            return simulated_order

        # --- Live Trading Mode ---
        else:
            order = None
            log_color = Fore.GREEN if side == 'buy' else Fore.RED
            action = "Closing" if reduce_only else "Entry"
            logger.info(f"{log_color}Attempting to place LIVE {order_type.upper()} {side.upper()} {action} order...")
            logger.info(f" -> Details: Size={amount_precise} {base_currency}, Limit={limit_price_precise}, SL={stop_loss_price_precise}, TP={take_profit_price_precise}, ReduceOnly={reduce_only}")

            try:
                if order_type == "market":
                    # Market orders usually don't allow SL/TP directly on creation, they are added later or via separate orders.
                    # Check exchange specifics. If SL/TP can be added here, include `params`.
                    # Many exchanges require SL/TP orders to be placed *separately* after the main order fills.
                    # For simplicity here, we assume SL/TP in `params` works for market orders if the exchange supports it.
                    market_params = params.copy() # Avoid modifying original params dict
                    order = self.exchange.create_market_order(
                        symbol=self.symbol,
                        side=side,
                        amount=amount_precise,
                        params=market_params # Pass SL/TP if supported
                    )
                elif order_type == "limit":
                    limit_params = params.copy()
                    order = self.exchange.create_limit_order(
                        symbol=self.symbol,
                        side=side,
                        amount=amount_precise,
                        price=limit_price_precise,
                        params=limit_params # Pass SL/TP and reduce_only
                    )
                else:
                    logger.error(f"{Fore.RED}Unsupported order type for live trading: {order_type}{Style.RESET_ALL}")
                    return None # Should have been caught by validation, but safeguard here

                # Log successful order placement (using data from the returned order dict)
                # Use .get() for optional fields like average, cost which might not be present immediately
                order_id = order.get('id', 'N/A')
                order_status = order.get('status', 'unknown')
                order_price = order.get('price') or limit_price_precise # Limit price if available
                order_avg_price = order.get('average')
                order_filled = order.get('filled', 0.0)
                order_cost = order.get('cost', 0.0)

                # Determine effective price for logging
                log_price_info = f"Price: {order_price:.2f}" if order_price else f"Market (~{current_price:.2f})"
                if order_avg_price: log_price_info += f", Avg: {order_avg_price:.2f}"

                logger.info(
                    f"{log_color}---> LIVE Order Placed Successfully: "
                    f"ID: {order_id}, Type: {order['type']}, Side: {order['side'].upper()}, "
                    f"Amount: {order['amount']:.6f}, Filled: {order_filled:.6f}, {log_price_info}, Cost: {order_cost:.2f}, "
                    f"Status: {order_status}, ReduceOnly: {order.get('reduceOnly', params.get('reduce_only', 'N/A'))}"
                    # Log SL/TP attempts - actual placement depends on exchange execution
                    f", SL Attempt: {params.get('stopLoss', 'N/A')}, TP Attempt: {params.get('takeProfit', 'N/A')}"
                    f", Confidence: {confidence_level}{Style.RESET_ALL}"
                )

                # Add custom info to the order dict for internal tracking if needed
                order['bot_custom_info'] = {
                     "confidence": confidence_level,
                     "initial_quote_size": order_size_quote,
                     "attempted_sl": stop_loss_price_precise,
                     "attempted_tp": take_profit_price_precise
                 }

                # CRITICAL: If SL/TP needs separate orders, place them *here* after confirming the main order placement.
                # This requires fetching the order status to confirm it's filled (for market) or open (for limit)
                # and then creating separate stop_loss_limit or take_profit_limit orders.
                # Example (conceptual):
                # if order and order_status in ['open', 'closed']: # Check if order seems active/filled
                #     if stop_loss_price_precise: self.place_stop_loss_order(order, stop_loss_price_precise)
                #     if take_profit_price_precise: self.place_take_profit_order(order, take_profit_price_precise)

                return order

            # --- Specific Error Handling for Orders ---
            except ccxt.InsufficientFunds as e:
                logger.error(f"{Fore.RED}LIVE Order Failed (Insufficient Funds): Cannot place {side} order for {amount_precise} {base_currency}. Check balance/margin. {e}{Style.RESET_ALL}")
                # Maybe fetch balance again here to log current state
                self.fetch_balance(quote_currency)
                return None
            except ccxt.InvalidOrder as e:
                # This often happens due to incorrect parameters, precision, or size/price limits
                logger.error(f"{Fore.RED}LIVE Order Failed (Invalid Order): Parameters likely incorrect or violate exchange rules. Error: {e}{Style.RESET_ALL}")
                logger.error(f" -> Attempted: Side={side}, Type={order_type}, Amount={amount_precise}, Limit={limit_price_precise}, SL={stop_loss_price_precise}, TP={take_profit_price_precise}, ReduceOnly={reduce_only}")
                # Log market limits again for comparison
                logger.error(f" -> Market Limits: Amount={amount_limits}, Cost={cost_limits}, Price={price_limits}")
                return None
            except ccxt.OrderNotFound as e: # Should not happen during creation, but handle defensively
                logger.error(f"{Fore.RED}LIVE Order Failed (Order Not Found post-creation?): {e}{Style.RESET_ALL}")
                return None
            except ccxt.ExchangeError as e: # Catch other specific exchange errors
                 logger.error(f"{Fore.RED}LIVE Order Failed (Exchange Error): {type(e).__name__} - {e}{Style.RESET_ALL}", exc_info=False) # exc_info=False usually sufficient
                 return None
            except Exception as e: # Catch any other unexpected error during order placement
                logger.error(f"{Fore.RED}LIVE Order Failed (Unexpected Error): Failed to place {side} order. Error: {e}{Style.RESET_ALL}", exc_info=True)
                return None


    def manage_positions(self) -> None:
        """
        Manages open positions: checks for SL/TP triggers, time-based exits,
        and activates/updates trailing stop losses. Places closing orders if triggers occur.
        """
        if not self.open_positions:
            # logger.debug("No open positions to manage.")
            return

        logger.debug(f"Managing {len(self.open_positions)} open position(s)...")
        current_price = self.fetch_market_price()
        if current_price is None:
            logger.warning(f"{Fore.YELLOW}Cannot manage positions: Failed to fetch current market price.{Style.RESET_ALL}")
            return

        # Iterate over a copy of the list to allow removal during iteration
        positions_to_remove = []
        for position in self.open_positions:
            try:
                position_id = position.get("id", "N/A") # Use order ID if available
                entry_price = position["entry_price"]
                position_side = position["side"] # 'buy' or 'sell'
                order_size = position["size"] # Amount in base currency
                entry_time = position["entry_time"]
                confidence = position.get("confidence", 0)
                base_sl_price = position["stop_loss"] # The initial SL price
                base_tp_price = position["take_profit"] # The initial TP price

                # --- Trailing Stop State ---
                # Check if TSL is enabled globally and for this position type
                tsl_enabled = self.trailing_stop_loss_percentage is not None and self.trailing_stop_loss_percentage > 0
                current_trailing_sl_price = position.get("trailing_stop_loss") # Price level of the current TSL
                is_tsl_active = current_trailing_sl_price is not None

                exit_reason = None # Track why we are exiting

                # --- 1. Time-Based Exit Check ---
                if self.time_based_exit_minutes and self.time_based_exit_minutes > 0:
                    time_elapsed_minutes = (time.time() - entry_time) / 60
                    if time_elapsed_minutes >= self.time_based_exit_minutes:
                        logger.info(
                            f"{Fore.YELLOW}Time-based exit triggered for {position_side.upper()} position "
                            f"(ID: {position_id}, Age: {time_elapsed_minutes:.1f} mins >= {self.time_based_exit_minutes} mins){Style.RESET_ALL}"
                        )
                        exit_reason = "Time Limit Reached"

                # --- 2. SL/TP Check ---
                # Determine the effective stop loss to check against (TSL if active, otherwise base SL)
                effective_stop_loss_price = current_trailing_sl_price if is_tsl_active else base_sl_price

                if position_side == "buy": # Managing a LONG position
                    # Stop Loss Check
                    if effective_stop_loss_price is not None and current_price <= effective_stop_loss_price:
                        logger.info(
                            f"{Fore.RED}Stop-loss triggered for LONG position (ID: {position_id}). "
                            f"Price ({current_price:.4f}) <= SL ({effective_stop_loss_price:.4f})"
                            f"{' (Trailing)' if is_tsl_active else ''}{Style.RESET_ALL}"
                        )
                        exit_reason = "Stop Loss Hit"
                    # Take Profit Check (use base TP, TSL handles profit locking)
                    elif base_tp_price is not None and current_price >= base_tp_price:
                        logger.info(
                            f"{Fore.GREEN}Take-profit triggered for LONG position (ID: {position_id}). "
                            f"Price ({current_price:.4f}) >= TP ({base_tp_price:.4f}){Style.RESET_ALL}"
                        )
                        exit_reason = "Take Profit Hit"
                    # Trailing Stop Activation/Update Logic (only if not already exiting)
                    elif tsl_enabled and not exit_reason:
                        # --- Activation ---
                        # Activate TSL if price moves significantly in favor. Example: crosses base TP.
                        # Alternative: Activate if price moves X% above entry (e.g., half the TP distance).
                        should_activate_tsl = not is_tsl_active and (
                            (base_tp_price is not None and current_price >= base_tp_price) # or
                            # current_price >= entry_price * (1 + 0.5 * self.base_take_profit_pct)
                        )
                        if should_activate_tsl:
                            # Calculate initial TSL price slightly below current price
                            new_trailing_sl = current_price * (1 - self.trailing_stop_loss_percentage)
                            # Ensure TSL starts at least slightly above entry price (breakeven+)
                            new_trailing_sl = max(new_trailing_sl, entry_price * (1 + 0.0005)) # e.g., 0.05% above entry
                            # Apply price precision
                            new_trailing_sl = float(self.exchange.price_to_precision(self.symbol, new_trailing_sl))

                            position["trailing_stop_loss"] = new_trailing_sl # Store the new TSL price
                            is_tsl_active = True # Mark as active for this iteration
                            current_trailing_sl_price = new_trailing_sl # Update local var
                            logger.info(
                                f"{Fore.MAGENTA}Trailing stop-loss ACTIVATED for LONG (ID: {position_id}) at {new_trailing_sl:.4f} "
                                f"(Current Price: {current_price:.4f}){Style.RESET_ALL}"
                            )

                        # --- Update ---
                        # If TSL is already active, check if price moved higher to update TSL upwards
                        elif is_tsl_active:
                            potential_new_tsl = current_price * (1 - self.trailing_stop_loss_percentage)
                            # Only update if the potential new TSL is higher than the current one
                            if potential_new_tsl > current_trailing_sl_price:
                                # Apply precision
                                potential_new_tsl = float(self.exchange.price_to_precision(self.symbol, potential_new_tsl))
                                position["trailing_stop_loss"] = potential_new_tsl # Update stored TSL
                                logger.info(
                                    f"{Fore.MAGENTA}Trailing stop-loss UPDATED for LONG (ID: {position_id}) to {potential_new_tsl:.4f} "
                                    f"(Current Price: {current_price:.4f}){Style.RESET_ALL}"
                                )
                                # No need to update local current_trailing_sl_price here, it's read next loop

                elif position_side == "sell": # Managing a SHORT position
                    # Stop Loss Check
                    if effective_stop_loss_price is not None and current_price >= effective_stop_loss_price:
                        logger.info(
                            f"{Fore.RED}Stop-loss triggered for SHORT position (ID: {position_id}). "
                            f"Price ({current_price:.4f}) >= SL ({effective_stop_loss_price:.4f})"
                            f"{' (Trailing)' if is_tsl_active else ''}{Style.RESET_ALL}"
                        )
                        exit_reason = "Stop Loss Hit"
                    # Take Profit Check
                    elif base_tp_price is not None and current_price <= base_tp_price:
                        logger.info(
                            f"{Fore.GREEN}Take-profit triggered for SHORT position (ID: {position_id}). "
                            f"Price ({current_price:.4f}) <= TP ({base_tp_price:.4f}){Style.RESET_ALL}"
                        )
                        exit_reason = "Take Profit Hit"
                    # Trailing Stop Activation/Update Logic (only if not already exiting)
                    elif tsl_enabled and not exit_reason:
                        # --- Activation ---
                        should_activate_tsl = not is_tsl_active and (
                             (base_tp_price is not None and current_price <= base_tp_price) # or
                            # current_price <= entry_price * (1 - 0.5 * self.base_take_profit_pct)
                        )
                        if should_activate_tsl:
                            new_trailing_sl = current_price * (1 + self.trailing_stop_loss_percentage)
                             # Ensure TSL starts at least slightly below entry price (breakeven+)
                            new_trailing_sl = min(new_trailing_sl, entry_price * (1 - 0.0005)) # e.g., 0.05% below entry
                            # Apply price precision
                            new_trailing_sl = float(self.exchange.price_to_precision(self.symbol, new_trailing_sl))

                            position["trailing_stop_loss"] = new_trailing_sl
                            is_tsl_active = True
                            current_trailing_sl_price = new_trailing_sl
                            logger.info(
                                f"{Fore.MAGENTA}Trailing stop-loss ACTIVATED for SHORT (ID: {position_id}) at {new_trailing_sl:.4f} "
                                f"(Current Price: {current_price:.4f}){Style.RESET_ALL}"
                            )

                        # --- Update ---
                        elif is_tsl_active:
                            potential_new_tsl = current_price * (1 + self.trailing_stop_loss_percentage)
                            # Only update if the potential new TSL is lower than the current one
                            if potential_new_tsl < current_trailing_sl_price:
                                # Apply precision
                                potential_new_tsl = float(self.exchange.price_to_precision(self.symbol, potential_new_tsl))
                                position["trailing_stop_loss"] = potential_new_tsl
                                logger.info(
                                    f"{Fore.MAGENTA}Trailing stop-loss UPDATED for SHORT (ID: {position_id}) to {potential_new_tsl:.4f} "
                                    f"(Current Price: {current_price:.4f}){Style.RESET_ALL}"
                                )


                # --- 3. Execute Exit Order ---
                if exit_reason:
                    logger.info(f"Initiating closing order for {position_side.upper()} position (ID: {position_id}) due to: {exit_reason}")
                    # Place a market order to close the position
                    close_side = "sell" if position_side == "buy" else "buy"
                    # Use the original 'order_size' (amount in base currency) stored in the position dict
                    # We need to calculate the quote value equivalent for place_order if it expects that
                    # However, place_order was refactored to accept base amount, so we use order_size directly.
                    # Let's double check place_order signature - it expects order_size_quote. Need conversion.
                    close_order_quote_size = order_size * current_price # Approximate quote value at current price

                    closing_order = self.place_order(
                        side=close_side,
                        order_size_quote=close_order_quote_size, # Pass quote value
                        confidence_level=confidence, # Pass original confidence (optional)
                        order_type="market", # Always use market order for reliable/immediate exit
                        reduce_only=True # IMPORTANT: Mark as reduce-only to ensure it only closes position
                        # SL/TP params usually not needed/supported for market close order
                    )
                    if closing_order:
                        exit_price = closing_order.get('average') or closing_order.get('info',{}).get('entry_price_estimate') or current_price
                        logger.info(f"{Fore.CYAN}---> Position (ID: {position_id}) closed via market order. Side: {close_side.upper()}, Size: {closing_order.get('amount', order_size):.6f}, Approx Exit Price: {exit_price:.4f}{Style.RESET_ALL}")

                        # --- PnL Calculation (Simplified Example) ---
                        pnl_pct = 0.0
                        pnl_quote = 0.0
                        if position_side == "buy":
                            pnl_quote = (exit_price - entry_price) * order_size
                            if entry_price > 0: pnl_pct = (exit_price / entry_price - 1) * 100
                        else: # Short position
                            pnl_quote = (entry_price - exit_price) * order_size
                            if entry_price > 0: pnl_pct = (entry_price / exit_price - 1) * 100

                        pnl_color = Fore.GREEN if pnl_quote > 0 else Fore.RED
                        logger.info(f"{pnl_color}Estimated PnL for trade {position_id}: {pnl_quote:.4f} {self.exchange.market(self.symbol)['quote']} ({pnl_pct:.3f}%){Style.RESET_ALL}")
                        # self.daily_pnl += pnl_quote # Accumulate PnL

                        positions_to_remove.append(position) # Mark for removal AFTER iteration
                    else:
                        # CRITICAL: Failed to close position! Requires manual intervention.
                        logger.critical(f"{Fore.RED}CRITICAL: Failed to place closing order for position (ID: {position_id}, Side: {position_side}, Size: {order_size}). Position remains open. MANUAL INTERVENTION REQUIRED.{Style.RESET_ALL}")
                        # Consider adding alerting mechanism here (email, telegram etc.)
                    # continue # Move to the next position (already handled by loop)

            except Exception as e:
                 logger.error(f"{Fore.RED}Error managing position {position.get('id', 'N/A')}: {e}{Style.RESET_ALL}", exc_info=True)
                 # Decide if position should be removed or retried later
                 # positions_to_remove.append(position) # Optionally remove problematic position state

        # Remove closed positions from the list
        if positions_to_remove:
            logger.debug(f"Removing {len(positions_to_remove)} closed/problematic positions from state.")
            self.open_positions = [pos for pos in self.open_positions if pos not in positions_to_remove]


    @retry_api_call()
    def cancel_all_open_orders(self, symbol: Optional[str] = None) -> int:
        """
        Cancels all open limit orders for the specified trading symbol.
        Defaults to the bot's configured symbol if None.

        Args:
            symbol: The market symbol (e.g., 'BTC/USDT:USDT') to cancel orders for.

        Returns:
            The number of orders successfully cancelled.
        """
        target_symbol = symbol or self.symbol
        logger.info(f"Checking for and cancelling open orders for {target_symbol}...")
        cancelled_count = 0
        try:
            # Fetch only open orders for the specific symbol
            # Ensure the exchange connection is valid before calling
            if not hasattr(self.exchange, 'fetch_open_orders'):
                 logger.warning(f"{Fore.YELLOW}Exchange {self.exchange_id} does not support fetch_open_orders via ccxt. Cannot automatically cancel.{Style.RESET_ALL}")
                 return 0

            open_orders = self.exchange.fetch_open_orders(target_symbol)

            if not open_orders:
                logger.info(f"No open orders found for {target_symbol}.")
                return 0

            logger.warning(f"{Fore.YELLOW}Found {len(open_orders)} open order(s) for {target_symbol}. Attempting cancellation...{Style.RESET_ALL}")

            for order in open_orders:
                order_id = order.get('id')
                order_side = order.get('side', 'N/A')
                order_price = order.get('price', 'N/A')
                order_amount = order.get('amount', 'N/A')
                if not order_id:
                    logger.warning(f"{Fore.YELLOW}Skipping order with missing ID: {order}{Style.RESET_ALL}")
                    continue

                try:
                    logger.debug(f"Attempting to cancel order: ID {order_id}, Side: {order_side}, Price: {order_price}, Amount: {order_amount}")
                    self.exchange.cancel_order(order_id, target_symbol)
                    logger.info(f"{Fore.YELLOW}Cancelled Order: ID {order_id}, Side: {order_side}, Price: {order_price}{Style.RESET_ALL}")
                    cancelled_count += 1
                    # Optional: Small sleep to avoid hitting rate limits aggressively if cancelling many orders
                    time.sleep(self.exchange.rateLimit / 2000) # Half the default rate limit delay

                except ccxt.OrderNotFound:
                    logger.warning(f"{Fore.YELLOW}Order {order_id} already closed, cancelled, or not found by the time cancellation was attempted.{Style.RESET_ALL}")
                    # Still count potentially? Or have a separate 'not_found_count'
                except ccxt.NetworkError as e:
                     # Let retry decorator handle this if configured
                     logger.error(f"{Fore.RED}Network error cancelling order {order_id}: {e}. Retrying if possible.{Style.RESET_ALL}")
                     raise e # Re-raise to trigger retry
                except ccxt.ExchangeError as e:
                     logger.error(f"{Fore.RED}Exchange error cancelling order {order_id}: {e}{Style.RESET_ALL}")
                     # Decide whether to retry or not based on error type
                except Exception as e:
                    logger.error(f"{Fore.RED}Unexpected error cancelling order {order_id}: {e}{Style.RESET_ALL}", exc_info=True)

            logger.info(f"Order cancellation process finished for {target_symbol}. Successfully cancelled: {cancelled_count}/{len(open_orders)}.")

        except ccxt.AuthenticationError as e:
             logger.error(f"{Fore.RED}Authentication error during order cancellation: {e}{Style.RESET_ALL}")
        except Exception as e:
            # Catch errors during fetch_open_orders itself
            logger.error(f"{Fore.RED}An error occurred during the order cancellation process (fetch or loop): {e}{Style.RESET_ALL}", exc_info=True)

        return cancelled_count


    # --- Main Trading Loop ---

    def run(self) -> None:
        """Starts the main trading loop of the bot."""
        logger.info(f"{Fore.CYAN}--- Starting Scalping Bot Main Loop (Symbol: {self.symbol}, Timeframe: {self.timeframe}) ---{Style.RESET_ALL}")
        if self.simulation_mode:
            logger.warning(f"{Fore.YELLOW}Reminder: Simulation mode is active. No real trades will occur.{Style.RESET_ALL}")

        # --- Initial Check & Cleanup ---
        # Cancel any potentially lingering open orders from previous runs before starting
        try:
            self.cancel_all_open_orders()
        except Exception as e:
             logger.error(f"{Fore.RED}Error during initial order cancellation: {e}. Continuing...{Style.RESET_ALL}")


        # --- Main Loop ---
        while True:
            self.iteration += 1
            start_time = time.time()
            logger.info(f"\n{Fore.BLUE}===== Iteration {self.iteration} | Time: {pd.Timestamp.now(tz='UTC').isoformat()} ====={Style.RESET_ALL}")

            try:
                # --- 1. Fetch Data ---
                # Use list comprehension for conciseness if preferred, but separate calls are clearer for logging/debugging
                current_price = self.fetch_market_price()
                orderbook_imbalance = self.fetch_order_book()
                historical_data = self.fetch_historical_data() # Fetches DataFrame

                # --- Data Integrity Check ---
                if current_price is None or historical_data is None or historical_data.empty:
                    logger.warning(
                        f"{Fore.YELLOW}Incomplete market data fetched this iteration (Price: {'OK' if current_price is not None else 'FAIL'}, "
                        f"HistData: {'OK' if historical_data is not None and not historical_data.empty else 'FAIL'}, "
                        f"OrderBook: {'OK' if orderbook_imbalance is not None else 'FAIL/NA'}). "
                        f"Skipping analysis and position management.{Style.RESET_ALL}"
                    )
                    # Wait and retry in the next iteration
                    time.sleep(DEFAULT_SLEEP_INTERVAL_SECONDS)
                    continue

                # --- 2. Calculate Indicators ---
                indicators = {}
                close_prices = historical_data['close'] # Use close prices Series
                # Volatility is primarily used for order sizing, calculate first if needed there
                indicators['volatility'] = self.calculate_volatility(close_prices, self.volatility_window)
                indicators['ema'] = self.calculate_ema(close_prices, self.ema_period)
                indicators['rsi'] = self.calculate_rsi(close_prices, self.rsi_period)
                # Unpack MACD results safely
                macd_results = self.calculate_macd(
                    close_prices, self.macd_short_period, self.macd_long_period, self.macd_signal_period
                )
                indicators['macd_line'], indicators['macd_signal'], indicators['macd_hist'] = macd_results if macd_results else (None, None, None)
                # Unpack Stoch RSI results safely
                stoch_results = self.calculate_stoch_rsi(
                    close_prices, self.rsi_period, self.stoch_rsi_period, self.stoch_rsi_k_period, self.stoch_rsi_d_period
                )
                indicators['stoch_k'], indicators['stoch_d'] = stoch_results if stoch_results else (None, None)

                # Log indicator state
                # Format indicators for cleaner logging, handling None values
                log_inds = {k: f"{v:.4f}" if isinstance(v, float) else ("N/A" if v is None else v)
                           for k, v in indicators.items()}
                logger.info(f"Market State: Price={current_price:.4f}, Volatility={log_inds['volatility']}")
                logger.info(f"Indicators: EMA={log_inds['ema']}, RSI={log_inds['rsi']}, "
                            f"MACD(L/S/H)=({log_inds['macd_line']}/{log_inds['macd_signal']}/{log_inds['macd_hist']}), "
                            f"Stoch(K/D)=({log_inds['stoch_k']}/{log_inds['stoch_d']})")
                logger.info(f"Order Book Imbalance (Ask/Bid): {f'{orderbook_imbalance:.3f}' if orderbook_imbalance is not None else 'N/A'} "
                            f"(Threshold: {self.imbalance_threshold})")


                # --- 3. Calculate Order Size ---
                # Calculate potential order size even if not entering, helps monitor capability
                order_size_quote = self.calculate_order_size()
                can_trade = order_size_quote > 0


                # --- 4. Compute Trade Signal ---
                signal_score, reasons = self.compute_trade_signal_score(
                    current_price, indicators, orderbook_imbalance
                )
                logger.info(f"Trade Signal Score: {signal_score}")
                # Log reasons only if score is potentially actionable or for debug
                if abs(signal_score) >= ENTRY_SIGNAL_THRESHOLD_ABS or logger.isEnabledFor(logging.DEBUG):
                    for reason in reasons:
                        logger.info(f" -> {reason}")


                # --- 5. Position Entry Logic ---
                can_open_new_position = len(self.open_positions) < self.max_open_positions

                if not can_open_new_position:
                     logger.info(
                        f"{Fore.YELLOW}Max open positions ({self.max_open_positions}) reached. Cannot open new positions.{Style.RESET_ALL}"
                    )
                elif not can_trade:
                     logger.warning(
                         f"{Fore.YELLOW}Cannot open new positions: Calculated order size is zero (check balance/config).{Style.RESET_ALL}"
                     )
                else:
                    # Check for LONG entry signal
                    if signal_score >= ENTRY_SIGNAL_THRESHOLD_ABS:
                        logger.info(f"{Fore.GREEN}Potential LONG entry signal detected (Score: {signal_score} >= {ENTRY_SIGNAL_THRESHOLD_ABS}){Style.RESET_ALL}")

                        # Adjust TP/SL based on confidence (signal score magnitude)
                        is_strong_signal = abs(signal_score) >= STRONG_SIGNAL_THRESHOLD_ABS
                        adjustment_factor = self.strong_signal_adjustment_factor if is_strong_signal else self.weak_signal_adjustment_factor
                        take_profit_pct = self.base_take_profit_pct * adjustment_factor
                        stop_loss_pct = self.base_stop_loss_pct * adjustment_factor

                        # Calculate target prices
                        stop_loss_price = current_price * (1 - stop_loss_pct)
                        take_profit_price = current_price * (1 + take_profit_pct)
                        limit_entry_price = None
                        if self.entry_order_type == "limit":
                            limit_entry_price = current_price * (1 - self.limit_order_entry_offset_pct_buy) # Below current price

                        # --- Place Entry Order ---
                        entry_order = self.place_order(
                            side="buy",
                            order_size_quote=order_size_quote,
                            confidence_level=signal_score,
                            order_type=self.entry_order_type,
                            limit_price=limit_entry_price,
                            stop_loss_price=stop_loss_price, # Attempt to place with order if supported
                            take_profit_price=take_profit_price, # Attempt to place with order if supported
                            reduce_only=False
                        )

                        if entry_order:
                            # Successfully placed order (or simulated)
                            # Use estimate from simulation or actual avg/price from live order
                            actual_entry_price = entry_order.get('average') or entry_order.get('info',{}).get('entry_price_estimate') or entry_order.get('price') or current_price # Best guess entry
                            actual_amount = entry_order.get('amount', 0.0) # Get actual amount from order

                            if actual_amount > 0: # Ensure order has valid amount
                                self.open_positions.append({
                                    "id": entry_order['id'], # Store order ID
                                    "side": "buy",
                                    "size": actual_amount, # Store actual amount from order
                                    "entry_price": actual_entry_price,
                                    "entry_time": time.time(), # Timestamp of adding to state
                                    "stop_loss": stop_loss_price, # Store calculated initial SL
                                    "take_profit": take_profit_price, # Store calculated initial TP
                                    "confidence": signal_score,
                                    "status": entry_order.get('status', 'unknown'), # Store initial order status
                                    # Trailing SL price ('trailing_stop_loss') will be added by manage_positions if activated
                                })
                                logger.info(f"{Fore.GREEN}---> Added LONG position to state. Size: {actual_amount:.6f}, Entry Est: {actual_entry_price:.4f}, "
                                            f"Base SL: {stop_loss_price:.4f} ({stop_loss_pct*100:.2f}%), Base TP: {take_profit_price:.4f} ({take_profit_pct*100:.2f}%)"
                                            f" Signal Strength: {'Strong' if is_strong_signal else 'Standard'}{Style.RESET_ALL}")
                            else:
                                logger.warning(f"{Fore.YELLOW}Entry order {entry_order.get('id')} reported zero amount, not adding to open positions.{Style.RESET_ALL}")


                    # Check for SHORT entry signal
                    elif signal_score <= -ENTRY_SIGNAL_THRESHOLD_ABS:
                        logger.info(f"{Fore.RED}Potential SHORT entry signal detected (Score: {signal_score} <= {-ENTRY_SIGNAL_THRESHOLD_ABS}){Style.RESET_ALL}")

                        is_strong_signal = abs(signal_score) >= STRONG_SIGNAL_THRESHOLD_ABS
                        adjustment_factor = self.strong_signal_adjustment_factor if is_strong_signal else self.weak_signal_adjustment_factor
                        take_profit_pct = self.base_take_profit_pct * adjustment_factor
                        stop_loss_pct = self.base_stop_loss_pct * adjustment_factor

                        stop_loss_price = current_price * (1 + stop_loss_pct)
                        take_profit_price = current_price * (1 - take_profit_pct)
                        limit_entry_price = None
                        if self.entry_order_type == "limit":
                             limit_entry_price = current_price * (1 + self.limit_order_entry_offset_pct_sell) # Above current price

                        # --- Place Entry Order ---
                        entry_order = self.place_order(
                            side="sell",
                            order_size_quote=order_size_quote,
                            confidence_level=signal_score,
                            order_type=self.entry_order_type,
                            limit_price=limit_entry_price,
                            stop_loss_price=stop_loss_price,
                            take_profit_price=take_profit_price,
                            reduce_only=False
                        )

                        if entry_order:
                            actual_entry_price = entry_order.get('average') or entry_order.get('info',{}).get('entry_price_estimate') or entry_order.get('price') or current_price
                            actual_amount = entry_order.get('amount', 0.0)

                            if actual_amount > 0:
                                self.open_positions.append({
                                    "id": entry_order['id'],
                                    "side": "sell",
                                    "size": actual_amount,
                                    "entry_price": actual_entry_price,
                                    "entry_time": time.time(),
                                    "stop_loss": stop_loss_price,
                                    "take_profit": take_profit_price,
                                    "confidence": signal_score,
                                    "status": entry_order.get('status', 'unknown'),
                                })
                                logger.info(f"{Fore.RED}---> Added SHORT position to state. Size: {actual_amount:.6f}, Entry Est: {actual_entry_price:.4f}, "
                                            f"Base SL: {stop_loss_price:.4f} ({stop_loss_pct*100:.2f}%), Base TP: {take_profit_price:.4f} ({take_profit_pct*100:.2f}%)"
                                            f" Signal Strength: {'Strong' if is_strong_signal else 'Standard'}{Style.RESET_ALL}")
                            else:
                                logger.warning(f"{Fore.YELLOW}Entry order {entry_order.get('id')} reported zero amount, not adding to open positions.{Style.RESET_ALL}")

                    else: # Score is between the thresholds
                        logger.info(f"Neutral signal score ({signal_score}). No trade entry action taken.")


                # --- 6. Manage Existing Positions ---
                # This should run regardless of entry signals to handle exits
                self.manage_positions()

                # --- 7. Periodic Cleanup (Optional) ---
                # Cancel lingering limit entry orders occasionally if they haven't filled
                # Use modulo operator for periodic execution (e.g., every 10 minutes if interval is 1 min)
                iterations_per_10_min = 600 // DEFAULT_SLEEP_INTERVAL_SECONDS
                if self.iteration % max(1, iterations_per_10_min) == 0: # Avoid modulo by zero
                    logger.info(f"Performing periodic cleanup (Iteration {self.iteration})...")
                    # Only cancel orders related to *this bot instance* if possible (e.g., using clientOrderId)
                    # For now, just cancels all open orders for the symbol.
                    # Be careful if other bots/manual trades use the same symbol/account.
                    self.cancel_all_open_orders()

                # --- 8. Wait for Next Iteration ---
                end_time = time.time()
                execution_time = end_time - start_time
                wait_time = max(0, DEFAULT_SLEEP_INTERVAL_SECONDS - execution_time)
                logger.debug(f"Iteration {self.iteration} complete. Execution time: {execution_time:.2f}s. Waiting {wait_time:.2f}s...")
                if wait_time > 0:
                    time.sleep(wait_time)

            except KeyboardInterrupt:
                # Catch Ctrl+C for graceful shutdown
                raise # Re-raise to be caught by the outer try/except
            except Exception as e:
                # Catch unexpected errors within the main loop iteration
                logger.critical(f"{Fore.RED}A critical error occurred within the main loop (Iteration {self.iteration}): {e}{Style.RESET_ALL}", exc_info=True)
                # Decide on action: continue, sleep longer, or shutdown?
                # For now, sleep longer to allow potential recovery or manual intervention
                logger.warning(f"{Fore.YELLOW}Sleeping for 60 seconds after critical error before next attempt...{Style.RESET_ALL}")
                time.sleep(60)


        # End of the while loop (should not be reached normally)
        logger.info("Main trading loop exited.")


    def shutdown(self):
        """Performs graceful shutdown procedures."""
        logger.warning(f"{Fore.YELLOW}--- Initiating Graceful Shutdown ---{Style.RESET_ALL}")

        # 1. Cancel All Open Orders placed by this bot (if possible)
        logger.info("Attempting to cancel all open orders for the symbol...")
        try:
            cancelled_count = self.cancel_all_open_orders()
            logger.info(f"Cancelled {cancelled_count} open orders.")
        except Exception as e:
            logger.error(f"{Fore.RED}Error during shutdown order cancellation: {e}{Style.RESET_ALL}", exc_info=True)

        # 2. Optionally Close Open Positions
        # Decide if you want to automatically close positions on shutdown. Risky if market is volatile.
        CLOSE_POSITIONS_ON_EXIT = False # Set to True to enable market close on exit
        if CLOSE_POSITIONS_ON_EXIT and self.open_positions:
             logger.warning(f"{Fore.YELLOW}Attempting to close {len(self.open_positions)} open position(s) with market orders...{Style.RESET_ALL}")
             # Use a copy as manage_positions might modify the list (though it shouldn't here)
             for position in list(self.open_positions):
                pos_id = position.get('id', 'N/A')
                pos_side = position['side']
                pos_size = position['size']
                logger.info(f"Closing position {pos_id} (Side: {pos_side}, Size: {pos_size})...")
                close_side = "sell" if pos_side == "buy" else "buy"
                current_price = self.fetch_market_price() # Get latest price
                if current_price:
                     close_order_quote_size = pos_size * current_price
                     closing_order = self.place_order(side=close_side, order_size_quote=close_order_quote_size, confidence_level=0, order_type="market", reduce_only=True)
                     if closing_order:
                         logger.info(f"{Fore.YELLOW}Market close order placed for position {pos_id}.{Style.RESET_ALL}")
                         # Remove from internal state immediately
                         self.open_positions.remove(position)
                     else:
                         logger.error(f"{Fore.RED}Failed to place market close order for position {pos_id}. Manual check required!{Style.RESET_ALL}")
                else:
                    logger.error(f"{Fore.RED}Could not fetch price to close position {pos_id}. Manual check required!{Style.RESET_ALL}")
        elif self.open_positions:
            logger.warning(f"{Fore.YELLOW}{len(self.open_positions)} position(s) remain open. Manual management required.{Style.RESET_ALL}")
            # Log details of open positions
            for pos in self.open_positions:
                 logger.warning(f" -> Open Position: ID={pos.get('id','N/A')}, Side={pos['side']}, Size={pos['size']}, Entry={pos['entry_price']:.4f}")


        # 3. Final Log Messages
        logger.info(f"{Fore.CYAN}--- Scalping Bot Shutdown Complete ---{Style.RESET_ALL}")

        # Ensure logs are flushed
        logging.shutdown()


# --- Main Execution Block ---
if __name__ == "__main__":
    bot_instance = None
    exit_code = 0
    try:
        bot_instance = ScalpingBot(config_file=CONFIG_FILE_NAME)
        bot_instance.run() # This will block until KeyboardInterrupt or critical error

    except KeyboardInterrupt:
        logger.warning(f"\n{Fore.YELLOW}Ctrl+C detected. Initiating graceful shutdown...{Style.RESET_ALL}")
        # Shutdown sequence is now handled within bot.shutdown()

    except SystemExit as e:
        # Catch SystemExit exceptions (e.g., from config validation/init)
        logger.info(f"Bot exited with status code {e.code}.")
        exit_code = e.code # Propagate exit code

    except Exception as e:
        # Catch any unexpected error during initialization or the outer loop structure
        logger.critical(f"{Fore.RED}An unhandled critical error occurred: {e}{Style.RESET_ALL}", exc_info=True)
        exit_code = 1 # Set error exit code

    finally:
        # Ensure shutdown sequence runs even if run() exits unexpectedly
        if bot_instance:
            bot_instance.shutdown()
        else:
            # If bot initialization failed, still try to shutdown logging
            logger.info("Bot instance was not fully initialized. Shutting down logging.")
            logging.shutdown()
        sys.exit(exit_code) # Exit with appropriate code
```
