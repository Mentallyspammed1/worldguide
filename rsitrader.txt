```python
# trading_bot_neon_enhanced_v2.py
# Enhanced version incorporating ATR SL/TP, Trailing Stops, Config File,
# Volume Confirmation, Retry Logic, and improved structure.

import ccxt
import os
import logging
from dotenv import load_dotenv
import time
import pandas as pd
import pandas_ta as ta # Using pandas_ta for indicator calculations
import json # For config, pretty printing order details and saving state
import os.path # For checking if state file exists
from typing import Optional, Tuple, Dict, Any, List, Union
import functools # For retry decorator
import sys # For exit

# --- Colorama Initialization and Neon Palette ---
try:
    from colorama import init, Fore, Back, Style
    init(autoreset=True) # Autoreset ensures styles don't leak

    # Define neon color palette
    NEON_GREEN = Fore.GREEN + Style.BRIGHT
    NEON_PINK = Fore.MAGENTA + Style.BRIGHT
    NEON_CYAN = Fore.CYAN + Style.BRIGHT
    NEON_RED = Fore.RED + Style.BRIGHT
    NEON_YELLOW = Fore.YELLOW + Style.BRIGHT
    NEON_BLUE = Fore.BLUE + Style.BRIGHT
    RESET = Style.RESET_ALL # Although autoreset is on, good practice
    COLORAMA_AVAILABLE = True
except ImportError:
    print("Warning: colorama not found. Neon styling will be disabled. Install with: pip install colorama")
    # Define dummy colors if colorama is not available
    NEON_GREEN = NEON_PINK = NEON_CYAN = NEON_RED = NEON_YELLOW = NEON_BLUE = RESET = ""
    COLORAMA_AVAILABLE = False

# --- Logging Configuration ---
log_format_base: str = '%(asctime)s %(levelname)s [%(filename)s:%(lineno)d] %(message)s'
# Configure root logger - handlers can be added later if needed (e.g., file handler)
logging.basicConfig(level=logging.INFO, format=log_format_base, datefmt='%Y-%m-%d %H:%M:%S')
logger: logging.Logger = logging.getLogger(__name__) # Get logger for this module

# --- Neon Display Functions ---

def print_neon_header():
    """Prints a neon-styled header banner."""
    print(f"{NEON_CYAN}{'=' * 70}{RESET}")
    print(f"{NEON_PINK}{Style.BRIGHT}     Enhanced RSI/OB Trader Neon Bot - Configurable v2     {RESET}")
    print(f"{NEON_CYAN}{'=' * 70}{RESET}")

def display_error_box(message: str):
    """Displays an error message in a neon box."""
    box_width = 70
    print(f"{NEON_RED}{'!' * box_width}{RESET}")
    print(f"{NEON_RED}! {message:^{box_width-4}} !{RESET}")
    print(f"{NEON_RED}{'!' * box_width}{RESET}")

def display_warning_box(message: str):
    """Displays a warning message in a neon box."""
    box_width = 70
    print(f"{NEON_YELLOW}{'~' * box_width}{RESET}")
    print(f"{NEON_YELLOW}~ {message:^{box_width-4}} ~{RESET}")
    print(f"{NEON_YELLOW}{'~' * box_width}{RESET}")

# Custom logging wrappers with colorama
def log_info(msg: str):
    """Logs an INFO level message with neon green color."""
    logger.info(f"{NEON_GREEN}{msg}{RESET}")

def log_error(msg: str, exc_info=False):
    """Logs an ERROR level message with a neon red box and color."""
    # Show first line in box for prominence, log full message
    first_line = msg.split('\n', 1)[0]
    display_error_box(first_line)
    logger.error(f"{NEON_RED}{msg}{RESET}", exc_info=exc_info)

def log_warning(msg: str):
    """Logs a WARNING level message with a neon yellow box and color."""
    display_warning_box(msg)
    logger.warning(f"{NEON_YELLOW}{msg}{RESET}")

def log_debug(msg: str):
    """Logs a DEBUG level message with simple white color."""
    # Use a less prominent color for debug
    logger.debug(f"{Fore.WHITE}{msg}{RESET}") # Simple white for debug

def print_cycle_divider(timestamp: pd.Timestamp):
    """Prints a neon divider for each trading cycle."""
    box_width = 70
    print(f"\n{NEON_BLUE}{'=' * box_width}{RESET}")
    print(f"{NEON_CYAN}Cycle Start: {timestamp.strftime('%Y-%m-%d %H:%M:%S %Z')}{RESET}")
    print(f"{NEON_BLUE}{'=' * box_width}{RESET}")

def display_position_status(position: Dict[str, Any], price_precision: int = 4, amount_precision: int = 8):
    """Displays position status with neon colors and formatted values."""
    status = position.get('status', None)
    entry_price = position.get('entry_price')
    quantity = position.get('quantity')
    sl = position.get('stop_loss')
    tp = position.get('take_profit')
    tsl = position.get('current_trailing_sl_price') # Added TSL display

    entry_str = f"{entry_price:.{price_precision}f}" if isinstance(entry_price, (float, int)) else "N/A"
    qty_str = f"{quantity:.{amount_precision}f}" if isinstance(quantity, (float, int)) else "N/A"
    sl_str = f"{sl:.{price_precision}f}" if isinstance(sl, (float, int)) else "N/A"
    tp_str = f"{tp:.{price_precision}f}" if isinstance(tp, (float, int)) else "N/A"
    tsl_str = f" | TSL: {tsl:.{price_precision}f}" if isinstance(tsl, (float, int)) else "" # Show TSL only if active

    if status == 'long':
        color = NEON_GREEN
        status_text = "LONG"
    elif status == 'short':
        color = NEON_RED
        status_text = "SHORT"
    else:
        color = NEON_CYAN
        status_text = "None"

    print(f"{color}Position Status: {status_text}{RESET} | Entry: {entry_str} | Qty: {qty_str} | SL: {sl_str} | TP: {tp_str}{tsl_str}")


def display_market_stats(current_price: float, rsi: float, stoch_k: float, stoch_d: float, atr: Optional[float], price_precision: int):
    """Displays market stats in a neon-styled panel."""
    print(f"{NEON_PINK}--- Market Stats ---{RESET}")
    print(f"{NEON_GREEN}Price:{RESET}  {current_price:.{price_precision}f}")
    print(f"{NEON_CYAN}RSI:{RESET}    {rsi:.2f}")
    print(f"{NEON_YELLOW}StochK:{RESET} {stoch_k:.2f}")
    print(f"{NEON_YELLOW}StochD:{RESET} {stoch_d:.2f}")
    # Use price_precision for ATR display as it's a price volatility measure
    if atr is not None:
         print(f"{NEON_BLUE}ATR:{RESET}    {atr:.{price_precision}f}") # Display ATR
    print(f"{NEON_PINK}--------------------{RESET}")

def display_order_blocks(bullish_ob: Optional[Dict], bearish_ob: Optional[Dict], price_precision: int):
    """Displays identified order blocks with neon colors."""
    found = False
    if bullish_ob:
        print(f"{NEON_GREEN}Bullish OB:{RESET} {bullish_ob['time'].strftime('%H:%M')} | Low: {bullish_ob['low']:.{price_precision}f} | High: {bullish_ob['high']:.{price_precision}f}")
        found = True
    if bearish_ob:
        print(f"{NEON_RED}Bearish OB:{RESET} {bearish_ob['time'].strftime('%H:%M')} | Low: {bearish_ob['low']:.{price_precision}f} | High: {bearish_ob['high']:.{price_precision}f}")
        found = True
    if not found:
        print(f"{NEON_BLUE}Order Blocks: None detected in recent data.{RESET}")


def display_signal(signal_type: str, direction: str, reason: str):
    """Displays trading signals with appropriate neon colors."""
    if direction.lower() == 'long':
        color = NEON_GREEN
    elif direction.lower() == 'short':
        color = NEON_RED
    else: # e.g., Exit, Warning
        color = NEON_YELLOW

    print(f"{color}{Style.BRIGHT}*** {signal_type.upper()} {direction.upper()} SIGNAL ***{RESET}\n   Reason: {reason}")

def neon_sleep_timer(seconds: int):
    """Displays a neon countdown timer in the console."""
    if not COLORAMA_AVAILABLE or seconds <= 0: # Fallback if colorama not installed or zero sleep
        if seconds > 0:
            print(f"Sleeping for {seconds} seconds...")
            time.sleep(seconds)
        return

    interval = 0.5 # Update interval for the timer display
    steps = int(seconds / interval)
    for i in range(steps, -1, -1):
        remaining_seconds = max(0, int(i * interval)) # Ensure non-negative
        # Flashing effect for last 5 seconds
        color = NEON_RED if remaining_seconds <= 5 and i % 2 == 0 else NEON_YELLOW
        print(f"{color}Next cycle in: {remaining_seconds} seconds... {Style.RESET_ALL}", end='\r')
        time.sleep(interval)
    print(" " * 50, end='\r')  # Clear line after countdown

def print_shutdown_message():
    """Prints a neon shutdown message."""
    box_width = 70
    print(f"\n{NEON_PINK}{'=' * box_width}{RESET}")
    print(f"{NEON_CYAN}{Style.BRIGHT}{'RSI/OB Trader Bot Stopped - Goodbye!':^{box_width}}{RESET}")
    print(f"{NEON_PINK}{'=' * box_width}{RESET}")


# --- Constants ---
DEFAULT_PRICE_PRECISION: int = 4
DEFAULT_AMOUNT_PRECISION: int = 8
POSITION_STATE_FILE = 'position_state.json' # Define filename for state persistence
CONFIG_FILE = 'config.json'

# --- Retry Decorator ---
RETRYABLE_EXCEPTIONS = (
    ccxt.NetworkError,
    ccxt.ExchangeNotAvailable,
    ccxt.RateLimitExceeded,
    ccxt.RequestTimeout,
    # ccxt.DDoSProtection, # Consider adding if encountered frequently
)

def retry_api_call(max_retries: int = 3, initial_delay: float = 5.0, backoff_factor: float = 2.0):
    """
    Decorator factory to create retry decorators for API calls.
    Handles specific RETRYABLE_EXCEPTIONS with exponential backoff.

    Args:
        max_retries: Maximum number of retries before giving up.
        initial_delay: Initial delay between retries in seconds.
        backoff_factor: Multiplier for the delay after each retry (e.g., 2 for exponential).

    Returns:
        A decorator function.
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            retries = 0
            delay = initial_delay
            while retries < max_retries:
                try:
                    return func(*args, **kwargs)
                except RETRYABLE_EXCEPTIONS as e:
                    retries += 1
                    if retries >= max_retries:
                        log_error(f"API call '{func.__name__}' failed after {max_retries} retries. Last error: {e}", exc_info=False)
                        raise # Re-raise the last exception to signal failure
                    else:
                        log_warning(f"API call '{func.__name__}' failed with {type(e).__name__}. Retrying in {delay:.1f}s... (Attempt {retries}/{max_retries})")
                        # Use neon sleep if available, otherwise time.sleep
                        try:
                            neon_sleep_timer(int(delay))
                        except NameError: # Fallback if neon_sleep_timer isn't defined (e.g., colorama issue)
                            time.sleep(delay)
                        delay *= backoff_factor # Exponential backoff
                except Exception as e:
                     # Handle non-retryable exceptions immediately
                     log_error(f"Non-retryable error in API call '{func.__name__}': {e}", exc_info=True)
                     raise # Re-raise immediately
            # This line should theoretically not be reached if max_retries > 0
            # but added for safety to ensure function returns or raises.
            raise RuntimeError(f"API call '{func.__name__}' failed unexpectedly after retries.")
        return wrapper
    return decorator


# --- Configuration Loading ---
def load_config(filename: str = CONFIG_FILE) -> Dict[str, Any]:
    """
    Loads configuration from a JSON file. Performs basic validation.
    Exits the script if critical errors occur during loading.

    Args:
        filename: The path to the configuration file.

    Returns:
        A dictionary containing the configuration parameters.
    """
    log_info(f"Attempting to load configuration from '{filename}'...")
    try:
        with open(filename, 'r') as f:
            config_data = json.load(f)
        log_info(f"Configuration loaded successfully from {filename}")
        # Basic validation (presence of essential keys)
        required_keys = ["exchange_id", "symbol", "timeframe", "risk_percentage", "simulation_mode"]
        missing_keys = [key for key in required_keys if key not in config_data]
        if missing_keys:
             log_error(f"CRITICAL: Missing required configuration keys in '{filename}': {missing_keys}")
             sys.exit(1) # Use sys.exit for clean exit
        # TODO: Add more specific validation (types, ranges) if needed (e.g., risk_percentage > 0)
        return config_data
    except FileNotFoundError:
        log_error(f"CRITICAL: Configuration file '{filename}' not found.")
        sys.exit(1)
    except json.JSONDecodeError as e:
        log_error(f"CRITICAL: Error decoding JSON from configuration file '{filename}': {e}")
        sys.exit(1)
    except Exception as e:
        log_error(f"CRITICAL: An unexpected error occurred loading configuration: {e}", exc_info=True)
        sys.exit(1)

# Load config early
config = load_config()

# Create the decorator instance using config values
api_retry_decorator = retry_api_call(
    max_retries=config.get("retry_max_retries", 3),
    initial_delay=config.get("retry_initial_delay", 5.0),
    backoff_factor=config.get("retry_backoff_factor", 2.0)
)

# --- Environment & Exchange Setup ---
print_neon_header() # Show header early
load_dotenv()
log_info("Attempting to load environment variables from .env file (for API keys)...")

exchange_id: str = config.get("exchange_id", "bybit").lower()
api_key_env_var: str = f"{exchange_id.upper()}_API_KEY"
secret_key_env_var: str = f"{exchange_id.upper()}_SECRET_KEY"
passphrase_env_var: str = f"{exchange_id.upper()}_PASSPHRASE" # Some exchanges like kucoin, okx use this

api_key: Optional[str] = os.getenv(api_key_env_var)
secret: Optional[str] = os.getenv(secret_key_env_var)
passphrase: str = os.getenv(passphrase_env_var, '')

if not api_key or not secret:
    log_error(f"CRITICAL: API Key or Secret not found using env vars '{api_key_env_var}' and '{secret_key_env_var}'. "
              f"Please ensure these exist in your .env file or environment.")
    sys.exit(1)

log_info(f"Attempting to connect to exchange: {exchange_id}")
exchange: ccxt.Exchange
try:
    exchange_class = getattr(ccxt, exchange_id)
    exchange_config: Dict[str, Any] = {
        'apiKey': api_key,
        'secret': secret,
        'enableRateLimit': True, # CCXT internal rate limiting
        'options': {
            # Adjust 'swap' or 'spot' based on your market type in config/symbol
            'defaultType': 'swap' if ':' in config.get("symbol", "") else 'spot',
            'adjustForTimeDifference': True, # Recommended for avoiding timestamp issues
        }
    }
    if passphrase:
        log_info("Passphrase detected, adding to exchange configuration.")
        exchange_config['password'] = passphrase

    exchange = exchange_class(exchange_config)

    # Load markets with retry mechanism applied
    @api_retry_decorator
    def load_markets_with_retry(exch_instance: ccxt.Exchange):
         """Loads exchange markets with retry logic."""
         log_info("Loading markets...")
         exch_instance.load_markets()

    load_markets_with_retry(exchange)

    log_info(f"Successfully connected to {exchange_id}. Markets loaded ({len(exchange.markets)} symbols found).")

except ccxt.AuthenticationError as e:
    log_error(f"Authentication failed connecting to {exchange_id}. Check API Key/Secret/Passphrase. Error: {e}")
    sys.exit(1)
except ccxt.ExchangeNotAvailable as e:
    log_error(f"Exchange {exchange_id} is not available. Error: {e}")
    sys.exit(1)
except AttributeError:
    log_error(f"Exchange ID '{exchange_id}' not found in ccxt library.")
    sys.exit(1)
except Exception as e:
    # Check if it's a retryable error that failed all retries (already logged by decorator)
    if not isinstance(e, RETRYABLE_EXCEPTIONS):
        log_error(f"An unexpected error occurred during exchange initialization or market loading: {e}", exc_info=True)
    sys.exit(1) # Exit if any error occurs during setup


# --- Trading Parameters (Loaded from config) ---
symbol: str = config.get("symbol", "").strip().upper()
if not symbol:
    log_error("CRITICAL: 'symbol' not specified in config.json")
    sys.exit(1)

# Validate symbol against exchange markets and get precision info
try:
    if symbol not in exchange.markets:
        log_warning(f"Symbol '{symbol}' from config not found or not supported on {exchange_id}.")
        available_symbols: List[str] = list(exchange.markets.keys())
        # Filter for potential swap markets if needed based on symbol format or default type
        if ':' in symbol or exchange_config.get('options', {}).get('defaultType') == 'swap':
             available_symbols = [s for s in available_symbols if ':' in s or exchange.markets[s].get('swap')]
        log_info(f"Some available symbols ({len(available_symbols)} total): {available_symbols[:15]}...")
        sys.exit(1)

    log_info(f"Using trading symbol from config: {symbol}")
    # Store precision info globally for convenience
    market_info = exchange.markets[symbol]
    price_precision_digits: int = int(market_info.get('precision', {}).get('price', DEFAULT_PRICE_PRECISION))
    amount_precision_digits: int = int(market_info.get('precision', {}).get('amount', DEFAULT_AMOUNT_PRECISION))
    # Calculate min_tick robustly
    min_tick_value = market_info.get('precision', {}).get('price')
    if min_tick_value is not None:
         min_tick: float = float(min_tick_value) # Use precision value directly if available
    else:
         min_tick: float = 1 / (10 ** price_precision_digits) if price_precision_digits > 0 else 0.01 # Fallback

    log_info(f"Symbol Precision | Price: {price_precision_digits} decimals (Min Tick: {min_tick}), Amount: {amount_precision_digits} decimals")

except Exception as e:
    log_error(f"An error occurred while validating the symbol or getting precision: {e}", exc_info=True)
    sys.exit(1)

timeframe: str = config.get("timeframe", "1h")
rsi_length: int = int(config.get("rsi_length", 14))
rsi_overbought: int = int(config.get("rsi_overbought", 70))
rsi_oversold: int = int(config.get("rsi_oversold", 30))
stoch_k: int = int(config.get("stoch_k", 14))
stoch_d: int = int(config.get("stoch_d", 3))
stoch_smooth_k: int = int(config.get("stoch_smooth_k", 3))
stoch_overbought: int = int(config.get("stoch_overbought", 80))
stoch_oversold: int = int(config.get("stoch_oversold", 20))
data_limit: int = int(config.get("data_limit", 200))
sleep_interval_seconds: int = int(config.get("sleep_interval_seconds", 900))
risk_percentage: float = float(config.get("risk_percentage", 0.01))
if risk_percentage <= 0 or risk_percentage >= 1:
    log_error(f"CRITICAL: 'risk_percentage' ({risk_percentage}) must be between 0 and 1 (exclusive).")
    sys.exit(1)

# SL/TP and Trailing Stop Parameters (Conditional loading)
enable_atr_sl_tp: bool = config.get("enable_atr_sl_tp", False)
enable_trailing_stop: bool = config.get("enable_trailing_stop", False)
atr_length: int = int(config.get("atr_length", 14)) # Needed if either ATR SL/TP or TSL is enabled

# Validate ATR length if needed
needs_atr = enable_atr_sl_tp or enable_trailing_stop
if needs_atr and atr_length <= 0:
    log_error(f"CRITICAL: 'atr_length' must be positive ({atr_length}) if ATR SL/TP or Trailing Stop is enabled.")
    sys.exit(1)

if enable_atr_sl_tp:
    atr_sl_multiplier: float = float(config.get("atr_sl_multiplier", 2.0))
    atr_tp_multiplier: float = float(config.get("atr_tp_multiplier", 3.0))
    log_info(f"Using ATR-based Stop Loss ({atr_sl_multiplier}x ATR) and Take Profit ({atr_tp_multiplier}x ATR).")
    if atr_sl_multiplier <= 0 or atr_tp_multiplier <= 0:
         log_error("CRITICAL: ATR SL/TP multipliers must be positive.")
         sys.exit(1)
else:
    stop_loss_percentage: float = float(config.get("stop_loss_percentage", 0.02))
    take_profit_percentage: float = float(config.get("take_profit_percentage", 0.04))
    log_info(f"Using Fixed Percentage Stop Loss ({stop_loss_percentage*100:.1f}%) and Take Profit ({take_profit_percentage*100:.1f}%).")
    if stop_loss_percentage <= 0 or take_profit_percentage <= 0:
         log_error("CRITICAL: Fixed SL/TP percentages must be positive.")
         sys.exit(1)

if enable_trailing_stop:
    trailing_stop_atr_multiplier: float = float(config.get("trailing_stop_atr_multiplier", 1.5))
    trailing_stop_activation_atr_multiplier: float = float(config.get("trailing_stop_activation_atr_multiplier", 1.0))
    log_info(f"Trailing Stop Loss is ENABLED (Activate @ {trailing_stop_activation_atr_multiplier}x ATR profit, Trail @ {trailing_stop_atr_multiplier}x ATR).")
    if trailing_stop_atr_multiplier <= 0 or trailing_stop_activation_atr_multiplier < 0: # Activation can be 0
         log_error("CRITICAL: Trailing stop ATR multiplier must be positive, activation multiplier non-negative.")
         sys.exit(1)
else:
    log_info("Trailing Stop Loss is DISABLED.")

# OB Parameters
ob_volume_threshold_multiplier: float = float(config.get("ob_volume_threshold_multiplier", 1.5))
ob_lookback: int = int(config.get("ob_lookback", 10))
if ob_lookback <= 0:
    log_error("CRITICAL: 'ob_lookback' must be positive.")
    sys.exit(1)

# Volume Confirmation Parameters
entry_volume_confirmation_enabled: bool = config.get("entry_volume_confirmation_enabled", True)
entry_volume_ma_length: int = int(config.get("entry_volume_ma_length", 20))
entry_volume_multiplier: float = float(config.get("entry_volume_multiplier", 1.2))
if entry_volume_confirmation_enabled:
    log_info(f"Entry Volume Confirmation: ENABLED (Vol > {entry_volume_multiplier}x MA({entry_volume_ma_length}))")
    if entry_volume_ma_length <= 0 or entry_volume_multiplier <= 0:
         log_error("CRITICAL: Volume MA length and multiplier must be positive.")
         sys.exit(1)
else:
    log_info("Entry Volume Confirmation: DISABLED")

# --- Simulation Mode ---
SIMULATION_MODE = config.get("simulation_mode", True) # Default to TRUE for safety
if SIMULATION_MODE:
    log_warning("SIMULATION MODE IS ACTIVE (set in config.json). No real orders will be placed.")
else:
    log_warning("!!! LIVE TRADING MODE IS ACTIVE (set in config.json). REAL ORDERS WILL BE PLACED. !!!")
    # Add confirmation step for live trading
    try:
        # Ask for confirmation only if running interactively
        if sys.stdin.isatty():
            user_confirm = input(f"{NEON_RED}TYPE 'LIVE' TO CONFIRM LIVE TRADING or press Enter to exit: {RESET}")
            if user_confirm.strip().upper() != "LIVE":
                log_info("Live trading not confirmed. Exiting.")
                sys.exit(0)
            log_info("Live trading confirmed by user.")
        else:
            log_warning("Running in non-interactive mode. Assuming confirmation for LIVE TRADING.")
            # Consider adding a mandatory delay or requiring a specific env var in non-interactive live mode for safety.
            time.sleep(5) # Short pause to allow cancellation if started accidentally

    except EOFError: # Handle environments where input is not possible
         log_error("Cannot get user confirmation in this environment. Exiting live mode for safety.")
         sys.exit(1)


# --- Position Management State (Includes Trailing Stop fields) ---
# Define the structure clearly
position_default_structure: Dict[str, Any] = {
    'status': None,         # None, 'long', or 'short'
    'entry_price': None,    # Float
    'quantity': None,       # Float
    'order_id': None,       # String (ID of the entry order)
    'stop_loss': None,      # Float (Initial or last manually set SL price)
    'take_profit': None,    # Float (Price level)
    'entry_time': None,     # pd.Timestamp (timezone-aware UTC)
    'sl_order_id': None,    # String (ID of the open SL order)
    'tp_order_id': None,    # String (ID of the open TP order)
    # Fields for Trailing Stop Loss
    'highest_price_since_entry': None, # Float: For long positions
    'lowest_price_since_entry': None,  # Float: For short positions
    'current_trailing_sl_price': None # Float: Active trailing SL price
}
position: Dict[str, Any] = position_default_structure.copy() # Initialize global position state

# --- State Saving and Resumption Functions ---
def save_position_state(filename: str = POSITION_STATE_FILE) -> None:
    """Saves the current position state dictionary to a JSON file."""
    global position
    try:
        # Create a copy to serialize Timestamp safely
        state_to_save = position.copy()
        entry_time = state_to_save.get('entry_time')
        if isinstance(entry_time, pd.Timestamp):
            # Ensure timezone information is handled correctly (ISO format preserves it)
            state_to_save['entry_time'] = entry_time.isoformat()

        with open(filename, 'w') as f:
            json.dump(state_to_save, f, indent=4)
        log_debug(f"Position state saved to {filename}") # Use debug for less noise
    except Exception as e:
        log_error(f"Error saving position state to {filename}: {e}", exc_info=True)

def load_position_state(filename: str = POSITION_STATE_FILE) -> None:
    """
    Loads position state from a JSON file.
    Handles missing keys by using defaults from `position_default_structure`.
    Converts saved timestamps back to timezone-aware pandas Timestamps.
    """
    global position
    log_info(f"Attempting to load position state from '{filename}'...")
    # Start with the default structure
    position = position_default_structure.copy()

    try:
        if os.path.exists(filename):
            with open(filename, 'r') as f:
                loaded_state: Dict[str, Any] = json.load(f)

            # Convert entry_time back to Timestamp if present and not None
            entry_time_str = loaded_state.get('entry_time')
            parsed_entry_time: Optional[pd.Timestamp] = None
            if entry_time_str:
                try:
                    # Attempt parsing, assume ISO format which includes timezone if saved correctly
                    ts = pd.Timestamp(entry_time_str)
                    # Ensure it's timezone-aware (UTC is preferred)
                    if ts.tzinfo is None:
                       ts = ts.tz_localize('UTC')
                    else:
                       ts = ts.tz_convert('UTC')
                    parsed_entry_time = ts
                except ValueError:
                    log_error(f"Could not parse entry_time '{entry_time_str}' from state file. Setting to None.")
                    # Keep parsed_entry_time as None

            # Update the global `position` dict, respecting the default structure
            updated_count = 0
            missing_in_file = []
            extra_in_file = []
            type_mismatches = []

            current_keys = set(position.keys())
            loaded_keys = set(loaded_state.keys())

            for key in current_keys:
                 default_value = position[key] # Get default from the initialized structure
                 if key in loaded_keys:
                     loaded_value = loaded_state[key]
                     # Special handling for entry_time
                     if key == 'entry_time':
                         loaded_value = parsed_entry_time

                     # Basic type check (allow None values)
                     if loaded_value is not None and default_value is not None and not isinstance(loaded_value, type(default_value)):
                         # Handle specific type conversions if needed (e.g., int to float)
                         if isinstance(default_value, float) and isinstance(loaded_value, int):
                             position[key] = float(loaded_value)
                             updated_count +=1
                         else:
                             type_mismatches.append(f"{key} (Expected {type(default_value)}, Got {type(loaded_value)})")
                             # Keep default value on mismatch
                     else:
                         position[key] = loaded_value
                         updated_count += 1
                 else:
                     missing_in_file.append(key)
                     # Keep the default value already set

            extra_in_file = list(loaded_keys - current_keys - {'entry_time'}) # Ignore entry_time string if parsed

            if missing_in_file:
                 log_warning(f"Keys missing in state file '{filename}' (using defaults): {missing_in_file}")
            if extra_in_file:
                 log_warning(f"Extra keys found in state file '{filename}' (ignored): {extra_in_file}")
            if type_mismatches:
                 log_warning(f"Type mismatches found in state file (using defaults for these): {type_mismatches}")


            log_info(f"Position state loaded from {filename}. Updated {updated_count} fields.")
            display_position_status(position, price_precision_digits, amount_precision_digits) # Display loaded state
        else:
            log_info(f"No position state file found at {filename}. Starting with default state.")
    except json.JSONDecodeError as e:
        log_error(f"Error decoding JSON from state file {filename}: {e}. Starting with default state.", exc_info=True)
        position = position_default_structure.copy() # Reset to default
    except Exception as e:
        log_error(f"Error loading position state from {filename}: {e}. Starting with default state.", exc_info=True)
        position = position_default_structure.copy() # Reset to default


# --- Data Fetching Function (Decorated) ---
@api_retry_decorator
def fetch_ohlcv_data(exchange_instance: ccxt.Exchange, trading_symbol: str, tf: str, limit_count: int) -> Optional[pd.DataFrame]:
    """
    Fetches OHLCV data, converts to a pandas DataFrame, cleanses, and returns it.
    Retries on common network/API errors using the decorator.

    Args:
        exchange_instance: The initialized ccxt exchange instance.
        trading_symbol: The symbol to fetch data for (e.g., 'BTC/USDT').
        tf: The timeframe string (e.g., '1h', '15m').
        limit_count: The maximum number of candles to fetch.

    Returns:
        A pandas DataFrame with OHLCV data indexed by timestamp, or None on failure.
    """
    log_debug(f"Fetching {limit_count} candles for {trading_symbol} on {tf} timeframe...")
    try:
        # Check if the market exists locally before fetching (faster than API call)
        if trading_symbol not in exchange_instance.markets:
             log_error(f"Symbol {trading_symbol} not loaded in exchange markets.")
             return None

        ohlcv: List[list] = exchange_instance.fetch_ohlcv(trading_symbol, tf, limit=limit_count)
        if not ohlcv:
            log_warning(f"No OHLCV data returned for {trading_symbol} ({tf}). Exchange might be down or symbol inactive.")
            return None

        df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        # Convert timestamp to datetime and set as index (UTC timezone)
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms', utc=True)
        df = df.set_index('timestamp')

        # Convert OHLCV columns to numeric, coercing errors to NaN
        numeric_cols: List[str] = ['open', 'high', 'low', 'close', 'volume']
        for col in numeric_cols:
            df[col] = pd.to_numeric(df[col], errors='coerce')

        initial_rows: int = len(df)
        # Drop rows where any of the essential OHLCV columns are NaN
        df.dropna(subset=numeric_cols, inplace=True)
        rows_dropped: int = initial_rows - len(df)
        if rows_dropped > 0:
            log_debug(f"Dropped {rows_dropped} rows with invalid OHLCV data.")

        if df.empty:
            log_warning(f"DataFrame became empty after cleaning for {trading_symbol} ({tf}).")
            return None

        log_debug(f"Successfully fetched and processed {len(df)} candles for {trading_symbol}.")
        return df

    # Handle specific non-retryable CCXT errors
    except ccxt.BadSymbol as e:
         log_error(f"BadSymbol error fetching OHLCV for {trading_symbol}: {e}. Check symbol format/availability.")
         return None
    except ccxt.ExchangeError as e: # Catch other non-retryable exchange errors
        log_error(f"Exchange specific error fetching OHLCV for {trading_symbol}: {e}")
        return None
    except Exception as e:
        # Error already logged by retry decorator if it was a retryable error that failed
        # Log here only if it's an unexpected non-CCXT error within this function's logic
        if not isinstance(e, RETRYABLE_EXCEPTIONS):
             log_error(f"An unexpected non-retryable error occurred fetching OHLCV: {e}", exc_info=True)
        return None # Return None if any exception occurred (retryable handled by decorator raise)


# --- Enhanced Order Block Identification Function ---
def identify_potential_order_block(df: pd.DataFrame, vol_thresh_mult: float, lookback_len: int) -> Tuple[Optional[Dict[str, Any]], Optional[Dict[str, Any]]]:
    """
    Identifies the most recent potential bullish and bearish order blocks.

    An order block is defined as:
    - Bullish OB: The last bearish candle before a strong, high-volume bullish move
                  that sweeps the low of the bearish candle.
    - Bearish OB: The last bullish candle before a strong, high-volume bearish move
                  that sweeps the high of the bullish candle.

    Args:
        df: DataFrame with OHLCV data, indexed by timestamp.
        vol_thresh_mult: Multiplier for average volume to define "high volume".
        lookback_len: How many candles back to calculate average volume.

    Returns:
        A tuple containing:
        - dict: Information about the most recent bullish OB found (or None).
        - dict: Information about the most recent bearish OB found (or None).
          Each dict contains 'high', 'low', 'time', 'type'.
    """
    if df is None or df.empty or 'volume' not in df.columns or len(df) < lookback_len + 2:
        log_debug(f"Not enough data or missing volume column for OB detection (need > {lookback_len + 1} rows with volume, got {len(df)}).")
        return None, None

    bullish_ob: Optional[Dict[str, Any]] = None
    bearish_ob: Optional[Dict[str, Any]] = None

    try:
        # Calculate average volume excluding the last (potentially incomplete) candle
        # Use data up to the second to last candle for average calculation
        completed_candles_df = df.iloc[:-1]
        avg_volume = 0.0
        # Ensure enough completed candles for rolling mean, use min_periods for robustness
        if len(completed_candles_df) >= lookback_len:
             # Calculate rolling mean on completed candles, take the last value
             avg_volume = completed_candles_df['volume'].rolling(window=lookback_len, min_periods=max(1, lookback_len // 2)).mean().iloc[-1]
             if pd.isna(avg_volume): avg_volume = 0.0 # Handle NaN result
        elif len(completed_candles_df) > 0:
             # If not enough for lookback, calculate mean of available completed candles
             avg_volume = completed_candles_df['volume'].mean()
             if pd.isna(avg_volume): avg_volume = 0.0

        volume_threshold = avg_volume * vol_thresh_mult if avg_volume > 0 else float('inf') # Avoid threshold=0
        log_debug(f"OB Analysis | Lookback: {lookback_len}, Avg Vol: {avg_volume:.2f}, Threshold Vol: {volume_threshold:.2f}")

        # Iterate backwards from second-to-last candle to find the most recent OBs
        # Look back up to 'lookback_len' candles for the pattern start
        search_limit = max(1, len(df) - lookback_len - 2) # Ensure index doesn't go below 1
        for i in range(len(df) - 2, search_limit -1, -1): # Stop before index search_limit
            # candle = df.iloc[i]         # The "impulse" or "reversal" candle
            # prev_candle = df.iloc[i-1]  # The candle forming the OB zone

            # Use .iloc for position-based indexing, ensure indices are valid
            try:
                candle = df.iloc[i]
                prev_candle = df.iloc[i-1]
            except IndexError:
                log_debug(f"IndexError accessing candles at index {i} or {i-1}. Stopping OB search.")
                break

            # Check for NaN values in the candles being examined
            if candle.isnull().any() or prev_candle.isnull().any():
                log_debug(f"Skipping OB check at index {i} due to NaN values.")
                continue

            is_high_volume = candle['volume'] > volume_threshold
            is_bullish_impulse = candle['close'] > candle['open'] and candle['close'] > prev_candle['high'] # Closes above prev high
            is_bearish_impulse = candle['close'] < candle['open'] and candle['close'] < prev_candle['low'] # Closes below prev low
            prev_is_bearish = prev_candle['close'] < prev_candle['open']
            prev_is_bullish = prev_candle['close'] > prev_candle['open']
            sweeps_prev_low = candle['low'] < prev_candle['low']
            sweeps_prev_high = candle['high'] > prev_candle['high']

            # --- Potential Bullish OB ---
            # Condition: Previous candle bearish, current is strong bullish impulse, high volume, sweeps low.
            if (not bullish_ob and # Find most recent
                prev_is_bearish and is_bullish_impulse and is_high_volume and sweeps_prev_low):
                bullish_ob = {
                    'high': prev_candle['high'], 'low': prev_candle['low'],
                    'time': prev_candle.name, # Timestamp of the bearish candle (the OB)
                    'type': 'bullish'
                }
                log_debug(f"Potential Bullish OB found at {prev_candle.name.strftime('%Y-%m-%d %H:%M')} (Trigger: {candle.name.strftime('%H:%M')})")
                # Optimization: If we found both, stop searching
                if bearish_ob: break

            # --- Potential Bearish OB ---
            # Condition: Previous candle bullish, current is strong bearish impulse, high volume, sweeps high.
            elif (not bearish_ob and # Find most recent (use elif as one pair can't be both)
                  prev_is_bullish and is_bearish_impulse and is_high_volume and sweeps_prev_high):
                bearish_ob = {
                    'high': prev_candle['high'], 'low': prev_candle['low'],
                    'time': prev_candle.name, # Timestamp of the bullish candle (the OB)
                    'type': 'bearish'
                }
                log_debug(f"Potential Bearish OB found at {prev_candle.name.strftime('%Y-%m-%d %H:%M')} (Trigger: {candle.name.strftime('%H:%M')})")
                # Optimization: If we found both, stop searching
                if bullish_ob: break

        return bullish_ob, bearish_ob

    except Exception as e:
        log_error(f"Error in order block identification: {e}", exc_info=True)
        return None, None


# --- Indicator Calculation Function (Adds ATR and Volume MA conditionally) ---
def calculate_technical_indicators(df: Optional[pd.DataFrame],
                                  rsi_len: int, stoch_params: Dict, # Pass params explicitly
                                  calc_atr: bool = False, atr_len: int = 14,
                                  calc_vol_ma: bool = False, vol_ma_len: int = 20
                                  ) -> Optional[pd.DataFrame]:
    """
    Calculates technical indicators (RSI, Stochastic, optional ATR, optional Volume MA)
    using the pandas_ta library and appends them to the DataFrame.

    Args:
        df: Input DataFrame with OHLCV data.
        rsi_len: Length for RSI calculation.
        stoch_params: Dictionary with 'k', 'd', 'smooth_k' for Stochastic.
        calc_atr: Boolean flag to calculate ATR.
        atr_len: Length for ATR calculation.
        calc_vol_ma: Boolean flag to calculate Volume Moving Average.
        vol_ma_len: Length for Volume MA calculation.

    Returns:
        The DataFrame with calculated indicators added, or None if input is invalid.
        Rows with NaN values generated by indicators are dropped.
    """
    if df is None or df.empty:
        log_warning("Input DataFrame is None or empty for indicator calculation.")
        return None

    log_debug(f"Calculating indicators on DataFrame with {len(df)} rows...")
    original_columns = set(df.columns)
    calculated_indicator_names = []
    try:
        # Calculate RSI
        rsi_col = f'RSI_{rsi_len}'
        df.ta.rsi(length=rsi_len, append=True, col_names=(rsi_col,))
        calculated_indicator_names.append(rsi_col)

        # Calculate Stochastic Oscillator
        stoch_k_col = f'STOCHk_{stoch_params["k"]}_{stoch_params["d"]}_{stoch_params["smooth_k"]}'
        stoch_d_col = f'STOCHd_{stoch_params["k"]}_{stoch_params["d"]}_{stoch_params["smooth_k"]}'
        df.ta.stoch(k=stoch_params['k'], d=stoch_params['d'], smooth_k=stoch_params['smooth_k'], append=True, col_names=(stoch_k_col, stoch_d_col))
        calculated_indicator_names.extend([stoch_k_col, stoch_d_col])


        # Calculate ATR if needed
        atr_col: Optional[str] = None
        if calc_atr:
            atr_col = f'ATRr_{atr_len}' # pandas_ta default name for raw ATR
            df.ta.atr(length=atr_len, append=True, col_names=(atr_col,))
            log_debug(f"ATR ({atr_len}) calculated.")
            calculated_indicator_names.append(atr_col)

        # Calculate Volume MA if needed
        vol_ma_col: Optional[str] = None
        if calc_vol_ma:
            if 'volume' in df.columns:
                vol_ma_col = f'VOL_MA_{vol_ma_len}'
                # Use pandas rolling mean directly for more control over min_periods
                df[vol_ma_col] = df['volume'].rolling(window=vol_ma_len, min_periods=max(1, vol_ma_len // 2)).mean()
                log_debug(f"Volume MA ({vol_ma_len}) calculated.")
                calculated_indicator_names.append(vol_ma_col)
            else:
                log_warning("Volume column not found, cannot calculate Volume MA.")

        new_columns: List[str] = list(set(df.columns) - original_columns)
        # Verify that expected columns were actually added
        missing_calc = [ind for ind in calculated_indicator_names if ind not in new_columns and ind is not None]
        if missing_calc:
             log_warning(f"Some expected indicators might not have been added to DataFrame: {missing_calc}")

        log_debug(f"Indicators calculated. Columns added: {sorted(new_columns)}")

        initial_len: int = len(df)
        # Drop rows with NaN values generated by indicators (only check calculated indicator columns)
        indicator_cols_to_check_nan = [col for col in calculated_indicator_names if col in df.columns and col is not None]
        if indicator_cols_to_check_nan:
            df.dropna(subset=indicator_cols_to_check_nan, inplace=True)
        else:
             log_warning("No valid indicator columns found to drop NaNs from.")

        rows_dropped_nan: int = initial_len - len(df)
        if rows_dropped_nan > 0:
             log_debug(f"Dropped {rows_dropped_nan} rows with NaN values after indicator calculation.")

        if df.empty:
            log_warning("DataFrame became empty after dropping NaN rows from indicators.")
            return None

        log_debug(f"Indicator calculation complete. DataFrame now has {len(df)} rows.")
        return df

    except Exception as e:
        log_error(f"Error calculating technical indicators: {e}", exc_info=True)
        return None

# --- Position Sizing Function (Decorated) ---
@api_retry_decorator
def calculate_position_size(exchange_instance: ccxt.Exchange, trading_symbol: str, current_price: float, stop_loss_price: float, risk_perc: float) -> Optional[float]:
    """
    Calculates the position size in the base currency based on account balance,
    risk percentage, and stop-loss distance. Retries balance fetching on errors.

    Args:
        exchange_instance: Initialized ccxt exchange instance.
        trading_symbol: The trading symbol (e.g., 'BTC/USDT').
        current_price: The current price of the asset.
        stop_loss_price: The calculated stop-loss price.
        risk_perc: The fraction of the available balance to risk (e.g., 0.01 for 1%).

    Returns:
        The calculated position size (float) in the base currency, or None on failure.
    """
    try:
        log_debug(f"Calculating position size: Symbol={trading_symbol}, Price={current_price}, SL={stop_loss_price}, Risk={risk_perc*100}%")
        # Fetch account balance (This call is retried by the decorator)
        # Use params={'type': 'swap' or 'future'} if needed for specific wallet balance
        market = exchange_instance.market(trading_symbol)
        balance_params = {}
        if market.get('swap', False) or market.get('future', False):
             # Try specifying type if balance differs for contract types
             # This varies by exchange, might need specific checks
             # balance_params = {'type': 'swap'} # Example
             pass # Keep empty for now, rely on default fetch_balance behavior

        balance = exchange_instance.fetch_balance(params=balance_params)

        # Determine quote currency robustly
        quote_currency = market.get('quote')
        if not quote_currency:
             parts = trading_symbol.split('/')
             if len(parts) > 1: quote_currency = parts[1].split(':')[0]
        if not quote_currency:
             log_error(f"Could not determine quote currency for {trading_symbol}.")
             return None
        log_debug(f"Quote currency: {quote_currency}")

        # Find available balance in quote currency (handle variations in balance structure)
        available_balance = 0.0
        # Common structures:
        if isinstance(balance.get('free'), dict) and quote_currency in balance['free']:
            available_balance = float(balance['free'][quote_currency])
        elif isinstance(balance.get(quote_currency), dict):
            available_balance = float(balance[quote_currency].get('free', 0.0))
        # Check total if free isn't directly available (less ideal, assumes no margin used)
        elif isinstance(balance.get(quote_currency), dict) and available_balance == 0.0:
            available_balance = float(balance[quote_currency].get('total', 0.0))
            if available_balance > 0: log_warning(f"Using 'total' {quote_currency} balance for calculation, 'free' was zero or unavailable.")
        # Exchange specific 'info' check (Example for Bybit USDT unified account)
        elif exchange_instance.id == 'bybit' and quote_currency == 'USDT' and 'info' in balance and 'result' in balance['info'] and isinstance(balance['info']['result'], dict) and 'list' in balance['info']['result']:
             for wallet_info in balance['info']['result']['list']:
                  if isinstance(wallet_info, dict) and wallet_info.get('coin') == quote_currency:
                      # Bybit Unified uses availableToWithdraw or walletBalance
                      available_balance = float(wallet_info.get('availableToWithdraw', wallet_info.get('walletBalance', 0.0)))
                      break
        # Add other exchange-specific checks if needed

        if available_balance <= 0:
            log_error(f"No available {quote_currency} balance ({available_balance}) found for trading. Check balance structure/funds. Balance details: {balance.get(quote_currency, balance.get('info', 'N/A'))}")
            return None
        log_info(f"Available balance ({quote_currency}): {available_balance:.{price_precision_digits}f}")

        # Calculate risk amount
        risk_amount = available_balance * risk_perc
        log_info(f"Risk per trade ({risk_perc*100:.2f}%): {risk_amount:.{price_precision_digits}f} {quote_currency}")

        # Calculate price difference for SL
        price_diff = abs(current_price - stop_loss_price)

        # Ensure price difference is meaningful (at least half a tick)
        if price_diff <= min_tick / 2:
            log_error(f"Stop-loss price {stop_loss_price:.{price_precision_digits}f} is too close to current price {current_price:.{price_precision_digits}f} (Diff: {price_diff}). Cannot calculate size.")
            return None
        log_debug(f"Price difference for SL: {price_diff:.{price_precision_digits}f}")

        # Calculate quantity
        # For linear contracts (like BTC/USDT:USDT), size is risk_amount / price_diff
        # For inverse contracts (like BTC/USD:BTC), size is risk_amount / (price_diff / current_price) * base_per_contract or similar logic needed
        # Assuming linear contracts for now based on common symbols like BTC/USDT
        # TODO: Add check for inverse contracts if needed: market.get('inverse')
        if market.get('inverse', False):
            log_error(f"Position sizing for inverse contracts ({trading_symbol}) is not fully implemented. Calculation may be inaccurate.")
            # Basic inverse approximation (needs refinement based on contract value)
            # quantity = (risk_amount / current_price) / (price_diff / current_price) = risk_amount / price_diff # Appears same for basic calc? Check contract specs.
            # Need to consider contract size if not 1 base unit per contract.

        quantity = risk_amount / price_diff
        log_debug(f"Calculated raw quantity: {quantity:.{amount_precision_digits+4}f}") # Show more precision initially

        # Adjust for precision and limits
        try:
            quantity_adjusted = float(exchange_instance.amount_to_precision(trading_symbol, quantity))
            log_debug(f"Quantity adjusted for precision: {quantity_adjusted:.{amount_precision_digits}f}")
        except ccxt.ExchangeError as precision_error:
             log_warning(f"Could not use exchange.amount_to_precision: {precision_error}. Using raw quantity rounded.")
             # Fallback: round manually (less accurate than exchange method)
             quantity_adjusted = round(quantity, amount_precision_digits)


        if quantity_adjusted <= 0:
            log_error(f"Calculated quantity {quantity_adjusted:.{amount_precision_digits}f} is zero or negative.")
            return None

        # Check limits (min/max amount, min cost)
        limits = market.get('limits', {})
        min_amount = limits.get('amount', {}).get('min')
        max_amount = limits.get('amount', {}).get('max')
        min_cost = limits.get('cost', {}).get('min')

        log_debug(f"Market Limits: Min Qty={min_amount}, Max Qty={max_amount}, Min Cost={min_cost}")

        if min_amount is not None and quantity_adjusted < min_amount:
            log_error(f"Calculated quantity {quantity_adjusted:.{amount_precision_digits}f} is below min amount {min_amount}.")
            return None
        if max_amount is not None and quantity_adjusted > max_amount:
            log_warning(f"Calculated quantity {quantity_adjusted:.{amount_precision_digits}f} exceeds max amount {max_amount}. Capping.")
            quantity_adjusted = float(exchange_instance.amount_to_precision(trading_symbol, max_amount)) # Ensure capped value also meets precision

        estimated_cost = quantity_adjusted * current_price
        if min_cost is not None and estimated_cost < min_cost:
             log_error(f"Estimated order cost ({estimated_cost:.{price_precision_digits}f} {quote_currency}) is below min cost {min_cost} {quote_currency}.")
             return None

        # Sanity check cost vs balance (allow for some slippage/fees)
        cost_buffer = 0.99 # Use 99% of balance as limit for cost check
        if estimated_cost > available_balance * cost_buffer:
             log_error(f"Estimated cost ({estimated_cost:.{price_precision_digits}f}) exceeds {cost_buffer*100:.0f}% of available balance ({available_balance:.{price_precision_digits}f}). Reduce risk % or add funds.")
             return None

        log_info(f"{NEON_GREEN}Position size calculated: {quantity_adjusted:.{amount_precision_digits}f} {market.get('base', '')}{RESET} (Risking ~{risk_amount:.2f} {quote_currency})")
        return quantity_adjusted

    # Handle non-retryable errors specifically
    except ccxt.AuthenticationError as e:
         log_error(f"Authentication error during position size calculation (fetching balance): {e}")
         return None
    except ccxt.ExchangeError as e: # Catch other non-retryable exchange errors
        log_error(f"Exchange error during position size calculation: {e}")
        return None
    except Exception as e:
        if not isinstance(e, RETRYABLE_EXCEPTIONS):
             log_error(f"Unexpected non-retryable error calculating position size: {e}", exc_info=True)
        # If it was a retryable error, the decorator would have logged and raised it.
        return None


# --- Order Placement Functions (Decorated) ---

# Helper for cancellation with retry
@api_retry_decorator
def cancel_order_with_retry(exchange_instance: ccxt.Exchange, order_id: str, trading_symbol: str):
    """
    Cancels an order by ID with retry logic applied by the decorator.

    Args:
        exchange_instance: Initialized ccxt exchange instance.
        order_id: The ID of the order to cancel.
        trading_symbol: The symbol the order belongs to.

    Raises:
        ccxt exceptions if cancellation fails after retries or encounters a non-retryable error.
    """
    if not order_id:
        log_debug("No order ID provided to cancel.")
        return # Nothing to cancel

    log_info(f"Attempting to cancel order ID: {order_id} for {trading_symbol}...")
    if not SIMULATION_MODE:
        # The actual API call is wrapped by the decorator
        exchange_instance.cancel_order(order_id, trading_symbol)
        log_info(f"Order {order_id} cancellation request sent.")
    else:
        log_warning(f"SIMULATION: Skipped cancelling order {order_id}.")


@api_retry_decorator
def place_market_order(exchange_instance: ccxt.Exchange, trading_symbol: str, side: str, amount: float, reduce_only: bool = False) -> Optional[Dict[str, Any]]:
    """
    Places a market order ('buy' or 'sell') with retry logic. Optionally reduceOnly.

    Args:
        exchange_instance: Initialized ccxt exchange instance.
        trading_symbol: The market symbol.
        side: 'buy' or 'sell'.
        amount: The quantity to trade in the base currency.
        reduce_only: If True, sets the reduceOnly parameter (typically for futures/swaps).

    Returns:
        The order dictionary returned by ccxt, or None on failure.
    """
    if side not in ['buy', 'sell']:
        log_error(f"Invalid order side: '{side}'.")
        return None
    if amount <= 0:
        log_error(f"Invalid order amount: {amount}.")
        return None

    try:
        market = exchange_instance.market(trading_symbol)
        base_currency: str = market.get('base', '')
        quote_currency: str = market.get('quote', '')
        amount_formatted = float(exchange_instance.amount_to_precision(trading_symbol, amount))

        log_info(f"Attempting to place {side.upper()} market order for {amount_formatted:.{amount_precision_digits}f} {base_currency} {'(ReduceOnly)' if reduce_only else ''}...")

        params = {}
        # Apply reduceOnly param if requested and market is a contract type
        is_contract_market = market.get('swap') or market.get('future') or market.get('contract')
        if reduce_only:
             if is_contract_market:
                  params['reduceOnly'] = True
                  log_debug("Applying 'reduceOnly=True' to market order.")
             else:
                  log_warning("ReduceOnly requested but market type is likely SPOT. Ignoring reduceOnly param for market order.")

        order: Optional[Dict[str, Any]] = None
        if SIMULATION_MODE:
            log_warning("!!! SIMULATION: Market order placement skipped.")
            # Create a realistic dummy order response
            sim_price = 0.0
            try: # Fetch ticker safely with retry
                 @api_retry_decorator
                 def fetch_ticker_for_sim(exch, sym):
                    """Fetches ticker for simulation price with retry."""
                    return exch.fetch_ticker(sym)
                 ticker = fetch_ticker_for_sim(exchange_instance, trading_symbol)
                 sim_price = ticker['last'] if ticker and 'last' in ticker else 0.0
            except Exception as ticker_e:
                log_warning(f"Could not fetch ticker for simulation price after retries: {ticker_e}")

            order_id = f'sim_market_{pd.Timestamp.now().strftime("%Y%m%d%H%M%S%f")}'
            sim_cost = amount_formatted * sim_price if sim_price > 0 else 0.0
            order = {
                'id': order_id, 'clientOrderId': order_id, 'timestamp': int(time.time() * 1000),
                'datetime': pd.Timestamp.now(tz='UTC').isoformat(), 'status': 'closed', # Assume instant fill
                'symbol': trading_symbol, 'type': 'market', 'timeInForce': 'IOC', # ImmediateOrCancel is typical for market
                'side': side, 'price': sim_price, 'average': sim_price, # Assume fill at fetched price
                'amount': amount_formatted, 'filled': amount_formatted, 'remaining': 0.0,
                'cost': sim_cost, 'fee': None, # Fee simulation could be added
                'info': {'simulated': True, 'reduceOnly': params.get('reduceOnly', False)}
            }
        else:
            # --- LIVE TRADING ---
            log_warning(f"!!! LIVE MODE: Placing real market order {'(ReduceOnly)' if params.get('reduceOnly') else ''}.")
            # The create_market_order call is wrapped by the decorator
            order = exchange_instance.create_market_order(trading_symbol, side, amount_formatted, params=params)
            # --- END LIVE TRADING ---

        # Log results (works for both simulated and real orders if structure is consistent)
        if order:
            log_info(f"{side.capitalize()} market order request processed {'(Simulated)' if SIMULATION_MODE else ''}.")
            order_id: Optional[str] = order.get('id')
            order_status: Optional[str] = order.get('status')
            # Use 'average' if available (filled price), fallback to 'price'
            order_price: Optional[float] = order.get('average', order.get('price'))
            order_filled: Optional[float] = order.get('filled')
            order_cost: Optional[float] = order.get('cost')

            price_str: str = f"{order_price:.{price_precision_digits}f}" if isinstance(order_price, (int, float)) else "N/A"
            filled_str: str = f"{order_filled:.{amount_precision_digits}f}" if isinstance(order_filled, (int, float)) else "N/A"
            cost_str: str = f"{order_cost:.{price_precision_digits}f}" if isinstance(order_cost, (int, float)) else "N/A"

            log_info(f"Order Result | ID: {order_id or 'N/A'}, Status: {order_status or 'N/A'}, Avg Price: {price_str}, "
                     f"Filled: {filled_str} {base_currency}, Cost: {cost_str} {quote_currency}")
        else:
            # Should only happen if simulation logic fails or decorator re-raises an error handled below
             log_error("Market order placement failed to return an order object.")
             return None

        # Add short delay after placing order to allow exchange processing / state update
        time.sleep(1.5) # Increased delay slightly
        return order

    # Handle specific non-retryable errors after decorator has handled retries
    except ccxt.InsufficientFunds as e:
        log_error(f"Insufficient funds for {side} {amount_formatted} {trading_symbol}. Error: {e}")
        return None
    except ccxt.OrderNotFound as e: # Can happen if order rejected immediately or after delay
        log_error(f"OrderNotFound error placing {side} {amount_formatted} {trading_symbol}. Likely rejected. Error: {e}")
        return None
    except ccxt.InvalidOrder as e:
         log_error(f"Invalid market order parameters for {side} {amount_formatted} {trading_symbol}: {e}")
         return None
    except ccxt.ExchangeError as e: # Catch other non-retryable exchange errors
        log_error(f"Exchange specific error placing {side} market order for {trading_symbol}: {e}")
        return None
    except Exception as e:
        # Log unexpected errors that weren't caught by specific handlers or the retry decorator
        if not isinstance(e, RETRYABLE_EXCEPTIONS):
             log_error(f"Unexpected non-retryable error placing {side} market order: {e}", exc_info=True)
        # If it was a retryable error that failed all retries, the decorator raised it, and it's caught here.
        # We return None as the operation ultimately failed.
        return None


# Applying retry to the *entire* SL/TP function can lead to duplicate orders if one part fails
# and the retry attempts both again. A more robust approach for live trading would involve:
# 1. Place SL. If error, handle/log.
# 2. Place TP. If error, handle/log.
# 3. Return the results of both attempts.
# However, for simplicity matching the original structure, the decorator is applied to the whole function here.
@api_retry_decorator
def place_sl_tp_orders(exchange_instance: ccxt.Exchange, trading_symbol: str, position_side: str, quantity: float, sl_price: float, tp_price: float) -> Tuple[Optional[Dict[str, Any]], Optional[Dict[str, Any]]]:
    """
    Places stop-loss (stop-market preferred) and take-profit (limit) orders.
    Uses reduceOnly for contract markets. Retries the whole placement process on network errors.

    Args:
        exchange_instance: Initialized ccxt exchange instance.
        trading_symbol: The market symbol.
        position_side: 'long' or 'short' (the side of the position being protected).
        quantity: The quantity of the position (in base currency).
        sl_price: The trigger price for the stop-loss.
        tp_price: The limit price for the take-profit.

    Returns:
        A tuple containing (sl_order_result, tp_order_result). Each result is the
        ccxt order dictionary or None if placement failed for that order.
    """
    sl_order: Optional[Dict[str, Any]] = None
    tp_order: Optional[Dict[str, Any]] = None

    if quantity <= 0 or position_side not in ['long', 'short']:
        log_error(f"Invalid input for SL/TP placement: Qty={quantity}, Side='{position_side}'")
        return None, None

    try:
        market = exchange_instance.market(trading_symbol)
        close_side = 'sell' if position_side == 'long' else 'buy' # Order side to close position
        qty_formatted = float(exchange_instance.amount_to_precision(trading_symbol, quantity))
        sl_price_formatted = float(exchange_instance.price_to_precision(trading_symbol, sl_price))
        tp_price_formatted = float(exchange_instance.price_to_precision(trading_symbol, tp_price))

        # Check Market type and capabilities
        is_contract_market = market.get('swap') or market.get('future') or market.get('contract')
        has_reduce_only_param = is_contract_market

        # Check if createOrder likely supports stop types via params (more common/reliable)
        unified_order_options = exchange_instance.options.get('createOrder', {})
        supported_stop_types = unified_order_options.get('stopTypes', [])
        supports_stop_market_via_create = 'stopMarket' in supported_stop_types
        supports_stop_limit_via_create = 'stopLimit' in supported_stop_types
        has_limit_method = exchange_instance.has.get('createLimitOrder', True) # Assume basic limit exists

        # Determine parameters
        sl_params = {'reduceOnly': True} if has_reduce_only_param else {}
        tp_params = {'reduceOnly': True} if has_reduce_only_param else {}

        # --- Attempt to Place Stop-Loss Order ---
        log_info(f"Attempting SL order: {close_side.upper()} {qty_formatted:.{amount_precision_digits}f} @ trigger ~{sl_price_formatted:.{price_precision_digits}f} {'(ReduceOnly)' if 'reduceOnly' in sl_params else ''}")
        sl_order_type: Optional[str] = None
        sl_order_price: Optional[float] = None # Only needed for stopLimit

        # Select SL order type
        if supports_stop_market_via_create:
            sl_order_type = 'stopMarket'
            sl_params['stopPrice'] = sl_price_formatted
            log_debug("Using stopMarket type for SL via createOrder.")
        elif supports_stop_limit_via_create:
            sl_order_type = 'stopLimit'
            # Calculate appropriate limit price offset for stopLimit
            limit_offset = abs(tp_price_formatted - sl_price_formatted) * 0.1 # 10% of TP-SL range
            limit_offset = max(limit_offset, min_tick * 5) # Ensure offset is at least a few ticks
            sl_limit_price = sl_price_formatted - limit_offset if close_side == 'sell' else sl_price_formatted + limit_offset
            sl_order_price = float(exchange_instance.price_to_precision(trading_symbol, sl_limit_price))
            sl_params['stopPrice'] = sl_price_formatted
            sl_params['price'] = sl_order_price # The limit price for the order placed after trigger
            log_warning(f"Using stopLimit type for SL via createOrder. Trigger: {sl_price_formatted:.{price_precision_digits}f}, Limit: {sl_order_price:.{price_precision_digits}f}.")
        else:
            log_error(f"Exchange {exchange_instance.id} appears not to support stopMarket or stopLimit via createOrder. Cannot place automated SL.")

        # Place SL order if type determined
        if sl_order_type:
            if SIMULATION_MODE:
                log_warning("!!! SIMULATION: Stop-loss order placement skipped.")
                sl_order_id = f'sim_sl_{pd.Timestamp.now().strftime("%Y%m%d%H%M%S%f")}'
                sl_order = {
                    'id': sl_order_id, 'status': 'open', 'symbol': trading_symbol, 'type': sl_order_type,
                    'side': close_side, 'amount': qty_formatted, 'price': sl_order_price,
                    'stopPrice': sl_params.get('stopPrice'), 'average': None, 'filled': 0.0,
                    'remaining': qty_formatted, 'cost': 0.0,
                    'info': {'simulated': True, 'reduceOnly': sl_params.get('reduceOnly', False)}
                }
            else:
                # --- LIVE TRADING ---
                log_warning(f"!!! LIVE MODE: Placing real {sl_order_type} stop-loss order.")
                # The create_order call is wrapped by the main function's decorator
                sl_order = exchange_instance.create_order(
                    symbol=trading_symbol, type=sl_order_type, side=close_side,
                    amount=qty_formatted, price=sl_order_price, params=sl_params
                )
                log_info(f"Stop-loss order request processed. ID: {sl_order.get('id', 'N/A')}, Status: {sl_order.get('status', 'N/A')}")
                time.sleep(0.75) # Small delay after live order
                # --- END LIVE TRADING ---

        # --- Attempt to Place Take-Profit Order ---
        log_info(f"Attempting TP order: {close_side.upper()} {qty_formatted:.{amount_precision_digits}f} @ limit {tp_price_formatted:.{price_precision_digits}f} {'(ReduceOnly)' if 'reduceOnly' in tp_params else ''}")
        tp_order_type = 'limit' # Standard limit order for TP

        if has_limit_method:
             if SIMULATION_MODE:
                 log_warning("!!! SIMULATION: Take-profit order placement skipped.")
                 tp_order_id = f'sim_tp_{pd.Timestamp.now().strftime("%Y%m%d%H%M%S%f")}'
                 tp_order = {
                     'id': tp_order_id, 'status': 'open', 'symbol': trading_symbol, 'type': tp_order_type,
                     'side': close_side, 'amount': qty_formatted, 'price': tp_price_formatted,
                     'average': None, 'filled': 0.0, 'remaining': qty_formatted, 'cost': 0.0,
                     'info': {'simulated': True, 'reduceOnly': tp_params.get('reduceOnly', False)}
                 }
             else:
                # --- LIVE TRADING ---
                 log_warning(f"!!! LIVE MODE: Placing real {tp_order_type} take-profit order.")
                 # The create_limit_order call is wrapped by the main function's decorator
                 tp_order = exchange_instance.create_limit_order(
                     symbol=trading_symbol, side=close_side, amount=qty_formatted,
                     price=tp_price_formatted, params=tp_params
                 )
                 log_info(f"Take-profit order request processed. ID: {tp_order.get('id', 'N/A')}, Status: {tp_order.get('status', 'N/A')}")
                 time.sleep(0.75) # Small delay after live order
                 # --- END LIVE TRADING ---
        else:
             log_error(f"Exchange {exchange_instance.id} does not support limit orders. Cannot place take-profit.")
             # tp_order remains None

        # Final check and warnings if one failed (based on returned order objects)
        sl_ok = sl_order and sl_order.get('id')
        tp_ok = tp_order and tp_order.get('id')
        if sl_ok and not tp_ok and has_limit_method: log_warning("SL placed, but TP failed.")
        elif not sl_ok and tp_ok and sl_order_type: log_warning("TP placed, but SL failed. Position unprotected!")
        elif not sl_ok and not tp_ok and sl_order_type and has_limit_method: log_error("Both SL and TP order placements failed.")
        elif not sl_order_type and not tp_ok: log_error("SL order type not supported, and TP placement failed.")
        elif not sl_order_type and tp_ok: log_warning("SL order type not supported, but TP was placed.")


        return sl_order, tp_order

    # Handle specific non-retryable errors after decorator retries
    except ccxt.InvalidOrder as e:
        log_error(f"Invalid order parameters placing SL/TP: {e}")
        # Return whatever might have succeeded before the error
        return sl_order, tp_order
    except ccxt.InsufficientFunds as e: # Should not happen with reduceOnly, but possible
         log_error(f"Insufficient funds error during SL/TP placement (unexpected): {e}")
         return sl_order, tp_order
    except ccxt.ExchangeError as e: # Catch other non-retryable exchange errors
        log_error(f"Exchange specific error placing SL/TP orders: {e}")
        return sl_order, tp_order
    except Exception as e:
        if not isinstance(e, RETRYABLE_EXCEPTIONS):
             log_error(f"Unexpected non-retryable error in place_sl_tp_orders: {e}", exc_info=True)
        # Return None, None to indicate total failure if an exception occurred after retries
        return None, None


# --- Position and Order Check Function (Decorated) ---
@api_retry_decorator
def check_position_and_orders(exchange_instance: ccxt.Exchange, trading_symbol: str) -> bool:
    """
    Checks if tracked SL/TP orders associated with the current position are still open.
    If a tracked order is found to be closed/filled, it assumes the position is closed,
    attempts to cancel the other corresponding order (SL or TP), resets the local
    position state, and returns True. Retries API calls on network errors.

    Args:
        exchange_instance: Initialized ccxt exchange instance.
        trading_symbol: The market symbol to check orders for.

    Returns:
        True if the position state was reset due to a detected closure, False otherwise.
    """
    global position
    if position['status'] is None:
        return False # No active position to check

    log_debug(f"Checking open orders vs local state for {trading_symbol}...")
    position_reset_flag = False
    try:
        # Fetch Open Orders for the specific symbol (retried by decorator)
        # Add since=timestamp parameter? Might reduce payload but adds complexity if orders are old.
        open_orders = exchange_instance.fetch_open_orders(trading_symbol)
        log_debug(f"Found {len(open_orders)} open orders for {trading_symbol}.")

        sl_order_id = position.get('sl_order_id')
        tp_order_id = position.get('tp_order_id')

        if not sl_order_id and not tp_order_id:
             # This state can occur if SL/TP placement failed initially or after a restart
             # without proper state restoration of order IDs.
             log_warning(f"In {position['status']} position but no SL/TP order IDs tracked. Cannot verify closure via orders.")
             # Alternative: Try fetching current position size from exchange here?
             # `fetch_positions` is often needed for futures/swaps, but can be complex/inconsistent.
             # Sticking to order-based check for now.
             # Consider adding fetch_positions as a fallback if market is contract type
             # if is_contract_market and exchange_instance.has.get('fetchPositions'):
             #    try: positions = exchange_instance.fetch_positions([trading_symbol]) ... logic ...
             return False # Cannot determine closure reliably based on orders

        # Check if tracked orders are still present in the fetched open orders
        open_order_ids = {order.get('id') for order in open_orders if order.get('id')}
        sl_found_open = sl_order_id in open_order_ids
        tp_found_open = tp_order_id in open_order_ids

        log_debug(f"Tracked SL ({sl_order_id or 'None'}) open: {sl_found_open}. Tracked TP ({tp_order_id or 'None'}) open: {tp_found_open}.")

        # --- Logic for State Reset ---
        order_to_cancel_id = None
        assumed_close_reason = None

        # If SL was tracked but is no longer open:
        if sl_order_id and not sl_found_open:
            log_info(f"{NEON_YELLOW}Stop-loss order {sl_order_id} no longer open. Assuming position closed via SL.{RESET}")
            position_reset_flag = True
            order_to_cancel_id = tp_order_id # Attempt to cancel the TP order
            assumed_close_reason = "SL"

        # Else if TP was tracked but is no longer open:
        elif tp_order_id and not tp_found_open:
            log_info(f"{NEON_GREEN}Take-profit order {tp_order_id} no longer open. Assuming position closed via TP.{RESET}")
            position_reset_flag = True
            order_to_cancel_id = sl_order_id # Attempt to cancel the SL order
            assumed_close_reason = "TP"

        # If a reset was triggered:
        if position_reset_flag:
            # Attempt to cancel the other order using the retry helper
            if order_to_cancel_id:
                 log_info(f"Attempting to cancel leftover {'TP' if assumed_close_reason == 'SL' else 'SL'} order {order_to_cancel_id}...")
                 try:
                     # Use the decorated cancel helper
                     cancel_order_with_retry(exchange_instance, order_to_cancel_id, trading_symbol)
                 except ccxt.OrderNotFound:
                     # This is expected if the other order filled almost simultaneously or was manually cancelled
                     log_info(f"Order {order_to_cancel_id} was already closed/cancelled.")
                 except Exception as e:
                     # Error logged by cancel_order_with_retry or its decorator
                     # Log error but proceed with state reset, manual check advised.
                     log_error(f"Failed to cancel leftover order {order_to_cancel_id} after retries. Manual check advised.", exc_info=False) # Don't need full trace here
            else:
                 log_debug(f"No corresponding {'TP' if assumed_close_reason == 'SL' else 'SL'} order ID was tracked or provided to cancel.")


            log_info("Resetting local position state.")
            # Reset all relevant fields using the default structure
            position.update(position_default_structure.copy()) # Reset to defaults
            save_position_state() # Save the reset state
            display_position_status(position, price_precision_digits, amount_precision_digits) # Show updated status
            return True # Indicate position was reset

        # If both orders are still open, or only one was tracked and it's still open
        log_debug("Position state appears consistent with tracked open orders.")
        return False # Position was not reset

    # Handle specific non-retryable errors from fetch_open_orders if they bypass decorator
    except ccxt.AuthenticationError as e:
         log_error(f"Authentication error checking position/orders: {e}")
         return False # State uncertain
    except ccxt.ExchangeError as e:
        log_error(f"Exchange error checking position/orders: {e}")
        return False # State uncertain
    except Exception as e:
        if not isinstance(e, RETRYABLE_EXCEPTIONS):
             log_error(f"Unexpected non-retryable error checking position/orders: {e}", exc_info=True)
        # Let retry handler manage retryable exceptions, but return False as state is uncertain
        return False


# --- Trailing Stop Loss Update Function (Adapted & Simplified Placement) ---
def update_trailing_stop(exchange_instance: ccxt.Exchange, trading_symbol: str, current_price: float, last_atr: float):
    """
    Checks if the trailing stop loss needs to be updated based on price movement and ATR.
    If an update is required, it cancels the old SL order and places a new one.

    Args:
        exchange_instance: Initialized ccxt exchange instance.
        trading_symbol: The market symbol.
        current_price: The current market price.
        last_atr: The last calculated ATR value.
    """
    global position
    # --- Pre-conditions for Trailing Stop ---
    if position['status'] is None: return # No position
    if not enable_trailing_stop: return # TSL disabled in config
    if position['sl_order_id'] is None:
        # Log only if TSL is enabled but no SL ID exists (might happen if initial SL placement failed)
        log_warning("Cannot perform trailing stop check: No active SL order ID tracked.")
        return
    if last_atr <= 0:
        log_warning("Cannot perform trailing stop check: Invalid ATR value (<= 0).")
        return

    log_debug(f"Checking trailing stop. Current SL Order: {position['sl_order_id']}, Current Tracked TSL Price: {position.get('current_trailing_sl_price')}")

    new_potential_tsl: Optional[float] = None
    activation_threshold_met = False
    # Use current_trailing_sl_price if set (meaning TSL is active), otherwise use the initial stop_loss
    current_effective_sl = position.get('current_trailing_sl_price') or position.get('stop_loss')

    if current_effective_sl is None:
        log_warning("Cannot check TSL improvement: current effective SL price is None (initial SL might be missing).")
        return

    # --- Update Peak Prices & Check Activation Threshold ---
    entry_price = position.get('entry_price')
    if entry_price is None:
        log_warning("Cannot check TSL activation: Entry price is missing from position state.")
        return

    if position['status'] == 'long':
        highest_seen = position.get('highest_price_since_entry', entry_price) # Initialize with entry if missing
        if current_price > highest_seen:
            position['highest_price_since_entry'] = current_price
            highest_seen = current_price
            # Consider saving state less frequently, e.g., only when TSL actually updates.
            # save_position_state() # Persisting every new high might be excessive I/O.

        # Price must move enough (ATR * activation multiplier) above entry to activate TSL
        activation_price = entry_price + (last_atr * trailing_stop_activation_atr_multiplier)
        if highest_seen > activation_price:
            activation_threshold_met = True
            # Calculate potential new TSL based on the highest price seen since activation started
            new_potential_tsl = highest_seen - (last_atr * trailing_stop_atr_multiplier)
            log_debug(f"Long TSL Activation Met. Highest: {highest_seen:.{price_precision_digits}f} > Activation: {activation_price:.{price_precision_digits}f}. Potential New TSL: {new_potential_tsl:.{price_precision_digits}f}")
        else:
             log_debug(f"Long TSL Activation NOT Met. Highest: {highest_seen:.{price_precision_digits}f} <= Activation: {activation_price:.{price_precision_digits}f}")

    elif position['status'] == 'short':
        lowest_seen = position.get('lowest_price_since_entry', entry_price) # Initialize with entry if missing
        if current_price < lowest_seen:
            position['lowest_price_since_entry'] = current_price
            lowest_seen = current_price
            # save_position_state() # Persisting every new low might be excessive I/O.

        # Price must move enough below entry to activate TSL
        activation_price = entry_price - (last_atr * trailing_stop_activation_atr_multiplier)
        if lowest_seen < activation_price:
            activation_threshold_met = True
            # Calculate potential new TSL based on the lowest price seen
            new_potential_tsl = lowest_seen + (last_atr * trailing_stop_atr_multiplier)
            log_debug(f"Short TSL Activation Met. Lowest: {lowest_seen:.{price_precision_digits}f} < Activation: {activation_price:.{price_precision_digits}f}. Potential New TSL: {new_potential_tsl:.{price_precision_digits}f}")
        else:
            log_debug(f"Short TSL Activation NOT Met. Lowest: {lowest_seen:.{price_precision_digits}f} >= Activation: {activation_price:.{price_precision_digits}f}")

    # --- Check if New TSL is an Improvement & Place Order ---
    if activation_threshold_met and new_potential_tsl is not None:
        should_update_tsl = False
        # Format potential new TSL to market precision for valid comparison
        new_tsl_formatted = float(exchange_instance.price_to_precision(trading_symbol, new_potential_tsl))

        # Check if new TSL is strictly better than current effective SL
        # AND ensure it's not placed beyond the current price (would cause immediate stop-out)
        if position['status'] == 'long':
             if new_tsl_formatted > current_effective_sl and new_tsl_formatted < current_price:
                 should_update_tsl = True
                 log_debug(f"Long TSL check: New ({new_tsl_formatted:.{price_precision_digits}f}) > Current ({current_effective_sl:.{price_precision_digits}f}) AND < Price ({current_price:.{price_precision_digits}f}) -> OK")
             else:
                 log_debug(f"Long TSL check: New ({new_tsl_formatted:.{price_precision_digits}f}) vs Current ({current_effective_sl:.{price_precision_digits}f}) vs Price ({current_price:.{price_precision_digits}f}) -> NO UPDATE")

        elif position['status'] == 'short':
             if new_tsl_formatted < current_effective_sl and new_tsl_formatted > current_price:
                 should_update_tsl = True
                 log_debug(f"Short TSL check: New ({new_tsl_formatted:.{price_precision_digits}f}) < Current ({current_effective_sl:.{price_precision_digits}f}) AND > Price ({current_price:.{price_precision_digits}f}) -> OK")
             else:
                  log_debug(f"Short TSL check: New ({new_tsl_formatted:.{price_precision_digits}f}) vs Current ({current_effective_sl:.{price_precision_digits}f}) vs Price ({current_price:.{price_precision_digits}f}) -> NO UPDATE")

        # --- Execute TSL Update (Cancel Old, Place New) ---
        if should_update_tsl:
            log_info(f"{NEON_YELLOW}Trailing Stop Update Triggered! New target SL: {new_tsl_formatted:.{price_precision_digits}f}{RESET}")
            old_sl_id = position['sl_order_id'] # Already confirmed not None

            try:
                # 1. Cancel Old SL Order (using retry helper)
                log_info(f"Cancelling old SL order {old_sl_id} for TSL update...")
                cancel_order_with_retry(exchange_instance, old_sl_id, trading_symbol)
                log_info(f"Old SL order {old_sl_id} cancellation request sent/simulated.")
                time.sleep(1.0) # Allow cancellation processing time

                # 2. Place New SL Order (Direct placement logic adapted from place_sl_tp_orders)
                log_info(f"Placing new TSL order at {new_tsl_formatted:.{price_precision_digits}f}")
                new_sl_order_result: Optional[Dict[str, Any]] = None
                try:
                    close_side = 'sell' if position['status'] == 'long' else 'buy'
                    current_qty = position.get('quantity')
                    if current_qty is None or current_qty <= 0:
                        log_error("Cannot place new TSL order: Invalid quantity in position state.")
                        raise ValueError("Invalid position quantity for TSL placement.") # Raise to prevent state update

                    qty_formatted = float(exchange_instance.amount_to_precision(trading_symbol, current_qty))
                    market = exchange_instance.market(trading_symbol)
                    is_contract_market = market.get('swap') or market.get('future') or market.get('contract')
                    has_reduce_only_param = is_contract_market

                    new_sl_params = {'reduceOnly': True} if has_reduce_only_param else {}
                    new_sl_order_type: Optional[str] = None
                    new_sl_order_price: Optional[float] = None # For stopLimit

                    # Check preferred stop types via createOrder params
                    unified_order_options = exchange_instance.options.get('createOrder', {})
                    supported_stop_types = unified_order_options.get('stopTypes', [])
                    supports_stop_market_via_create = 'stopMarket' in supported_stop_types
                    supports_stop_limit_via_create = 'stopLimit' in supported_stop_types

                    if supports_stop_market_via_create:
                        new_sl_order_type = 'stopMarket'
                        new_sl_params['stopPrice'] = new_tsl_formatted
                    elif supports_stop_limit_via_create:
                        new_sl_order_type = 'stopLimit'
                        # Need original TP for offset calculation, fallback if missing
                        original_tp_price = position.get('take_profit', current_price * (1.05 if position['status'] == 'long' else 0.95))
                        limit_offset = abs(original_tp_price - new_tsl_formatted) * 0.1
                        limit_offset = max(limit_offset, min_tick * 5)
                        sl_limit_price = new_tsl_formatted - limit_offset if close_side == 'sell' else new_tsl_formatted + limit_offset
                        new_sl_order_price = float(exchange_instance.price_to_precision(trading_symbol, sl_limit_price))
                        new_sl_params['stopPrice'] = new_tsl_formatted
                        new_sl_params['price'] = new_sl_order_price
                    else:
                         # If neither stop type is supported, log error and cannot proceed
                         log_error(f"Exchange {exchange_instance.id} supports neither stopMarket nor stopLimit via createOrder for TSL. Cannot place new TSL order.")
                         raise ccxt.NotSupported(f"Exchange {exchange_instance.id} does not support required stop order types for TSL.")

                    log_info(f"Attempting direct placement of new TSL order ({new_sl_order_type})")
                    if SIMULATION_MODE:
                        log_warning("!!! SIMULATION: New TSL order placement skipped.")
                        new_sl_order_id = f'sim_tsl_{pd.Timestamp.now().strftime("%Y%m%d%H%M%S%f")}'
                        new_sl_order_result = {'id': new_sl_order_id, 'status': 'open', 'info': {'simulated': True}}
                    else:
                        log_warning(f"!!! LIVE MODE: Placing real {new_sl_order_type} TSL order.")
                        # Apply retry decorator specifically to this placement call for granularity
                        @api_retry_decorator
                        def place_new_tsl_order_live():
                            """Places the new TSL order with retry."""
                            return exchange_instance.create_order(
                                symbol=trading_symbol, type=new_sl_order_type, side=close_side,
                                amount=qty_formatted, price=new_sl_order_price, params=new_sl_params
                            )
                        new_sl_order_result = place_new_tsl_order_live()

                    # --- Update State on Successful Placement ---
                    if new_sl_order_result and new_sl_order_result.get('id'):
                        new_id = new_sl_order_result['id']
                        log_info(f"New trailing SL order placed successfully: ID {new_id}")
                        position['stop_loss'] = new_tsl_formatted # Update the reference SL price
                        position['sl_order_id'] = new_id
                        position['current_trailing_sl_price'] = new_tsl_formatted # Mark the active TSL price
                        save_position_state() # Save the successful update
                    else:
                        # This case means placing the new order failed after cancellation worked
                        log_error(f"Failed to place new trailing SL order after cancelling old one {old_sl_id}. POSITION MAY BE UNPROTECTED.")
                        position['sl_order_id'] = None # Mark SL as lost
                        position['current_trailing_sl_price'] = None
                        save_position_state()

                except Exception as place_e:
                    # Error logged by retry decorator or specific handlers within placement logic
                    log_error(f"Error placing new trailing SL order: {place_e}. POSITION MAY BE UNPROTECTED.", exc_info=True)
                    position['sl_order_id'] = None # Ensure SL state reflects failure
                    position['current_trailing_sl_price'] = None
                    save_position_state()

            except ccxt.OrderNotFound:
                log_warning(f"Old SL order {old_sl_id} not found during TSL update cancellation (might have been filled/cancelled already).")
                # If SL filled, check_position_and_orders should handle the reset next cycle.
                # Mark TSL as inactive if SL ID is now gone.
                position['current_trailing_sl_price'] = None
                position['sl_order_id'] = None # Ensure SL ID is cleared
                save_position_state() # Save the cleared state
            except Exception as cancel_e:
                # Error logged by cancel_order_with_retry or its decorator
                log_error(f"Error cancelling old SL order {old_sl_id} during TSL update: {cancel_e}. Aborting TSL placement.", exc_info=False)
                # Do not proceed to place new SL if cancellation failed unexpectedly. Position remains protected by the old SL (if it still exists).

# --- Main Trading Loop ---
log_info(f"Initializing trading bot for {symbol} on {timeframe}...")
# Load position state ONCE at startup
load_position_state()
log_info(f"Risk per trade: {risk_percentage*100:.2f}%")
log_info(f"Bot check interval: {sleep_interval_seconds} seconds ({sleep_interval_seconds/60:.1f} minutes)")
log_info(f"{NEON_YELLOW}Press Ctrl+C to stop the bot gracefully.{RESET}")

while True:
    try:
        cycle_start_time: pd.Timestamp = pd.Timestamp.now(tz='UTC')
        print_cycle_divider(cycle_start_time)

        # 1. Check Position/Order Consistency FIRST
        # This function now resets state if SL/TP filled and cancels the other order
        position_was_reset = check_position_and_orders(exchange, symbol)
        # Display status *after* the check, reflecting any resets
        display_position_status(position, price_precision_digits, amount_precision_digits)
        if position_was_reset:
             log_info("Position state reset by order check. Proceeding to check for new entries.")
             # Continue loop immediately to check signals without sleeping
             continue # Skip the rest of the loop for this iteration

        # 2. Fetch Fresh OHLCV Data
        ohlcv_df: Optional[pd.DataFrame] = fetch_ohlcv_data(exchange, symbol, timeframe, limit_count=data_limit)
        if ohlcv_df is None or ohlcv_df.empty:
            log_warning(f"Could not fetch valid OHLCV data. Waiting...")
            neon_sleep_timer(sleep_interval_seconds)
            continue

        # 3. Calculate Technical Indicators (Conditionally include ATR, Vol MA)
        needs_atr = enable_atr_sl_tp or enable_trailing_stop
        needs_vol_ma = entry_volume_confirmation_enabled
        stoch_params = {'k': stoch_k, 'd': stoch_d, 'smooth_k': stoch_smooth_k}
        df_with_indicators: Optional[pd.DataFrame] = calculate_technical_indicators(
            ohlcv_df.copy(), # Use copy to avoid modifying the original fetched data
            rsi_len=rsi_length, stoch_params=stoch_params,
            calc_atr=needs_atr, atr_len=atr_length,
            calc_vol_ma=needs_vol_ma, vol_ma_len=entry_volume_ma_length
        )
        if df_with_indicators is None or df_with_indicators.empty:
             log_warning(f"Indicator calculation failed. Waiting...")
             neon_sleep_timer(sleep_interval_seconds)
             continue

        # 4. Get Latest Data and Indicator Values
        if len(df_with_indicators) < 2: # Need at least previous and current candle data
            log_warning("Not enough data points after indicator calculation. Waiting...")
            neon_sleep_timer(sleep_interval_seconds)
            continue

        latest_data: pd.Series = df_with_indicators.iloc[-1]
        # Construct indicator column names dynamically based on config
        rsi_col_name: str = f'RSI_{rsi_length}'
        stoch_k_col_name: str = f'STOCHk_{stoch_k}_{stoch_d}_{stoch_smooth_k}'
        stoch_d_col_name: str = f'STOCHd_{stoch_k}_{stoch_d}_{stoch_smooth_k}'
        atr_col_name: Optional[str] = f'ATRr_{atr_length}' if needs_atr else None
        vol_ma_col_name: Optional[str] = f'VOL_MA_{entry_volume_ma_length}' if needs_vol_ma else None

        # Check required columns exist
        required_base_cols: List[str] = ['close', 'high', 'low', 'open', 'volume']
        required_indicator_cols: List[str] = [rsi_col_name, stoch_k_col_name, stoch_d_col_name]
        if needs_atr and atr_col_name: required_indicator_cols.append(atr_col_name)
        if needs_vol_ma and vol_ma_col_name: required_indicator_cols.append(vol_ma_col_name)

        all_required_cols = required_base_cols + [col for col in required_indicator_cols if col is not None]
        missing_cols = [col for col in all_required_cols if col not in df_with_indicators.columns]

        if missing_cols:
            log_error(f"Required columns missing in DataFrame: {missing_cols}. Check config/data/indicator calculation. Available: {df_with_indicators.columns.tolist()}")
            neon_sleep_timer(sleep_interval_seconds)
            continue

        # Extract latest values safely, checking for NaNs
        try:
            current_price: float = float(latest_data['close'])
            current_high: float = float(latest_data['high'])
            current_low: float = float(latest_data['low'])
            last_rsi: float = float(latest_data[rsi_col_name])
            last_stoch_k: float = float(latest_data[stoch_k_col_name])
            last_stoch_d: float = float(latest_data[stoch_d_col_name])

            last_atr: Optional[float] = None
            if needs_atr and atr_col_name:
                atr_val = latest_data.get(atr_col_name)
                if pd.notna(atr_val) and atr_val > 0: # Ensure ATR is positive
                    last_atr = float(atr_val)
                else:
                     log_warning(f"ATR value is NaN or non-positive ({atr_val}) for the latest candle. ATR-based logic will be skipped or may fail.")

            current_volume: Optional[float] = None
            last_volume_ma: Optional[float] = None
            if needs_vol_ma and vol_ma_col_name and 'volume' in latest_data:
                 vol_val = latest_data.get('volume')
                 vol_ma_val = latest_data.get(vol_ma_col_name)
                 if pd.notna(vol_val): current_volume = float(vol_val)
                 if pd.notna(vol_ma_val): last_volume_ma = float(vol_ma_val)
                 if current_volume is None or last_volume_ma is None:
                     log_warning("Volume or Volume MA is NaN. Volume confirmation may be skipped.")

            # Final check for essential NaNs that would break logic
            essential_values = [current_price, last_rsi, last_stoch_k, last_stoch_d]
            if any(pd.isna(v) for v in essential_values):
                 raise ValueError("Essential indicator value (Price, RSI, Stoch) is NaN.")

        except (KeyError, ValueError, TypeError) as e:
             log_error(f"Error extracting latest data or essential value is NaN: {e}. Data: {latest_data.to_dict()}", exc_info=True)
             neon_sleep_timer(sleep_interval_seconds)
             continue

        # Display Market Stats
        display_market_stats(current_price, last_rsi, last_stoch_k, last_stoch_d, last_atr, price_precision_digits)

        # 5. Identify Order Blocks
        bullish_ob, bearish_ob = identify_potential_order_block(
            df_with_indicators,
            vol_thresh_mult=ob_volume_threshold_multiplier,
            lookback_len=ob_lookback
        )
        display_order_blocks(bullish_ob, bearish_ob, price_precision_digits)


        # 6. Apply Trading Logic

        # --- Check if ALREADY IN A POSITION ---
        if position['status'] is not None:
            log_info(f"Currently in {position['status'].upper()} position.")

            # A. Check Trailing Stop Logic (runs first if enabled)
            # This function now handles all internal checks (enabled, ATR valid, SL ID exists)
            update_trailing_stop(exchange, symbol, current_price, last_atr if last_atr else 0.0)
            # Note: If TSL update fails to place new SL, position might become unprotected.


            # B. Check for Indicator-Based Exits (Optional Secondary Exit / Fallback)
            # This acts as a fallback IF SL/TP somehow fail or if you want faster exits based on indicators.
            execute_indicator_exit = False
            exit_reason = ""
            # Check RSI exit condition
            if position['status'] == 'long' and last_rsi > rsi_overbought:
                 exit_reason = f"Indicator Exit Signal (RSI {last_rsi:.1f} > {rsi_overbought})"
                 execute_indicator_exit = True
            elif position['status'] == 'short' and last_rsi < rsi_oversold:
                 exit_reason = f"Indicator Exit Signal (RSI {last_rsi:.1f} < {rsi_oversold})"
                 execute_indicator_exit = True
            # Add other indicator exit conditions here if desired (e.g., Stoch cross back)

            if execute_indicator_exit:
                display_signal("Exit", position['status'], exit_reason)
                log_warning(f"Attempting to close {position['status'].upper()} position via FALLBACK market order due to indicator signal.")

                # IMPORTANT: Cancel existing SL and TP orders *before* sending market exit order
                sl_id_to_cancel = position.get('sl_order_id')
                tp_id_to_cancel = position.get('tp_order_id')
                orders_cancelled_successfully = True # Assume success initially

                for order_id, order_type in [(sl_id_to_cancel, "SL"), (tp_id_to_cancel, "TP")]:
                    if order_id:
                        log_info(f"Cancelling existing {order_type} order {order_id} before fallback exit...")
                        try:
                            # Use the helper which includes retries
                            cancel_order_with_retry(exchange, order_id, symbol)
                        except ccxt.OrderNotFound:
                            log_info(f"{order_type} order {order_id} already closed/cancelled.")
                        except Exception as e:
                            # Error logged by helper, but mark as failed for safety
                            log_error(f"Error cancelling {order_type} order {order_id} during fallback exit: {e}", exc_info=False)
                            orders_cancelled_successfully = False # Mark cancellation as potentially failed

                if not orders_cancelled_successfully:
                     log_error("Failed to cancel one or both SL/TP orders. Aborting fallback market exit to avoid potential issues. MANUAL INTERVENTION MAY BE REQUIRED.")
                     # Do not proceed with market exit if cancellations failed
                else:
                    # Proceed with market exit order (use reduceOnly=True)
                    close_side = 'sell' if position['status'] == 'long' else 'buy'
                    exit_qty = position.get('quantity') # Get current quantity from state
                    if exit_qty is None or exit_qty <= 0:
                         log_error("Cannot place fallback exit order: Invalid quantity in position state.")
                    else:
                        # Place the market order to close the position
                        order_result = place_market_order(exchange, symbol, close_side, exit_qty, reduce_only=True)

                        # Check if order likely filled/accepted (market orders might not return 'closed' instantly)
                        if order_result and order_result.get('id'):
                            log_info(f"Fallback {position['status']} position close order placed/processed: ID {order_result.get('id', 'N/A')}")
                        else:
                            log_error(f"Fallback market order placement FAILED for {position['status']} position. Result: {order_result}")
                            # Critical: Bot tried to exit but failed. Manual intervention likely needed.

                        # Reset position state immediately after *attempting* market exit,
                        # regardless of confirmation, as the intent was to close.
                        # check_position_and_orders will verify closure on the next cycle.
                        log_info("Resetting local position state after indicator-based market exit attempt.")
                        position.update(position_default_structure.copy()) # Reset to defaults
                        save_position_state()
                        display_position_status(position, price_precision_digits, amount_precision_digits)
                        # Exit loop for this cycle after attempting exit
                        neon_sleep_timer(sleep_interval_seconds)
                        continue # Go to next cycle immediately
            else:
                 # If no indicator exit condition met, log monitoring status
                 sl_id_str = position.get('sl_order_id') or 'N/A'
                 tp_id_str = position.get('tp_order_id') or 'N/A'
                 log_info(f"Monitoring {position['status'].upper()} position. Waiting for SL ({sl_id_str}) / TP ({tp_id_str}) or TSL update.")


        # --- Check for NEW ENTRIES (only if not currently in a position) ---
        else: # position['status'] is None
            log_info("No active position. Checking for entry signals...")

            # --- Volume Confirmation Check ---
            volume_confirmed = False
            if entry_volume_confirmation_enabled:
                if current_volume is not None and last_volume_ma is not None and last_volume_ma > 0:
                    volume_threshold = last_volume_ma * entry_volume_multiplier
                    if current_volume > volume_threshold:
                        volume_confirmed = True
                        log_debug(f"Volume confirmed: Current Vol ({current_volume:.2f}) > Threshold ({volume_threshold:.2f})")
                    else:
                        log_debug(f"Volume NOT confirmed: Current Vol ({current_volume:.2f}) <= Threshold ({volume_threshold:.2f})")
                else:
                    log_debug("Volume confirmation enabled but volume or MA data is missing/invalid.")
            else:
                volume_confirmed = True # Skip check if disabled

            # --- Base Signal Conditions (RSI + Stoch) ---
            base_long_signal = last_rsi < rsi_oversold and last_stoch_k < stoch_oversold
            base_short_signal = last_rsi > rsi_overbought and last_stoch_k > stoch_overbought

            # --- Order Block Price Proximity Check ---
            long_ob_price_check = False
            long_ob_reason_part = ""
            if base_long_signal and bullish_ob:
                # Define entry zone near the bullish OB
                ob_range = bullish_ob['high'] - bullish_ob['low']
                # Allow entry if price is within OB or slightly above (e.g., 10% of range or min ticks)
                entry_zone_high = bullish_ob['high'] + max(ob_range * 0.10, min_tick * 2)
                entry_zone_low = bullish_ob['low']
                if entry_zone_low <= current_price <= entry_zone_high:
                    long_ob_price_check = True
                    long_ob_reason_part = f"Price near Bullish OB [{entry_zone_low:.{price_precision_digits}f} - {entry_zone_high:.{price_precision_digits}f}]"
                else:
                    log_debug(f"Base Long signal met, but price {current_price:.{price_precision_digits}f} outside Bullish OB entry zone.")
            elif base_long_signal:
                 log_debug("Base Long signal met, but no recent Bullish OB found.")

            short_ob_price_check = False
            short_ob_reason_part = ""
            if base_short_signal and bearish_ob:
                # Define entry zone near the bearish OB
                ob_range = bearish_ob['high'] - bearish_ob['low']
                # Allow entry if price is within OB or slightly below
                entry_zone_low = bearish_ob['low'] - max(ob_range * 0.10, min_tick * 2)
                entry_zone_high = bearish_ob['high']
                if entry_zone_low <= current_price <= entry_zone_high:
                    short_ob_price_check = True
                    short_ob_reason_part = f"Price near Bearish OB [{entry_zone_low:.{price_precision_digits}f} - {entry_zone_high:.{price_precision_digits}f}]"
                else:
                     log_debug(f"Base Short signal met, but price {current_price:.{price_precision_digits}f} outside Bearish OB entry zone.")
            elif base_short_signal:
                  log_debug("Base Short signal met, but no recent Bearish OB found.")


            # --- Combine Conditions for Final Entry Signal ---
            # All conditions must be met: Base Signal + OB Proximity + Volume Confirmation
            long_entry_condition = base_long_signal and long_ob_price_check and volume_confirmed
            short_entry_condition = base_short_signal and short_ob_price_check and volume_confirmed

            # Construct reason strings for logging/display
            long_reason = ""
            short_reason = ""
            if long_entry_condition:
                 long_reason = (f"RSI ({last_rsi:.1f} < {rsi_oversold}), "
                                f"StochK ({last_stoch_k:.1f} < {stoch_oversold}), "
                                f"{long_ob_reason_part}" +
                                (", Volume Confirmed" if entry_volume_confirmation_enabled else ""))
            elif short_entry_condition:
                 short_reason = (f"RSI ({last_rsi:.1f} > {rsi_overbought}), "
                                 f"StochK ({last_stoch_k:.1f} > {stoch_overbought}), "
                                 f"{short_ob_reason_part}" +
                                 (", Volume Confirmed" if entry_volume_confirmation_enabled else ""))
            # Log reasons for failure if base signal was met but other checks failed
            elif base_long_signal and long_ob_price_check and not volume_confirmed and entry_volume_confirmation_enabled:
                 log_debug("Long Base/OB conditions met, but volume not confirmed.")
            elif base_short_signal and short_ob_price_check and not volume_confirmed and entry_volume_confirmation_enabled:
                 log_debug("Short Base/OB conditions met, but volume not confirmed.")
            elif base_long_signal and not long_ob_price_check:
                 # Already logged OB proximity failure
                 pass
            elif base_short_signal and not short_ob_price_check:
                 # Already logged OB proximity failure
                 pass


            # --- Execute Entry ---
            side_to_enter: Optional[str] = None
            entry_reason: Optional[str] = None
            active_ob: Optional[Dict] = None

            if long_entry_condition:
                side_to_enter = 'buy'
                entry_reason = long_reason
                active_ob = bullish_ob
            elif short_entry_condition: # Use elif to prevent long/short in same cycle
                side_to_enter = 'sell'
                entry_reason = short_reason
                active_ob = bearish_ob

            if side_to_enter and entry_reason:
                display_signal("Entry", side_to_enter, entry_reason)

                # Calculate SL/TP prices based on config (ATR or Fixed %)
                stop_loss_price: Optional[float] = None
                take_profit_price: Optional[float] = None
                if enable_atr_sl_tp:
                    if last_atr: # Ensure last_atr is valid (positive)
                        if side_to_enter == 'buy':
                            stop_loss_price = current_price - (last_atr * atr_sl_multiplier)
                            take_profit_price = current_price + (last_atr * atr_tp_multiplier)
                        else: # short
                            stop_loss_price = current_price + (last_atr * atr_sl_multiplier)
                            take_profit_price = current_price - (last_atr * atr_tp_multiplier)
                        log_info(f"Calculated ATR-based SL: {stop_loss_price:.{price_precision_digits}f} ({atr_sl_multiplier}x ATR), TP: {take_profit_price:.{price_precision_digits}f} ({atr_tp_multiplier}x ATR)")
                    else:
                        log_error(f"Cannot calculate ATR SL/TP: Invalid ATR value ({last_atr}). Skipping {side_to_enter.upper()} entry.")
                        continue # Skip entry attempt
                else: # Fixed percentage
                    if side_to_enter == 'buy':
                        stop_loss_price = current_price * (1 - stop_loss_percentage)
                        take_profit_price = current_price * (1 + take_profit_percentage)
                    else: # short
                        stop_loss_price = current_price * (1 + stop_loss_percentage)
                        take_profit_price = current_price * (1 - take_profit_percentage)
                    log_info(f"Calculated Fixed % SL: {stop_loss_price:.{price_precision_digits}f} ({stop_loss_percentage*100:.1f}%), TP: {take_profit_price:.{price_precision_digits}f} ({take_profit_percentage*100:.1f}%)")

                # Adjust SL based on Order Block if it provides a tighter stop
                # Ensure active_ob exists and its levels are valid numbers
                if active_ob and isinstance(active_ob.get('low'), (float, int)) and isinstance(active_ob.get('high'), (float, int)):
                    ob_low = active_ob['low']
                    ob_high = active_ob['high']
                    adjusted_sl: Optional[float] = None

                    if side_to_enter == 'buy' and ob_low > stop_loss_price:
                        # Set SL just below the OB low (add buffer relative to OB low)
                        adjusted_sl_raw = ob_low * (1 - 0.0005) # e.g., 0.05% below low
                        # Ensure adjustment doesn't push SL too close or above current price, and is still below OB low
                        if adjusted_sl_raw < current_price and adjusted_sl_raw < ob_low:
                            adjusted_sl = float(exchange.price_to_precision(symbol, adjusted_sl_raw))
                            log_info(f"Adjusted SL tighter based on Bullish OB low: {adjusted_sl:.{price_precision_digits}f}")
                        else:
                            log_warning(f"Could not adjust SL based on Bullish OB low {ob_low:.{price_precision_digits}f} as adjustment ({adjusted_sl_raw:.{price_precision_digits}f}) is invalid relative to price/OB.")
                    elif side_to_enter == 'sell' and ob_high < stop_loss_price:
                        # Set SL just above the OB high
                        adjusted_sl_raw = ob_high * (1 + 0.0005) # e.g., 0.05% above high
                        # Ensure adjustment is valid
                        if adjusted_sl_raw > current_price and adjusted_sl_raw > ob_high:
                             adjusted_sl = float(exchange.price_to_precision(symbol, adjusted_sl_raw))
                             log_info(f"Adjusted SL tighter based on Bearish OB high: {adjusted_sl:.{price_precision_digits}f}")
                        else:
                             log_warning(f"Could not adjust SL based on Bearish OB high {ob_high:.{price_precision_digits}f} as adjustment ({adjusted_sl_raw:.{price_precision_digits}f}) is invalid relative to price/OB.")

                    if adjusted_sl is not None:
                         stop_loss_price = adjusted_sl


                # Final SL/TP validation (check against current price and each other)
                if stop_loss_price is None or take_profit_price is None:
                     log_error(f"SL or TP price calculation failed. Skipping {side_to_enter.upper()} entry.")
                     continue
                if side_to_enter == 'buy' and (stop_loss_price >= current_price or take_profit_price <= current_price):
                     log_error(f"Invalid LONG SL/TP: SL {stop_loss_price:.{price_precision_digits}f}, TP {take_profit_price:.{price_precision_digits}f} relative to Price {current_price:.{price_precision_digits}f}. Skipping entry.")
                     continue
                if side_to_enter == 'sell' and (stop_loss_price <= current_price or take_profit_price >= current_price):
                     log_error(f"Invalid SHORT SL/TP: SL {stop_loss_price:.{price_precision_digits}f}, TP {take_profit_price:.{price_precision_digits}f} relative to Price {current_price:.{price_precision_digits}f}. Skipping entry.")
                     continue

                # Calculate position size
                quantity = calculate_position_size(exchange, symbol, current_price, stop_loss_price, risk_percentage)
                if quantity is None or quantity <= 0:
                    log_error(f"Failed to calculate valid position size. Skipping {side_to_enter.upper()} entry.")
                else:
                    # Place entry market order
                    entry_order_result = place_market_order(exchange, symbol, side_to_enter, quantity, reduce_only=False) # Entry is never reduceOnly

                    # Check if order was placed and likely filled
                    is_filled = entry_order_result and (entry_order_result.get('status') == 'closed' or (entry_order_result.get('status') == 'open' and entry_order_result.get('filled', 0) > 0))

                    if is_filled:
                        entry_price_actual = entry_order_result.get('average', current_price) # Use average fill price if available
                        filled_quantity = entry_order_result.get('filled', quantity) # Use actual filled quantity

                        log_info(f"{side_to_enter.upper()} position entry order filled/processed: ID {entry_order_result.get('id', 'N/A')} at ~{entry_price_actual:.{price_precision_digits}f} for {filled_quantity:.{amount_precision_digits}f}")

                        # Place SL/TP orders *after* confirming entry fill/placement
                        sl_order, tp_order = place_sl_tp_orders(exchange, symbol, position_side=side_to_enter, quantity=filled_quantity, sl_price=stop_loss_price, tp_price=take_profit_price)

                        # Update position state ONLY if entry was successful
                        position.update({
                            'status': side_to_enter,
                            'entry_price': entry_price_actual,
                            'quantity': filled_quantity,
                            'order_id': entry_order_result.get('id'),
                            'stop_loss': stop_loss_price,
                            'take_profit': take_profit_price,
                            'entry_time': pd.Timestamp.now(tz='UTC'), # Record entry time
                            'sl_order_id': sl_order.get('id') if sl_order else None,
                            'tp_order_id': tp_order.get('id') if tp_order else None,
                            # Initialize TSL fields
                            'highest_price_since_entry': entry_price_actual if side_to_enter == 'long' else None,
                            'lowest_price_since_entry': entry_price_actual if side_to_enter == 'short' else None,
                            'current_trailing_sl_price': None # TSL starts inactive
                        })
                        save_position_state() # Save the new position state
                        display_position_status(position, price_precision_digits, amount_precision_digits) # Show new status

                        # Warn if SL/TP placement failed after successful entry
                        if not (sl_order and sl_order.get('id')) or not (tp_order and tp_order.get('id')):
                            log_warning("Entry successful, but SL and/or TP order placement failed or did not return ID. POSITION MAY BE UNPROTECTED! Monitor closely!")
                    else:
                        log_error(f"Failed to place or confirm fill for {side_to_enter.upper()} entry order. Result: {entry_order_result}")
                        # Position state remains None

            else: # No entry condition met
                log_info("Conditions not met for new entry.")


        # 7. Wait for the next cycle
        log_info(f"Cycle complete. Waiting for {sleep_interval_seconds} seconds...")
        neon_sleep_timer(sleep_interval_seconds)

    # --- Graceful Shutdown Handling ---
    except KeyboardInterrupt:
        log_info("Keyboard interrupt detected (Ctrl+C). Stopping the bot...")
        save_position_state()  # Save final state before exiting

        # Attempt to cancel open orders for the symbol if not in simulation mode
        if not SIMULATION_MODE:
            log_info(f"Attempting to cancel all open orders for {symbol}...")
            try:
                # Fetch open orders first (use retry)
                @api_retry_decorator
                def fetch_open_orders_on_exit(exch: ccxt.Exchange, sym: str) -> List[Dict]:
                    """Fetches open orders for shutdown cancellation."""
                    return exch.fetch_open_orders(sym)

                open_orders = fetch_open_orders_on_exit(exchange, symbol)

                if not open_orders:
                    log_info("No open orders found to cancel.")
                else:
                    log_warning(f"Found {len(open_orders)} open orders for {symbol}. Attempting cancellation...")
                    cancelled_count = 0
                    failed_count = 0
                    for order in open_orders:
                        order_id = order.get('id')
                        if not order_id: continue # Skip if no ID
                        try:
                            log_info(f"Cancelling order ID: {order_id} (Type: {order.get('type', 'N/A')}, Side: {order.get('side','N/A')})...")
                            # Use cancel helper with retry
                            cancel_order_with_retry(exchange, order_id, symbol)
                            cancelled_count += 1
                            time.sleep(0.3) # Small delay between cancellations to avoid rate limits
                        except ccxt.OrderNotFound:
                             log_info(f"Order {order_id} already closed/cancelled.")
                             cancelled_count += 1 # Count as effectively cancelled
                        except Exception as cancel_e:
                            # Error logged by helper, count as failed
                            log_error(f"Failed to cancel order {order_id} on exit after retries.", exc_info=False)
                            failed_count +=1
                    log_info(f"Order cancellation attempt complete. Success/Already Closed: {cancelled_count}, Failed: {failed_count}")
                    if failed_count > 0:
                        log_error(f"{failed_count} orders could not be cancelled automatically. Please check the exchange manually.")
            except Exception as e:
                log_error(f"Error fetching or cancelling open orders on exit: {e}", exc_info=True)
                log_error("Manual check of open orders on the exchange is recommended.")
        else:
             log_info("Simulation mode: Skipping order cancellation on exit.")

        break # Exit the main while loop

    # --- Robust Error Handling for the Main Loop ---
    except ccxt.RateLimitExceeded as e:
        log_error(f"Main loop Rate Limit Error: {e}. Waiting longer (default + 60s)...", exc_info=False)
        neon_sleep_timer(sleep_interval_seconds + 60) # Wait longer than usual
    except ccxt.NetworkError as e:
        log_error(f"Main loop Network Error: {e}. Default sleep + relying on API call retries...", exc_info=False)
        neon_sleep_timer(sleep_interval_seconds) # Rely on retry decorator within API calls for backoff
    except ccxt.ExchangeError as e: # Catch other potentially recoverable exchange issues
        log_error(f"Main loop Exchange Error: {e}. Default sleep + retry...", exc_info=False)
        # Could add specific handling for maintenance errors etc. here if needed
        neon_sleep_timer(sleep_interval_seconds)
    except Exception as e:
        log_error(f"CRITICAL unexpected error in main loop: {e}", exc_info=True)
        log_info("Attempting to recover by saving state and waiting 60s before next cycle...")
        try:
            save_position_state() # Save state on critical error
        except Exception as save_e:
            log_error(f"Failed to save state during critical error handling: {save_e}", exc_info=True)
        neon_sleep_timer(60) # Wait a bit before trying next cycle

# --- Bot Exit ---
print_shutdown_message()
sys.exit(0)

```
