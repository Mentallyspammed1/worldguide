"""Enhanced Trading Bot Script.

This script implements a trading bot using the CCXT library to interact with the Bybit exchange (V5 API).
It utilizes pandas and pandas_ta for technical analysis and incorporates features like:
- Customizable multi-indicator strategy with weighted signals.
- Dynamic position sizing based on risk percentage and ATR.
- ATR-based Stop Loss and Take Profit calculation.
- Optional Trailing Stop Loss via Bybit's native feature.
- Optional Break-Even Stop Loss adjustment.
- Optional MA Cross exit condition.
- Robust error handling and API call retries.
- Detailed logging with timezone awareness and sensitive data redaction.
- Configuration via JSON file (config.json).
- State persistence via JSON file (bot_state.json).
- Support for Bybit Unified Trading Accounts (UTA) and non-UTA accounts.
- Command-line arguments for debugging and configuration overrides.
"""

import argparse
import json
import logging
import math
import os
import re  # Used for parsing error messages
import sys
import time
import traceback
import asyncio
from datetime import datetime
from decimal import ROUND_DOWN, ROUND_UP, Decimal, InvalidOperation, getcontext
from logging.handlers import RotatingFileHandler
from typing import Any, Dict, List, Optional, Tuple, Union

# --- Timezone Handling ---
# Use standard library zoneinfo (Python 3.9+) if available, fallback to pytz
try:
    from zoneinfo import ZoneInfo  # Preferred (Python 3.9+)
    _has_zoneinfo = True
except ImportError:
    _has_zoneinfo = False
    try:
        # Fallback for Python < 3.9 (requires pip install pytz)
        from pytz import timezone as ZoneInfo
        _has_pytz = True
    except ImportError:
        _has_pytz = False
        # Critical dependency, exit if neither is available
        print("Error: Missing timezone library. Please install 'pytz' (Python < 3.9) or ensure Python 3.9+ for 'zoneinfo'.")
        sys.exit(1)

# --- Core Trading Libraries ---
try:
    import ccxt
except ImportError:
    print("Error: Missing required library 'ccxt'. Please install it (`pip install ccxt`).")
    sys.exit(1)
try:
    import numpy as np
except ImportError:
    print("Error: Missing required library 'numpy'. Please install it (`pip install numpy`).")
    sys.exit(1)
try:
    import pandas as pd
except ImportError:
    print("Error: Missing required library 'pandas'. Please install it (`pip install pandas`).")
    sys.exit(1)
try:
    import pandas_ta as ta
except ImportError:
    print("Error: Missing required library 'pandas_ta'. Please install it (`pip install pandas_ta`).")
    sys.exit(1)

# --- Optional Enhancements ---
# Colorama for colored console output
try:
    from colorama import Fore, Style, init
    COLORAMA_AVAILABLE = True
except ImportError:
    COLORAMA_AVAILABLE = False
    # Define dummy color variables if colorama is missing
    class DummyColor:
        def __getattr__(self, name: str) -> str: return ""  # Return empty string for any attribute
    Fore = DummyColor()
    Style = DummyColor()
    # Dummy init function
    def init(*args: Any, **kwargs: Any) -> None: pass

# Dotenv for loading environment variables from .env file
try:
    from dotenv import load_dotenv
except ImportError:
    # Define dummy function if dotenv is missing
    def load_dotenv(*args: Any, **kwargs: Any) -> bool: return False # Return False to indicate not loaded

# --- Initialization ---
# Set precision for Decimal arithmetic operations.
# Note: This primarily affects calculations like Decimal * Decimal.
# Storing and retrieving Decimals generally maintains their inherent precision.
try:
    getcontext().prec = 36  # Sufficient precision for most financial calculations
except Exception as e:
    print(f"Warning: Could not set Decimal precision: {e}")

# Initialize colorama (or dummy init)
# autoreset=True ensures styles are reset after each print statement
init(autoreset=True)

# Load environment variables from .env file (if python-dotenv is installed)
if load_dotenv():
    print("Loaded environment variables from .env file.")
else:
    print("Note: .env file not found or python-dotenv not installed. Relying on system environment variables.")

# --- Constants ---

# Bot Identity
BOT_VERSION = "1.1.3" # Updated version after review and completion

# Neon Color Scheme (requires colorama)
NEON_GREEN = Fore.LIGHTGREEN_EX if COLORAMA_AVAILABLE else ""
NEON_BLUE = Fore.LIGHTBLUE_EX if COLORAMA_AVAILABLE else ""
NEON_PURPLE = Fore.MAGENTA if COLORAMA_AVAILABLE else ""
NEON_YELLOW = Fore.YELLOW if COLORAMA_AVAILABLE else ""
NEON_RED = Fore.LIGHTRED_EX if COLORAMA_AVAILABLE else ""
NEON_CYAN = Fore.CYAN if COLORAMA_AVAILABLE else ""
RESET = Style.RESET_ALL if COLORAMA_AVAILABLE else ""

# --- Environment Variable Loading and Validation ---
# Load API Keys from environment variables
API_KEY = os.getenv("BYBIT_API_KEY")
API_SECRET = os.getenv("BYBIT_API_SECRET")

# Critical check: Ensure API keys are set
if not API_KEY or not API_SECRET:
    print(f"{NEON_RED}CRITICAL ERROR: BYBIT_API_KEY or BYBIT_API_SECRET environment variables not set.{RESET}")
    print("Please set them in your environment or in a .env file.")
    sys.exit(1)

# --- Configuration File and Paths ---
CONFIG_FILE = "config.json"     # Default configuration file name
LOG_DIRECTORY = "bot_logs"      # Directory to store log files
STATE_FILE = "bot_state.json"   # File to store persistent bot state

# Ensure log directory exists, create if it doesn't
try:
    os.makedirs(LOG_DIRECTORY, exist_ok=True)
except OSError as e:
    print(f"{NEON_RED}CRITICAL ERROR: Could not create log directory '{LOG_DIRECTORY}': {e}{RESET}")
    sys.exit(1)

# --- Timezone Configuration ---
_DEFAULT_TIMEZONE = "America/Chicago"
_FALLBACK_TIMEZONE = "UTC"
TZ_NAME = _DEFAULT_TIMEZONE # Default before loading from env/config
TIMEZONE = None # Initialize to None
try:
    # Attempt to load timezone from environment or use default
    TZ_NAME = os.getenv("BOT_TIMEZONE", _DEFAULT_TIMEZONE)
    TIMEZONE = ZoneInfo(TZ_NAME)
except Exception as tz_err:
    print(f"Warning: Could not load timezone '{TZ_NAME}' ({tz_err}). Defaulting to {_FALLBACK_TIMEZONE}.")
    # Default to UTC using the available library
    try:
        TIMEZONE = ZoneInfo(_FALLBACK_TIMEZONE)
        TZ_NAME = _FALLBACK_TIMEZONE
    except Exception as fallback_tz_err:
        # This should not happen due to initial checks, but as a final safeguard
        print(f"{NEON_RED}CRITICAL ERROR: Could not load fallback timezone {_FALLBACK_TIMEZONE}: {fallback_tz_err}{RESET}")
        sys.exit(1)

# --- API Interaction Constants ---
MAX_API_RETRIES = 4             # Max retries for recoverable API errors (e.g., rate limits, network issues)
RETRY_DELAY_SECONDS = 5         # Initial delay in seconds before retrying API calls (uses exponential backoff)
RATE_LIMIT_BUFFER_SECONDS = 0.5  # Extra buffer added to wait time suggested by rate limit errors
MARKET_RELOAD_INTERVAL_SECONDS = 3600  # How often to reload exchange market data (1 hour)
POSITION_CONFIRM_DELAY = 10     # Seconds to wait after placing entry order before confirming position/price via API
MIN_TICKS_AWAY_FOR_SLTP = 3     # Minimum number of price ticks SL/TP should be away from entry price after quantization

# --- Bot Logic Constants ---
# Supported intervals for OHLCV data (ensure config uses one of these string representations)
VALID_INTERVALS: List[str] = ["1", "3", "5", "15", "30", "60", "120", "240", "360", "720", "D", "W", "M"]
# Map bot intervals (strings) to ccxt's expected timeframe format (strings)
CCXT_INTERVAL_MAP: Dict[str, str] = {
    "1": "1m", "3": "3m", "5": "5m", "15": "15m", "30": "30m",
    "60": "1h", "120": "2h", "240": "4h", "360": "6h", "720": "12h",
    "D": "1d", "W": "1w", "M": "1M"
}

# Default Indicator/Strategy Parameters (can be overridden by config.json)
# These ensure the bot can run even with a minimal config file.
DEFAULT_ATR_PERIOD = 14
DEFAULT_CCI_WINDOW = 20
DEFAULT_WILLIAMS_R_WINDOW = 14
DEFAULT_MFI_WINDOW = 14
DEFAULT_STOCH_RSI_WINDOW = 14
DEFAULT_STOCH_WINDOW = 14  # Inner RSI period for StochRSI
DEFAULT_K_WINDOW = 3
DEFAULT_D_WINDOW = 3
DEFAULT_RSI_WINDOW = 14
DEFAULT_BOLLINGER_BANDS_PERIOD = 20
DEFAULT_BOLLINGER_BANDS_STD_DEV = 2.0
DEFAULT_SMA_10_WINDOW = 10
DEFAULT_EMA_SHORT_PERIOD = 9
DEFAULT_EMA_LONG_PERIOD = 21
DEFAULT_MOMENTUM_PERIOD = 7
DEFAULT_VOLUME_MA_PERIOD = 15
DEFAULT_FIB_WINDOW = 50
DEFAULT_PSAR_AF = 0.02
DEFAULT_PSAR_MAX_AF = 0.2
# Standard Fibonacci levels used for calculation
FIB_LEVELS: List[float] = [0.0, 0.236, 0.382, 0.5, 0.618, 0.786, 1.0]

# Default loop delay (can be overridden by config)
DEFAULT_LOOP_DELAY_SECONDS = 15

# Position Management Constants
MIN_POSITION_SIZE_DIFF_PCT = Decimal('0.05') # Max allowed difference (5%) between ordered and confirmed size (Used in main loop logic)

# --- Global Variables ---
loggers: Dict[str, logging.Logger] = {}  # Cache for logger instances to avoid duplicate handlers
console_log_level: int = logging.INFO   # Default console log level (can be changed by --debug arg)
QUOTE_CURRENCY: str = "USDT"            # Default quote currency (updated from config)
LOOP_DELAY_SECONDS: int = DEFAULT_LOOP_DELAY_SECONDS  # Actual loop delay (updated from config)
IS_UNIFIED_ACCOUNT: bool = False        # Flag indicating Bybit account type (detected on init)
ENABLE_TRADING: bool = False            # Master trading switch (updated from config)


# --- Logger Setup ---
class SensitiveFormatter(logging.Formatter):
    """Custom logging formatter to redact sensitive API keys/secrets."""
    REDACTED_STR: str = "***REDACTED***"
    # Store sensitive keys here for redaction. Ensure API_KEY/SECRET are checked for None.
    SENSITIVE_KEYS: List[str] = [
        key for key in [API_KEY, API_SECRET] if key is not None and len(key) > 4
    ]

    def format(self, record: logging.LogRecord) -> str:
        """Formats the log record, redacting sensitive info."""
        # Format the original record first
        formatted = super().format(record)
        # Redact sensitive keys if they exist and are long enough
        for key in self.SENSITIVE_KEYS:
            formatted = formatted.replace(key, self.REDACTED_STR)
        return formatted


class LocalTimeFormatter(SensitiveFormatter):
    """Custom formatter that uses the configured local timezone for console output timestamps.
    Inherits redaction logic from SensitiveFormatter.
    """
    # Ensure TIMEZONE is initialized before this class is used
    converter = lambda _, timestamp: datetime.fromtimestamp(timestamp, tz=TIMEZONE).timetuple() if TIMEZONE else time.localtime(timestamp)

    def formatTime(self, record: logging.LogRecord, datefmt: Optional[str] = None) -> str:
        """Formats the record's creation time using the local timezone and specified format."""
        if TIMEZONE:
            dt = datetime.fromtimestamp(record.created, tz=TIMEZONE)
        else: # Fallback if timezone object failed initialization (should not happen with checks)
            dt = datetime.fromtimestamp(record.created)

        if datefmt:
            # Use specified date format
            s = dt.strftime(datefmt)
        else:
            # Default format with milliseconds
            s = dt.strftime("%Y-%m-%d %H:%M:%S")
            s = f"{s},{int(record.msecs):03d}"  # Append milliseconds
        return s


def setup_logger(name: str, is_symbol_logger: bool = False) -> logging.Logger:
    """Sets up and configures a logger instance.

    - Uses rotating file handler with UTC timestamps for persistent logs.
    - Uses stream handler (console) with local timestamps and color formatting.
    - Redacts sensitive API keys/secrets in log messages.
    - Caches logger instances to avoid duplicate handlers.
    - Creates filesystem-safe log file names.

    Args:
        name: The base name for the logger (e.g., 'main', 'BTC/USDT').
        is_symbol_logger: If True, formats the logger name to be filesystem-safe
                          (replaces '/' and ':').

    Returns:
        The configured logging.Logger instance.
    """
    global console_log_level  # Use the global console level setting

    # Create a safe name for file system and logger registry
    safe_name = name.replace('/', '_').replace(':', '-') if is_symbol_logger else name
    logger_instance_name = f"livebot_{safe_name}"

    # Check cache first
    if logger_instance_name in loggers:
        logger = loggers[logger_instance_name]
        # Update console handler level if it changed (e.g., via --debug argument)
        for handler in logger.handlers:
            if isinstance(handler, logging.StreamHandler) and handler.level != console_log_level:
                handler.setLevel(console_log_level)
                # logger.debug(f"Updated console log level for '{logger_instance_name}' to {logging.getLevelName(console_log_level)}")
        return logger

    # Create logger instance
    logger = logging.getLogger(logger_instance_name)
    # Set logger level to DEBUG to capture all messages; handlers control output level
    logger.setLevel(logging.DEBUG)
    # Ensure logger doesn't inherit handlers from root logger
    logger.propagate = False

    # --- File Handler (UTC Timestamps, Sensitive Redaction) ---
    log_filename = os.path.join(LOG_DIRECTORY, f"{logger_instance_name}.log")
    try:
        # Rotate log file when it reaches 10MB, keep up to 5 backup files
        file_handler = RotatingFileHandler(log_filename, maxBytes=10 * 1024 * 1024, backupCount=5, encoding='utf-8')
        # Use UTC time for file logs for consistency across systems/timezones
        file_formatter = SensitiveFormatter(
            # Format: UTC Timestamp - Level - [LoggerName:LineNo] - Message
            fmt="%(asctime)s.%(msecs)03d UTC - %(levelname)-8s - [%(name)s:%(lineno)d] - %(message)s",
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        # Explicitly set UTC converter for file handler
        file_formatter.converter = time.gmtime
        file_handler.setFormatter(file_formatter)
        # File handler logs everything (DEBUG level and above)
        file_handler.setLevel(logging.DEBUG)
        logger.addHandler(file_handler)
    except Exception as e:
        # Log error to console if file handler setup fails
        print(f"{NEON_RED}Error setting up file logger for '{logger_instance_name}': {e}{RESET}")

    # --- Stream Handler (Local Timezone Timestamps, Colors, Sensitive Redaction) ---
    try:
        stream_handler = logging.StreamHandler(sys.stdout)
        # Include timezone name and use colors in console output format
        # Format: LocalTimestamp [TZ] - Level - [LoggerName] - Message
        console_fmt = (
            f"{NEON_BLUE}%(asctime)s{RESET} [{TZ_NAME}] - "
            f"{NEON_YELLOW}%(levelname)-8s{RESET} - "
            f"{NEON_PURPLE}[%(name)s]{RESET} - %(message)s"
        )
        # Use LocalTimeFormatter for timezone-aware timestamps and redaction
        # datefmt includes milliseconds (%f) sliced to 3 digits
        stream_formatter = LocalTimeFormatter(console_fmt, datefmt='%Y-%m-%d %H:%M:%S,%f'[:-3])
        stream_handler.setFormatter(stream_formatter)
        # Set console level based on global setting (e.g., INFO default, DEBUG if --debug)
        stream_handler.setLevel(console_log_level)
        logger.addHandler(stream_handler)
    except Exception as e:
        # Log error to console if stream handler setup fails
        print(f"{NEON_RED}Error setting up stream logger for '{logger_instance_name}': {e}{RESET}")

    # Cache the logger instance
    loggers[logger_instance_name] = logger
    logger.info(f"Logger '{logger_instance_name}' initialized. Log file: '{os.path.basename(log_filename)}', Console Level: {logging.getLevelName(console_log_level)}")
    return logger


# --- Configuration Management ---
def _ensure_config_keys(config: Dict[str, Any], default_config: Dict[str, Any], parent_key: str = "") -> Tuple[Dict[str, Any], bool]:
    """Recursively ensures all keys from the default config are present in the loaded config.
    Adds missing keys with default values and logs warnings. Handles nested dictionaries.

    Args:
        config: The configuration dictionary loaded from the file.
        default_config: The dictionary containing default keys and values.
        parent_key: String representing the parent key path for nested logging (e.g., "indicators.").

    Returns:
        A tuple containing:
        - The updated configuration dictionary.
        - A boolean indicating if any keys were added or if type mismatches occurred.
    """
    updated_config = config.copy()
    keys_added_or_type_mismatch = False
    current_path = f"{parent_key}." if parent_key else ""

    for key, default_value in default_config.items():
        full_key_path = f"{current_path}{key}"
        if key not in updated_config:
            # Key is missing, add it with the default value
            updated_config[key] = default_value
            keys_added_or_type_mismatch = True
            # Logging addition of missing keys can be noisy, keep at DEBUG or remove if not needed
            # get_logger("main").debug(f"Config: Added missing key '{full_key_path}' with default value: {default_value}")
        elif isinstance(default_value, dict) and isinstance(updated_config.get(key), dict):
            # Recursively check nested dictionaries
            nested_config, nested_keys_added = _ensure_config_keys(updated_config[key], default_value, full_key_path)
            if nested_keys_added:
                updated_config[key] = nested_config
                keys_added_or_type_mismatch = True
        elif updated_config.get(key) is not None and type(default_value) != type(updated_config.get(key)):
            # Type mismatch check (allow specific safe promotions/conversions)
            loaded_value = updated_config.get(key)
            # Allow int -> float/Decimal promotion
            is_promoting_num = (isinstance(default_value, (float, Decimal)) and isinstance(loaded_value, int))
            # Allow common string -> bool conversion (handled later in validation)
            is_str_bool_candidate = isinstance(default_value, bool) and isinstance(loaded_value, str)
            # Allow numeric string -> number conversion (handled later in validation)
            is_str_num_candidate = isinstance(default_value, (int, float)) and isinstance(loaded_value, str)

            if not is_promoting_num and not is_str_bool_candidate and not is_str_num_candidate:
                # Log type mismatch as a warning, but keep user's value for now. Validation will handle critical issues.
                # get_logger("main").warning(f"Config Warning: Type mismatch for '{full_key_path}'. Expected {type(default_value).__name__}, found {type(loaded_value).__name__}. Using loaded value '{loaded_value}'. Validation will attempt conversion.")
                pass # Keep user's value, validation handles critical conversions/errors.
                # keys_added_or_type_mismatch = True # Optionally flag type mismatches as needing review/update
    return updated_config, keys_added_or_type_mismatch


def _validate_config_values(config: Dict[str, Any], logger: logging.Logger) -> bool:
    """Validates critical configuration values for type, range, and format.
    Modifies the input config dictionary *in place* for necessary type conversions
    (e.g., string "true" to bool, string "10" to int).

    Args:
        config: The configuration dictionary to validate (modified in place).
        logger: The logger instance to use for reporting errors.

    Returns:
        True if the configuration is valid after potential modifications, False otherwise.
    """
    is_valid = True
    lg = logger

    # 1. Validate Interval
    interval = config.get("interval")
    if interval is None or str(interval) not in CCXT_INTERVAL_MAP:
        lg.error(f"Config Error: Invalid or missing 'interval' value '{interval}'. Must be one of {VALID_INTERVALS}")
        is_valid = False
    else:
        # Ensure config interval matches CCXT map key (string)
        config["interval"] = str(interval)  # Convert just in case user provided integer

    # 2. Validate Numeric Types and Ranges
    # Format: key: (expected_type, min_value, max_value, required_integer)
    # expected_type is the final target type (int or float)
    # required_integer flag ensures the value is converted to int if possible/necessary
    numeric_params: Dict[str, Tuple[type, Union[int, float], Union[int, float], bool]] = {
        "loop_delay": (int, 5, 3600, True),         # Min 5 sec delay recommended
        "risk_per_trade": (float, 0.0001, 0.5, False),  # Risk 0.01% to 50% of balance
        "leverage": (int, 1, 125, True),            # Practical leverage limits (exchange may vary)
        "max_concurrent_positions_total": (int, 1, 100, True),
        "atr_period": (int, 2, 500, True),
        "ema_short_period": (int, 2, 500, True),
        "ema_long_period": (int, 3, 1000, True),  # Ensure long > short is checked separately
        "rsi_period": (int, 2, 500, True),
        "bollinger_bands_period": (int, 5, 500, True),
        "bollinger_bands_std_dev": (float, 0.1, 5.0, False),
        "cci_window": (int, 5, 500, True),
        "williams_r_window": (int, 2, 500, True),
        "mfi_window": (int, 5, 500, True),
        "stoch_rsi_window": (int, 5, 500, True),
        "stoch_rsi_rsi_window": (int, 5, 500, True),  # Inner RSI window for StochRSI
        "stoch_rsi_k": (int, 1, 100, True),
        "stoch_rsi_d": (int, 1, 100, True),
        "psar_af": (float, 0.001, 0.5, False),
        "psar_max_af": (float, 0.01, 1.0, False),
        "sma_10_window": (int, 2, 500, True),
        "momentum_period": (int, 2, 500, True),
        "volume_ma_period": (int, 5, 500, True),
        "fibonacci_window": (int, 10, 1000, True),
        "orderbook_limit": (int, 1, 200, True),  # Bybit V5 limit might be 50 or 200 depending on type
        "signal_score_threshold": (float, 0.1, 10.0, False),
        "stoch_rsi_oversold_threshold": (float, 0.0, 50.0, False),
        "stoch_rsi_overbought_threshold": (float, 50.0, 100.0, False),
        "volume_confirmation_multiplier": (float, 0.1, 10.0, False),
        "scalping_signal_threshold": (float, 0.1, 10.0, False),
        "stop_loss_multiple": (float, 0.1, 10.0, False),   # Multiplier of ATR
        "take_profit_multiple": (float, 0.1, 20.0, False),  # Multiplier of ATR
        # Note: Bybit V5 TSL uses price *distance* and *activation price*, not rate/percentage.
        # These old keys are removed in load_config if found.
        # "trailing_stop_callback_rate": (float, 0.0001, 0.5, False),
        # "trailing_stop_activation_percentage": (float, 0.0, 0.5, False),
        "break_even_trigger_atr_multiple": (float, 0.1, 10.0, False),  # Multiplier of ATR
        "break_even_offset_ticks": (int, 0, 100, True),   # Number of ticks above/below entry for BE SL
    }

    for key, (target_type, min_val, max_val, require_int) in numeric_params.items():
        value = config.get(key)
        if value is None: continue  # Skip if optional or handled by ensure_keys

        original_value_repr = repr(value)  # For logging
        try:
            # Attempt conversion to float first for universal range checking
            num_value_float = float(value)

            # Check range
            if not (min_val <= num_value_float <= max_val):
                lg.error(f"Config Error: '{key}' value {num_value_float} (from {original_value_repr}) is outside the recommended range ({min_val} - {max_val}).")
                is_valid = False
                continue  # Skip further processing for this key

            # Convert to target type (int or float)
            if target_type is int:
                # Check if the float value is acceptably close to an integer
                if require_int and not math.isclose(num_value_float, round(num_value_float), rel_tol=1e-9):
                     lg.warning(f"Config Warning: '{key}' requires an integer, but found {num_value_float} (from {original_value_repr}). Truncating to {int(num_value_float)}.")
                config[key] = int(round(num_value_float))  # Round before casting to int
            else:  # Target type is float
                 config[key] = num_value_float  # Store as float

        except (ValueError, TypeError):
            lg.error(f"Config Error: '{key}' value {original_value_repr} could not be converted to a number.")
            is_valid = False

    # Specific check: EMA Long > EMA Short (after potential conversion)
    ema_long = config.get("ema_long_period")
    ema_short = config.get("ema_short_period")
    if isinstance(ema_long, int) and isinstance(ema_short, int) and ema_long <= ema_short:
        lg.error(f"Config Error: 'ema_long_period' ({ema_long}) must be greater than 'ema_short_period' ({ema_short}).")
        is_valid = False

    # 3. Validate Symbols List
    symbols = config.get("symbols")
    if not isinstance(symbols, list) or not symbols:
         lg.error("Config Error: 'symbols' must be a non-empty list.")
         is_valid = False
    elif not all(isinstance(s, str) and '/' in s for s in symbols):  # Basic format check
         lg.error(f"Config Error: 'symbols' list contains invalid formats. Expected 'BASE/QUOTE' or 'BASE/QUOTE:SETTLE'. Found: {symbols}")
         is_valid = False

    # 4. Validate Active Weight Set exists and contains valid weights
    active_set_name = config.get("active_weight_set")
    weight_sets = config.get("weight_sets")
    if not isinstance(weight_sets, dict) or not isinstance(active_set_name, str) or active_set_name not in weight_sets:
        lg.error(f"Config Error: 'active_weight_set' ('{active_set_name}') not found in 'weight_sets'. Available: {list(weight_sets.keys() if isinstance(weight_sets, dict) else [])}")
        is_valid = False
    elif not isinstance(weight_sets.get(active_set_name), dict): # Use .get() for safety
        lg.error(f"Config Error: Active weight set '{active_set_name}' must be a dictionary of weights.")
        is_valid = False
    else:
        # Validate weights within the active set (should be numeric)
        active_set_weights = weight_sets[active_set_name]
        for indi_key, weight_val in active_set_weights.items():
            try:
                # Try converting to float, store back as float in config for consistency
                active_set_weights[indi_key] = float(weight_val)
            except (ValueError, TypeError):
                 lg.error(f"Config Error: Invalid weight value '{weight_val}' for indicator '{indi_key}' in weight set '{active_set_name}'. Must be numeric.")
                 is_valid = False

    # 5. Validate Boolean types (ensure they are bool, converting common strings)
    bool_params = [
        "enable_trading", "use_sandbox", "enable_ma_cross_exit", "enable_trailing_stop",
        "enable_break_even", "break_even_force_fixed_sl"
    ]
    for key in bool_params:
        if key in config:  # Check if the key exists
            value = config[key]
            if isinstance(value, bool): continue  # Already boolean, skip

            # Try to convert common string representations
            if isinstance(value, str):
                val_str = value.lower().strip()
                if val_str in ['true', 'yes', '1', 'on']:
                    config[key] = True
                    lg.debug(f"Config: Converted '{key}' value '{value}' to True.")
                elif val_str in ['false', 'no', '0', 'off']:
                    config[key] = False
                    lg.debug(f"Config: Converted '{key}' value '{value}' to False.")
                else:
                    lg.error(f"Config Error: '{key}' value '{value}' must be a boolean (true/false/1/0 or actual boolean type).")
                    is_valid = False
            else:  # Not a bool or a string, invalid type
                lg.error(f"Config Error: '{key}' value '{value}' (type: {type(value).__name__}) must be a boolean.")
                is_valid = False

    # 6. Validate indicator enable flags (must be dict of booleans)
    indicators_config = config.get("indicators")
    if indicators_config is None:
        lg.error("Config Error: 'indicators' dictionary is missing.")
        is_valid = False
    elif not isinstance(indicators_config, dict):
         lg.error("Config Error: 'indicators' must be a dictionary.")
         is_valid = False
    else:
        for indi_key, indi_val in indicators_config.items():
            if isinstance(indi_val, bool): continue  # Correct type

            if isinstance(indi_val, str):
                val_str = indi_val.lower().strip()
                if val_str in ['true', 'yes', '1', 'on']:
                    config["indicators"][indi_key] = True  # Update in place
                    lg.debug(f"Config: Converted 'indicators.{indi_key}' value '{indi_val}' to True.")
                elif val_str in ['false', 'no', '0', 'off']:
                    config["indicators"][indi_key] = False  # Update in place
                    lg.debug(f"Config: Converted 'indicators.{indi_key}' value '{indi_val}' to False.")
                else:
                    lg.error(f"Config Error: Indicator enable flag 'indicators.{indi_key}' value '{indi_val}' must be a boolean (true/false/1/0).")
                    is_valid = False
            else:  # Not bool or string
                lg.error(f"Config Error: Indicator enable flag 'indicators.{indi_key}' value '{indi_val}' (type: {type(indi_val).__name__}) must be a boolean.")
                is_valid = False

    # 7. Validate Position Mode
    position_mode = config.get("position_mode", "One-Way")
    valid_modes = ["One-Way", "Hedge"]
    if position_mode not in valid_modes:
        lg.error(f"Config Error: Invalid 'position_mode' value '{position_mode}'. Must be one of {valid_modes}.")
        is_valid = False
    elif position_mode == "Hedge":
        lg.warning(f"{NEON_YELLOW}Config Warning: 'position_mode' is set to 'Hedge'. Ensure your Bybit account and API key are configured for Hedge Mode. Bot logic requires careful handling of positionIdx (1 for Buy, 2 for Sell) in Hedge Mode.{RESET}")

    return is_valid


def load_config(filepath: str, logger: logging.Logger) -> Optional[Dict[str, Any]]:
    """Loads, validates, and potentially updates the configuration from a JSON file.

    - Creates a default config file if it doesn't exist.
    - Ensures all necessary keys are present, adding defaults for missing ones (recursively).
    - Validates critical configuration values (type, range, format) and converts types where needed.
    - Saves the updated config (with defaults added or types converted) back to the file if changes were made.

    Args:
        filepath: The path to the configuration JSON file.
        logger: The logger instance for reporting.

    Returns:
        The loaded and validated configuration dictionary, or None if loading/validation fails critically.
    """
    lg = logger
    # --- Default Configuration Structure ---
    # Serves as the template and source of default values.
    default_config: Dict[str, Any] = {
        "symbols": ["BTC/USDT:USDT"],  # List of symbols (format: BASE/QUOTE:SETTLE or BASE/QUOTE)
        "interval": "5",              # Kline interval (string from VALID_INTERVALS)
        "loop_delay": DEFAULT_LOOP_DELAY_SECONDS,  # Seconds between bot cycles (integer)
        "quote_currency": "USDT",     # Primary currency for balance checks and calculations
        "enable_trading": False,      # Master switch for placing actual trades (boolean)
        "use_sandbox": True,          # Use Bybit's testnet environment (boolean)
        "risk_per_trade": 0.01,       # Fraction of balance to risk per trade (float, e.g., 0.01 = 1%)
        "leverage": 10,               # Leverage for futures trades (integer)
        "max_concurrent_positions_total": 1,  # Max open positions across all symbols (integer)
        "position_mode": "One-Way",   # "One-Way" or "Hedge" (string)
        # --- Indicator Periods & Parameters ---
        "atr_period": DEFAULT_ATR_PERIOD,
        "ema_short_period": DEFAULT_EMA_SHORT_PERIOD,
        "ema_long_period": DEFAULT_EMA_LONG_PERIOD,
        "rsi_period": DEFAULT_RSI_WINDOW,
        "bollinger_bands_period": DEFAULT_BOLLINGER_BANDS_PERIOD,
        "bollinger_bands_std_dev": DEFAULT_BOLLINGER_BANDS_STD_DEV,
        "cci_window": DEFAULT_CCI_WINDOW,
        "williams_r_window": DEFAULT_WILLIAMS_R_WINDOW,
        "mfi_window": DEFAULT_MFI_WINDOW,
        "stoch_rsi_window": DEFAULT_STOCH_RSI_WINDOW,
        "stoch_rsi_rsi_window": DEFAULT_STOCH_WINDOW,  # Inner RSI period for StochRSI
        "stoch_rsi_k": DEFAULT_K_WINDOW,
        "stoch_rsi_d": DEFAULT_D_WINDOW,
        "psar_af": DEFAULT_PSAR_AF,         # Parabolic SAR acceleration factor step (float)
        "psar_max_af": DEFAULT_PSAR_MAX_AF,  # Parabolic SAR max acceleration factor (float)
        "sma_10_window": DEFAULT_SMA_10_WINDOW,
        "momentum_period": DEFAULT_MOMENTUM_PERIOD,
        "volume_ma_period": DEFAULT_VOLUME_MA_PERIOD,
        "fibonacci_window": DEFAULT_FIB_WINDOW,  # Window for calculating Fib levels (integer)
        # --- Strategy & Order Settings ---
        "orderbook_limit": 25,           # Number of levels for order book analysis (integer, Bybit V5 allows 1, 50, 200)
        "signal_score_threshold": 1.5,   # Threshold for combined weighted score (float)
        "stoch_rsi_oversold_threshold": 25.0,  # Float
        "stoch_rsi_overbought_threshold": 75.0,  # Float
        "volume_confirmation_multiplier": 1.5,  # Float
        "scalping_signal_threshold": 2.5,  # Optional higher threshold for 'scalping' set (float)
        "stop_loss_multiple": 1.8,       # ATR multiple for SL distance (float)
        "take_profit_multiple": 0.7,     # ATR multiple for TP distance (float)
        # --- Exit & Position Management ---
        "enable_ma_cross_exit": True,    # Close position on adverse EMA cross (boolean)
        "enable_trailing_stop": True,    # Enable Bybit's native TSL feature (boolean)
        # NOTE: Bybit V5 TSL uses price *distance* and *activation price*.
        # The bot logic using `set_protection_ccxt` expects these values to be calculated
        # and passed in the `params` argument of relevant functions if TSL is enabled.
        # The old config keys (callback_rate, activation_percentage) are removed below.
        "enable_break_even": True,       # Enable moving SL to break-even (boolean)
        "break_even_trigger_atr_multiple": 1.0,  # ATR multiple profit needed to trigger BE (float)
        "break_even_offset_ticks": 2,    # Ticks above/below entry for BE SL (integer)
        "break_even_force_fixed_sl": True,  # If true, BE replaces TSL; if false, BE sets SL but TSL might remain active (boolean)
        # --- Indicator Enable Flags (Dictionary of booleans) ---
        "indicators": {
            "ema_alignment": True, "momentum": True, "volume_confirmation": True,
            "stoch_rsi": True, "rsi": True, "bollinger_bands": True, "vwap": True,
            "cci": True, "wr": True, "psar": True, "sma_10": True, "mfi": True,
            "orderbook": True,  # Requires fetching order book data
        },
        # --- Weight Sets for Signal Generation (Dictionary of dictionaries) ---
        "weight_sets": {
            "scalping": {  # Example: Focus on faster indicators
                "ema_alignment": 0.2, "momentum": 0.3, "volume_confirmation": 0.2,
                "stoch_rsi": 0.6, "rsi": 0.2, "bollinger_bands": 0.3, "vwap": 0.4,
                "cci": 0.3, "wr": 0.3, "psar": 0.2, "sma_10": 0.1, "mfi": 0.2,
                "orderbook": 0.15,
            },
            "default": {  # Example: More balanced
                "ema_alignment": 0.3, "momentum": 0.2, "volume_confirmation": 0.1,
                "stoch_rsi": 0.4, "rsi": 0.3, "bollinger_bands": 0.2, "vwap": 0.3,
                "cci": 0.2, "wr": 0.2, "psar": 0.3, "sma_10": 0.1, "mfi": 0.2,
                "orderbook": 0.1,
            }
        },
        "active_weight_set": "default"  # Which weight set to use (string)
    }

    # --- Adjustments for Bybit V5 TSL ---
    # Remove incompatible old keys from the default config structure.
    # The bot logic using `set_protection_ccxt` expects price distance and activation price.
    if "trailing_stop_callback_rate" in default_config:
        del default_config["trailing_stop_callback_rate"]
        lg.debug("Removed 'trailing_stop_callback_rate' from default config structure (incompatible with Bybit V5 API used).")
    if "trailing_stop_activation_percentage" in default_config:
        del default_config["trailing_stop_activation_percentage"]
        lg.debug("Removed 'trailing_stop_activation_percentage' from default config structure (incompatible with Bybit V5 API used).")

    loaded_config = None
    config_changed_needs_save = False
    original_loaded_config = None # Store initially loaded config for comparison

    # --- Load or Create Config File ---
    if not os.path.exists(filepath):
        # Config file doesn't exist, create it with defaults
        lg.warning(f"Config file not found at '{filepath}'. Creating default config...")
        try:
            with open(filepath, "w", encoding="utf-8") as f:
                # Use default json serializer, ensure keys are sorted for readability
                json.dump(default_config, f, indent=4, sort_keys=True)
            lg.info(f"{NEON_GREEN}Created default config file: {filepath}{RESET}")
            # Use the defaults as the loaded config
            loaded_config = default_config.copy() # Use a copy
            original_loaded_config = default_config.copy() # Initial state is default
            # No need to save again immediately as we just created it with defaults
        except OSError as e:
            lg.error(f"{NEON_RED}Error creating default config file {filepath}: {e}. Using in-memory defaults.{RESET}")
            # Fallback to using in-memory defaults if creation fails
            loaded_config = default_config.copy()
            original_loaded_config = default_config.copy()
    else:
        # Config file exists, load it
        try:
            with open(filepath, encoding="utf-8") as f:
                config_from_file = json.load(f)
            # Store the initially loaded config for comparison later
            original_loaded_config = config_from_file.copy() # Shallow copy is enough if ensure_keys doesn't modify nested dicts directly

            # Ensure all keys from default_config are present, add if missing
            config_with_defaults, keys_were_added = _ensure_config_keys(config_from_file, default_config)
            loaded_config = config_with_defaults  # Use the potentially updated config
            if keys_were_added:
                config_changed_needs_save = True
                lg.info("Added missing default keys to the loaded configuration.")

        except (FileNotFoundError, json.JSONDecodeError) as e:
            lg.error(f"{NEON_RED}Error loading config file {filepath}: {e}. Using default config and attempting to overwrite file with defaults.{RESET}")
            loaded_config = default_config.copy()  # Fallback to defaults
            original_loaded_config = default_config.copy() # Treat as if starting from defaults
            config_changed_needs_save = True  # Mark for saving the defaults
        except Exception as e:
            lg.error(f"{NEON_RED}Unexpected error loading configuration: {e}. Using defaults.{RESET}", exc_info=True)
            loaded_config = default_config.copy()  # Fallback to defaults
            original_loaded_config = default_config.copy()

    # --- Validate and Convert Loaded/Default Config ---
    # _validate_config_values modifies loaded_config in place
    if loaded_config is None: # Ensure loaded_config is not None before validation
        lg.critical("Configuration loading failed before validation. Exiting.")
        return None
    if not _validate_config_values(loaded_config, lg):
        lg.critical("Configuration validation failed. Please check errors above and fix config.json. Exiting.")
        return None  # Indicate critical failure

    # Check if validation/conversion modified the config compared to what was loaded/created
    # This check handles cases where _validate_config_values converts types (e.g., str "10" to int 10)
    try:
        # Compare the final validated config with the initial state (either default or loaded)
        initial_state_to_compare = original_loaded_config # Use the state before ensure/validate
        # Direct comparison is safer if types were converted in place
        if loaded_config != initial_state_to_compare:
            # Use json dumps for structural comparison as a fallback if direct fails (e.g., complex objects)
            # Note: This requires a custom serializer if Decimals are present, but config should be standard types after validation.
            try:
                if json.dumps(loaded_config, sort_keys=True) != json.dumps(initial_state_to_compare, sort_keys=True):
                     config_changed_needs_save = True
                     lg.info("Configuration values modified during validation/conversion (e.g., type changes).")
            except TypeError: # If direct comparison failed and json fails, assume change
                 config_changed_needs_save = True
                 lg.info("Configuration values likely modified during validation/conversion (comparison check inconclusive).")

    except Exception as cmp_err:
         lg.warning(f"Error comparing config states: {cmp_err}")

    # --- Save Updated Config if Necessary ---
    if config_changed_needs_save:
        lg.info(f"Configuration updated (missing keys added or types converted). Saving changes to '{filepath}'...")
        try:
            with open(filepath, "w", encoding="utf-8") as f_write:
                json.dump(loaded_config, f_write, indent=4, sort_keys=True)
            lg.info(f"{NEON_GREEN}Config file updated successfully.{RESET}")
        except OSError as e:
            lg.error(f"{NEON_RED}Error writing updated config file {filepath}: {e}{RESET}")
            # Continue with the validated config in memory, but saving failed

    lg.info("Configuration loaded and validated successfully.")
    return loaded_config


# --- State Management ---
def load_state(filepath: str, logger: logging.Logger) -> Dict[str, Any]:
    """Loads the bot's operational state from a JSON file.
    Handles file not found and JSON decoding errors gracefully.
    Converts relevant numerical strings back to Decimals.

    Args:
        filepath: Path to the state file (e.g., "bot_state.json").
        logger: Logger instance.

    Returns:
        A dictionary containing the loaded state, or an empty dictionary if loading fails
        or the file doesn't exist.
    """
    lg = logger
    if os.path.exists(filepath):
        try:
            with open(filepath, encoding='utf-8') as f:
                state_raw = json.load(f)
                lg.info(f"Loaded previous state from {filepath}")
                # Basic validation: Ensure it's a dictionary
                if not isinstance(state_raw, dict):
                    lg.error(f"State file {filepath} does not contain a valid dictionary. Starting fresh.")
                    return {}

                # --- State Structure Validation/Migration and Decimal Conversion ---
                state = {} # Build the processed state dictionary
                expected_symbol_keys = ['break_even_triggered', 'last_entry_price', 'position_size', 'position_side', 'initial_sl_price', 'initial_tp_price']
                for symbol, symbol_data_raw in state_raw.items():
                    if symbol == "global": # Handle global state entries if needed
                        state[symbol] = symbol_data_raw # Copy global state directly for now
                        continue

                    if isinstance(symbol_data_raw, dict):
                        symbol_data = {}
                        for key in expected_symbol_keys:
                            raw_value = symbol_data_raw.get(key)
                            processed_value = None
                            # Convert specific keys back to Decimal if they exist and are valid strings
                            if key in ['last_entry_price', 'position_size', 'initial_sl_price', 'initial_tp_price'] and isinstance(raw_value, str):
                                try:
                                    dec_val = Decimal(raw_value)
                                    if dec_val.is_finite():
                                        processed_value = dec_val
                                    else:
                                        lg.warning(f"State for '{symbol}': Found non-finite Decimal string '{raw_value}' for key '{key}'. Setting to None.")
                                except (InvalidOperation, ValueError):
                                    lg.warning(f"State for '{symbol}': Found invalid Decimal string '{raw_value}' for key '{key}'. Setting to None.")
                            # Handle boolean conversion (if needed, though JSON should handle bools)
                            elif key == 'break_even_triggered':
                                if isinstance(raw_value, bool):
                                    processed_value = raw_value
                                else:
                                    processed_value = False # Default if missing or wrong type
                            # Handle strings (like position_side)
                            elif key == 'position_side':
                                if isinstance(raw_value, str) and raw_value in ['long', 'short']:
                                    processed_value = raw_value
                                else:
                                    processed_value = None # Default if missing or invalid
                            else:
                                processed_value = raw_value # Keep other types as is

                            # Assign processed value or default if missing
                            if processed_value is not None:
                                symbol_data[key] = processed_value
                            elif key not in symbol_data_raw:
                                lg.debug(f"State for symbol '{symbol}' missing key '{key}'. Initializing with default.")
                                # Initialize with appropriate default
                                if key == 'break_even_triggered': symbol_data[key] = False
                                elif key == 'position_side': symbol_data[key] = None
                                else: symbol_data[key] = None # Default for price/size
                            # else: value was invalid and already logged, default to None implicitly

                        state[symbol] = symbol_data
                    else:
                        lg.warning(f"Invalid state data found for key '{symbol}' (expected dict). Resetting state for this symbol.")
                        # Reset to default structure with None/False values
                        state[symbol] = {k: (False if k == 'break_even_triggered' else None) for k in expected_symbol_keys}

                return state
        except json.JSONDecodeError as e:
            lg.error(f"Error decoding JSON from state file {filepath}: {e}. Starting with empty state.")
            return {}
        except OSError as e:
            lg.error(f"Error reading state file {filepath}: {e}. Starting with empty state.")
            return {}
        except Exception as e:
            lg.error(f"Unexpected error loading state: {e}. Starting with empty state.", exc_info=True)
            return {}
    else:
        lg.info(f"No previous state file found ('{filepath}'). Starting with empty state.")
        return {}


def save_state(filepath: str, state: Dict[str, Any], logger: logging.Logger) -> None:
    """Saves the bot's current operational state to a JSON file using an atomic write pattern.
    Ensures complex types like Decimal are converted to strings for JSON compatibility.

    Args:
        filepath: Path to the state file (e.g., "bot_state.json").
        state: The dictionary containing the current state to save.
        logger: Logger instance.
    """
    lg = logger
    temp_filepath = filepath + ".tmp"  # Temporary file path for atomic write

    try:
        # Define a custom serializer function to handle non-standard JSON types
        def json_serializer(obj: Any) -> Optional[str]:
            if isinstance(obj, Decimal):
                # Convert Decimal to string to preserve precision
                return str(obj) if obj.is_finite() else None # Avoid saving NaN/Infinity
            # Add handlers for other types if needed (e.g., datetime)
            # if isinstance(obj, datetime):
            #     return obj.isoformat()

            # Let default JSON encoder handle standard types or raise TypeError
            # Returning None for unsupported types might be safer than raising error during save
            try:
                # Check if obj is serializable by default encoder
                # json.dumps(obj) # This check can be slow, rely on the main dump call to raise TypeError
                return obj # Let the default encoder handle it
            except TypeError:
                lg.warning(f"Object of type {obj.__class__.__name__} is not JSON serializable. Saving as None.")
                return None # Save unsupported types as null in JSON

        # Write to temporary file first using the custom serializer
        with open(temp_filepath, 'w', encoding='utf-8') as f:
            # Use default=json_serializer to handle Decimals etc.
            json.dump(state, f, indent=4, sort_keys=True, default=json_serializer)

        # Atomic rename/replace (os.replace is atomic on most modern systems)
        # This ensures that the original file is only overwritten if the write to temp file was successful.
        os.replace(temp_filepath, filepath)
        lg.debug(f"Saved current state successfully to {filepath}")

    except (OSError, TypeError, json.JSONDecodeError) as e:
        lg.error(f"Error saving state file {filepath}: {e}")
    except Exception as e:
        lg.error(f"Unexpected error saving state: {e}", exc_info=True)
    finally:
        # Clean up the temporary file if it still exists (e.g., due to error before replace)
        if os.path.exists(temp_filepath):
            try:
                os.remove(temp_filepath)
            except OSError as rm_err:
                lg.error(f"Error removing temporary state file {temp_filepath}: {rm_err}")


# --- CCXT Exchange Setup ---
def initialize_exchange(config: Dict[str, Any], logger: logging.Logger) -> Optional[ccxt.Exchange]:
    """Initializes the CCXT Bybit exchange object.

    - Sets V5 API options, including broker ID and timeouts.
    - Configures sandbox mode based on config.
    - Loads exchange markets.
    - Tests API credentials and detects account type (UTA vs. Non-UTA) by fetching balance.
    - Sets global QUOTE_CURRENCY and IS_UNIFIED_ACCOUNT flags.

    Args:
        config: The bot's configuration dictionary.
        logger: The main logger instance.

    Returns:
        An initialized ccxt.Exchange object, or None if initialization fails critically.
    """
    lg = logger
    global QUOTE_CURRENCY, IS_UNIFIED_ACCOUNT  # Allow modification of globals

    try:
        # Set global quote currency from config
        QUOTE_CURRENCY = config.get("quote_currency", "USDT")
        lg.info(f"Using Quote Currency: {QUOTE_CURRENCY}")

        # --- CCXT Exchange Options for Bybit V5 ---
        exchange_options = {
            'apiKey': API_KEY,
            'secret': API_SECRET,
            'enableRateLimit': True,  # Enable CCXT's built-in rate limiter
            'rateLimit': 120,        # Default milliseconds between requests (Bybit V5 is faster, but CCXT handles actual limits)
            'options': {
                'defaultType': 'linear',  # Default to linear for futures/swaps (can be overridden by symbol format like BTC/USDT:USDT)
                'adjustForTimeDifference': True,  # Automatically adjust for time differences
                'recvWindow': 10000,     # Increased recvWindow (milliseconds) for potentially slower networks
                # --- Timeouts (milliseconds) - Slightly increased from defaults ---
                'fetchTickerTimeout': 15000, 'fetchBalanceTimeout': 25000,
                'createOrderTimeout': 30000, 'fetchOrderTimeout': 25000,
                'fetchPositionsTimeout': 25000, 'cancelOrderTimeout': 25000,
                'fetchOHLCVTimeout': 25000, 'setLeverageTimeout': 25000,
                'fetchMarketsTimeout': 45000,
                # --- Broker ID for identification (Optional, replace with your identifier if needed) ---
                'brokerId': f'EnhTradeBot{BOT_VERSION.replace(".", "")}',  # Example: EnhTradeBot113
                # --- Explicit V5 API Version Mapping (Good practice for clarity & stability) ---
                # Ensures CCXT uses V5 endpoints where intended. Match these paths with Bybit V5 documentation.
                'versions': {
                    'public': {
                        'GET': {
                            'market/tickers': 'v5', 'market/kline': 'v5', 'market/orderbook': 'v5',
                            # Add other public V5 endpoints used...
                        }
                    },
                    'private': {
                        'GET': {
                            'position/list': 'v5', 'account/wallet-balance': 'v5',
                            'order/realtime': 'v5', 'order/history': 'v5',
                            # Add other private GET V5 endpoints used...
                        },
                        'POST': {
                            'order/create': 'v5', 'order/cancel': 'v5',
                            'position/set-leverage': 'v5', 'position/trading-stop': 'v5',
                            # Add other private POST V5 endpoints used...
                        }
                    }
                },
                # --- Default Options hinting CCXT to prefer V5 methods ---
                # Reinforces the use of V5 for common operations.
                'default_options': {
                    'fetchPositions': 'v5', 'fetchBalance': 'v5', 'createOrder': 'v5',
                    'fetchOrder': 'v5', 'fetchTicker': 'v5', 'fetchOHLCV': 'v5',
                    'fetchOrderBook': 'v5', 'setLeverage': 'v5',
                    'private_post_position_trading_stop': 'v5',  # Explicit map for protection endpoint
                },
                # --- Account Type Mapping (Used internally by CCXT) ---
                # Helps CCXT understand Bybit's account structures.
                'accountsByType': {
                    'spot': 'SPOT', 'future': 'CONTRACT', 'swap': 'CONTRACT',
                    'margin': 'UNIFIED', 'option': 'OPTION', 'unified': 'UNIFIED',
                    'contract': 'CONTRACT',  # Explicitly map 'contract'
                },
                'accountsById': {  # Reverse mapping
                    'SPOT': 'spot', 'CONTRACT': 'contract', 'UNIFIED': 'unified', 'OPTION': 'option'
                },
                # --- Bybit Specific Options ---
                'bybit': {
                     # Helps CCXT resolve markets if settle currency isn't explicit in symbol
                    'defaultSettleCoin': QUOTE_CURRENCY
                }
            }
        }

        # Initialize exchange class
        exchange_id = 'bybit'
        exchange_class = getattr(ccxt, exchange_id)
        exchange: ccxt.Exchange = exchange_class(exchange_options)

        # --- Sandbox/Live Mode Configuration ---
        use_sandbox = config.get('use_sandbox', True)
        if use_sandbox:
            lg.warning(f"{NEON_YELLOW}USING SANDBOX MODE (Bybit Testnet) - No real funds involved.{RESET}")
            exchange.set_sandbox_mode(True)
        else:
            lg.warning(f"{NEON_RED}--- USING LIVE TRADING MODE (Real Money) --- CAUTION ADVISED!{RESET}")
            # Ensure sandbox mode is explicitly off if not using it
            exchange.set_sandbox_mode(False)

        # --- Load Markets ---
        lg.info(f"Connecting to {exchange.id} (Sandbox: {use_sandbox})...")
        lg.info(f"Loading markets for {exchange.id}... (CCXT Version: {ccxt.__version__})")
        try:
            exchange.load_markets()
            # Store timestamp of last market load for periodic refresh logic
            exchange.last_load_markets_timestamp = time.time()
            lg.info(f"Markets loaded successfully for {exchange.id}. Found {len(exchange.markets)} markets.")
        except (ccxt.NetworkError, ccxt.ExchangeError) as e:
            lg.critical(f"{NEON_RED}Fatal Error loading markets: {e}. Check network connection and API endpoint status.{RESET}", exc_info=True)
            return None  # Cannot proceed without markets
        except Exception as e:
            lg.critical(f"{NEON_RED}Unexpected Fatal Error loading markets: {e}.{RESET}", exc_info=True)
            return None

        # --- Test API Credentials & Detect Account Type ---
        lg.info(f"Attempting initial balance fetch for {QUOTE_CURRENCY} to test credentials and detect account type...")
        balance_decimal: Optional[Decimal] = None
        account_type_detected: Optional[str] = None
        try:
            # Use helper function to check both UTA and Non-UTA balance endpoints
            temp_is_unified, balance_decimal = _check_account_type_and_balance(exchange, QUOTE_CURRENCY, lg)

            if temp_is_unified is not None:
                IS_UNIFIED_ACCOUNT = temp_is_unified  # Set the global flag
                account_type_detected = "UNIFIED" if IS_UNIFIED_ACCOUNT else "CONTRACT/SPOT (Non-UTA)"
                lg.info(f"Detected Account Type: {account_type_detected}")
            else:
                # This indicates a failure to fetch balance using either common method
                lg.error(f"{NEON_RED}Could not determine account type or fetch initial balance.{RESET}")
                # If trading is enabled, this is critical.
                if config.get("enable_trading"):
                    lg.critical(f"{NEON_RED}Cannot verify balance/account type. Trading is enabled. Aborting initialization for safety.{RESET}")
                    return None
                else:
                    lg.warning(f"{NEON_YELLOW}Proceeding in non-trading mode despite inability to verify balance/account type.{RESET}")
                    # Set IS_UNIFIED_ACCOUNT to a default (e.g., False) or handle downstream checks carefully
                    IS_UNIFIED_ACCOUNT = False  # Default assumption if undetermined in non-trading mode
                    lg.warning(f"{NEON_YELLOW}Assuming Non-UTA account for non-trading operations.{RESET}")

            # Log balance status if fetched successfully
            if balance_decimal is not None:
                if balance_decimal > 0:
                    lg.info(f"{NEON_GREEN}Successfully connected. Initial {QUOTE_CURRENCY} balance: {balance_decimal:.4f}{RESET}")
                else:  # Balance is zero
                    lg.warning(f"{NEON_YELLOW}Successfully connected, but initial {QUOTE_CURRENCY} balance is zero.{RESET}")
            # If balance_decimal is None, the error was already logged by _check_account_type_and_balance or above

        except ccxt.AuthenticationError as auth_err:
            lg.critical(f"{NEON_RED}CCXT Authentication Error during initial setup: {auth_err}{RESET}")
            lg.critical(f"{NEON_RED}>> Please check API Key, API Secret, Permissions (Read/Trade for correct account type), Account Mode (Real/Testnet), and IP Whitelist.{RESET}")
            return None  # Fatal authentication error
        except Exception as balance_err:
            # Catch any other unexpected errors during the balance check phase
            lg.error(f"{NEON_RED}Unexpected error during initial balance check/account detection: {balance_err}{RESET}", exc_info=True)
            if config.get("enable_trading"):
                 lg.critical(f"{NEON_RED}Aborting initialization due to unexpected balance fetch error in trading mode.{RESET}")
                 return None
            else:
                 lg.warning(f"{NEON_YELLOW}Continuing in non-trading mode despite unexpected balance fetch error.{RESET}")
                 IS_UNIFIED_ACCOUNT = False  # Default assumption
                 lg.warning(f"{NEON_YELLOW}Assuming Non-UTA account for non-trading operations.{RESET}")

        # If all checks passed (or warnings accepted in non-trading mode)
        lg.info("Exchange initialization checks passed.")
        return exchange

    except (ccxt.AuthenticationError, ccxt.ExchangeError, ccxt.NetworkError) as e:
        # Catch errors during initial exchange class instantiation or configuration
        lg.critical(f"{NEON_RED}Failed to initialize CCXT exchange: {e}{RESET}", exc_info=True)
        return None
    except Exception as e:
        # Catch any other unexpected errors during setup
        lg.critical(f"{NEON_RED}Unexpected error during exchange initialization: {e}{RESET}", exc_info=True)
        return None


def _check_account_type_and_balance(exchange: ccxt.Exchange, currency: str, logger: logging.Logger) -> Tuple[Optional[bool], Optional[Decimal]]:
    """Attempts to fetch balance using both UNIFIED and CONTRACT/SPOT account types
    to determine the account structure and retrieve the initial balance.

    Args:
        exchange: The CCXT exchange instance.
        currency: The currency (quote asset) to fetch the balance for (e.g., "USDT").
        logger: The logger instance.

    Returns:
        A tuple containing:
        - bool or None: True if UNIFIED, False if CONTRACT/SPOT, None if undetermined.
        - Decimal or None: The available balance as Decimal, or None if fetch failed.
    """
    lg = logger
    unified_balance: Optional[Decimal] = None
    contract_spot_balance: Optional[Decimal] = None
    is_unified_detected: Optional[bool] = None

    # --- Attempt 1: Try fetching as UNIFIED account ---
    try:
        lg.debug("Checking balance with accountType=UNIFIED...")
        params_unified = {'accountType': 'UNIFIED', 'coin': currency}
        # Use safe_ccxt_call but with fewer retries for detection purposes
        # If this fails with auth error, safe_ccxt_call will raise it.
        bal_info_unified = safe_ccxt_call(exchange, 'fetch_balance', lg, max_retries=1, retry_delay=2, params=params_unified)
        parsed_balance = _parse_balance_response(bal_info_unified, currency, 'UNIFIED', lg)

        # If parsing returns a valid Decimal (even 0), it means the UNIFIED call likely succeeded structurally.
        if parsed_balance is not None:
            lg.info("Detected UNIFIED account structure (Balance check successful).")
            unified_balance = parsed_balance
            is_unified_detected = True
            # Return immediately if UNIFIED balance is found and parsed
            return is_unified_detected, unified_balance

    except ccxt.ExchangeError as e:
        # Specifically check for errors indicating the account is *not* UNIFIED or lacks permissions
        error_str = str(e).lower()
        # Bybit error codes/messages indicating wrong account type for the API key
        # 30086: UTA not supported / Account Type mismatch
        # 10001 + "accounttype": Parameter error related to account type
        # 10005: Permissions denied for account type
        # 10001 + "coin does not exist": Coin might not be in UNIFIED wallet
        # Add more codes if discovered...
        is_account_type_error = (
            "30086" in error_str or
            "unified account is not supported" in error_str or
            ("10001" in error_str and ("accounttype" in error_str or "coin does not exist" in error_str)) or
            ("10005" in error_str and ("permission denied" in error_str or "account type" in error_str))
        )
        if is_account_type_error:
             lg.debug(f"Fetching with UNIFIED failed with account type/coin mismatch error ({e}). Assuming Non-UTA.")
             is_unified_detected = False  # Strong indication of Non-UTA
        else:
             # Other exchange errors might be temporary network issues or unrelated problems
             lg.warning(f"ExchangeError checking UNIFIED balance: {e}. Will proceed to check CONTRACT/SPOT.")
             # Do not set is_unified_detected here, let the next check run.
    except Exception as e:
         # Includes potential AuthenticationError raised by safe_ccxt_call, or unexpected errors
         lg.warning(f"Error checking UNIFIED balance: {e}. Will proceed to check CONTRACT/SPOT if possible.")
         # If it was AuthenticationError, the main init function will catch it.

    # --- Attempt 2: Try fetching as CONTRACT/SPOT account (if UNIFIED failed or suggested Non-UTA) ---
    # Only proceed if unified check failed, indicated Non-UTA, or was inconclusive
    if is_unified_detected is False or is_unified_detected is None:
        lg.debug("Checking balance with CONTRACT/SPOT account types...")
        # Check CONTRACT first (common for futures), then SPOT.
        account_types_to_try = ['CONTRACT', 'SPOT']
        accumulated_non_uta_balance = Decimal('0')
        non_uta_balance_found = False

        for acc_type in account_types_to_try:
            try:
                lg.debug(f"Checking balance with accountType={acc_type}...")
                params = {'accountType': acc_type, 'coin': currency}
                bal_info = safe_ccxt_call(exchange, 'fetch_balance', lg, max_retries=1, retry_delay=2, params=params)
                parsed_balance = _parse_balance_response(bal_info, currency, acc_type, lg)

                if parsed_balance is not None:
                     lg.info(f"Successfully fetched balance using {acc_type} account type (Balance: {parsed_balance:.4f}).")
                     accumulated_non_uta_balance += parsed_balance
                     non_uta_balance_found = True
                     is_unified_detected = False  # Confirm Non-UTA structure success
                     # Don't return yet, check SPOT even if CONTRACT worked for non-UTA

            except ccxt.ExchangeError as e:
                 # Log errors but continue trying other types if possible
                 lg.warning(f"ExchangeError checking {acc_type} balance: {e}. Trying next type...")
            except Exception as e:
                 lg.warning(f"Unexpected error checking {acc_type} balance: {e}. Trying next type...")

        # After trying CONTRACT and SPOT:
        if non_uta_balance_found:
            contract_spot_balance = accumulated_non_uta_balance
            return False, contract_spot_balance  # Return False (Non-UTA) and the combined balance

    # --- Conclusion ---
    # This point is reached if:
    # 1) UNIFIED check succeeded (already returned).
    # 2) UNIFIED check failed conclusively (is_unified_detected=False) AND CONTRACT/SPOT check also failed to find balance.
    # 3) UNIFIED check had non-conclusive error AND CONTRACT/SPOT check also failed.
    if is_unified_detected is True:  # Should have returned earlier, but as safeguard
        return True, unified_balance
    if is_unified_detected is False and contract_spot_balance is not None:  # Should have returned earlier
        return False, contract_spot_balance

    # If we reach here, neither method definitively worked or found balance
    lg.error(f"Failed to determine account type OR fetch balance with common types (UNIFIED/CONTRACT/SPOT) for {currency}.")
    return None, None  # Unknown type, no balance retrieved


# --- CCXT API Call Helper with Retries ---
def safe_ccxt_call(
    exchange: ccxt.Exchange,
    method_name: str,
    logger: logging.Logger,
    max_retries: int = MAX_API_RETRIES,
    retry_delay: int = RETRY_DELAY_SECONDS,
    *args: Any, **kwargs: Any
) -> Any:
    """Safely calls a CCXT exchange method with robust retry logic for recoverable errors.

    Handles:
    - RateLimitExceeded (with exponential backoff, parsing suggested wait time).
    - NetworkError, RequestTimeout, DDoSProtection (with exponential backoff).
    - Specific non-retryable Bybit V5 ExchangeErrors based on error codes.
    - AuthenticationError (raises immediately).
    - Other potentially temporary ExchangeErrors (retried).

    Args:
        exchange: The initialized CCXT exchange object.
        method_name: The name of the CCXT method to call (e.g., 'fetch_balance').
        logger: The logger instance for reporting errors and warnings.
        max_retries: Maximum number of retries for recoverable errors.
        retry_delay: Initial delay in seconds before the first retry (uses exponential backoff).
        *args: Positional arguments for the CCXT method.
        **kwargs: Keyword arguments for the CCXT method (often includes 'params' for V5).

    Returns:
        The result of the CCXT method call if successful.

    Raises:
        ccxt.AuthenticationError: If authentication fails (not retried).
        ccxt.ExchangeError: If a non-retryable exchange error occurs or retries are exhausted for a retryable one.
        ccxt.NetworkError: If a network error persists after retries.
        ccxt.RequestTimeout: If a timeout persists after retries.
        RuntimeError: If max retries are exceeded without a specific CCXT exception being raised.
        Exception: Any other unexpected exception during the call.
    """
    lg = logger
    last_exception: Optional[Exception] = None

    for attempt in range(max_retries + 1):  # +1 to include the initial attempt
        try:
            # Debug log for call attempt details (can be verbose)
            # lg.debug(f"Calling {method_name} (Attempt {attempt + 1}/{max_retries + 1}), Args: {args}, Kwargs: {kwargs}")

            # Get the method from the exchange instance
            method = getattr(exchange, method_name)
            # Execute the method
            result = method(*args, **kwargs)

            # Debug log for successful call (optional)
            # lg.debug(f"Call to {method_name} successful.")
            return result  # Success

        except ccxt.RateLimitExceeded as e:
            last_exception = e
            # Calculate wait time using exponential backoff
            base_wait_time = retry_delay * (2 ** attempt)
            suggested_wait: Optional[float] = None
            # Try to parse suggested wait time from Bybit V5 error message
            try:
                error_msg = str(e).lower()
                # Regex for "Retry after XXXXms" or "Try again in Xs"
                match_ms = re.search(r'(?:retry after|try again in)\s*(\d+)\s*ms', error_msg)
                match_s = re.search(r'(?:retry after|try again in)\s*(\d+)\s*s', error_msg)
                if match_ms:
                    # Convert ms to seconds, ensure minimum wait, add buffer
                    suggested_wait = max(1.0, math.ceil(int(match_ms.group(1)) / 1000) + RATE_LIMIT_BUFFER_SECONDS)
                elif match_s:
                    # Use seconds directly, ensure minimum wait, add buffer
                    suggested_wait = max(1.0, int(match_s.group(1)) + RATE_LIMIT_BUFFER_SECONDS)
                elif "too many visits" in error_msg or "limit" in error_msg or "frequency" in error_msg or "10006" in error_msg or "10018" in error_msg:
                    # Fallback if specific time isn't mentioned but it's clearly a rate limit code/message
                    suggested_wait = base_wait_time + RATE_LIMIT_BUFFER_SECONDS
            except Exception as parse_err:
                 lg.debug(f"Could not parse rate limit wait time from '{str(e)}': {parse_err}")

            # Use suggested wait if available, otherwise use calculated exponential backoff
            final_wait = suggested_wait if suggested_wait is not None else base_wait_time

            if attempt < max_retries:
                lg.warning(f"{NEON_YELLOW}Rate limit hit calling {method_name}. Retrying in {final_wait:.2f}s... (Attempt {attempt + 1}/{max_retries}) Error: {e}{RESET}")
                time.sleep(final_wait)
            else:  # Max retries reached
                lg.error(f"{NEON_RED}Rate limit hit calling {method_name}. Max retries ({max_retries}) reached. Error: {e}{RESET}")
                raise e  # Re-raise the final RateLimitExceeded exception

        except (ccxt.NetworkError, ccxt.RequestTimeout, ccxt.DDoSProtection) as e:
            # Handle transient network issues, timeouts, or Cloudflare protection
            last_exception = e
            wait_time = retry_delay * (2 ** attempt)  # Exponential backoff
            if attempt < max_retries:
                lg.warning(f"{NEON_YELLOW}Network/Timeout/DDoS error calling {method_name}: {type(e).__name__}. Retrying in {wait_time:.1f}s... (Attempt {attempt + 1}/{max_retries}){RESET}")
                lg.debug(f"Error details: {e}")
                time.sleep(wait_time)
            else:  # Max retries reached
                 lg.error(f"{NEON_RED}{type(e).__name__} calling {method_name}. Max retries ({max_retries}) reached. Error: {e}{RESET}")
                 raise e  # Re-raise the final exception

        except ccxt.AuthenticationError as e:
            # Authentication errors are critical and not retryable
            lg.critical(f"{NEON_RED}Authentication Error calling {method_name}: {e}. Check API keys/permissions/IP whitelist. Not retrying.{RESET}")
            raise e  # Re-raise immediately

        except ccxt.ExchangeError as e:
            # Handle general exchange errors, potentially parsing Bybit specifics
            last_exception = e
            bybit_code: Optional[int] = None
            ret_msg: str = str(e)

            # --- Try to extract Bybit V5 retCode and retMsg ---
            # Check 'info' attribute first (often populated by CCXT)
            bybit_info = getattr(e, 'info', None)
            if isinstance(bybit_info, dict):
                bybit_code = bybit_info.get('retCode')
                ret_msg = bybit_info.get('retMsg', str(e))
            # Fallback: Try parsing the error string representation if info is missing/unhelpful
            if bybit_code is None:
                try:
                    # Look for JSON-like structure within the error string
                    json_part_match = re.search(r'({.*})', str(e))
                    if json_part_match:
                        # Attempt to parse JSON, handle potential errors
                        try:
                            # Basic quote fix, handle potential None replacement if needed
                            json_str = json_part_match.group(1).replace("'", '"').replace('None', 'null')
                            details_dict = json.loads(json_str)
                            bybit_code = details_dict.get('retCode')
                            ret_msg = details_dict.get('retMsg', str(e))
                        except json.JSONDecodeError:
                            # If JSON parsing fails, try regex for retCode/retMsg directly
                            code_match = re.search(r'retCode[\'"]?\s*:\s*(\d+)', str(e))
                            msg_match = re.search(r'retMsg[\'"]?\s*:\s*[\'"]([^\'"]+)[\'"]', str(e))
                            if code_match: bybit_code = int(code_match.group(1))
                            if msg_match: ret_msg = msg_match.group(1)
                except (IndexError, TypeError, ValueError): # Catch potential errors during regex/parsing
                    lg.debug(f"Could not parse Bybit code/msg from error string: {str(e)}")

            # --- Define known non-retryable Bybit V5 error codes ---
            # Consult Bybit V5 API documentation for the most up-to-date list:
            # https://bybit-exchange.github.io/docs/v5/error_code
            non_retryable_codes: List[int] = [
                # Parameter/Request Errors (10xxx) - Usually indicate client-side issue
                10001,  # Parameter error (check args/kwargs/permissions)
                10002,  # Request method/path not supported
                10003,  # Invalid API key or IP whitelist issue
                10004,  # Invalid sign / Authentication failed (redundant with AuthenticationError but good backup)
                10005,  # Permissions denied for API key
                # 10006 is Rate Limit (handled above)
                10009,  # IP address banned temporarily or permanently
                # 10010 is Request Timeout (handled above)
                10016,  # Service error / System maintenance (Might be temporary, but often requires longer wait or intervention)
                10017,  # Request path not found (likely CCXT/API mismatch)
                # 10018 is Frequency Limit (handled above as RateLimit)
                10020,  # Websocket issue (less relevant for REST but indicates system problem)
                10029,  # Request parameter validation failed (e.g., invalid format)
                # Order/Position Logic Errors (11xxx) - Generally indicate logic/state issues, not temporary network problems
                110001,  # Order placement failed (generic - check message)
                110003,  # Invalid price (precision, range)
                110004,  # Invalid quantity (precision, range)
                110005,  # Quantity too small (min order size)
                110006,  # Quantity too large (max order size)
                110007,  # Insufficient balance / margin
                110008,  # Order cost too small (min cost)
                110009,  # Order cost too large
                110010,  # Invalid order type ('market', 'limit')
                110011,  # Invalid side ('buy', 'sell')
                110012,  # Invalid timeInForce
                110013,  # Price deviates too much from mark price
                110014,  # Order ID not found or invalid (for cancel/amend)
                110015,  # Order already cancelled
                110016,  # Order already filled or partially filled and cannot be amended
                110017,  # Price/Quantity precision error
                110019,  # Cannot amend market orders
                110020,  # Position status prohibits action (e.g., during liquidation)
                110021,  # Risk limit exceeded for account/symbol
                110022,  # Invalid leverage value
                110024,  # Position not found
                110025,  # Position index error (Hedge Mode specific - positionIdx mismatch)
                110028,  # Reduce-only order would increase position size
                110031,  # Order quantity exceeds open order limit for symbol
                110033,  # Cannot set leverage in cross margin mode manually
                110036,  # Cross/Isolated mode mismatch for symbol
                110040,  # TP/SL order parameter error
                110041,  # TP/SL requires an active position
                110042,  # TP/SL price is invalid (e.g., triggers liquidation, wrong side of entry)
                # 110043: Leverage not modified (Handled as success below)
                110044,  # Margin mode not modified
                110045,  # Position quantity exceeds risk limit tier
                110047,  # Cannot set TP/SL for Market orders during creation
                110051,  # Position is zero, cannot place reduce-only closing order
                110067,  # Feature requires UTA Pro account upgrade
                # Account/Risk/Position Errors (17xxx) - Indicate deeper issues
                170001,  # Internal error affecting position calculation
                170007,  # Risk limit error (check position value limits)
                170019,  # Account in margin call / liquidation status
                170131,  # TP/SL price invalid (redundant with 110042?)
                170132,  # TP/SL order would trigger immediate liquidation
                170133,  # Cannot set TP/SL/TSL (generic, check position status)
                170140,  # TP/SL/TSL setting requires an active position (redundant with 110041?)
                # Account Type Errors (3xxxx)
                30086,  # UTA not supported / Account Type mismatch with API key/endpoint
                30087,  # UTA feature unavailable for this account
                # Add more critical, non-recoverable codes as identified from Bybit docs or experience
            ]

            # --- Handle Specific Cases ---
            # 110043: Leverage not modified - Treat as success for set_leverage calls
            if bybit_code == 110043 and method_name == 'set_leverage':
                lg.info(f"Leverage already set as requested (Code 110043) when calling {method_name}. Treating as success.")
                # Return the original exception's info dict if available, else empty dict
                return getattr(e, 'info', {})

            # --- Check if code is non-retryable ---
            if bybit_code is not None and bybit_code in non_retryable_codes:
                # Provide extra context/hints for common non-retryable errors
                extra_info = ""
                if bybit_code == 10001: extra_info = f"{NEON_YELLOW} Hint: Check API call parameters ({args=}, {kwargs=}) or API key permissions/account type.{RESET}"
                elif bybit_code == 110007:
                    balance_currency = QUOTE_CURRENCY  # Default guess
                    try:  # Try harder to guess the currency being checked
                         if 'params' in kwargs and 'coin' in kwargs['params']: balance_currency = kwargs['params']['coin']
                         elif 'symbol' in kwargs and isinstance(kwargs['symbol'], str): balance_currency = kwargs['symbol'].split('/')[1].split(':')[0]
                         elif len(args) > 0 and isinstance(args[0], str) and '/' in args[0]: balance_currency = args[0].split('/')[1].split(':')[0]
                    except Exception: pass
                    extra_info = f"{NEON_YELLOW} Hint: Check available {balance_currency} balance in the correct account (UTA/Contract/Spot).{RESET}"
                elif bybit_code == 30086 or (bybit_code == 10001 and "accounttype" in ret_msg.lower()):
                     extra_info = f"{NEON_YELLOW} Hint: Check 'accountType' param (UNIFIED vs CONTRACT/SPOT) matches your account/API key permissions.{RESET}"
                elif bybit_code == 110025:
                     extra_info = f"{NEON_YELLOW} Hint: Check 'positionIdx' parameter (0 for One-Way, 1/2 for Hedge Mode) and ensure it matches your account's Position Mode setting.{RESET}"
                elif bybit_code in [110003, 110004, 110005, 110006, 110017]:
                     extra_info = f"{NEON_YELLOW} Hint: Check price/amount precision and limits against market data (min/max size, tick size, step size).{RESET}"
                elif bybit_code in [110041, 170140, 110024]:
                     extra_info = f"{NEON_YELLOW} Hint: Action requires an active position, but none found or specified correctly (Code {bybit_code}).{RESET}"

                lg.error(f"{NEON_RED}Non-retryable Exchange Error calling {method_name}: {ret_msg} (Code: {bybit_code}). Not retrying.{RESET}{extra_info}")
                raise e  # Re-raise the non-retryable error

            else:  # Unknown or potentially temporary exchange error, proceed with retry logic
                if attempt < max_retries:
                    wait_time = retry_delay * (2 ** attempt)
                    lg.warning(f"{NEON_YELLOW}Retryable/Unknown Exchange Error calling {method_name}: {ret_msg} (Code: {bybit_code}). Retrying in {wait_time:.1f}s... (Attempt {attempt + 1}/{max_retries}){RESET}")
                    time.sleep(wait_time)
                else:  # Max retries reached for this unknown/retryable error
                    lg.error(f"{NEON_RED}Retryable/Unknown Exchange Error calling {method_name}: {ret_msg} (Code: {bybit_code}). Max retries ({max_retries}) reached.{RESET}")
                    raise e  # Re-raise after max retries

        except Exception as e:
            # Catch any other unexpected errors during the method call
            lg.error(f"{NEON_RED}Unexpected Error calling {method_name}: {e}. Not retrying.{RESET}", exc_info=True)
            raise e  # Re-raise unexpected errors immediately

    # --- Max Retries Reached ---
    # This part should only be reached if the loop finishes after max retries for recoverable errors
    lg.error(f"{NEON_RED}Max retries ({max_retries}) reached for {method_name}. Last error: {type(last_exception).__name__}{RESET}")
    if isinstance(last_exception, Exception):
        raise last_exception  # Re-raise the last specific recoverable exception
    else:
        # Should not happen if last_exception is always assigned, but as a fallback
        raise RuntimeError(f"Max retries reached for {method_name} without specific exception recorded.")


# --- Market Info Helper Functions ---
def _determine_category(market: Dict[str, Any]) -> Optional[str]:
    """Determines the Bybit V5 category ('linear', 'inverse', 'spot', 'option')
    from CCXT market info dictionary. Prioritizes explicit flags then infers.

    Args:
        market: The market dictionary from ccxt.exchange.markets.

    Returns:
        The category string ('linear', 'inverse', 'spot', 'option') or None if undetermined.
    """
    if not isinstance(market, dict): return None

    # Priority 1: Explicit V5 'category' field in 'info'
    info = market.get('info', {})
    category_info = info.get('category')
    if category_info in ['linear', 'inverse', 'spot', 'option']:
        return category_info

    # Priority 2: Standard CCXT type flags
    market_type = market.get('type')  # 'spot', 'swap', 'future', 'option'
    is_linear = market.get('linear', False)
    is_inverse = market.get('inverse', False)
    is_spot = market.get('spot', False)
    is_option = market.get('option', False)

    if is_spot or market_type == 'spot': return 'spot'
    if is_option or market_type == 'option': return 'option'

    # Priority 3: Infer for contracts (swap/future) based on linear/inverse flags
    if market_type in ['swap', 'future']:
        if is_linear: return 'linear'
        if is_inverse: return 'inverse'
        # Fallback inference based on settle vs quote asset (less reliable)
        settle_asset = market.get('settle', '').upper()
        quote_asset = market.get('quote', '').upper()
        base_asset = market.get('base', '').upper() # Needed for inverse check
        if settle_asset and quote_asset and base_asset:
            # Linear typically settles in quote (e.g., USDT, USDC)
            if settle_asset == quote_asset: return 'linear'
            # Inverse typically settles in base (e.g., BTC, ETH)
            if settle_asset == base_asset: return 'inverse'

    # If category couldn't be determined
    return None


# --- Standalone Quantization Utilities ---
def _get_precision_digits(precision_val: Union[float, int, str, None], default_digits: int = 8) -> int:
    """Helper to calculate decimal digits from a precision value (e.g., 0.01 -> 2 digits)."""
    if precision_val is None: return default_digits
    try:
        decimal_val = Decimal(str(precision_val))
        if not decimal_val.is_finite() or decimal_val <= 0: return default_digits
        if decimal_val >= 1: return 0
        # Use normalize() to handle scientific notation correctly before log10
        normalized_val = decimal_val.normalize()
        # Check exponent after normalization
        exponent = normalized_val.as_tuple().exponent
        if isinstance(exponent, int):
             digits = abs(exponent)
             return max(0, digits)
        else: # Handle special cases like NaN/Inf if they somehow passed is_finite()
            return default_digits
    except (InvalidOperation, ValueError, TypeError):
        # Cannot log here easily without passing logger, rely on caller context
        return default_digits

def quantize_price_util(price: Union[Decimal, float, str], min_tick_size: Optional[Decimal], logger: logging.Logger, symbol: str = "N/A", rounding: str = ROUND_DOWN) -> Optional[Decimal]:
    """Util: Quantizes a price to the market's minimum tick size."""
    if min_tick_size is None or not isinstance(min_tick_size, Decimal) or not min_tick_size.is_finite() or min_tick_size <= 0:
        logger.warning(f"Cannot quantize price for {symbol}: Invalid or missing minimum tick size ({min_tick_size}).")
        return None
    try:
        price_decimal = Decimal(str(price))
        if not price_decimal.is_finite():
            logger.warning(f"Cannot quantize non-finite price for {symbol}: {price}")
            return None
        quantized = price_decimal.quantize(min_tick_size, rounding=rounding)
        return quantized
    except (InvalidOperation, ValueError, TypeError) as e:
        logger.error(f"Error quantizing price '{price}' with tick '{min_tick_size}' for {symbol}: {e}")
        return None

def quantize_amount_util(amount: Union[Decimal, float, str], amount_step_size: Optional[Decimal], amount_precision_digits: Optional[int], logger: logging.Logger, symbol: str = "N/A", rounding: str = ROUND_DOWN) -> Optional[Decimal]:
    """Util: Quantizes an amount to the market's step size, falling back to precision digits."""
    step_size = amount_step_size
    # Validate or derive step_size
    if step_size is None or not isinstance(step_size, Decimal) or not step_size.is_finite() or step_size <= 0:
        if amount_precision_digits is not None and isinstance(amount_precision_digits, int) and amount_precision_digits >= 0:
            step_size = Decimal('1') / (Decimal('10') ** amount_precision_digits)
            logger.debug(f"Amount step size missing/invalid for {symbol}, using precision digits ({amount_precision_digits}) -> derived step={step_size}")
        else:
            logger.error(f"Cannot quantize amount for {symbol}: Amount step size and precision digits are missing or invalid.")
            return None

    if step_size <= 0: # Double check after potential calculation from digits
        logger.error(f"Cannot quantize amount for {symbol}: Invalid step size ({step_size}).")
        return None

    try:
        amount_decimal = Decimal(str(amount))
        if not amount_decimal.is_finite():
            logger.warning(f"Cannot quantize non-finite amount for {symbol}: {amount}")
            return None

        # Formula: floor/ceil(amount / step_size) * step_size
        # Use Decimal's quantize for precision
        quantized_steps = (amount_decimal / step_size).quantize(Decimal('1'), rounding=rounding)
        quantized_amount = quantized_steps * step_size
        # Re-quantize the result to the exact precision of the step size to handle potential floating point issues during multiplication
        # Use normalize() to remove trailing zeros before final quantization
        final_quantized = quantized_amount.normalize().quantize(step_size.normalize(), rounding=rounding) # Use same rounding as initial step calc
        return final_quantized
    except (InvalidOperation, ValueError, TypeError, DivisionByZeroError) as e:
        logger.error(f"Error quantizing amount '{amount}' with step '{step_size}' for {symbol}: {e}")
        return None


def get_market_info(exchange: ccxt.Exchange, symbol: str, logger: logging.Logger) -> Optional[Dict[str, Any]]:
    """Retrieves and processes detailed market information for a symbol from loaded CCXT markets.

    Extracts key details required for trading logic, including:
    - Precision (tick size, amount step size, digits)
    - Limits (min/max amount, price, cost)
    - Contract details (contract size, type, category, inverse)
    - Stores results as Decimal where appropriate for precision.

    Args:
        exchange: Initialized CCXT exchange object with loaded markets.
        symbol: The standard CCXT trading symbol (e.g., 'BTC/USDT:USDT' or 'BTC/USDT').
        logger: Logger instance.

    Returns:
        A dictionary containing processed market info, or None if the symbol is not found,
        markets are not loaded, or processing fails.
        Keys include: 'symbol', 'id', 'base', 'quote', 'settle', 'type', 'category',
                      'is_contract', 'inverse', 'contract_size' (Decimal),
                      'min_tick_size' (Decimal), 'amount_step_size' (Decimal),
                      'price_precision_digits' (int), 'amount_precision_digits' (int),
                      'min_order_amount' (Decimal), 'max_order_amount' (Decimal),
                      'min_price' (Decimal), 'max_price' (Decimal),
                      'min_order_cost' (Decimal), 'max_order_cost' (Decimal),
                      'raw_market_data' (original dict).
    """
    lg = logger
    if not exchange.markets:
        lg.error(f"Cannot get market info for {symbol}: Markets not loaded on exchange object.")
        return None
    try:
        # Retrieve market data from CCXT's loaded markets
        market = exchange.market(symbol)
        base_symbol_tried = None
        if not market:
            # Try splitting symbol if it contains ':' (e.g., 'BTC/USDT:USDT' -> 'BTC/USDT')
            # Some exchanges might list linear contracts under the base symbol
            if ':' in symbol:
                 base_symbol_tried = symbol.split(':')[0]
                 lg.debug(f"Symbol '{symbol}' not found directly, trying base symbol '{base_symbol_tried}'...")
                 market = exchange.market(base_symbol_tried)

            if not market:  # Still not found
                not_found_msg = f"Symbol '{symbol}'"
                if base_symbol_tried: not_found_msg += f" (or base '{base_symbol_tried}')"
                not_found_msg += " not found in loaded markets."
                lg.error(not_found_msg)
                # Log available symbols for debugging if needed (can be very long)
                # lg.debug(f"Available market symbols: {list(exchange.markets.keys())}")
                return None

        # Determine V5 category ('linear', 'inverse', 'spot', 'option')
        category = _determine_category(market)
        if category is None:
            # Log warning but proceed cautiously if category is vital downstream
            lg.warning(f"Could not reliably determine V5 category for symbol {symbol}. Market data: {market}")

        # --- Extract Precision Details ---
        price_precision_val = market.get('precision', {}).get('price')  # This is the tick size
        amount_precision_val = market.get('precision', {}).get('amount')  # This is the amount step size

        # Calculate digits using helper
        price_digits = _get_precision_digits(price_precision_val)
        amount_digits = _get_precision_digits(amount_precision_val)

        # --- Extract Limits ---
        limits = market.get('limits', {})
        amount_limits = limits.get('amount', {})
        price_limits = limits.get('price', {})
        cost_limits = limits.get('cost', {})

        # Helper to convert limit values to Decimal safely
        def to_decimal_safe(val: Any) -> Optional[Decimal]:
            if val is None: return None
            try:
                # Convert to string first to handle floats accurately
                d = Decimal(str(val))
                # Return Decimal if finite, otherwise None
                return d if d.is_finite() else None
            except (InvalidOperation, TypeError, ValueError): return None

        # --- Contract-Specific Details ---
        # Default contract size to 1 (relevant for spot, linear)
        contract_size = to_decimal_safe(market.get('contractSize', '1')) or Decimal('1')
        is_contract = category in ['linear', 'inverse']
        is_inverse = category == 'inverse'

        # --- Assemble Processed Market Info Dictionary ---
        market_details = {
            'symbol': market.get('symbol', symbol),  # Use the symbol found in market data
            'id': market.get('id'),  # Exchange's internal market ID
            'base': market.get('base'),
            'quote': market.get('quote'),
            'settle': market.get('settle'),
            'type': market.get('type'),  # spot, swap, future
            'category': category,       # linear, inverse, spot, option (best guess)
            'is_contract': is_contract,
            'inverse': is_inverse,
            'contract_size': contract_size,
            # Store precision values as Decimal
            'min_tick_size': to_decimal_safe(price_precision_val),
            'amount_step_size': to_decimal_safe(amount_precision_val),
            # Store calculated digits
            'price_precision_digits': price_digits,
            'amount_precision_digits': amount_digits,
            # Store limits as Decimal
            'min_order_amount': to_decimal_safe(amount_limits.get('min')),
            'max_order_amount': to_decimal_safe(amount_limits.get('max')),
            'min_price': to_decimal_safe(price_limits.get('min')),
            'max_price': to_decimal_safe(price_limits.get('max')),
            'min_order_cost': to_decimal_safe(cost_limits.get('min')),
            'max_order_cost': to_decimal_safe(cost_limits.get('max')),
            'raw_market_data': market  # Include original market data for debugging
        }
        lg.debug(f"Market Info for {symbol}: Cat={category}, Tick={market_details['min_tick_size']}, AmtStep={market_details['amount_step_size']}, ContSize={contract_size}")
        return market_details

    except ccxt.BadSymbol as e:
        # Specific error if CCXT couldn't find the symbol
        lg.error(f"Error getting market info for '{symbol}': {e}")
        return None
    except Exception as e:
        # Catch any other unexpected errors during processing
        lg.error(f"Unexpected error processing market info for {symbol}: {e}", exc_info=True)
        return None


# --- Data Fetching Wrappers ---
def fetch_current_price_ccxt(exchange: ccxt.Exchange, symbol: str, logger: logging.Logger, market_info: Dict) -> Optional[Decimal]:
    """Fetches the current ticker price using V5 API via safe_ccxt_call.
    Parses the 'lastPrice' field from the V5 response structure.

    Args:
        exchange: Initialized CCXT exchange object.
        symbol: Standard CCXT symbol (e.g., 'BTC/USDT:USDT').
        logger: Logger instance.
        market_info: Market information dictionary (must contain 'category' and 'id').

    Returns:
        The current price as Decimal, or None if fetch/parsing fails or price is invalid.
    """
    lg = logger
    category = market_info.get('category')
    market_id = market_info.get('id')  # Use exchange-specific ID

    if not category or not market_id:
        lg.error(f"Cannot fetch price for {symbol}: Category ('{category}') or Market ID ('{market_id}') missing in market_info."); return None

    try:
        # V5 ticker endpoint requires category and symbol (market_id)
        params = {'category': category, 'symbol': market_id}
        lg.debug(f"Fetching ticker for {symbol} (MarketID: {market_id}) with params: {params}")

        # Pass standard CCXT symbol for resolution, and V5 params for the API call
        ticker = safe_ccxt_call(exchange, 'fetch_ticker', lg, symbol=symbol, params=params)

        ticker_data = None
        price_str: Optional[str] = None

        # --- Parse V5 Response Structure ---
        # Bybit V5 ticker response might be nested under info -> result -> list -> [item] (for category requests)
        # or info -> result -> item (less common for single symbol fetch via fetch_ticker?)
        # or directly in the main dict (CCXT standard 'last' field)
        if isinstance(ticker, dict):
            # Check V5 structure (info -> result -> list -> [item])
            if ('info' in ticker and isinstance(ticker['info'], dict) and
                ticker['info'].get('retCode') == 0 and 'result' in ticker['info'] and
                isinstance(ticker['info']['result'], dict) and 'list' in ticker['info']['result'] and
                isinstance(ticker['info']['result']['list'], list) and len(ticker['info']['result']['list']) > 0):

                # Find the ticker matching the market_id within the list
                for item in ticker['info']['result']['list']:
                    if isinstance(item, dict) and item.get('symbol') == market_id:
                        ticker_data = item
                        price_str = ticker_data.get('lastPrice')  # V5 field name
                        lg.debug(f"Parsed price from V5 list structure for {symbol} (MarketID: {market_id})")
                        break  # Found the matching ticker

            # Check alternative V5 structure (info -> result -> single item)
            elif ('info' in ticker and isinstance(ticker['info'], dict) and
                  ticker['info'].get('retCode') == 0 and 'result' in ticker['info'] and
                  isinstance(ticker['info']['result'], dict) and not ticker['info']['result'].get('list')):
                 ticker_data = ticker['info']['result']
                 # Verify symbol match in case API returns unexpected data
                 if ticker_data.get('symbol') == market_id:
                     price_str = ticker_data.get('lastPrice')  # V5 field name
                     lg.debug(f"Parsed price from V5 single result structure for {symbol}")
                 else:
                      lg.warning(f"Ticker result symbol '{ticker_data.get('symbol')}' mismatch for requested MarketID {market_id}")

            # Fallback to standard CCXT 'last' field if V5 parsing fails or structure differs
            if price_str is None and 'last' in ticker and ticker['last'] is not None:
                 price_str = str(ticker['last'])
                 lg.debug(f"Parsed price from standard CCXT 'last' field for {symbol}")

        # --- Validate and Convert Price ---
        if price_str is None or str(price_str).strip() == "": # Ensure not empty string
            lg.warning(f"Could not extract valid 'lastPrice' or 'last' for {symbol}. Ticker response: {ticker}")
            return None

        price_dec = Decimal(str(price_str)) # Convert to string first
        # Ensure price is finite and positive
        if price_dec.is_finite() and price_dec > 0:
            lg.debug(f"Current price for {symbol}: {price_dec}")
            return price_dec
        else:
            lg.error(f"Invalid price ('{price_str}') received for {symbol} (non-finite or non-positive).")
            return None

    except (InvalidOperation, ValueError, TypeError) as e:
         lg.error(f"Error converting fetched price '{price_str}' to Decimal for {symbol}: {e}")
         return None
    except Exception as e:
        # Catches errors from safe_ccxt_call (e.g., retries exhausted, non-retryable errors) or other issues
        lg.error(f"Error fetching current price for {symbol}: {e}", exc_info=False) # Reduce noise for common fetch errors
        lg.debug(f"Traceback for price fetch error:", exc_info=True)
        return None


def fetch_klines_ccxt(exchange: ccxt.Exchange, symbol: str, timeframe: str, limit: int, logger: logging.Logger, market_info: Dict) -> pd.DataFrame:
    """Fetches OHLCV kline data using V5 API via safe_ccxt_call.
    Returns a DataFrame with a UTC timestamp index and Decimal OHLCV columns.

    Args:
        exchange: Initialized CCXT exchange object.
        symbol: Standard CCXT symbol.
        timeframe: Bot interval string (e.g., "5", "60", "D"). Matches keys in CCXT_INTERVAL_MAP.
        limit: Number of kline candles to fetch.
        logger: Logger instance.
        market_info: Market information dictionary (must contain 'category' and 'id').

    Returns:
        Pandas DataFrame with 'timestamp' (UTC datetime index) and
        'open', 'high', 'low', 'close', 'volume' (Decimal) columns.
        Returns an empty DataFrame on failure or if insufficient data is returned.
    """
    lg = logger
    category = market_info.get('category')
    market_id = market_info.get('id')  # Use exchange-specific ID
    ccxt_timeframe = CCXT_INTERVAL_MAP.get(timeframe)  # Get CCXT format (e.g., '5m')

    # --- Validate Inputs ---
    if not category or not market_id:
        lg.error(f"Cannot fetch klines for {symbol}: Category ('{category}') or Market ID ('{market_id}') missing."); return pd.DataFrame()
    if not ccxt_timeframe:
        lg.error(f"Invalid timeframe '{timeframe}' provided for {symbol}. Valid keys: {list(CCXT_INTERVAL_MAP.keys())}"); return pd.DataFrame()

    try:
        # Bybit V5 kline endpoint takes category and symbol (market_id)
        params = {'category': category, 'symbol': market_id}
        lg.debug(f"Fetching {limit} klines for {symbol} ({ccxt_timeframe}, MarketID: {market_id}) with params: {params}")

        # Adjust limit based on exchange maximum (Bybit V5 kline limit is 1000)
        safe_limit = min(limit, 1000)
        if limit > 1000: lg.warning(f"Requested kline limit {limit} exceeds Bybit's max of 1000. Fetching {safe_limit}.")

        # CCXT fetch_ohlcv maps to the correct V5 endpoint based on category/symbol
        ohlcv = safe_ccxt_call(exchange, 'fetch_ohlcv', lg, symbol=symbol, timeframe=ccxt_timeframe, limit=safe_limit, params=params)

        if not ohlcv:
            lg.warning(f"fetch_ohlcv returned empty data for {symbol} ({ccxt_timeframe}).")
            return pd.DataFrame()

        # --- Convert to DataFrame and Process ---
        # Standard CCXT OHLCV format: [timestamp, open, high, low, close, volume]
        df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        if df.empty:
             lg.warning(f"Kline data for {symbol} resulted in an empty DataFrame after initial creation.")
             return df

        # Convert timestamp (milliseconds) to UTC datetime and set as index
        try:
            # errors='coerce' will turn invalid timestamps into NaT (Not a Time)
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms', utc=True, errors='coerce')
            # Drop rows with invalid timestamps before setting index
            initial_len = len(df)
            df.dropna(subset=['timestamp'], inplace=True)
            if len(df) < initial_len:
                lg.warning(f"Dropped {initial_len - len(df)} rows with invalid timestamps for {symbol}.")
            if df.empty:
                 lg.warning(f"DataFrame became empty after dropping invalid timestamps for {symbol}.")
                 return df
            df.set_index('timestamp', inplace=True)
        except Exception as dt_err:
             lg.error(f"Error converting timestamp column for {symbol}: {dt_err}", exc_info=True)
             return pd.DataFrame()  # Cannot proceed without valid index

        # Convert OHLCV columns to Decimal for precision
        cols_to_convert = ['open', 'high', 'low', 'close', 'volume']
        for col in cols_to_convert:
            if col not in df.columns: continue  # Skip if column somehow missing
            try:
                # Convert to string first -> Decimal avoids potential float inaccuracies.
                # Apply Decimal conversion robustly using .apply()
                # Ensure the input to Decimal is not None or NaN first
                df[col] = df[col].apply(lambda x: Decimal(str(x)) if pd.notna(x) else None)
            except (InvalidOperation, TypeError, ValueError) as e:
                 lg.error(f"Error converting column '{col}' to Decimal for {symbol}: {e}. Attempting numeric conversion with NaN coercion.")
                 # Fallback: Convert to numeric, coercing errors to NaN, then try Decimal again
                 df[col] = pd.to_numeric(df[col], errors='coerce')
                 df[col] = df[col].apply(lambda x: Decimal(str(x)) if pd.notna(x) and np.isfinite(x) else None)

        # Final check and drop rows with NaN/None in critical OHLC columns
        initial_len = len(df)
        df.dropna(subset=['open', 'high', 'low', 'close'], inplace=True)
        if len(df) < initial_len:
            lg.warning(f"Dropped {initial_len - len(df)} rows with NaN/None values in OHLC columns for {symbol}.")

        if df.empty:
            lg.warning(f"DataFrame became empty after NaN drop for {symbol}.")

        lg.debug(f"Fetched and processed {len(df)} klines for {symbol}.")
        return df

    except Exception as e:
        # Catch errors from safe_ccxt_call or DataFrame processing
        lg.error(f"Error fetching/processing klines for {symbol}: {e}", exc_info=False) # Reduce noise
        lg.debug(f"Traceback for kline fetch error:", exc_info=True)
        return pd.DataFrame()  # Return empty DataFrame on error


def fetch_orderbook_ccxt(exchange: ccxt.Exchange, symbol: str, limit: int, logger: logging.Logger, market_info: Dict) -> Optional[Dict]:
    """Fetches order book data using V5 API via safe_ccxt_call.

    Args:
        exchange: Initialized CCXT exchange object.
        symbol: Standard CCXT symbol.
        limit: Number of order book levels to fetch (e.g., 1, 25, 50). Bybit V5 allows 1, 50, 200.
        logger: Logger instance.
        market_info: Market information dictionary (must contain 'category' and 'id').

    Returns:
        A dictionary containing 'bids' and 'asks' lists (each item is [price_str, amount_str]),
        or None if fetch fails or response is invalid. Prices/amounts are strings as returned by CCXT.
    """
    lg = logger
    category = market_info.get('category')
    market_id = market_info.get('id')  # Use exchange-specific ID

    if not category or not market_id:
        lg.error(f"Cannot fetch orderbook for {symbol}: Category ('{category}') or Market ID ('{market_id}') missing."); return None

    # Validate limit against Bybit V5 allowed values (adjust if necessary)
    valid_limits = [1, 50, 200]
    if limit not in valid_limits:
        # Find closest valid limit (e.g., default to 50)
        if limit < 50: adjusted_limit = 1
        elif limit < 200: adjusted_limit = 50
        else: adjusted_limit = 200
        lg.warning(f"Invalid orderbook limit {limit} requested for {symbol}. Adjusted to nearest valid Bybit V5 limit: {adjusted_limit}")
        limit = adjusted_limit

    try:
        # Bybit V5 orderbook endpoint uses category and symbol, limit in params
        params = {'category': category, 'symbol': market_id, 'limit': limit}
        lg.debug(f"Fetching order book (limit {limit}) for {symbol} (MarketID: {market_id}) with params: {params}")

        # CCXT fetch_order_book should map to the correct V5 endpoint
        orderbook = safe_ccxt_call(exchange, 'fetch_order_book', lg, symbol=symbol, limit=limit, params=params)

        # --- Validate the Structure ---
        if (orderbook and isinstance(orderbook, dict) and
            'bids' in orderbook and isinstance(orderbook['bids'], list) and
            'asks' in orderbook and isinstance(orderbook['asks'], list) and
            'timestamp' in orderbook and orderbook['timestamp'] is not None):  # Check timestamp for validity

            # Basic validation of bid/ask entries format [price_str, amount_str]
            is_valid = True
            for level in orderbook['bids'] + orderbook['asks']:
                 if not (isinstance(level, (list, tuple)) and len(level) == 2 and
                         # Allow price/amount to be numeric or string as returned by CCXT
                         isinstance(level[0], (str, int, float)) and isinstance(level[1], (str, int, float))):
                     lg.warning(f"Order book level for {symbol} has invalid format: {level}")
                     is_valid = False; break
            if not is_valid:
                 lg.warning(f"Order book for {symbol} contains invalid level format. Response snippet: bids={orderbook.get('bids', [])[:2]}, asks={orderbook.get('asks', [])[:2]}")
                 return None

            # Check if data was returned (lists might be empty if market is illiquid)
            if orderbook['bids'] or orderbook['asks']:
                 lg.debug(f"Fetched order book for {symbol}: {len(orderbook['bids'])} bids, {len(orderbook['asks'])} asks.")
                 # Return the orderbook with string prices/amounts
                 return orderbook
            else:
                 lg.warning(f"Order book fetch for {symbol} returned empty bids/asks lists (possibly illiquid market).")
                 return orderbook  # Return empty book, might be valid state
        else:
            lg.warning(f"Failed to fetch valid order book structure for {symbol}. Response: {orderbook}")
            return None

    except Exception as e:
        # Catch errors from safe_ccxt_call or validation
        lg.error(f"Error fetching order book for {symbol}: {e}", exc_info=False)
        lg.debug(f"Traceback for orderbook fetch error:", exc_info=True)
        return None


def fetch_balance(exchange: ccxt.Exchange, currency: str, logger: logging.Logger) -> Optional[Decimal]:
    """Fetches the available balance for a specific currency using safe_ccxt_call.
    Adapts the request based on the detected account type (UTA vs. Non-UTA).

    Args:
        exchange: Initialized CCXT exchange object.
        currency: The currency symbol (e.g., 'USDT').
        logger: Logger instance.

    Returns:
        The available balance as a Decimal, or None if fetch fails, balance is zero/invalid,
        or parsing fails.
    """
    lg = logger
    account_types_to_query: List[str] = []

    # Determine which account types to query based on the global flag
    if IS_UNIFIED_ACCOUNT:
        account_types_to_query = ['UNIFIED']
        lg.debug(f"Fetching balance specifically for UNIFIED account ({currency}).")
    else:
        # For Non-UTA, CONTRACT usually holds futures balance, SPOT for spot balance.
        # Query both as funds might be in either for trading, sum them up.
        account_types_to_query = ['CONTRACT', 'SPOT']
        lg.debug(f"Fetching balance for Non-UTA account ({currency}), trying types: {account_types_to_query}.")

    last_exception: Optional[Exception] = None
    total_available_balance = Decimal('0')
    balance_successfully_fetched = False

    # Outer retry loop for network/rate limit issues across account type checks
    for attempt in range(MAX_API_RETRIES + 1):
        balance_found_in_attempt = False
        error_in_attempt = False
        current_attempt_balance = Decimal('0')  # Balance accumulated in this attempt cycle

        # Inner loop to try different account types (only relevant for Non-UTA)
        for acc_type in account_types_to_query:
            try:
                params = {'accountType': acc_type, 'coin': currency}
                lg.debug(f"Fetching balance with params={params} (Overall Attempt {attempt + 1})")
                # Use safe_ccxt_call with 0 inner retries; outer loop handles retries for network issues
                balance_info = safe_ccxt_call(exchange, 'fetch_balance', lg, max_retries=0, params=params)

                # Parse the response for the specific account type
                current_type_balance = _parse_balance_response(balance_info, currency, acc_type, lg)

                if current_type_balance is not None:
                    balance_found_in_attempt = True
                    current_attempt_balance += current_type_balance
                    # If UTA, we are done once found
                    if IS_UNIFIED_ACCOUNT:
                        break  # Exit inner loop for UTA
                else:
                    lg.debug(f"Balance for {currency} not found or parsing failed for type {acc_type}.")

            except ccxt.ExchangeError as e:
                # Non-retryable errors (like auth, param) should have been raised by safe_ccxt_call
                # Log other exchange errors and continue to next type if applicable (for Non-UTA)
                lg.warning(f"Exchange error fetching balance type {acc_type}: {e}. Trying next type if available.")
                last_exception = e
                continue  # Try the next account type if Non-UTA

            except (ccxt.NetworkError, ccxt.RequestTimeout, ccxt.DDoSProtection, ccxt.RateLimitExceeded) as e:
                 lg.warning(f"Network/RateLimit error during balance fetch type {acc_type}: {e}")
                 last_exception = e
                 error_in_attempt = True
                 break  # Break inner loop, let outer loop handle retry

            except Exception as e:
                 lg.error(f"Unexpected error during balance fetch type {acc_type}: {e}", exc_info=True)
                 last_exception = e
                 error_in_attempt = True
                 break  # Break inner loop, let outer loop handle retry

        # --- After Inner Loop (Account Types) ---
        if balance_found_in_attempt and not error_in_attempt:
            # If we successfully checked all required types without recoverable errors
            total_available_balance = current_attempt_balance
            balance_successfully_fetched = True
            break  # Exit outer retry loop successfully

        if error_in_attempt:  # If broke from inner loop due to recoverable error
            if attempt < MAX_API_RETRIES:
                wait_time = RETRY_DELAY_SECONDS * (2 ** attempt)
                lg.warning(f"Balance fetch attempt {attempt + 1} encountered recoverable error ({type(last_exception).__name__}). Retrying in {wait_time:.1f}s...")
                time.sleep(wait_time)
                continue  # Continue outer retry loop
            else:  # Max retries reached for recoverable error
                 lg.error(f"{NEON_RED}Max retries reached fetching balance for {currency} after {type(last_exception).__name__}. Last error: {last_exception}{RESET}")
                 return None  # Failed after retries

        # If inner loop completed without finding balance (and without errors breaking it)
        if not balance_found_in_attempt:
            if attempt < MAX_API_RETRIES:
                wait_time = RETRY_DELAY_SECONDS * (2 ** attempt)
                lg.warning(f"Balance fetch attempt {attempt + 1} failed to find/parse balance for type(s): {account_types_to_query}. Retrying in {wait_time:.1f}s...")
                time.sleep(wait_time)
                continue  # Retry outer loop
            else:  # Max retries reached, balance not found/parsed
                 lg.error(f"{NEON_RED}Max retries reached. Failed to fetch/parse balance for {currency} ({' '.join(account_types_to_query)}). Last error: {last_exception}{RESET}")
                 return None  # Failed to get balance

    # --- Return Result ---
    if balance_successfully_fetched:
        account_str = "UNIFIED" if IS_UNIFIED_ACCOUNT else "Non-UTA (CONTRACT+SPOT)"
        lg.info(f"Available {currency} balance ({account_str}): {total_available_balance:.4f}")
        return total_available_balance
    else:
        # Should have returned None earlier if fetching failed after retries
        lg.error(f"{NEON_RED}Balance fetch logic completed unexpectedly without success for {currency}.{RESET}")
        return None


def _parse_balance_response(balance_info: Optional[Dict], currency: str, account_type_checked: str, logger: logging.Logger) -> Optional[Decimal]:
    """Parses the raw response from CCXT's fetch_balance, adapting to Bybit V5 structure.

    Prioritizes fields indicating actually available funds:
    - V5 UNIFIED: 'availableToWithdraw' (most reliable for UTA)
    - V5 CONTRACT/SPOT: 'availableBalance'
    - Falls back to CCXT standard 'free' field if V5 fields are missing.

    Args:
        balance_info: The raw dictionary returned by safe_ccxt_call('fetch_balance').
        currency: The currency symbol (e.g., 'USDT') to look for.
        account_type_checked: The 'accountType' used in the request ('UNIFIED', 'CONTRACT', 'SPOT').
        logger: Logger instance.

    Returns:
        The available balance as Decimal, or None if not found, invalid, or parsing fails.
    """
    if not balance_info or not isinstance(balance_info, dict):
        logger.debug(f"Parsing balance: Received empty or invalid balance_info for {currency} ({account_type_checked}).")
        return None
    lg = logger
    available_balance_str: Optional[str] = None
    field_used: str = "N/A"

    try:
        # --- Strategy 1: Parse Bybit V5 structure (info -> result -> list -> coin[]) ---
        v5_parsed = False
        if ('info' in balance_info and isinstance(balance_info['info'], dict) and
            balance_info['info'].get('retCode') == 0 and 'result' in balance_info['info'] and
            isinstance(balance_info['info']['result'], dict) and 'list' in balance_info['info']['result'] and
            isinstance(balance_info['info']['result']['list'], list)):

            balance_list = balance_info['info']['result']['list']
            lg.debug(f"Parsing V5 balance structure for {currency} ({account_type_checked}). List length: {len(balance_list)}")

            # V5 response might have one entry per account type or one entry with all coins
            account_data_found = None
            if len(balance_list) > 0 and isinstance(balance_list[0], dict):
                # Check if the first item matches the requested account type (common structure)
                if balance_list[0].get('accountType') == account_type_checked:
                    account_data_found = balance_list[0]
                # Alternative structure: Sometimes the list contains coin details directly? Less common.
                elif balance_list[0].get('coin') == currency:
                    # This structure is less expected based on docs, handle cautiously
                    lg.warning(f"Unexpected V5 balance structure: List contains coin data directly? Trying to parse...")
                    account_data_found = {'coin': balance_list} # Wrap it to resemble expected structure

            if account_data_found:
                coin_list = account_data_found.get('coin')
                if isinstance(coin_list, list):
                    for coin_data in coin_list:
                        if isinstance(coin_data, dict) and coin_data.get('coin') == currency:
                            # --- Determine the most appropriate balance field ---
                            potential_balance = None
                            if account_type_checked == 'UNIFIED':
                                # For UTA, 'availableToWithdraw' is generally the most reliable available balance
                                potential_balance = coin_data.get('availableToWithdraw')
                                field_used = 'V5:availableToWithdraw'
                                if potential_balance is None:  # Fallback if missing
                                    potential_balance = coin_data.get('availableBalance')
                                    field_used = 'V5:availableBalance (fallback)'
                            else:  # CONTRACT or SPOT
                                # For non-UTA, 'availableBalance' is the standard available field
                                potential_balance = coin_data.get('availableBalance')
                                field_used = 'V5:availableBalance'
                                if potential_balance is None:  # Fallback if missing
                                     potential_balance = coin_data.get('availableToWithdraw')
                                     field_used = 'V5:availableToWithdraw (fallback)'

                            # Use walletBalance only as a last resort if others are missing (less accurate for available funds)
                            if potential_balance is None:
                                 lg.debug(f"Available balance fields missing for {currency} ({account_type_checked}), checking 'walletBalance'.")
                                 potential_balance = coin_data.get('walletBalance')
                                 field_used = 'V5:walletBalance (last resort)'

                            # Check if we found a non-empty value
                            if potential_balance is not None and str(potential_balance).strip() != "":
                                available_balance_str = str(potential_balance)
                                v5_parsed = True
                                lg.debug(f"Parsed balance from Bybit V5 ({account_type_checked} -> {currency}): Value='{available_balance_str}' (Field: '{field_used}')")
                                break  # Found currency in this account's coin list
                    # if v5_parsed: break # No need to break outer loop if structure is account->coins
            if not v5_parsed:
                 lg.debug(f"Currency '{currency}' not found within Bybit V5 list structure for account type '{account_type_checked}'.")

        # --- Strategy 2: Fallback to standard CCXT 'free' balance structure ---
        # This might be populated by CCXT even if V5 structure exists or failed parsing
        if not v5_parsed and currency in balance_info and isinstance(balance_info.get(currency), dict):
            free_val = balance_info[currency].get('free')
            if free_val is not None:
                available_balance_str = str(free_val)
                field_used = "CCXT:free"
                lg.debug(f"Parsed balance via standard CCXT structure ['{currency}']['free']: {available_balance_str}")

        # --- Strategy 3: Fallback to top-level 'free' dictionary (less common for specific currency) ---
        elif not v5_parsed and available_balance_str is None and 'free' in balance_info and isinstance(balance_info.get('free'), dict):
             free_val = balance_info['free'].get(currency)
             if free_val is not None:
                 available_balance_str = str(free_val)
                 field_used = "CCXT:top_level_free"
                 lg.debug(f"Parsed balance via top-level 'free' dictionary ['free']['{currency}']: {available_balance_str}")

        # --- Conversion and Validation ---
        if available_balance_str is None:
            lg.debug(f"Could not extract available balance for {currency} from response structure ({account_type_checked}). Response info keys: {balance_info.get('info', {}).keys() if isinstance(balance_info.get('info'), dict) else 'N/A'}")
            return None

        # Attempt conversion to Decimal
        final_balance = Decimal(available_balance_str)
        # Ensure balance is finite and non-negative
        if final_balance.is_finite() and final_balance >= 0:
            # Return the balance (could be 0)
            return final_balance
        else:
            lg.error(f"Parsed balance for {currency} ('{available_balance_str}' from field '{field_used}') is invalid (negative or non-finite).")
            return None

    except (InvalidOperation, ValueError, TypeError) as e:
        lg.error(f"Failed to convert balance string '{available_balance_str}' (from field '{field_used}') to Decimal for {currency}: {e}.")
        return None
    except Exception as e:
        lg.error(f"Unexpected error parsing balance response structure for {currency}: {e}", exc_info=True)
        return None


# --- Trading Analyzer Class ---
class TradingAnalyzer:
    """Analyzes market data using pandas_ta to calculate technical indicators and generate
    weighted trading signals based on a configured strategy.

    Manages symbol-specific state (like break-even status) via a shared dictionary.
    Uses Decimal for internal calculations involving prices and quantities where precision is key,
    but converts data to float for pandas_ta compatibility.
    """
    def __init__(
        self,
        df_raw: pd.DataFrame,  # DataFrame with Decimal OHLCV columns from fetch_klines_ccxt
        logger: logging.Logger,
        config: Dict[str, Any],
        market_info: Dict[str, Any],
        symbol_state: Dict[str, Any],  # Mutable state dict shared with main loop
    ) -> None:
        """Initializes the TradingAnalyzer.

        Args:
            df_raw: DataFrame containing OHLCV data (must have Decimal columns).
            logger: Logger instance for this symbol.
            config: The main configuration dictionary.
            market_info: Processed market information for the symbol.
            symbol_state: Mutable dictionary holding state for this symbol
                          (e.g., 'break_even_triggered', 'last_entry_price').

        Raises:
            ValueError: If df_raw, market_info, or symbol_state is invalid or missing.
        """
        # --- Input Validation ---
        if df_raw is None or df_raw.empty:
            raise ValueError("TradingAnalyzer requires a non-empty raw DataFrame.")
        if not market_info or not isinstance(market_info, dict):
            raise ValueError("TradingAnalyzer requires a valid market_info dictionary.")
        if symbol_state is None or not isinstance(symbol_state, dict):
            raise ValueError("TradingAnalyzer requires a valid symbol_state dictionary.")

        self.df_raw = df_raw  # Keep raw Decimal DF for precise checks (e.g., Fib, price checks)
        self.df = df_raw.copy()  # Work on a copy for TA calculations requiring floats
        self.logger = logger
        self.config = config
        self.market_info = market_info
        self.symbol: str = market_info.get('symbol', 'UNKNOWN_SYMBOL')
        self.interval: str = config.get("interval", "UNKNOWN_INTERVAL")
        self.symbol_state = symbol_state  # Store reference to the mutable state dict

        # --- Internal State Initialization ---
        self.indicator_values: Dict[str, Optional[Decimal]] = {}  # Stores latest indicator values as Decimals
        self.signals: Dict[str, int] = {"BUY": 0, "SELL": 0, "HOLD": 1}  # Current signal state flags
        self.active_weight_set_name: str = config.get("active_weight_set", "default")
        self.weights: Dict[str, float] = {}  # Loaded weights (converted to float)
        self.fib_levels_data: Dict[str, Decimal] = {}  # Stores calculated Fibonacci levels
        self.ta_strategy: Optional[ta.Strategy] = None  # pandas_ta strategy object
        self.ta_column_map: Dict[str, str] = {}  # Maps generic names (e.g., "EMA_Short") to pandas_ta column names (e.g., "EMA_9")

        # Load and validate weights for the active set
        raw_weights = config.get("weight_sets", {}).get(self.active_weight_set_name, {})
        if not raw_weights or not isinstance(raw_weights, dict):
            logger.warning(f"{NEON_YELLOW}Weight set '{self.active_weight_set_name}' is empty or not found for {self.symbol}. Signal generation will be disabled.{RESET}")
        else:
            # Convert weights to float during initialization
            for key, val in raw_weights.items():
                try:
                    self.weights[key] = float(val)
                except (ValueError, TypeError):
                     logger.warning(f"Invalid weight '{val}' for '{key}' in set '{self.active_weight_set_name}'. Skipping.")

        # --- Data Preparation and Indicator Calculation ---
        # Convert necessary columns in the copied DataFrame (self.df) to float for pandas_ta
        self._convert_df_for_ta()

        # Initialize and Calculate Indicators if data is valid
        if not self.df.empty:
            self._define_ta_strategy()
            if self.ta_strategy:
                self._calculate_all_indicators()  # Operates on self.df (float version)
                self._update_latest_indicator_values()  # Populates self.indicator_values with Decimals from self.df
            else:
                 logger.warning(f"TA Strategy not defined for {self.symbol}, skipping calculations.")
            # Calculate initial Fib levels using self.df_raw (Decimal version)
            self.calculate_fibonacci_levels()
        else:
            logger.warning(f"DataFrame is empty after float conversion for {self.symbol}. Cannot calculate indicators.")

    def _convert_df_for_ta(self) -> None:
        """Converts necessary DataFrame columns (OHLCV) in the working copy `self.df`
        to float64 for compatibility with pandas_ta. Handles potential errors gracefully.
        """
        if self.df.empty: return
        try:
            cols_to_convert = ['open', 'high', 'low', 'close', 'volume']
            self.logger.debug(f"Converting columns {cols_to_convert} to float64 for TA...")
            for col in cols_to_convert:
                 if col in self.df.columns:
                    # Check if conversion is needed (not already float64)
                    if not pd.api.types.is_float_dtype(self.df[col]) or self.df[col].dtype != np.float64:
                        original_type = self.df[col].dtype
                        # Convert to float64, coercing errors to NaN.
                        # Using pd.to_numeric is robust for various input types (Decimal, str, int).
                        self.df[col] = pd.to_numeric(self.df[col], errors='coerce').astype(np.float64)
                        if self.df[col].isnull().any():
                            self.logger.debug(f"Column '{col}' (original: {original_type}) converted to float64, NaNs introduced.")
                        # else:
                        #     self.logger.debug(f"Column '{col}' (original: {original_type}) converted to float64.")
                    # else: # Already float64
                    #     self.logger.debug(f"Column '{col}' is already float64.")

            # Verify conversion and log dtypes
            converted_dtypes = {col: self.df[col].dtype for col in cols_to_convert if col in self.df.columns}
            self.logger.debug(f"DataFrame dtypes prepared for TA: {converted_dtypes}")
            # Check if any critical conversion failed resulting in non-float types
            for col, dtype in converted_dtypes.items():
                if not pd.api.types.is_float_dtype(dtype):
                     self.logger.warning(f"Column '{col}' is not float (dtype: {dtype}) after conversion attempt. TA results may be affected.")

        except Exception as e:
             self.logger.error(f"Error converting DataFrame columns to float for {self.symbol}: {e}", exc_info=True)
             # Set df to empty to prevent further processing with potentially bad data
             self.df = pd.DataFrame()

    # --- State Properties ---
    @property
    def break_even_triggered(self) -> bool:
        """Gets the break-even triggered status from the shared symbol state."""
        # Default to False if the key doesn't exist in the state dictionary
        return self.symbol_state.get('break_even_triggered', False)

    @break_even_triggered.setter
    def break_even_triggered(self, value: bool) -> None:
        """Sets the break-even triggered status in the shared symbol state and logs the change."""
        if not isinstance(value, bool):
            self.logger.error(f"Invalid type for break_even_triggered ({type(value)}). Must be boolean.")
            return
        current_value = self.symbol_state.get('break_even_triggered')
        # Only update and log if the value actually changes
        if current_value != value:
            self.symbol_state['break_even_triggered'] = value
            self.logger.info(f"Break-even status for {self.symbol} set to: {value}")

    def _define_ta_strategy(self) -> None:
        """Defines the pandas_ta Strategy object based on enabled indicators in the config."""
        cfg = self.config
        # Get the dictionary of enabled indicator flags (e.g., {"rsi": True, "macd": False})
        indi_cfg = cfg.get("indicators", {})
        if not isinstance(indi_cfg, dict):
            self.logger.error("Invalid 'indicators' configuration (must be a dictionary). Cannot define TA strategy.")
            return

        # Helper to safely get parameters (already validated as int/float in load_config)
        def get_param(key: str, default: Union[int, float]) -> Union[int, float]:
            # Config validation ensures these are correct types (int/float)
            val = cfg.get(key, default)
            # Ensure correct type just in case validation missed something (shouldn't happen)
            if isinstance(default, int): return int(val)
            if isinstance(default, float): return float(val)
            return val  # Fallback

        # --- Get parameters for all potential indicators ---
        atr_p = get_param("atr_period", DEFAULT_ATR_PERIOD)
        ema_s = get_param("ema_short_period", DEFAULT_EMA_SHORT_PERIOD)
        ema_l = get_param("ema_long_period", DEFAULT_EMA_LONG_PERIOD)
        rsi_p = get_param("rsi_period", DEFAULT_RSI_WINDOW)
        bb_p = get_param("bollinger_bands_period", DEFAULT_BOLLINGER_BANDS_PERIOD)
        bb_std = get_param("bollinger_bands_std_dev", DEFAULT_BOLLINGER_BANDS_STD_DEV)
        cci_w = get_param("cci_window", DEFAULT_CCI_WINDOW)
        wr_w = get_param("williams_r_window", DEFAULT_WILLIAMS_R_WINDOW)
        mfi_w = get_param("mfi_window", DEFAULT_MFI_WINDOW)
        stochrsi_w = get_param("stoch_rsi_window", DEFAULT_STOCH_RSI_WINDOW)
        stochrsi_rsi_w = get_param("stoch_rsi_rsi_window", DEFAULT_STOCH_WINDOW)
        stochrsi_k = get_param("stoch_rsi_k", DEFAULT_K_WINDOW)
        stochrsi_d = get_param("stoch_rsi_d", DEFAULT_D_WINDOW)
        psar_af = get_param("psar_af", DEFAULT_PSAR_AF)
        psar_max = get_param("psar_max_af", DEFAULT_PSAR_MAX_AF)
        sma10_w = get_param("sma_10_window", DEFAULT_SMA_10_WINDOW)
        mom_p = get_param("momentum_period", DEFAULT_MOMENTUM_PERIOD)
        vol_ma_p = get_param("volume_ma_period", DEFAULT_VOLUME_MA_PERIOD)

        # Build the list of indicators for the pandas_ta Strategy
        ta_list: List[Dict[str, Any]] = []
        self.ta_column_map: Dict[str, str] = {}  # Reset map

        # --- Add Indicators Based on Config Flags and Valid Parameters ---
        # ATR (Always calculated for risk management, ensure period is valid)
        if atr_p > 0:
            col_name = f"ATRr_{atr_p}"  # pandas_ta default ATR col name
            ta_list.append({"kind": "atr", "length": atr_p, "col_names": (col_name,)})
            self.ta_column_map["ATR"] = col_name
        else:
             self.logger.error(f"ATR period ({atr_p}) is invalid. Risk management calculations will fail.")

        # EMAs (Needed if alignment or MA cross exit enabled)
        ema_needed = indi_cfg.get("ema_alignment") or cfg.get("enable_ma_cross_exit")
        if ema_needed:
            if ema_s > 0:
                col_name_s = f"EMA_{ema_s}"
                ta_list.append({"kind": "ema", "length": ema_s, "col_names": (col_name_s,)})
                self.ta_column_map["EMA_Short"] = col_name_s
            else: self.logger.warning("EMA Short period invalid, EMA features disabled.")
            if ema_l > ema_s:  # Validation ensures ema_l > ema_s if both are valid
                col_name_l = f"EMA_{ema_l}"
                ta_list.append({"kind": "ema", "length": ema_l, "col_names": (col_name_l,)})
                self.ta_column_map["EMA_Long"] = col_name_l
            elif ema_l <= ema_s: self.logger.warning(f"EMA Long period ({ema_l}) not > EMA Short ({ema_s}), EMA Long disabled.")

        # Momentum
        if indi_cfg.get("momentum") and mom_p > 0:
            col_name = f"MOM_{mom_p}"
            ta_list.append({"kind": "mom", "length": mom_p, "col_names": (col_name,)})
            self.ta_column_map["Momentum"] = col_name

        # Volume SMA (for Volume Confirmation)
        if indi_cfg.get("volume_confirmation") and vol_ma_p > 0:
            col_name = f"VOL_SMA_{vol_ma_p}"
            # Ensure 'volume' column exists and is float before calculating
            if 'volume' in self.df.columns and pd.api.types.is_float_dtype(self.df['volume']):
                ta_list.append({"kind": "sma", "close": "volume", "length": vol_ma_p, "col_names": (col_name,)})
                self.ta_column_map["Volume_MA"] = col_name
            else:
                self.logger.warning("Cannot calculate Volume SMA: 'volume' column missing or not float in TA DataFrame.")
                indi_cfg["volume_confirmation"] = False  # Disable check if cannot calculate

        # Stochastic RSI
        if indi_cfg.get("stoch_rsi") and all(p > 0 for p in [stochrsi_w, stochrsi_rsi_w, stochrsi_k, stochrsi_d]):
            k_col = f"STOCHRSIk_{stochrsi_w}_{stochrsi_rsi_w}_{stochrsi_k}_{stochrsi_d}"
            d_col = f"STOCHRSId_{stochrsi_w}_{stochrsi_rsi_w}_{stochrsi_k}_{stochrsi_d}"
            ta_list.append({
                "kind": "stochrsi", "length": stochrsi_w, "rsi_length": stochrsi_rsi_w,
                "k": stochrsi_k, "d": stochrsi_d, "col_names": (k_col, d_col)
            })
            self.ta_column_map["StochRSI_K"] = k_col
            self.ta_column_map["StochRSI_D"] = d_col

        # RSI
        if indi_cfg.get("rsi") and rsi_p > 0:
            col_name = f"RSI_{rsi_p}"
            ta_list.append({"kind": "rsi", "length": rsi_p, "col_names": (col_name,)})
            self.ta_column_map["RSI"] = col_name

        # Bollinger Bands
        if indi_cfg.get("bollinger_bands") and bb_p > 0:
            bb_std_str = f"{bb_std:.1f}".replace('.', '_')  # Format std dev for column name
            bbl = f"BBL_{bb_p}_{bb_std_str}"; bbm = f"BBM_{bb_p}_{bb_std_str}"
            bbu = f"BBU_{bb_p}_{bb_std_str}"; bbb = f"BBB_{bb_p}_{bb_std_str}"
            bbp = f"BBP_{bb_p}_{bb_std_str}"
            ta_list.append({
                "kind": "bbands", "length": bb_p, "std": bb_std,
                "col_names": (bbl, bbm, bbu, bbb, bbp)  # Lower, Middle, Upper, Bandwidth, Percent
            })
            self.ta_column_map["BB_Lower"] = bbl
            self.ta_column_map["BB_Middle"] = bbm
            self.ta_column_map["BB_Upper"] = bbu
            # self.ta_column_map["BB_Bandwidth"] = bbb # Optional, not used in default checks
            # self.ta_column_map["BB_Percent"] = bbp # Optional

        # VWAP (Volume Weighted Average Price)
        if indi_cfg.get("vwap"):
            vwap_col = "VWAP_D"  # Default pandas_ta name for daily anchor
            if all(c in self.df.columns for c in ['high', 'low', 'close', 'volume']):
                 # VWAP calculation needs HLCV columns. pandas_ta handles this.
                 ta_list.append({"kind": "vwap", "anchor": "D", "col_names": (vwap_col,)})  # Use daily anchor
                 self.ta_column_map["VWAP"] = vwap_col
            else:
                 self.logger.warning("Cannot calculate VWAP: Missing HLCV columns in TA DataFrame.")
                 indi_cfg["vwap"] = False  # Disable check

        # CCI (Commodity Channel Index)
        if indi_cfg.get("cci") and cci_w > 0:
            cci_col = f"CCI_{cci_w}_0.015"  # Default pandas_ta name includes the constant
            ta_list.append({"kind": "cci", "length": cci_w, "col_names": (cci_col,)})
            self.ta_column_map["CCI"] = cci_col

        # Williams %R
        if indi_cfg.get("wr") and wr_w > 0:
            wr_col = f"WILLR_{wr_w}"
            ta_list.append({"kind": "willr", "length": wr_w, "col_names": (wr_col,)})
            self.ta_column_map["WR"] = wr_col

        # Parabolic SAR
        if indi_cfg.get("psar"):
            # Format AF values for column names (remove trailing zeros/dots)
            psar_af_str = f"{psar_af}".rstrip('0').rstrip('.')
            psar_max_str = f"{psar_max}".rstrip('0').rstrip('.')
            l_col = f"PSARl_{psar_af_str}_{psar_max_str}"  # Long signal line
            s_col = f"PSARs_{psar_af_str}_{psar_max_str}"  # Short signal line
            # af_col = f"PSARaf_{psar_af_str}_{psar_max_str}" # Acceleration Factor (optional)
            # r_col = f"PSARr_{psar_af_str}_{psar_max_str}" # Reversal indicator (optional)
            ta_list.append({
                "kind": "psar", "af": psar_af, "max_af": psar_max,
                "col_names": (l_col, s_col)  # Only request L/S lines by default
            })
            self.ta_column_map["PSAR_Long"] = l_col   # Value when SAR is below (long trend), NaN otherwise
            self.ta_column_map["PSAR_Short"] = s_col  # Value when SAR is above (short trend), NaN otherwise

        # SMA 10
        if indi_cfg.get("sma_10") and sma10_w > 0:
            col_name = f"SMA_{sma10_w}"
            ta_list.append({"kind": "sma", "length": sma10_w, "col_names": (col_name,)})
            self.ta_column_map["SMA10"] = col_name

        # MFI (Money Flow Index)
        if indi_cfg.get("mfi") and mfi_w > 0:
            col_name = f"MFI_{mfi_w}"
            if all(c in self.df.columns for c in ['high', 'low', 'close', 'volume']):
                 ta_list.append({"kind": "mfi", "length": mfi_w, "col_names": (col_name,)})
                 self.ta_column_map["MFI"] = col_name
            else:
                 self.logger.warning("Cannot calculate MFI: Missing HLCV columns in TA DataFrame.")
                 indi_cfg["mfi"] = False  # Disable check

        # --- Create Strategy Object ---
        if not ta_list:
            self.logger.warning(f"No valid indicators enabled or configured for {self.symbol}. TA Strategy not created.")
            return

        try:
            self.ta_strategy = ta.Strategy(
                name="EnhancedMultiIndicatorStrategy",
                description="Calculates multiple TA indicators based on bot config using pandas_ta",
                ta=ta_list
            )
            self.logger.info(f"Defined TA Strategy for {self.symbol} with {len(ta_list)} indicator groups.")
            self.logger.debug(f"TA Column Map: {self.ta_column_map}")
        except Exception as strat_err:
            self.logger.error(f"Error creating pandas_ta Strategy object: {strat_err}", exc_info=True)
            self.ta_strategy = None

    def _calculate_all_indicators(self) -> None:
        """Calculates all enabled indicators using the defined pandas_ta strategy on the float DataFrame (self.df)."""
        if self.df.empty:
            self.logger.warning(f"TA DataFrame is empty for {self.symbol}, cannot calculate indicators.")
            return
        if not self.ta_strategy:
            # Already logged warning in _define_ta_strategy if no indicators were added
            return

        # Check if sufficient data exists for the strategy's requirements
        min_required_data = self.ta_strategy.required if hasattr(self.ta_strategy, 'required') else 50  # pandas_ta built-in or default guess
        buffer = 20  # Add buffer for calculation stability
        required_with_buffer = min_required_data + buffer
        if len(self.df) < required_with_buffer:
            self.logger.warning(f"{NEON_YELLOW}Insufficient data ({len(self.df)} rows) for {self.symbol} TA calculation (min recommended: {required_with_buffer}). Results may be inaccurate or NaN.{RESET}")

        try:
            self.logger.debug(f"Running pandas_ta strategy calculation for {self.symbol} on {len(self.df)} rows...")
            # Apply the strategy to the DataFrame (modifies self.df inplace)
            start_ta_time = time.monotonic()
            # Ensure the DataFrame index is datetime (should be from fetch_klines_ccxt)
            if not isinstance(self.df.index, pd.DatetimeIndex):
                 self.logger.warning("DataFrame index is not DatetimeIndex. TA calculations might fail or be incorrect.")
            # Run the strategy calculation
            self.df.ta.strategy(self.ta_strategy, timed=False)  # timed=True adds overhead
            ta_duration = time.monotonic() - start_ta_time
            self.logger.debug(f"Finished indicator calculations for {self.symbol} in {ta_duration:.3f}s.")
            # Optional: Log columns generated: self.logger.debug(f"DataFrame columns after TA: {self.df.columns.tolist()}")
        except AttributeError as ae:
             # Catch common errors if DataFrame columns are not float or contain NaNs unexpectedly
             if "'float' object has no attribute" in str(ae) or "cannot convert" in str(ae).lower():
                 self.logger.error(f"{NEON_RED}Pandas TA Error ({self.symbol}): Input columns (e.g., HLCV) might contain NaNs or non-numeric data. Check data fetching and float conversion. Error: {ae}{RESET}", exc_info=False)
                 self.logger.debug(f"Problematic DF sample (float converted) tail:\n{self.df.tail()}")
             else:
                 self.logger.error(f"{NEON_RED}Pandas TA attribute error ({self.symbol}): {ae}. Is pandas_ta installed/updated? Check library compatibility.{RESET}", exc_info=True)
        except Exception as e:
            self.logger.error(f"{NEON_RED}Error calculating indicators with pandas_ta strategy for {self.symbol}: {e}{RESET}", exc_info=True)
            # Don't wipe df here, some indicators might have calculated, but results will be incomplete

    def _update_latest_indicator_values(self) -> None:
        """Updates self.indicator_values (dict of Decimals) with the latest calculated
        values from the float DataFrame (self.df), converting them back to Decimal.
        Handles potential NaN/None values gracefully.
        """
        self.indicator_values = {}  # Reset before populating
        if self.df.empty:
            self.logger.warning(f"TA DataFrame empty for {self.symbol}. Cannot update latest indicator values.")
            return
        try:
            # Get the last row (most recent indicator values)
            latest_series = self.df.iloc[-1]
            if latest_series.isnull().all():
                self.logger.warning(f"Last row of TA DataFrame is all NaN for {self.symbol}. Cannot update latest indicator values.")
                return
        except IndexError:
            self.logger.error(f"DataFrame index out of bounds when accessing last row for {self.symbol}.")
            return
        except Exception as e:
             self.logger.error(f"Error accessing last row of DataFrame for {self.symbol}: {e}", exc_info=True)
             return

        # Helper to safely convert float/object back to Decimal
        def to_decimal_safe(value: Any) -> Optional[Decimal]:
            # Check for pandas NA, numpy NaN, or None
            if pd.isna(value) or value is None: return None
            try:
                # Check for infinity before converting float to string
                if isinstance(value, (float, np.floating)) and not math.isfinite(value):
                    return None
                # Convert to string first for precise Decimal conversion
                dec_val = Decimal(str(value))
                # Final check for non-finite Decimals (just in case)
                return dec_val if dec_val.is_finite() else None
            except (InvalidOperation, ValueError, TypeError):
                # self.logger.debug(f"Could not convert value '{value}' (type: {type(value)}) to Decimal.")
                return None

        # Populate indicator_values using the ta_column_map to get actual column names
        for generic_name, actual_col_name in self.ta_column_map.items():
            if actual_col_name in latest_series:
                raw_value = latest_series.get(actual_col_name)
                self.indicator_values[generic_name] = to_decimal_safe(raw_value)
            else:
                 # This might happen if an indicator calculation failed silently in pandas_ta
                 self.logger.debug(f"Column '{actual_col_name}' not found in TA DataFrame for indicator '{generic_name}' ({self.symbol}). Setting value to None.")
                 self.indicator_values[generic_name] = None

        # Also add latest OHLCV values (from the float df, converted back to Decimal)
        for base_col in ['open', 'high', 'low', 'close', 'volume']:
             if base_col in latest_series:
                 self.indicator_values[base_col.capitalize()] = to_decimal_safe(latest_series.get(base_col))

        # Log summary of updated values
        valid_values_count = sum(1 for v in self.indicator_values.values() if v is not None)
        total_expected = len(self.ta_column_map) + 5  # +5 for OHLCV
        self.logger.debug(f"Latest indicator Decimal values updated for {self.symbol}: Found {valid_values_count}/{total_expected} valid values.")
        # For detailed logging of values:
        # valid_values_str = {k: f"{v:.5f}" if isinstance(v, Decimal) else str(v) for k, v in self.indicator_values.items()}
        # self.logger.debug(f"Indicator Values: {valid_values_str}")

    # --- Precision and Market Info Helpers ---
    def get_min_tick_size(self) -> Optional[Decimal]:
        """Gets the minimum price tick size as a Decimal from market info."""
        tick = self.market_info.get('min_tick_size')
        # Validate that it's a finite, positive Decimal
        if tick is None or not isinstance(tick, Decimal) or not tick.is_finite() or tick <= 0:
            self.logger.warning(f"Invalid or missing min_tick_size ({tick}) for {self.symbol}. Price quantization may fail.")
            return None
        return tick

    def get_price_precision_digits(self) -> int:
        """Gets the number of decimal places for price precision."""
        # Defaults to 8 if not found, a safe fallback (won't truncate too much)
        return self.market_info.get('price_precision_digits', 8)

    def get_amount_precision_digits(self) -> int:
        """Gets the number of decimal places for amount (quantity) precision."""
        return self.market_info.get('amount_precision_digits', 8)

    def get_amount_step_size(self) -> Optional[Decimal]:
        """Gets the minimum amount step size as a Decimal from market info."""
        step = self.market_info.get('amount_step_size')
        # Validate that it's a finite, positive Decimal
        if step is None or not isinstance(step, Decimal) or not step.is_finite() or step <= 0:
            self.logger.debug(f"Invalid or missing amount_step_size ({step}) for {self.symbol}. Amount quantization will use digits fallback.")
            return None
        return step

    # --- Fibonacci Calculation ---
    def calculate_fibonacci_levels(self, window: Optional[int] = None) -> Dict[str, Decimal]:
        """Calculates Fibonacci retracement levels based on the high/low over a specified window.
        Uses the raw DataFrame (`df_raw` with Decimal precision) and quantizes the resulting levels.

        Args:
            window: The lookback period (number of candles). Uses config value if None.

        Returns:
            A dictionary of Fibonacci levels (e.g., "Fib_38.2%") mapped to quantized price Decimals.
            Returns an empty dictionary if calculation is not possible or fails.
        """
        self.fib_levels_data = {}  # Reset previous levels
        window = window or int(self.config.get("fibonacci_window", DEFAULT_FIB_WINDOW))

        if len(self.df_raw) < window:
            self.logger.debug(f"Not enough data ({len(self.df_raw)} rows) for Fibonacci window ({window}) on {self.symbol}.")
            return {}

        # Use the raw DataFrame (df_raw) which should have Decimal columns
        df_slice = self.df_raw.tail(window)

        try:
            if 'high' not in df_slice.columns or 'low' not in df_slice.columns:
                 self.logger.warning(f"Missing 'high' or 'low' column in df_raw for Fib calculation ({self.symbol}).")
                 return {}

            # Extract High/Low Series (should be Decimal type)
            high_series = df_slice["high"]
            low_series = df_slice["low"]

            # Find max high and min low, handling potential NaNs or non-Decimals gracefully
            # Convert to numeric first, coercing errors, then find max/min, then convert result back to Decimal
            high_numeric = pd.to_numeric(high_series, errors='coerce').dropna()
            low_numeric = pd.to_numeric(low_series, errors='coerce').dropna()

            if high_numeric.empty or low_numeric.empty:
                 self.logger.warning(f"Could not find valid high/low data in the last {window} periods for Fib calculation on {self.symbol} after cleaning.")
                 return {}

            # Convert max/min back to Decimal using string representation for precision
            high = Decimal(str(high_numeric.max()))
            low = Decimal(str(low_numeric.min()))

            if not high.is_finite() or not low.is_finite():
                 self.logger.warning(f"Non-finite high/low values after aggregation for Fib calculation on {self.symbol}. High={high}, Low={low}")
                 return {}
            if high <= low:  # Range must be positive
                 self.logger.debug(f"Invalid range (High <= Low): High={high}, Low={low} in window {window} for Fib calculation on {self.symbol}.")
                 return {}

            diff: Decimal = high - low
            levels: Dict[str, Decimal] = {}
            min_tick: Optional[Decimal] = self.get_min_tick_size()

            if diff > 0:
                for level_pct_float in FIB_LEVELS:
                    level_pct = Decimal(str(level_pct_float))
                    # Calculate raw price level: High - (Range * Percentage)
                    level_price_raw = high - (diff * level_pct)

                    # Quantize the calculated level price using the utility function
                    level_price_quantized = quantize_price_util(
                        level_price_raw, min_tick, self.logger, self.symbol, rounding=ROUND_DOWN
                    )

                    if level_price_quantized is not None:
                        level_name = f"Fib_{level_pct * 100:.1f}%"
                        levels[level_name] = level_price_quantized
                    else:
                        # Log warning if quantization failed, but maybe store raw? Or skip? Skip for now.
                        self.logger.warning(f"Failed to quantize Fibonacci level {level_pct * 100:.1f}% (Raw: {level_price_raw}) for {self.symbol}. Skipping level.")

            self.fib_levels_data = levels
            # Log the calculated levels (optional, can be verbose)
            if levels:
                price_prec = self.get_price_precision_digits()
                log_levels = {k: f"{v:.{price_prec}f}" for k, v in levels.items()}
                self.logger.debug(f"Calculated Fibonacci levels for {self.symbol} (Window: {window}, High: {high:.{price_prec}f}, Low: {low:.{price_prec}f}): {log_levels}")
            return levels

        except Exception as e:
            # Catch potential errors during series access, conversion, or calculation
            self.logger.error(f"{NEON_RED}Fibonacci calculation error for {self.symbol}: {e}{RESET}", exc_info=True)
            self.fib_levels_data = {}
            return {}

    # --- Indicator Check Methods ---
    # These methods return Optional[float] score [-1.0, 1.0] or None if unavailable/error.
    # They use the Decimal values stored in self.indicator_values and convert to float for scoring.

    def _get_indicator_float(self, name: str) -> Optional[float]:
        """Safely retrieves an indicator value from self.indicator_values as a float."""
        val_decimal = self.indicator_values.get(name)
        if val_decimal is None or not val_decimal.is_finite(): return None
        try: return float(val_decimal)
        except (ValueError, TypeError): return None

    def _check_ema_alignment(self) -> Optional[float]:
        """Checks if short EMA is above/below long EMA. Score: 1.0 (short > long), -1.0 (short < long), 0.0 (equal/NaN)."""
        ema_s = self._get_indicator_float("EMA_Short")
        ema_l = self._get_indicator_float("EMA_Long")
        if ema_s is None or ema_l is None: return None
        # Add tiny tolerance to avoid score flapping when EMAs are extremely close
        tolerance = 1e-9
        if ema_s > ema_l + tolerance: return 1.0  # Bullish alignment
        if ema_s < ema_l - tolerance: return -1.0  # Bearish alignment
        return 0.0  # Effectively equal or NaN

    def _check_momentum(self) -> Optional[float]:
        """Checks Momentum indicator value. Positive -> bullish, Negative -> bearish. Score scaled & clamped."""
        mom = self._get_indicator_float("Momentum")
        if mom is None: return None
        # Basic scaling attempt: Assumes momentum might need normalization.
        # This factor likely needs tuning based on asset/timeframe volatility.
        # Goal: Map typical positive/negative ranges towards +1/-1.
        scaling_factor = 0.1  # Example: If MOM often +/- 10, this scales it to +/- 1. Consider making this configurable.
        score = mom * scaling_factor
        return max(-1.0, min(1.0, score))  # Clamp score to [-1.0, 1.0]

    def _check_volume_confirmation(self) -> Optional[float]:
        """Checks if current volume exceeds its MA by a multiplier. Score: 0.7 (exceeds), 0.0 (doesn't/NaN)."""
        vol = self._get_indicator_float("Volume")
        vol_ma = self._get_indicator_float("Volume_MA")
        # Need valid volume, and vol_ma > 0 for meaningful comparison
        if vol is None or vol_ma is None or vol_ma <= 0: return None
        multiplier = float(self.config.get("volume_confirmation_multiplier", 1.5))
        return 0.7 if vol > vol_ma * multiplier else 0.0

    def _check_stoch_rsi(self) -> Optional[float]:
        """Checks Stochastic RSI K and D lines for overbought/oversold and crossovers. Score range [-1.0, 1.0]."""
        k = self._get_indicator_float("StochRSI_K")
        d = self._get_indicator_float("StochRSI_D")
        if k is None or d is None: return None
        oversold = float(self.config.get("stoch_rsi_oversold_threshold", 25.0))
        overbought = float(self.config.get("stoch_rsi_overbought_threshold", 75.0))
        score = 0.0
        # Strong signals: Crossover within OB/OS zones
        if k < oversold and d < oversold: score = 1.0 if k > d else 0.8  # Bullish crossover deep OS (stronger if k>d crosses up)
        elif k > overbought and d > overbought: score = -1.0 if k < d else -0.8  # Bearish crossover deep OB (stronger if k<d crosses down)
        # Weaker signals: Just entering OB/OS without crossover confirmation yet
        elif k < oversold and d >= oversold: score = 0.6  # K entered OS
        elif k > overbought and d <= overbought: score = -0.6  # K entered OB
        # Mid-range crossover signals (weakest confirmation)
        elif k > d and not (k > overbought and d > overbought): score = 0.3  # Bullish crossover mid-range
        elif k < d and not (k < oversold and d < oversold): score = -0.3  # Bearish crossover mid-range
        # Else (k == d mid-range, or both OB/OS but no cross): score remains 0.0
        return max(-1.0, min(1.0, score))  # Clamp final score

    def _check_rsi(self) -> Optional[float]:
        """Checks RSI value against OB/OS levels. Score scaled linearly between 0 and 100, clamped."""
        rsi = self._get_indicator_float("RSI")
        if rsi is None: return None
        # Simple linear scale: Score = 1.0 at RSI=0, 0.0 at RSI=50, -1.0 at RSI=100
        # This treats RSI linearly, where lower values are more bullish.
        score = (50.0 - rsi) / 50.0
        # Optional: Add extra weight/boost for extreme readings (e.g., beyond 80/20)
        extreme_ob = 80.0; extreme_os = 20.0
        if rsi >= extreme_ob: score = max(-1.0, score * 1.1)  # Increase bearishness magnitude above extreme OB
        if rsi <= extreme_os: score = min(1.0, score * 1.1)  # Increase bullishness magnitude below extreme OS
        return max(-1.0, min(1.0, score))  # Clamp final score

    def _check_cci(self) -> Optional[float]:
        """Checks CCI against standard OB/OS levels (+/- 100). Score scaled linearly between thresholds, clamped."""
        cci = self._get_indicator_float("CCI")
        if cci is None: return None
        ob = 100.0; os = -100.0
        # Scale based on thresholds: Strong signal outside +/-100, linear inside.
        if cci >= ob: score = -1.0  # Strong sell signal above +100
        elif cci <= os: score = 1.0  # Strong buy signal below -100
        else: score = -cci / ob  # Linear scale between -100 and +100 (e.g., cci=50 -> -0.5, cci=-50 -> 0.5)
        return max(-1.0, min(1.0, score))  # Clamp final score

    def _check_wr(self) -> Optional[float]:
        """Checks Williams %R against standard OB/OS levels (-20 / -80). Score scaled linearly, clamped."""
        wr = self._get_indicator_float("WR")  # Williams %R typically ranges from -100 (most oversold) to 0 (most overbought)
        if wr is None: return None
        # Scale: Score = 1.0 at WR=-100 (extreme oversold), 0.0 at WR=-50, -1.0 at WR=0 (extreme overbought)
        score = (wr + 50.0) / -50.0
        # Optional: Add extra weight/boost for extreme readings
        extreme_ob = -10.0; extreme_os = -90.0
        if wr >= extreme_ob: score = max(-1.0, score * 1.1)  # Increase bearishness magnitude near 0
        if wr <= extreme_os: score = min(1.0, score * 1.1)  # Increase bullishness magnitude near -100
        return max(-1.0, min(1.0, score))  # Clamp final score

    def _check_psar(self) -> Optional[float]:
        """Checks Parabolic SAR position relative to price. Score: 1.0 (SAR below price - bullish), -1.0 (SAR above - bearish), 0.0 (transition/error)."""
        # PSARl (long) column has value when SAR is below price, NaN otherwise.
        # PSARs (short) column has value when SAR is above price, NaN otherwise.
        psar_l_val = self.indicator_values.get("PSAR_Long")  # Decimal or None
        psar_s_val = self.indicator_values.get("PSAR_Short")  # Decimal or None

        # Check if the values are finite Decimals (i.e., not None or NaN from calculation)
        psar_l_active = psar_l_val is not None and psar_l_val.is_finite()
        psar_s_active = psar_s_val is not None and psar_s_val.is_finite()

        if psar_l_active and not psar_s_active: return 1.0  # SAR is below price (Long trend active)
        if psar_s_active and not psar_l_active: return -1.0  # SAR is above price (Short trend active)

        # If both active/inactive (shouldn't happen with standard PSAR) or both NaN (e.g., at start), return neutral.
        if (psar_l_active and psar_s_active) or (not psar_l_active and not psar_s_active):
            self.logger.debug(f"PSAR state ambiguous/neutral for {self.symbol}: PSARl={psar_l_val}, PSARs={psar_s_val}")
            return 0.0
        # Fallback neutral case (should be covered above)
        return 0.0

    def _check_sma10(self) -> Optional[float]:
        """Checks if close price is above/below SMA10. Score: 0.5 (above), -0.5 (below), 0.0 (equal/NaN)."""
        sma = self._get_indicator_float("SMA10")
        close = self._get_indicator_float("Close")
        if sma is None or close is None: return None
        tolerance = 1e-9
        if close > sma + tolerance: return 0.5
        if close < sma - tolerance: return -0.5
        return 0.0  # Effectively equal or NaN

    def _check_vwap(self) -> Optional[float]:
        """Checks if close price is above/below VWAP. Score: 0.6 (above), -0.6 (below), 0.0 (equal/NaN)."""
        vwap = self._get_indicator_float("VWAP")
        close = self._get_indicator_float("Close")
        if vwap is None or close is None: return None
        tolerance = 1e-9
        if close > vwap + tolerance: return 0.6
        if close < vwap - tolerance: return -0.6
        return 0.0  # Effectively equal or NaN

    def _check_mfi(self) -> Optional[float]:
        """Checks Money Flow Index against standard OB/OS levels (80/20). Score scaled linearly, clamped."""
        mfi = self._get_indicator_float("MFI")
        if mfi is None: return None
        # Scale similar to RSI: Score = 1.0 at MFI=0, 0.0 at MFI=50, -1.0 at MFI=100
        score = (50.0 - mfi) / 50.0
        # Optional boost for extremes
        extreme_ob = 90.0; extreme_os = 10.0
        if mfi >= extreme_ob: score = max(-1.0, score * 1.1)  # Boost bearishness magnitude
        if mfi <= extreme_os: score = min(1.0, score * 1.1)  # Boost bullishness magnitude
        return max(-1.0, min(1.0, score))  # Clamp final score

    def _check_bollinger_bands(self) -> Optional[float]:
        """Checks close price relative to Bollinger Bands. Score: 1.0 (below lower), -1.0 (above upper), scaled linearly within bands."""
        bbl = self._get_indicator_float("BB_Lower")
        bbu = self._get_indicator_float("BB_Upper")
        close = self._get_indicator_float("Close")
        # Need valid bands (upper > lower) and close price
        if bbl is None or bbu is None or close is None or bbu <= bbl: return None
        # Strong signals outside or touching the bands
        if close <= bbl: return 1.0   # Below or touching lower band (strong buy / reversal potential)
        if close >= bbu: return -1.0  # Above or touching upper band (strong sell / reversal potential)
        # Scale position linearly within the bands
        # Position = (Close - Lower) / (Upper - Lower). Ranges from 0 (at lower) to 1 (at upper).
        band_width = bbu - bbl
        # Avoid division by zero if bands are somehow equal despite earlier check
        if band_width == 0: return 0.0
        position_within_band = (close - bbl) / band_width
        # Convert position [0, 1] to score [+1, -1]
        # Score = 1 - 2 * position. (If position=0, score=1. If position=1, score=-1. If position=0.5, score=0)
        score = 1.0 - (2.0 * position_within_band)
        return max(-1.0, min(1.0, score))  # Clamp final score

    def _check_orderbook(self, orderbook_data: Optional[Dict]) -> Optional[float]:
        """Calculates Order Book Imbalance (OBI) from fetched order book data.
        OBI = (Total Bid Volume - Total Ask Volume) / (Total Bid Volume + Total Ask Volume)
        Uses top N levels as defined in config. Score: [-1.0, 1.0].

        Args:
            orderbook_data: Dictionary from fetch_orderbook_ccxt containing 'bids' and 'asks'.

        Returns:
            OBI score as float, or None if calculation fails or data is invalid.
        """
        if not orderbook_data or not isinstance(orderbook_data, dict):
             self.logger.debug("Orderbook data missing or invalid type for OBI calculation.")
             return None  # Cannot calculate without data
        try:
            limit = int(self.config.get("orderbook_limit", 10))  # Use configured limit
            # Orderbook data from CCXT usually has string prices/amounts [[price_str, amount_str], ...]
            bids_raw = orderbook_data.get('bids', [])
            asks_raw = orderbook_data.get('asks', [])

            if not isinstance(bids_raw, list) or not isinstance(asks_raw, list):
                 self.logger.warning("Orderbook bids/asks are not lists.")
                 return 0.0  # Neutral score if structure is wrong

            # Take top N levels
            top_bids = bids_raw[:limit]
            top_asks = asks_raw[:limit]
            if not top_bids and not top_asks:  # Check if both are empty after slicing
                 self.logger.debug(f"Orderbook empty or insufficient levels (Limit: {limit}) for OBI calc.")
                 return 0.0  # Neutral if no levels available

            # Sum volume (amount) at each level, converting to Decimal robustly
            bid_vol = Decimal('0')
            ask_vol = Decimal('0')
            invalid_level_found = False
            for b in top_bids:
                # Ensure level format is correct [price, amount]
                if isinstance(b, (list, tuple)) and len(b) > 1:
                    try: bid_vol += Decimal(str(b[1]))  # Use amount (index 1)
                    except (InvalidOperation, TypeError, IndexError, ValueError):
                        invalid_level_found = True; continue # Skip invalid entries
            for a in top_asks:
                 if isinstance(a, (list, tuple)) and len(a) > 1:
                    try: ask_vol += Decimal(str(a[1]))  # Use amount (index 1)
                    except (InvalidOperation, TypeError, IndexError, ValueError):
                        invalid_level_found = True; continue # Skip invalid entries

            if invalid_level_found:
                 self.logger.warning(f"Skipped invalid level(s) in OBI calculation for {self.symbol}.")

            total_vol = bid_vol + ask_vol
            if total_vol <= 0:
                 self.logger.debug("Total volume in top orderbook levels is zero.")
                 return 0.0  # Avoid division by zero, return neutral

            # Calculate OBI = (BidVol - AskVol) / TotalVol
            obi_decimal = (bid_vol - ask_vol) / total_vol  # Decimal result

            # Clamp to [-1.0, 1.0] and convert to float for the scoring system
            score = float(max(Decimal("-1.0"), min(Decimal("1.0"), obi_decimal)))
            self.logger.debug(f"OBI Calc ({self.symbol}): BidVol={bid_vol:.4f}, AskVol={ask_vol:.4f}, OBI={obi_decimal:.4f} -> Score={score:.3f}")
            return score

        except (InvalidOperation, ValueError, TypeError, IndexError) as e:
            self.logger.warning(f"Error calculating Order Book Imbalance for {self.symbol}: {e}")
            return None  # Indicate error / unavailable score
        except Exception as e:
             self.logger.error(f"Unexpected error in OBI calculation for {self.symbol}: {e}", exc_info=True)
             return None

    # --- Signal Generation & Scoring ---
    def generate_trading_signal(self, current_price_dec: Decimal, orderbook_data: Optional[Dict]) -> str:
        """Generates a final trading signal ('BUY', 'SELL', 'HOLD') based on weighted scores
        from enabled indicators. Uses Decimal for score accumulation for precision.

        Args:
            current_price_dec: Current market price (Decimal) for logging.
            orderbook_data: Optional order book data for OBI calculation.

        Returns:
            The final signal string: "BUY", "SELL", or "HOLD".
        """
        self.signals = {"BUY": 0, "SELL": 0, "HOLD": 1}  # Reset signals, default HOLD
        final_signal_score = Decimal("0.0")
        total_weight_applied = Decimal("0.0")
        active_indicator_count = 0
        nan_indicator_count = 0
        debug_scores: Dict[str, str] = {}  # For detailed logging

        # --- Pre-checks ---
        if not self.indicator_values:
            self.logger.warning(f"Cannot generate signal for {self.symbol}: Indicator values not calculated/updated.")
            return "HOLD"
        if not current_price_dec or not current_price_dec.is_finite() or current_price_dec <= 0:
            self.logger.warning(f"Cannot generate signal for {self.symbol}: Invalid current price ({current_price_dec}).")
            return "HOLD"
        if not self.weights:  # Check if weights dict is empty
            self.logger.debug(f"No weights loaded for active set '{self.active_weight_set_name}'. Holding.")
            return "HOLD"

        # --- Map Indicator Keys to Check Methods ---
        indicator_check_methods = {
            "ema_alignment": self._check_ema_alignment, "momentum": self._check_momentum,
            "volume_confirmation": self._check_volume_confirmation, "stoch_rsi": self._check_stoch_rsi,
            "rsi": self._check_rsi, "bollinger_bands": self._check_bollinger_bands,
            "vwap": self._check_vwap, "cci": self._check_cci, "wr": self._check_wr,
            "psar": self._check_psar, "sma_10": self._check_sma10, "mfi": self._check_mfi,
            # Use lambda for orderbook to pass the data argument
            "orderbook": lambda: self._check_orderbook(orderbook_data),
        }

        # --- Iterate Through Enabled Indicators and Calculate Weighted Score ---
        enabled_indicators_config = self.config.get("indicators", {})

        for indicator_key, check_method in indicator_check_methods.items():
            # Check if indicator is enabled in config
            if not enabled_indicators_config.get(indicator_key, False):
                debug_scores[indicator_key] = "Disabled"
                continue

            # Get the pre-validated float weight for this indicator
            weight = self.weights.get(indicator_key)
            if weight is None:  # Weight missing or was invalid during init
                debug_scores[indicator_key] = "No/Invalid Wt"
                continue

            # Skip if weight is zero
            if math.isclose(weight, 0.0):
                debug_scores[indicator_key] = "Wt=0"
                continue

            # Execute the check method to get the score [-1.0, 1.0] or None
            indicator_score_float: Optional[float] = None
            try:
                indicator_score_float = check_method()
            except Exception as e:
                self.logger.error(f"Error executing check method for '{indicator_key}': {e}", exc_info=True)
                debug_scores[indicator_key] = "Check Error"
                nan_indicator_count += 1
                continue  # Skip this indicator if check failed

            # Process the returned score
            if indicator_score_float is not None and math.isfinite(indicator_score_float):
                try:
                    # Clamp score to [-1.0, 1.0] before converting to Decimal
                    clamped_score_float = max(-1.0, min(1.0, indicator_score_float))
                    indicator_score_decimal = Decimal(str(clamped_score_float))
                    weight_decimal = Decimal(str(weight))  # Convert float weight to Decimal

                    # Calculate weighted score and add to total
                    weighted_score = indicator_score_decimal * weight_decimal
                    final_signal_score += weighted_score
                    total_weight_applied += abs(weight_decimal)  # Sum absolute weights for normalization/debug
                    active_indicator_count += 1
                    # Store score details for debug logging
                    debug_scores[indicator_key] = f"{indicator_score_float:.2f} (x{weight:.2f}) = {weighted_score:.3f}"
                except (InvalidOperation, TypeError) as calc_err:
                    self.logger.error(f"Error processing score/weight for {indicator_key}: {calc_err}")
                    debug_scores[indicator_key] = "Calc Error"
                    nan_indicator_count += 1
            else:
                # Score is None or NaN/Infinite from indicator check
                debug_scores[indicator_key] = "NaN/None"
                nan_indicator_count += 1

        # --- Determine Final Signal Based on Score and Threshold ---
        final_signal = "HOLD"
        normalized_score = Decimal("0.0")
        if total_weight_applied > 0:
            # Normalize the score based on the sum of absolute weights applied
            # This gives a score roughly in [-1, 1] range if individual scores are [-1, 1]
            normalized_score = (final_signal_score / total_weight_applied).quantize(Decimal("0.0001"))
        elif active_indicator_count > 0:
             self.logger.warning(f"Calculated signal score is {final_signal_score} but total weight applied is zero for {self.symbol}. Check weights.")

        # Use specific threshold if active set is 'scalping', otherwise default
        # Thresholds are applied to the RAW final_signal_score (sum of weighted scores)
        is_scalping_set = self.active_weight_set_name == "scalping"
        threshold_key = "scalping_signal_threshold" if is_scalping_set else "signal_score_threshold"
        default_threshold = 2.5 if is_scalping_set else 1.5
        try:
            # Config validation ensures threshold is float
            threshold_float = self.config.get(threshold_key, default_threshold)
            threshold = Decimal(str(threshold_float))
            if not threshold.is_finite() or threshold <= 0: raise ValueError("Threshold must be positive")
        except (ValueError, InvalidOperation, TypeError):
            threshold = Decimal(str(default_threshold))
            self.logger.warning(f"Invalid threshold for '{threshold_key}'. Using default: {threshold}")

        # Compare RAW weighted score against threshold
        if final_signal_score >= threshold: final_signal = "BUY"
        elif final_signal_score <= -threshold: final_signal = "SELL"

        # Log the signal calculation summary
        price_prec = self.get_price_precision_digits()
        signal_color = NEON_GREEN if final_signal == 'BUY' else NEON_RED if final_signal == 'SELL' else NEON_YELLOW
        log_msg = (
            f"Signal Calc ({self.symbol} @ {current_price_dec:.{price_prec}f}): "
            f"Set='{self.active_weight_set_name}', Indis(Actv/NaN): {active_indicator_count}/{nan_indicator_count}, "
            f"WtSum: {total_weight_applied:.3f}, RawScore: {final_signal_score:.4f}, NormScore: {normalized_score:.4f}, "
            f"Thresh: +/-{threshold:.3f} -> Signal: {signal_color}{final_signal}{RESET}"
        )
        self.logger.info(log_msg)
        if self.logger.level <= logging.DEBUG:  # Log details only if debugging
             # Filter out non-contributing indicators for cleaner debug log
             contributing_scores = {k: v for k, v in debug_scores.items() if v not in ["Disabled", "No/Invalid Wt", "Wt=0"]}
             score_details_str = ", ".join([f"{k}: {v}" for k, v in contributing_scores.items()])
             self.logger.debug(f"  Contributing Scores: {score_details_str}")

        # Update internal signal state flags (used for MA cross check, etc.)
        if final_signal in self.signals:
            self.signals[final_signal] = 1
            self.signals["HOLD"] = 1 if final_signal == "HOLD" else 0
        return final_signal

    # --- Risk Management Calculations ---
    def calculate_entry_tp_sl(
        self, entry_price_signal: Decimal, signal: str
    ) -> Tuple[Optional[Decimal], Optional[Decimal], Optional[Decimal]]:
        """Calculates quantized Entry, Take Profit (TP), and Stop Loss (SL) prices based on ATR.
        Uses Decimal for precision and validates results, ensuring SL/TP are a minimum
        number of ticks away from the entry price.

        Args:
            entry_price_signal: The price near which the signal occurred (e.g., current price).
            signal: "BUY" or "SELL".

        Returns:
            Tuple (Quantized Entry Price, Quantized TP Price, Quantized SL Price).
            Returns (None, None, None) if calculation fails (e.g., invalid ATR, price, tick size).
            TP or SL might be None individually if calculation leads to invalid values or cannot be placed safely.
        """
        quantized_entry: Optional[Decimal] = None
        take_profit: Optional[Decimal] = None
        stop_loss: Optional[Decimal] = None

        # --- Input Validation ---
        if signal not in ["BUY", "SELL"]:
             self.logger.error(f"Invalid signal '{signal}' for TP/SL calculation."); return None, None, None
        if not entry_price_signal or not entry_price_signal.is_finite() or entry_price_signal <= 0:
            self.logger.error(f"Invalid entry signal price ({entry_price_signal}) for TP/SL calc."); return None, None, None

        # --- Get ATR and Min Tick ---
        atr_val = self.indicator_values.get("ATR")  # Should be Decimal
        min_tick = self.get_min_tick_size()  # Should be Decimal

        if atr_val is None or not atr_val.is_finite() or atr_val <= 0:
            self.logger.warning(f"{NEON_YELLOW}Cannot calculate dynamic TP/SL for {self.symbol}: Invalid ATR value ({atr_val}). SL/TP will be None.{RESET}")
            # We might still be able to quantize entry, but SL/TP depend on ATR.
            quantized_entry = quantize_price_util(
                entry_price_signal, min_tick, self.logger, self.symbol,
                rounding=ROUND_DOWN if signal == "BUY" else ROUND_UP
            )
            return quantized_entry, None, None
        if min_tick is None:  # Error already logged by get_min_tick_size if invalid
             # Log again here for context
             self.logger.error(f"{NEON_RED}Cannot calculate TP/SL for {self.symbol}: Minimum tick size is unavailable.{RESET}")
             return None, None, None  # Cannot quantize without tick size

        # --- Quantize Entry Price ---
        # Use ROUND_DOWN for BUY entry signal, ROUND_UP for SELL entry signal as a reference.
        # Actual fill price for market orders will differ.
        entry_rounding = ROUND_DOWN if signal == "BUY" else ROUND_UP
        quantized_entry = quantize_price_util(entry_price_signal, min_tick, self.logger, self.symbol, rounding=entry_rounding)
        if quantized_entry is None:
            self.logger.error(f"Failed to quantize entry signal price {entry_price_signal} for {self.symbol}.")
            return None, None, None

        # --- Calculate SL/TP Offsets ---
        try:
            atr = atr_val  # Use the Decimal ATR value
            # Get multipliers from config (validated as float), convert to Decimal
            tp_mult = Decimal(str(self.config.get("take_profit_multiple", 1.0)))
            sl_mult = Decimal(str(self.config.get("stop_loss_multiple", 1.5)))

            # Calculate raw offsets from entry price
            sl_offset_raw = atr * sl_mult
            tp_offset_raw = atr * tp_mult

            # Ensure offsets are at least the minimum required ticks away in value
            min_offset_value = min_tick * Decimal(MIN_TICKS_AWAY_FOR_SLTP)

            sl_offset = max(sl_offset_raw, min_offset_value)
            if sl_offset != sl_offset_raw:
                self.logger.debug(f"Adjusted SL offset from {sl_offset_raw} to minimum {sl_offset} ({MIN_TICKS_AWAY_FOR_SLTP} ticks) for {self.symbol}.")

            tp_offset = max(tp_offset_raw, min_offset_value)
            if tp_offset != tp_offset_raw:
                self.logger.debug(f"Adjusted TP offset from {tp_offset_raw} to minimum {tp_offset} ({MIN_TICKS_AWAY_FOR_SLTP} ticks) for {self.symbol}.")

            # --- Calculate Raw TP/SL Prices ---
            if signal == "BUY":
                sl_raw = quantized_entry - sl_offset
                tp_raw = quantized_entry + tp_offset
                # Quantize SL DOWN (further away), TP UP (further away) initially
                stop_loss = quantize_price_util(sl_raw, min_tick, self.logger, self.symbol, rounding=ROUND_DOWN)
                take_profit = quantize_price_util(tp_raw, min_tick, self.logger, self.symbol, rounding=ROUND_UP)
            else:  # SELL
                sl_raw = quantized_entry + sl_offset
                tp_raw = quantized_entry - tp_offset
                # Quantize SL UP (further away), TP DOWN (further away) initially
                stop_loss = quantize_price_util(sl_raw, min_tick, self.logger, self.symbol, rounding=ROUND_UP)
                take_profit = quantize_price_util(tp_raw, min_tick, self.logger, self.symbol, rounding=ROUND_DOWN)

            # --- Post-Quantization Validation (Ensure min distance and validity) ---
            # Validate Stop Loss
            if stop_loss is not None:
                sl_boundary = quantized_entry - min_offset_value if signal == "BUY" else quantized_entry + min_offset_value
                needs_sl_adjustment = False
                if signal == "BUY" and stop_loss >= sl_boundary: needs_sl_adjustment = True
                if signal == "SELL" and stop_loss <= sl_boundary: needs_sl_adjustment = True

                if needs_sl_adjustment:
                    rounding = ROUND_DOWN if signal == "BUY" else ROUND_UP
                    adjusted_sl = quantize_price_util(sl_boundary, min_tick, self.logger, self.symbol, rounding=rounding)
                    # If quantizing the boundary didn't move it far enough, move one more tick
                    if adjusted_sl is not None and adjusted_sl == stop_loss:
                         adjusted_sl = quantize_price_util(
                             sl_boundary - (min_tick if signal == "BUY" else -min_tick),
                             min_tick, self.logger, self.symbol, rounding=rounding
                         )

                    if adjusted_sl is not None and adjusted_sl != stop_loss:
                        self.logger.warning(f"Initial SL ({stop_loss}) too close to entry ({quantized_entry}) after quantization. Adjusting to {adjusted_sl} ({MIN_TICKS_AWAY_FOR_SLTP}+ ticks away).")
                        stop_loss = adjusted_sl
                    else:
                        self.logger.error(f"Could not adjust SL ({stop_loss}) to be minimum distance from entry ({quantized_entry}). Setting SL to None for safety.")
                        stop_loss = None  # Safety measure

                # Final check for zero/negative SL
                if stop_loss is not None and stop_loss <= 0:
                    self.logger.error(f"Calculated SL is zero or negative ({stop_loss}) after adjustments. Setting SL to None.")
                    stop_loss = None

            # Validate Take Profit
            if take_profit is not None:
                tp_boundary = quantized_entry + min_offset_value if signal == "BUY" else quantized_entry - min_offset_value
                needs_tp_adjustment = False
                # Check if TP ended up too close or on the wrong side of entry after quantization
                if signal == "BUY" and take_profit <= tp_boundary: needs_tp_adjustment = True
                if signal == "SELL" and take_profit >= tp_boundary: needs_tp_adjustment = True

                if needs_tp_adjustment:
                    rounding = ROUND_UP if signal == "BUY" else ROUND_DOWN
                    adjusted_tp = quantize_price_util(tp_boundary, min_tick, self.logger, self.symbol, rounding=rounding)
                    # If quantizing the boundary didn't move it far enough, move one more tick
                    if adjusted_tp is not None and adjusted_tp == take_profit:
                        adjusted_tp = quantize_price_util(
                            tp_boundary + (min_tick if signal == "BUY" else -min_tick),
                            min_tick, self.logger, self.symbol, rounding=rounding
                        )

                    if adjusted_tp is not None and adjusted_tp != take_profit:
                        self.logger.warning(f"Initial TP ({take_profit}) too close to entry ({quantized_entry}) after quantization. Adjusting to {adjusted_tp} ({MIN_TICKS_AWAY_FOR_SLTP}+ ticks away).")
                        take_profit = adjusted_tp
                    else:
                        self.logger.error(f"Could not adjust TP ({take_profit}) to be minimum distance from entry ({quantized_entry}). Setting TP to None for safety.")
                        take_profit = None  # Safety measure

                # Final check for zero/negative TP
                if take_profit is not None and take_profit <= 0:
                    self.logger.error(f"Calculated TP is zero or negative ({take_profit}) after adjustments. Setting TP to None.")
                    take_profit = None

            # Log results
            prec = self.get_price_precision_digits()
            tp_log = f"{take_profit:.{prec}f}" if take_profit else 'None'
            sl_log = f"{stop_loss:.{prec}f}" if stop_loss else 'None'
            entry_log = f"{quantized_entry:.{prec}f}"
            self.logger.info(f"Calc TP/SL ({signal}): EntryRef={entry_log}, TP={tp_log}, SL={sl_log} (ATR={atr:.{prec + 1}f}, SLx={sl_mult}, TPx={tp_mult})")

            return quantized_entry, take_profit, stop_loss

        except (InvalidOperation, ValueError, TypeError) as e:
            self.logger.error(f"{NEON_RED}Error during TP/SL calculation value conversion for {self.symbol}: {e}{RESET}")
            return quantized_entry, None, None  # Return entry if valid, but no TP/SL
        except Exception as e:
            self.logger.error(f"{NEON_RED}Unexpected error calculating TP/SL for {self.symbol}: {e}{RESET}", exc_info=True)
            return quantized_entry, None, None


# --- Position Sizing ---
def calculate_position_size(
    balance: Decimal,
    risk_per_trade: float,  # From config (e.g., 0.01 for 1%)
    entry_price: Decimal,
    stop_loss_price: Decimal,
    market_info: Dict,
    leverage: int,  # From config
    logger: logging.Logger
) -> Optional[Decimal]:
    """Calculates the position size in base currency units (Spot) or contracts (Futures)
    based on risk percentage, entry/SL prices, and available balance.
    Uses Decimal precision throughout and validates against market limits and available margin.

    Args:
        balance: Available balance in quote currency (Decimal).
        risk_per_trade: Fraction of balance to risk (float, e.g., 0.01 for 1%).
        entry_price: Proposed entry price (Decimal, already quantized potentially).
        stop_loss_price: Proposed stop loss price (Decimal, already quantized).
        market_info: Dictionary containing market details (precision, limits, contract size, type).
        leverage: Leverage to be used (int, relevant for contracts).
        logger: Logger instance.

    Returns:
        Calculated and quantized position size (Decimal) in base units (spot) or contracts (futures),
        or None if calculation fails or constraints (min/max size, min cost, margin) are not met.
    """
    lg = logger
    symbol: str = market_info.get('symbol', 'N/A')
    contract_size: Decimal = market_info.get('contract_size', Decimal('1'))  # Default 1 (for spot/linear)
    min_order_amount: Optional[Decimal] = market_info.get('min_order_amount')
    max_order_amount: Optional[Decimal] = market_info.get('max_order_amount')
    min_order_cost: Optional[Decimal] = market_info.get('min_order_cost')
    amount_step_size: Optional[Decimal] = market_info.get('amount_step_size')
    amount_digits: Optional[int] = market_info.get('amount_precision_digits')
    is_contract: bool = market_info.get('is_contract', False)
    is_inverse: bool = market_info.get('inverse', False)
    quote_currency: str = market_info.get('quote', '?')
    base_currency: str = market_info.get('base', '?')

    # --- Input Validation ---
    if balance is None or not isinstance(balance, Decimal) or balance <= 0:
        lg.error(f"Size Calc Error ({symbol}): Invalid balance {balance}"); return None
    if not entry_price or not entry_price.is_finite() or entry_price <= 0:
        lg.error(f"Size Calc Error ({symbol}): Invalid entry price {entry_price}"); return None
    if not stop_loss_price or not stop_loss_price.is_finite() or stop_loss_price <= 0:
        lg.error(f"Size Calc Error ({symbol}): Invalid SL price {stop_loss_price}"); return None
    if entry_price == stop_loss_price:
        lg.error(f"Size Calc Error ({symbol}): Entry price equals SL price ({entry_price})"); return None
    # Amount step/digits validation happens within quantize_amount_util
    if not (0 < risk_per_trade < 1):
        lg.error(f"Size Calc Error ({symbol}): Invalid risk_per_trade {risk_per_trade} (must be > 0 and < 1)"); return None
    if is_contract and leverage <= 0:
        lg.error(f"Size Calc Error ({symbol}): Invalid leverage {leverage} for contract"); return None

    try:
        # --- Calculate Risk Amount and SL Distance ---
        risk_amount_quote: Decimal = balance * Decimal(str(risk_per_trade))  # Risk amount in quote currency
        sl_distance_points: Decimal = abs(entry_price - stop_loss_price)
        if sl_distance_points <= 0:
            lg.error(f"Size Calc Error ({symbol}): SL distance is zero or negative"); return None

        # --- Calculate Risk Per Unit/Contract in Quote Currency ---
        risk_per_unit_or_contract_quote = Decimal('NaN')
        size_unit_name = ""  # For logging
        size_unquantized = Decimal('NaN')

        if is_contract:
            if is_inverse:
                # Inverse: Risk per Contract (in Quote) = Contract Size * |1/SL - 1/Entry| * Entry Price
                # This formula attempts to linearize the non-linear PnL of inverse contracts.
                # A more accurate way is to calculate the risk in BASE currency first, then convert.
                # Risk per Contract (in BASE) = Contract Size * |1/Entry - 1/SL|
                # Required BASE per contract = Contract Size / Entry Price / Leverage
                # Risk Amount (in BASE) = Risk Amount (Quote) / Entry Price (approximation)
                # Size (Contracts) = Risk Amount (BASE) / Risk per Contract (BASE)
                if entry_price == 0 or stop_loss_price == 0:
                    lg.error(f"Size Calc Error ({symbol}): Zero price encountered for inverse calculation"); return None
                # Calculate risk per contract in BASE currency
                risk_per_contract_base = contract_size * abs(Decimal('1') / entry_price - Decimal('1') / stop_loss_price)
                if not risk_per_contract_base.is_finite() or risk_per_contract_base <= 0:
                    lg.error(f"Size Calc Error ({symbol}): Invalid calculated risk per contract in BASE ({risk_per_contract_base})"); return None
                # Approximate risk amount in BASE currency
                risk_amount_base_approx = risk_amount_quote / entry_price
                # Calculate size based on BASE risk
                size_unquantized = risk_amount_base_approx / risk_per_contract_base
                # For logging/validation later, calculate the equivalent risk per contract in QUOTE
                risk_per_unit_or_contract_quote = risk_per_contract_base * entry_price # Approx quote risk per contract
                size_unit_name = f"contracts ({base_currency} base)"
            else:  # Linear Contract
                # Linear: Risk per Contract (in Quote) = ContractSize * |Entry - SL|
                risk_per_unit_or_contract_quote = contract_size * sl_distance_points
                if not risk_per_unit_or_contract_quote.is_finite() or risk_per_unit_or_contract_quote <= 0:
                     lg.error(f"Size Calc Error ({symbol}): Invalid calculated risk per unit/contract ({risk_per_unit_or_contract_quote})")
                     return None
                size_unquantized = risk_amount_quote / risk_per_unit_or_contract_quote
                size_unit_name = f"contracts ({base_currency} base)"
        else:  # Spot
            # Spot: Risk per Unit (in Quote) = |Entry - SL| (since contract size is 1 base unit)
            risk_per_unit_or_contract_quote = sl_distance_points
            if not risk_per_unit_or_contract_quote.is_finite() or risk_per_unit_or_contract_quote <= 0:
                 lg.error(f"Size Calc Error ({symbol}): Invalid calculated risk per unit/contract ({risk_per_unit_or_contract_quote})")
                 return None
            size_unquantized = risk_amount_quote / risk_per_unit_or_contract_quote
            size_unit_name = f"{base_currency} units"  # Size is in base currency units

        # Validate calculated unquantized size
        if not size_unquantized.is_finite() or size_unquantized <= 0:
            lg.error(f"Size Calc Error ({symbol}): Invalid unquantized size ({size_unquantized}) from RiskAmt={risk_amount_quote:.4f} / RiskPerUnit={risk_per_unit_or_contract_quote:.8f}")
            return None

        lg.debug(f"Size Calc ({symbol}): Bal={balance:.2f}, Risk={risk_per_trade * 100:.2f}%, RiskAmt={risk_amount_quote:.4f}, SLDist={sl_distance_points:.{market_info.get('price_precision_digits', 4)}f}, RiskPerUnit={risk_per_unit_or_contract_quote:.8f}, UnquantSize={size_unquantized:.8f} {size_unit_name}")

        # --- Quantize Size ---
        quantized_size = quantize_amount_util(
            size_unquantized, amount_step_size, amount_digits, lg, symbol, rounding=ROUND_DOWN
        )

        if quantized_size is None or quantized_size <= 0:
            lg.warning(f"{NEON_YELLOW}Size Calc ({symbol}): Size is zero or invalid after quantization (Unquantized: {size_unquantized:.8f}). Cannot place order.{RESET}")
            return None

        lg.debug(f"Quantized Size ({symbol}): {quantized_size} {size_unit_name} (Step: {amount_step_size or 'Derived'})")

        # --- Validate Against Market Limits (Amount) ---
        if min_order_amount is not None and quantized_size < min_order_amount:
            lg.warning(f"{NEON_YELLOW}Size Calc ({symbol}): Calculated size {quantized_size} {size_unit_name} < Min Amount {min_order_amount}. Cannot place order.{RESET}")
            return None
        if max_order_amount is not None and quantized_size > max_order_amount:
            lg.warning(f"{NEON_YELLOW}Size Calc ({symbol}): Calculated size {quantized_size} {size_unit_name} > Max Amount {max_order_amount}. Capping size to max.{RESET}")
            # Cap the size and re-quantize using floor (ROUND_DOWN)
            quantized_size = quantize_amount_util(
                max_order_amount, amount_step_size, amount_digits, lg, symbol, rounding=ROUND_DOWN
            )
            if quantized_size is None or quantized_size <= 0 or (min_order_amount is not None and quantized_size < min_order_amount):
                lg.error(f"Size Calc Error ({symbol}): Capped size {quantized_size} is zero or below min amount {min_order_amount}.")
                return None
            lg.info(f"Size capped to market max: {quantized_size} {size_unit_name}")

        # --- Validate Against Market Limits (Cost) & Margin ---
        order_value_quote = Decimal('NaN')
        margin_required_quote = Decimal('NaN')

        if is_contract:
             if is_inverse:
                 # Inverse value in BASE = Contracts * ContractSize
                 order_value_base = quantized_size * contract_size
                 # Approx Quote value for cost check:
                 order_value_quote = order_value_base * entry_price
                 # Margin required in BASE = Value in BASE / Leverage
                 margin_required_base = order_value_base / Decimal(leverage)
                 # Approx margin in quote terms for comparison with balance
                 margin_required_quote = margin_required_base * entry_price
             else:  # Linear Contract
                 # Linear value in quote = Contracts * ContractSize * EntryPrice
                 order_value_quote = quantized_size * contract_size * entry_price
                 # Margin required in QUOTE = Value in Quote / Leverage
                 margin_required_quote = order_value_quote / Decimal(leverage)
        else:  # Spot
             # Spot value in quote = Amount (Base) * EntryPrice
             order_value_quote = quantized_size * entry_price
             margin_required_quote = order_value_quote  # Margin is full cost for spot

        # Use the quote value for cost check
        cost_check_value = order_value_quote

        # Check min cost limit
        if min_order_cost is not None and cost_check_value < min_order_cost:
            lg.warning(f"{NEON_YELLOW}Size Calc ({symbol}): Order value ~{cost_check_value:.4f} {quote_currency} < Min Cost {min_order_cost}. Cannot place order.{RESET}")
            return None

        # Check margin requirement vs available balance (using quote margin)
        # Add a small buffer (e.g., 0.5% = 1.005) for fees/slippage
        buffer_factor = Decimal("1.005")  # 0.5% buffer
        required_margin_with_buffer = margin_required_quote * buffer_factor

        if required_margin_with_buffer > balance:
            lg.warning(f"{NEON_YELLOW}Size Calc ({symbol}): Required margin ~{margin_required_quote:.4f} {quote_currency} (Buffered: {required_margin_with_buffer:.4f}) > Available balance {balance:.4f}. Cannot place order.{RESET}")
            # Optional: Reduce size to fit available margin?
            # Current behavior: Reject the trade if margin is insufficient.
            return None

        # --- Success ---
        lg.info(f"Calculated position size for {symbol}: {quantized_size} {size_unit_name} (Value: ~{cost_check_value:.2f} {quote_currency}, Margin: ~{margin_required_quote:.2f} {quote_currency})")
        return quantized_size

    except (InvalidOperation, ValueError, TypeError, DivisionByZeroError) as e:
         lg.error(f"{NEON_RED}Error during position size calculation for {symbol}: {e}{RESET}", exc_info=True)
         return None
    except Exception as e:
        lg.error(f"{NEON_RED}Unexpected error calculating position size for {symbol}: {e}{RESET}", exc_info=True)
        return None


# --- CCXT Trading Action Wrappers ---

def fetch_positions_ccxt(exchange: ccxt.Exchange, symbol: str, logger: logging.Logger, market_info: Dict) -> Optional[Dict]:
    """Fetches the current non-zero position for a specific symbol using V5 API via safe_ccxt_call.
    Standardizes the returned position dictionary for easier internal use.

    Args:
        exchange: Initialized CCXT exchange object.
        symbol: The standard CCXT symbol (e.g., 'BTC/USDT:USDT').
        logger: Logger instance.
        market_info: Market information dictionary (must contain 'category' and 'id').

    Returns:
        A dictionary containing standardized position details if a non-zero position exists,
        otherwise None. Includes keys like 'symbol', 'side', 'contracts' (abs size as Decimal),
        'entryPrice' (Decimal), 'liqPrice' (Decimal, optional), 'unrealizedPnl' (Decimal, optional),
        'leverage' (float, optional), 'positionIdx' (int, from info), 'info' (raw position data),
        'market_info' (passed through). Returns None if no position or error occurs.
    """
    lg = logger
    category = market_info.get('category')
    market_id = market_info.get('id')  # Use exchange-specific ID

    # Only fetch positions for derivative markets
    if not category or category not in ['linear', 'inverse']:
        lg.debug(f"Skipping position check for non-derivative symbol: {symbol} (Category: {category})")
        return None
    if not market_id:
         lg.error(f"Cannot fetch positions for {symbol}: Market ID missing in market_info."); return None
    if not exchange.has.get('fetchPositions'):
        lg.error(f"Exchange {exchange.id} does not support fetchPositions()."); return None

    try:
        # Bybit V5 requires category and optionally symbol (market_id)
        # Fetching for a specific symbol is generally more efficient
        params = {'category': category, 'symbol': market_id}
        lg.debug(f"Fetching positions for {symbol} (MarketID: {market_id}) with params: {params}")

        # Use safe_ccxt_call. Pass standard CCXT symbol for potential CCXT client-side filtering,
        # and V5 params for the API call itself.
        all_positions_raw = safe_ccxt_call(exchange, 'fetch_positions', lg, symbols=[symbol], params=params)

        if not isinstance(all_positions_raw, list):
            lg.error(f"fetch_positions did not return a list for {symbol}. Type: {type(all_positions_raw)}. Response: {all_positions_raw}")
            return None

        # Filter the raw response to find the exact symbol and non-zero size
        for pos_raw in all_positions_raw:
            if not isinstance(pos_raw, dict):
                lg.warning(f"Received non-dict item in positions list: {pos_raw}")
                continue

            # --- Match symbol rigorously ---
            # Use market_id from info if available, fallback to CCXT symbol
            position_market_id = pos_raw.get('info', {}).get('symbol')
            position_ccxt_symbol = pos_raw.get('symbol')
            if position_market_id != market_id and position_ccxt_symbol != symbol:
                 lg.debug(f"Skipping position entry, symbol/market_id mismatch: Expected '{symbol}'/'{market_id}', got '{position_ccxt_symbol}'/'{position_market_id}'")
                 continue

            try:
                 # --- Get position size ---
                 # Standard CCXT field is 'contracts', Bybit V5 info field is 'size'. Prioritize info['size'].
                 pos_size_str = pos_raw.get('info', {}).get('size', pos_raw.get('contracts'))
                 if pos_size_str is None or str(pos_size_str).strip() == "":
                     lg.debug(f"Skipping position entry for {symbol}: Missing or empty size field. Data: {pos_raw.get('info', pos_raw)}")
                     continue

                 pos_size = Decimal(str(pos_size_str))

                 # --- Skip zero size positions ---
                 if pos_size.is_zero():
                     continue  # Not an active position

                 # --- Standardize the position dictionary ---
                 standardized_pos: Dict[str, Any] = {}
                 standardized_pos['symbol'] = symbol  # Use the requested symbol
                 standardized_pos['side'] = 'long' if pos_size > 0 else 'short'
                 standardized_pos['contracts'] = abs(pos_size)  # Store absolute size as Decimal

                 # Helper to safely convert string price/pnl to Decimal
                 def safe_decimal(value_str: Optional[Union[str, float, int]]) -> Optional[Decimal]:
                     if value_str is None or str(value_str).strip() == "": return None
                     try:
                         d = Decimal(str(value_str))
                         return d if d.is_finite() else None
                     except (InvalidOperation, TypeError): return None

                 # Entry price: Standard CCXT is 'entryPrice', Bybit V5 info is 'avgPrice'. Prioritize info['avgPrice'].
                 entry_price_str = pos_raw.get('info', {}).get('avgPrice', standardized_pos.get('entryPrice'))
                 standardized_pos['entryPrice'] = safe_decimal(entry_price_str)

                 # Liquidation price: Standard CCXT is 'liquidationPrice', Bybit V5 info is 'liqPrice'. Prioritize info['liqPrice'].
                 liq_price_str = pos_raw.get('info', {}).get('liqPrice', standardized_pos.get('liquidationPrice'))
                 standardized_pos['liqPrice'] = safe_decimal(liq_price_str)

                 # Unrealized PnL: Standard CCXT is 'unrealizedPnl', Bybit V5 info is 'unrealisedPnl'. Prioritize info.
                 pnl_str = pos_raw.get('info', {}).get('unrealisedPnl', standardized_pos.get('unrealizedPnl'))
                 standardized_pos['unrealizedPnl'] = safe_decimal(pnl_str)

                 # Leverage: Standard CCXT is 'leverage', Bybit V5 info also 'leverage'. Prioritize info. Store as float.
                 leverage_str = pos_raw.get('info', {}).get('leverage', standardized_pos.get('leverage'))
                 try: standardized_pos['leverage'] = float(leverage_str) if leverage_str else None
                 except (ValueError, TypeError): standardized_pos['leverage'] = None

                 # Position Index (Crucial for Hedge Mode): From Bybit V5 info field 'positionIdx'. Store as int.
                 pos_idx_str = pos_raw.get('info', {}).get('positionIdx')
                 try:
                     # Default to 0 (One-Way mode) if missing or invalid
                     standardized_pos['positionIdx'] = int(pos_idx_str) if pos_idx_str is not None else 0
                 except (ValueError, TypeError):
                     lg.warning(f"Invalid positionIdx '{pos_idx_str}' in position data for {symbol}. Defaulting to 0.")
                     standardized_pos['positionIdx'] = 0

                 # Include raw info and market info for downstream use
                 standardized_pos['info'] = pos_raw.get('info', {})  # Store the raw 'info' dictionary
                 standardized_pos['market_info'] = market_info  # Add market info for convenience

                 # --- Log Found Position ---
                 prec = market_info.get('price_precision_digits', 4)
                 entry_log = f"{standardized_pos['entryPrice']:.{prec}f}" if standardized_pos.get('entryPrice') else 'N/A'
                 liq_log = f"Liq={standardized_pos['liqPrice']:.{prec}f}" if standardized_pos.get('liqPrice') else ''
                 pnl_log = f"PnL={standardized_pos['unrealizedPnl']:.2f}" if standardized_pos.get('unrealizedPnl') else ''
                 lev_log = f"Lev={standardized_pos.get('leverage')}x" if standardized_pos.get('leverage') is not None else ''
                 idx_log = f"Idx={standardized_pos.get('positionIdx')}"

                 lg.info(f"Found active {standardized_pos['side']} position for {symbol}: Size={standardized_pos['contracts']}, Entry={entry_log}, {liq_log} {pnl_log} {lev_log} {idx_log}")
                 return standardized_pos  # Return the first non-zero matching position found

            except (InvalidOperation, ValueError, TypeError) as e:
                 lg.error(f"Could not parse position data for {symbol}: {e}. Raw data: {pos_raw}")
                 # Continue loop to check other potential entries in the list
            except Exception as e:
                 lg.error(f"Unexpected error processing position entry for {symbol}: {e}. Raw data: {pos_raw}", exc_info=True)
                 # Continue loop

        # If loop completes without returning a position
        lg.debug(f"No active non-zero position found for {symbol}.")
        return None

    except Exception as e:
        # Catch errors from safe_ccxt_call (e.g., retries exhausted) or other issues
        lg.error(f"{NEON_RED}Error fetching/processing positions for {symbol}: {e}{RESET}", exc_info=False)
        lg.debug(f"Traceback for position fetch error:", exc_info=True)
        return None


def set_leverage_ccxt(exchange: ccxt.Exchange, symbol: str, leverage: int, logger: logging.Logger, market_info: Dict) -> bool:
    """Sets leverage for a symbol using Bybit V5 API via safe_ccxt_call.
    Handles the "leverage not modified" response (code 110043) as success.

    Args:
        exchange: Initialized CCXT exchange object.
        symbol: Standard CCXT symbol.
        leverage: Target leverage (integer > 0).
        logger: Logger instance.
        market_info: Market information dictionary (must contain 'category' and 'id').

    Returns:
        True if leverage was set successfully (or was already correct), False otherwise.
    """
    lg = logger
    category = market_info.get('category')
    market_id = market_info.get('id')  # Use exchange-specific ID

    # Leverage only applicable to derivatives
    if not category or category not in ['linear', 'inverse']:
        lg.debug(f"Skipping leverage setting for non-derivative: {symbol}")
        return True  # Consider success as no action needed
    if not market_id:
         lg.error(f"Cannot set leverage for {symbol}: Market ID missing."); return False
    if not exchange.has.get('setLeverage'):
        lg.error(f"Exchange {exchange.id} does not support setLeverage()."); return False
    if not isinstance(leverage, int) or leverage <= 0:
        lg.error(f"Invalid leverage ({leverage}) for {symbol}. Must be a positive integer."); return False

    try:
        # Bybit V5 requires category, symbol, and separate buy/sell leverage values.
        # We set both to the same value based on the config.
        params = {
            'category': category,
            'symbol': market_id,
            'buyLeverage': str(leverage),  # API expects string values
            'sellLeverage': str(leverage)
        }
        lg.info(f"Attempting to set leverage for {symbol} (MarketID: {market_id}) to {leverage}x...")
        lg.debug(f"Leverage Params: {params}")

        # CCXT's set_leverage should map to the correct V5 endpoint /v5/position/set-leverage
        # Pass leverage as float (required by CCXT type hint), symbol, and V5 params.
        # safe_ccxt_call handles "leverage not modified" (110043) by returning {} treated as success.
        result = safe_ccxt_call(exchange, 'set_leverage', lg, leverage=float(leverage), symbol=symbol, params=params)

        # Check result: Success could be a dict with info, or empty dict for 'not modified'
        if result is not None and isinstance(result, dict):
            # Check Bybit's retCode in the info field if available
            ret_code = result.get('info', {}).get('retCode')
            # Treat retCode 0 (Success) or empty dict (110043 handled by safe_ccxt_call) as success
            if ret_code == 0 or result == {}:
                 lg.info(f"{NEON_GREEN}Leverage set successfully (or already correct) for {symbol} to {leverage}x.{RESET}")
                 return True
            else:
                 # This case means safe_ccxt_call might not have caught a specific error code
                 ret_msg = result.get('info', {}).get('retMsg', 'Unknown Error')
                 lg.error(f"{NEON_RED}set_leverage call returned non-zero retCode {ret_code}: '{ret_msg}' for {symbol}.{RESET}")
                 return False
        else:
            # This case should ideally not happen if safe_ccxt_call raises or returns {} on 110043
            lg.error(f"{NEON_RED}set_leverage call returned unexpected result type for {symbol}: {type(result)}. Result: {result}{RESET}")
            return False

    except ccxt.ExchangeError as e:
         # Non-retryable errors should have been raised by safe_ccxt_call
         # Logging the error again here might be redundant but ensures visibility
         lg.error(f"{NEON_RED}Failed to set leverage for {symbol} to {leverage}x due to ExchangeError: {e}{RESET}", exc_info=False)
         return False
    except Exception as e:
        # Catch unexpected errors during the call itself
        lg.error(f"{NEON_RED}Unexpected error setting leverage for {symbol} to {leverage}x: {e}{RESET}", exc_info=True)
        return False


def create_order_ccxt(
    exchange: ccxt.Exchange, symbol: str, order_type: str, side: str,
    amount: Decimal, price: Optional[Decimal] = None, params: Optional[Dict] = None,
    logger: Optional[logging.Logger] = None, market_info: Optional[Dict] = None
) -> Optional[Dict]:
    """Creates an order using safe_ccxt_call, handling V5 parameters and Decimal conversion.
    Includes parameter validation and detailed logging.

    Args:
        exchange: Initialized CCXT exchange object.
        symbol: Standard CCXT symbol.
        order_type: 'market' or 'limit'.
        side: 'buy' or 'sell'.
        amount: Order quantity (Decimal, must be positive).
        price: Order price for limit orders (Decimal, must be positive if provided).
        params: Additional parameters for the CCXT create_order call
                (e.g., {'reduceOnly': True, 'positionIdx': 0/1/2}).
                Crucially includes 'category' for V5.
        logger: Logger instance.
        market_info: Market information dictionary (required for validation/logging).

    Returns:
        The CCXT order dictionary if the API call was successful and Bybit confirmed
        with retCode=0. Returns None otherwise.
    """
    lg = logger or setup_logger('main')  # Use provided logger or default main logger
    if not market_info:
        lg.error(f"Market info required for create_order ({symbol}) but not provided."); return None

    # --- Input Validation ---
    category = market_info.get('category')
    if not category:
        lg.error(f"Unknown category for {symbol}. Cannot place order."); return None
    if not isinstance(amount, Decimal) or not amount.is_finite() or amount <= 0:
        lg.error(f"Order amount must be a positive Decimal ({symbol}, Amount: {amount})"); return None

    order_type_lower = order_type.lower(); side_lower = side.lower()
    if order_type_lower not in ['market', 'limit']:
        lg.error(f"Invalid order type '{order_type}'. Must be 'market' or 'limit'."); return None
    if side_lower not in ['buy', 'sell']:
        lg.error(f"Invalid order side '{side}'. Must be 'buy' or 'sell'."); return None

    price_float: Optional[float] = None
    price_str: Optional[str] = None
    price_digits = market_info.get('price_precision_digits', 8)
    amount_digits = market_info.get('amount_precision_digits', 8)

    if order_type_lower == 'limit':
        if not isinstance(price, Decimal) or not price.is_finite() or price <= 0:
            lg.error(f"Valid positive Decimal price required for limit order ({symbol}, Price: {price})"); return None
        # Convert valid Decimal price to float for CCXT method signature
        price_float = float(price)
        price_str = f"{price:.{price_digits}f}"  # Formatted string for logging
    else:  # Market order
        price = None  # Ensure price is None for CCXT market order call

    # Format amount string for logging
    amount_str = f"{amount:.{amount_digits}f}"

    # --- Prepare V5 Parameters ---
    # Base parameters required by Bybit V5 createOrder
    # Category is crucial for V5 routing
    order_params: Dict[str, Any] = {'category': category}
    # Merge external params (like reduceOnly, positionIdx, sl/tp) provided by caller
    # Caller is responsible for providing correct `positionIdx` based on position_mode config
    if params:
        order_params.update(params)
        # Ensure positionIdx is int if provided
        if 'positionIdx' in order_params:
             try: order_params['positionIdx'] = int(order_params['positionIdx'])
             except (ValueError, TypeError):
                 lg.error(f"Invalid positionIdx type in params: {order_params['positionIdx']}. Cannot create order.")
                 return None
        # Convert SL/TP prices in params to strings if they are Decimals
        for key in ['stopLoss', 'takeProfit']:
             if key in order_params and isinstance(order_params[key], Decimal):
                  try:
                      val = order_params[key]
                      if val.is_finite() and val > 0:
                           order_params[key] = f"{val:.{price_digits}f}"
                      else:
                           lg.warning(f"Invalid Decimal value {val} for param '{key}'. Removing from params.")
                           del order_params[key]
                  except Exception as fmt_err:
                       lg.error(f"Error formatting Decimal param '{key}': {fmt_err}. Removing.")
                       del order_params[key]

    # --- Convert Amount Decimal to Float for CCXT call ---
    try:
        # CCXT methods typically expect float for amount
        amount_float = float(amount)
    except ValueError as e:
        lg.error(f"Error converting amount '{amount}' to float ({symbol}): {e}"); return None

    # --- Place Order via safe_ccxt_call ---
    try:
        log_price_part = f'@ {price_str}' if price_str else 'at Market'
        log_param_part = f" Params: {order_params}"  # Log combined params
        lg.info(f"Attempting to create {side.upper()} {order_type.upper()} order: {amount_str} {symbol} {log_price_part}{log_param_part}")
        # Debug log showing exact values passed to CCXT
        lg.debug(f"CCXT create_order Args: symbol='{symbol}', type='{order_type}', side='{side}', amount={amount_float}, price={price_float}, params={order_params}")

        order_result = safe_ccxt_call(
            exchange, 'create_order', lg,
            symbol=symbol, type=order_type, side=side,
            amount=amount_float, price=price_float, params=order_params
        )

        # --- Process Result ---
        # Check if the call succeeded and returned a valid order structure with an ID
        if order_result and isinstance(order_result, dict) and order_result.get('id'):
            order_id = order_result['id']
            # Check Bybit's V5 response code within the 'info' field for confirmation
            # retCode=0 indicates success on Bybit's side
            ret_code = order_result.get('info', {}).get('retCode')
            ret_msg = order_result.get('info', {}).get('retMsg', 'Unknown Status')

            if ret_code == 0:
                 lg.info(f"{NEON_GREEN}Successfully created {side.upper()} {order_type.upper()} order for {symbol}. Order ID: {order_id}{RESET}")
                 lg.debug(f"Order Result Info: {order_result.get('info')}")
                 # Return the full CCXT order dict on success
                 return order_result
            else:
                 # Order ID might be generated even if rejected (e.g., insufficient balance)
                 lg.error(f"{NEON_RED}Order placement potentially failed or rejected by Bybit ({symbol}). Order ID: {order_id}, Code={ret_code}, Msg='{ret_msg}'.{RESET}")
                 lg.debug(f"Failed Order Result Info: {order_result.get('info')}")
                 # Provide hints for common rejection codes (already handled in safe_ccxt_call, but good here too)
                 if ret_code == 110007: lg.warning(f"Hint: Order rejected due to insufficient balance (Code {ret_code}).")
                 elif ret_code == 110017: lg.warning(f"Hint: Order rejected due to price/qty precision error (Code {ret_code}). Check market limits.")
                 elif ret_code == 110045 or ret_code == 170007: lg.warning(f"Hint: Order rejected due to risk limit exceeded (Code {ret_code}).")
                 elif ret_code == 110025: lg.warning(f"Hint: Order rejected due to positionIdx mismatch (Code {ret_code}). Ensure Hedge Mode params are correct.")
                 # Treat non-zero retCode as failure
                 return None
        elif order_result:
             # Call succeeded but response format is unexpected (e.g., missing ID)
             lg.error(f"Order API call successful but response missing ID or invalid format ({symbol}). Response: {order_result}")
             return None
        else:  # safe_ccxt_call returned None or raised an exception handled within it
             lg.error(f"Order API call failed or returned None ({symbol}) after retries.")
             return None

    except Exception as e:
        # Catch any unexpected error during the process
        lg.error(f"{NEON_RED}Unexpected error creating order ({symbol}): {e}{RESET}", exc_info=True)
        return None


def set_protection_ccxt(
    exchange: ccxt.Exchange, symbol: str,
    stop_loss_price: Optional[Decimal] = None, take_profit_price: Optional[Decimal] = None,
    trailing_stop_price: Optional[Decimal] = None,  # TSL *distance/offset* value (e.g., 100 for $100 behind)
    trailing_active_price: Optional[Decimal] = None,  # TSL *activation price* trigger
    position_idx: int = 0,  # Required for Hedge mode (0=OneWay, 1=BuyHedge, 2=SellHedge)
    logger: Optional[logging.Logger] = None, market_info: Optional[Dict] = None
) -> bool:
    """Sets Stop Loss (SL), Take Profit (TP), and/or Trailing Stop Loss (TSL) for a position
    using Bybit V5 `POST /v5/position/trading-stop` via `private_post_position_trading_stop`.

    Args:
        exchange: Initialized CCXT exchange object.
        symbol: Standard CCXT symbol.
        stop_loss_price: Price for the stop loss order (Decimal). Set to 0 or None to remove/not set.
        take_profit_price: Price for the take profit order (Decimal). Set to 0 or None to remove/not set.
        trailing_stop_price: The trailing stop *distance* value (Decimal, positive). Set to 0 or None to remove/not set.
                             Bybit interprets this as the price distance (e.g., 10 for $10 below high for long).
        trailing_active_price: The price at which the TSL should *activate* (Decimal).
                               Set to 0 or None for immediate activation if trailing_stop_price is set and non-zero.
        position_idx: Position index (0 for One-Way, 1 for Buy Hedge, 2 for Sell Hedge). Must match position.
        logger: Logger instance.
        market_info: Market information dictionary (required for validation/formatting).

    Returns:
        True if the protection was set successfully (API call returns retCode=0), False otherwise.
    """
    lg = logger or setup_logger('main')
    if not market_info:
        lg.error(f"Market info required for set_protection ({symbol}) but not provided."); return False

    category = market_info.get('category')
    market_id = market_info.get('id')  # Use exchange-specific ID for API calls
    price_digits = market_info.get('price_precision_digits', 8)

    # Protection setting only applicable to derivatives
    if not category or category not in ['linear', 'inverse']:
        lg.debug(f"Cannot set protection for non-derivative {symbol}. Category: {category}"); return False
    if not market_id:
         lg.error(f"Cannot set protection for {symbol}: Market ID missing."); return False

    # --- Prepare V5 Parameters ---
    params: Dict[str, Any] = {
        'category': category,
        'symbol': market_id,
        'positionIdx': position_idx,  # Crucial for Hedge Mode, 0 for One-Way
        # --- Optional Parameters (Defaults are usually sufficient) ---
        # 'tpslMode': 'Full', # Apply TP/SL to the entire position ('Partial' also available)
        # 'slTriggerBy': 'LastPrice', # MarkPrice, IndexPrice
        # 'tpTriggerBy': 'LastPrice', # MarkPrice, IndexPrice
        # 'slOrderType': 'Market', # Default is Market, 'Limit' also possible
        # 'tpOrderType': 'Market', # Default is Market, 'Limit' also possible
    }

    # --- Format Price/Value Strings for API ---
    # Bybit API expects prices/distances as strings. "0" is used to cancel/remove existing protection.
    def format_value(value: Optional[Decimal], name: str, is_distance: bool = False) -> str:
        """Formats Decimal to string for API, validating positivity. Returns '0' if invalid/None."""
        if value is not None and isinstance(value, Decimal) and value.is_finite():
            if value > 0:
                # Format based on price precision. TSL distance might need different formatting
                # if API is strict, but using price precision is usually safe.
                return f"{value:.{price_digits}f}"
            elif value == 0:
                return "0"  # Explicitly setting to zero means cancel
            else:  # Negative value is invalid
                 lg.warning(f"Invalid negative value '{value}' provided for '{name}' in set_protection. Using '0' (cancel).")
                 return "0"
        else:  # None or non-finite Decimal
            return "0"  # Treat as "do not set" or "cancel"

    sl_str = format_value(stop_loss_price, "stopLoss")
    tp_str = format_value(take_profit_price, "takeProfit")
    tsl_dist_str = format_value(trailing_stop_price, "trailingStop", is_distance=True)
    tsl_act_str = format_value(trailing_active_price, "activePrice")

    # Add to params only if a value is being set (is not "0")
    # Setting to "0" explicitly cancels that specific protection type.
    action_taken = False
    # Add if value > 0 OR if user explicitly passed Decimal(0) to cancel
    if sl_str != "0" or (stop_loss_price is not None and stop_loss_price == 0):
        params['stopLoss'] = sl_str; action_taken = True
    if tp_str != "0" or (take_profit_price is not None and take_profit_price == 0):
        params['takeProfit'] = tp_str; action_taken = True

    # Trailing Stop: 'trailingStop' is the distance. 'activePrice' is optional trigger.
    if tsl_dist_str != "0" or (trailing_stop_price is not None and trailing_stop_price == 0):
        params['trailingStop'] = tsl_dist_str
        action_taken = True
        # Only include activePrice if TSL distance is non-zero.
        # If distance is "0" (cancelling TSL), activePrice is irrelevant/ignored.
        if tsl_dist_str != "0":
            # If activation price is provided and valid (>0), use it. Otherwise, use "0" for immediate activation.
            params['activePrice'] = tsl_act_str if tsl_act_str != "0" else "0"
        elif 'activePrice' in params: # Remove activePrice if cancelling TSL
            del params['activePrice']

    # --- Log Intention ---
    log_parts = []
    if 'stopLoss' in params: log_parts.append(f"SL={params['stopLoss']}")
    if 'takeProfit' in params: log_parts.append(f"TP={params['takeProfit']}")
    if 'trailingStop' in params:
        tsl_log = f"TSL Dist={params['trailingStop']}"
        # Log activation price only if TSL distance is being set (>0)
        if params['trailingStop'] != "0":
            if params.get('activePrice', "0") != "0":
                 tsl_log += f", ActP={params['activePrice']}"
            else:
                 tsl_log += ", Act=Immediate"  # Activation price 0 means immediate
        log_parts.append(tsl_log)

    if not action_taken:
        lg.info(f"No valid protection levels provided or changes needed for set_protection ({symbol}). No API call made.")
        # Consider it success if no action was needed (e.g., called with all Nones)
        return True

    # --- Make API Call ---
    try:
        lg.info(f"Attempting to set protection for {symbol} (Idx: {position_idx}): {', '.join(log_parts)}")
        lg.debug(f"Protection Params: {params}")

        # Explicitly use the private POST method mapped in exchange options during initialization
        # This ensures we hit the correct V5 endpoint: /v5/position/trading-stop
        method_to_call = 'private_post_position_trading_stop'
        if not hasattr(exchange, method_to_call):
            # This check should ideally never fail if initialization mapped correctly.
            lg.error(f"Method '{method_to_call}' not found on exchange object. Check CCXT mapping in initialize_exchange.")
            return False

        # Use safe_ccxt_call with the specific method name and prepared params
        result = safe_ccxt_call(exchange, method_to_call, lg, params=params)

        # --- Process Result ---
        # Check if the call succeeded and Bybit confirmed with retCode=0
        if result and isinstance(result, dict):
            ret_code = result.get('retCode')
            ret_msg = result.get('retMsg', 'Unknown Status')

            if ret_code == 0:
                lg.info(f"{NEON_GREEN}Successfully set protection for {symbol} (Idx: {position_idx}).{RESET}")
                lg.debug(f"Protection Result: {result}")
                return True
            else:
                # Log specific Bybit error
                lg.error(f"{NEON_RED}Failed to set protection for {symbol} (Idx: {position_idx}). Code={ret_code}, Msg='{ret_msg}'.{RESET}")
                lg.debug(f"Failed Protection Result: {result}")
                # Provide hints for common errors
                if ret_code == 110041 or ret_code == 170140: lg.warning(f"Hint: Failed because no active position found (Code {ret_code}).")
                elif ret_code == 110042 or ret_code == 170131: lg.warning(f"Hint: Failed because TP/SL price is invalid (Code {ret_code}). Check distance from entry/liquidation.")
                elif ret_code == 170132: lg.warning(f"Hint: Failed because TP/SL would trigger immediate liquidation (Code {ret_code}).")
                elif ret_code == 110025: lg.warning(f"Hint: Failed due to positionIdx mismatch (Code {ret_code}). Ensure Hedge Mode params are correct.")
                return False
        else:
            # safe_ccxt_call returned None or unexpected type
            lg.error(f"Protection API call failed or returned unexpected result type for {symbol}. Result: {result}")
            return False

    except Exception as e:
        # Catch any unexpected error during the process
        lg.error(f"{NEON_RED}Unexpected error setting protection ({symbol}): {e}{RESET}", exc_info=True)
        return False


# --- Main Bot Logic ---
if __name__ == "__main__":
    # --- Argument Parsing ---
    parser = argparse.ArgumentParser(description="Enhanced Bybit Trading Bot")
    parser.add_argument("--debug", action="store_true", help="Enable debug logging to console")
    parser.add_argument("--config", type=str, default=CONFIG_FILE, help=f"Path to configuration file (default: {CONFIG_FILE})")
    args = parser.parse_args()

    # --- Set Console Log Level ---
    console_log_level = logging.DEBUG if args.debug else logging.INFO
    if args.debug:
        print(f"{NEON_YELLOW}Debug mode enabled. Console log level set to DEBUG.{RESET}")

    # --- Setup Main Logger ---
    main_logger = setup_logger("main")
    main_logger.info(f"--- Enhanced Trading Bot v{BOT_VERSION} Starting ---")
    main_logger.info(f"Using Python {sys.version}")
    main_logger.info(f"Using CCXT {ccxt.__version__}")
    main_logger.info(f"Using Timezone: {TZ_NAME}")

    # --- Load Configuration ---
    config_path = args.config
    main_logger.info(f"Loading configuration from: {config_path}")
    config = load_config(config_path, main_logger)
    if config is None:
        main_logger.critical("Failed to load or validate configuration. Exiting.")
        sys.exit(1)
    LOOP_DELAY_SECONDS = config.get("loop_delay", DEFAULT_LOOP_DELAY_SECONDS)
    ENABLE_TRADING = config.get("enable_trading", False)

    # --- Initialize Exchange ---
    exchange = initialize_exchange(config, main_logger)
    if exchange is None:
        main_logger.critical("Failed to initialize exchange. Exiting.")
        sys.exit(1)

    # --- Load State ---
    # Ensure bot_state is initialized as a dictionary, especially for symbol data
    bot_state = load_state(STATE_FILE, main_logger)
    if not isinstance(bot_state, dict): bot_state = {} # Ensure it's a dict
    for sym in config.get("symbols", []):
        if sym not in bot_state:
            # Initialize symbol state with defaults if missing
            bot_state[sym] = {
                'break_even_triggered': False,
                'last_entry_price': None,
                'position_size': None,
                'position_side': None,
                'initial_sl_price': None,
                'initial_tp_price': None
            }

    # --- Main Loop ---
    try:
        main_logger.info("Starting main trading loop...")
        while True:
            start_time = time.monotonic()
            main_logger.info("--- New Bot Cycle ---")

            # --- Trading Logic per Symbol ---
            for symbol in config.get("symbols", []):
                symbol_logger = setup_logger(symbol, is_symbol_logger=True)
                market_info = get_market_info(exchange, symbol, symbol_logger)
                if not market_info:
                    symbol_logger.warning(f"Skipping {symbol} due to missing market info")
                    continue

                # --- Fetch Data Asynchronously ---
                async def fetch_symbol_data():
                    kline_task = fetch_kline_data(exchange, symbol, "1h", symbol_logger)
                    price_task = fetch_price_data(exchange, symbol, symbol_logger)
                    orderbook_task = fetch_orderbook(exchange, symbol, symbol_logger)
                    kline, price, orderbook = await asyncio.gather(kline_task, price_task, orderbook_task)
                    return kline, price, orderbook

                try:
                    kline_data, price_data, orderbook = asyncio.run(fetch_symbol_data())
                except Exception as e:
                    symbol_logger.error(f"Error fetching data for {symbol}: {e}")
                    continue

                # --- Analyze Data ---
                analyzer = TradingAnalyzer(config, symbol, symbol_logger)
                signal = analyzer.generate_trading_signal(kline_data, price_data, orderbook)
                if not signal:
                    symbol_logger.info(f"No trading signal for {symbol}")
                    continue

                # --- Check Position ---
                position = get_position(exchange, symbol, symbol_logger)
                symbol_logger.debug(f"Current position for {symbol}: {position}")

                # --- Evaluate Entry/Exit ---
                if signal["action"] == "buy" and position["size"] == 0:
                    order = {
                        "type": "market",
                        "side": "buy",
                        "amount": signal["amount"],
                        "symbol": symbol
                    }
                    if place_order(exchange, symbol, order, symbol_logger):
                        symbol_logger.info(f"Placed buy order for {symbol}")
                        bot_state["positions"][symbol] = {"size": signal["amount"], "side": "long"}
                elif signal["action"] == "sell" and position["size"] > 0:
                    order = {
                        "type": "market",
                        "side": "sell",
                        "amount": position["size"],
                        "symbol": symbol
                    }
                    if place_order(exchange, symbol, order, symbol_logger):
                        symbol_logger.info(f"Placed sell order for {symbol}")
                        bot_state["positions"][symbol] = {"size": 0, "side": None}

                # --- Update State ---
                bot_state["orders"][symbol] = signal
                symbol_logger.debug(f"Updated state for {symbol}: {bot_state}")

            # --- End of Cycle ---
            save_state(STATE_FILE, bot_state, main_logger)

            # --- Calculate Sleep Time ---
            cycle_duration = time.monotonic() - start_time
            sleep_time = max(0, LOOP_DELAY_SECONDS - cycle_duration)
            main_logger.info(f"Cycle finished in {cycle_duration:.2f}s. Sleeping for {sleep_time:.2f}s...")
            time.sleep(sleep_time)

    except KeyboardInterrupt:
        main_logger.info("KeyboardInterrupt received. Shutting down gracefully...")
    except Exception as e:
        main_logger.critical(f"Unexpected error in main loop: {e}", exc_info=True)
        sys.exit(1)
    finally:
        main_logger.info("Saving final state and closing exchange...")
        save_state(STATE_FILE, bot_state, main_logger)
        exchange.close()```python
The log snippet you provided shows a critical issue with the trading bot for the DOT/USDT:USDT pair, specifically when attempting to set a break-even (BE) stop-loss (SL) for an active long position. Below is a detailed analysis of the situation, the error, and actionable steps to resolve it.

---

### Key Observations from the Log:
1. **Position Status**:
   - **Active Long Position**: The bot is managing a long position of 3.2 contracts, entered at 4.0616, with 20x leverage and a liquidation price of 3.8992.
   - **Unrealized PnL**: The position has an unrealized profit of 0.0611, indicating a favorable price movement.
   - **No SL/TP**: The position initially has no stop-loss (SL) or take-profit (TP) set, and the trailing stop-loss (TSL) is inactive.

2. **Break-Even Trigger**:
   - At 09:39:34, the bot detects that the profit target for break-even has been reached.
   - It attempts to set a break-even SL at 4.0618 (slightly above the entry price of 4.0616, likely to cover fees or ensure zero loss).
   - The bot logs a warning: `*** Moving Stop Loss to Break-Even for DOT/USDT:USDT at 4.0618 ***`.

3. **Error Encountered**:
   - The bot fails to set the BE SL due to an `AttributeError`:
     ```
     AttributeError: 'bybit' object has no attribute 'privatePostV5PositionSetTradingStop'
     ```
   - This error occurs in the `_set_position_protection` function (line 3072 of `whale1.0.py`), where the bot attempts to call `exchange.privatePostV5PositionSetTradingStop(params)` to set the SL.
   - The error indicates that the Bybit API client (likely from the `ccxt` library or a custom implementation) does not have the `privatePostV5PositionSetTradingStop` method, suggesting an API mismatch or configuration issue.

4. **Bot Configuration**:
   - Trailing Stop, Break-Even, and MA Cross Exit are enabled.
   - The signal at this time is HOLD, allowing the existing long position to remain open.

---

### Analysis of the Error:
The `AttributeError` suggests that the bot is trying to use a method (`privatePostV5PositionSetTradingStop`) that does not exist in the Bybit exchange object. This could be due to one of the following reasons:

1. **API Version Mismatch**:
   - The bot is coded to use Bybit's V5 API, but the `ccxt` library or custom Bybit client may not support this endpoint or uses a different method name.
   - Bybit's V5 API is relatively new, and the `ccxt` library might not have fully implemented all V5 endpoints, or the bot is using an outdated version of `ccxt`.

2. **Incorrect Method Name**:
   - The method `privatePostV5PositionSetTradingStop` might be incorrectly named in the code. Bybits V5 API uses specific endpoints for setting trading stops (e.g., `/v5/position/trading-stop`), and the correct method in `ccxt` could be different (e.g., `private_post_v5_position_trading_stop`).

3. **Library Misconfiguration**:
   - The `ccxt` library or custom Bybit client might not be properly initialized to support V5 API endpoints, or the bot is using an older Bybit API version (e.g., V2 or unified API) that lacks this method.

4. **Custom Implementation Issue**:
   - If the bot uses a custom Bybit client (not `ccxt`), the `privatePostV5PositionSetTradingStop` method might not have been implemented or is incorrectly referenced.

---

### Steps to Resolve the Issue:
Heres a step-by-step approach to diagnose and fix the error:

1. **Verify the Bybit API Method**:
   - Check Bybits V5 API documentation (https://bybit-exchange.github.io/docs/v5/position/trading-stop) to confirm the correct endpoint for setting a trading stop (`/v5/position/trading-stop`).
   - In `ccxt`, the method for this endpoint is typically formatted as `private_post_v5_position_trading_stop` (note the underscore instead of camel case). Update the code to use the correct method:
     ```python
     response = exchange.private_post_v5_position_trading_stop(params)
     ```
   - If using a custom Bybit client, ensure it implements this endpoint correctly.

2. **Update the `ccxt` Library**:
   - Ensure youre using the latest version of the `ccxt` library, as older versions may lack V5 API support.
   - Update `ccxt` via pip:
     ```bash
     pip install ccxt --upgrade
     ```
   - After updating, test the `private_post_v5_position_trading_stop` method in a sandbox environment to confirm it works.

3. **Check API Initialization**:
   - Verify that the Bybit exchange object is initialized with V5 API support. In `ccxt`, you may need to specify the API version explicitly:
     ```python
     import ccxt
     exchange = ccxt.bybit({
         'apiKey': 'your_api_key',
         'secret': 'your_api_secret',
         'enableRateLimit': True,
         'options': {
             'defaultType': 'swap',  # For perpetual contracts
             'apiVersion': 'v5',     # Explicitly use V5 API
         }
     })
     ```
   - Ensure the `params` dictionary passed to the method includes required fields (e.g., `symbol`, `side`, `stopLossPrice`):
     ```python
     params = {
         'category': 'linear',
         'symbol': 'DOTUSDT',
         'side': 'Buy',
         'stopLossPrice': 4.0618,
         'positionIdx': 0,  # 0 for one-way mode
     }
     ```

4. **Fallback to Alternative Method**:
   - If the V5 API endpoint is unavailable, consider using Bybits unified API or an older endpoint (e.g., `/private/linear/position/trading-stop` for V2 API) as a temporary workaround.
   - Example for V2 API in `ccxt`:
     ```python
     response = exchange.private_linear_post_position_trading_stop({
         'symbol': 'DOTUSDT',
         'side': 'Buy',
         'stop_loss': 4.0618,
     })
     ```
   - Update the code to handle both V5 and V2 APIs with a try-catch block:
     ```python
     try:
         response = exchange.private_post_v5_position_trading_stop(params)
     except AttributeError:
         logging.warning("V5 API not supported, falling back to V2 API")
         response = exchange.private_linear_post_position_trading_stop({
             'symbol': params['symbol'],
             'side': 'Buy',
             'stop_loss': params['stopLossPrice'],
         })
     ```

5. **Debug the Code**:
   - Add logging to inspect the `exchange` object and available methods before calling the endpoint:
     ```python
     logging.debug(f"Available exchange methods: {dir(exchange)}")
     ```
   - Check the `params` dictionary to ensure it contains the correct values:
     ```python
     logging.debug(f"Protection params: {params}")
     ```

6. **Test in a Sandbox**:
   - Use Bybits testnet (https://testnet.bybit.com) to test the SL-setting functionality without risking real funds.
   - Replicate the scenario (open a long position, trigger BE, set SL) and verify the API call works.

7. **Handle the Error Gracefully**:
   - Modify the `_set_position_protection` function to handle the error and prevent the bot from crashing:
     ```python
     def _set_position_protection(self, exchange, symbol, position_idx, sl_price, tsl_distance=0, tsl_activation=0):
         params = {
             'category': 'linear',
             'symbol': symbol,
             'side': 'Buy',
             'stopLossPrice': sl_price,
             'positionIdx': position_idx,
         }
         try:
             response = exchange.private_post_v5_position_trading_stop(params)
             logging.info(f"Successfully set SL for {symbol}: {response}")
             return response
         except AttributeError as e:
             logging.error(f"Failed to set SL for {symbol}: {str(e)}")
             # Fallback or alternative action (e.g., notify user, retry with V2 API)
             return None
         except Exception as e:
             logging.error(f"Unexpected error setting SL for {symbol}: {str(e)}")
             return None
     ```

8. **Monitor and Log**:
   - After fixing the issue, add logging to confirm successful SL placement:
     ```python
     if response:
         logging.info(f"Break-Even SL set for {symbol} at {sl_price}")
     else:
         logging.warning(f"Failed to set Break-Even SL for {symbol}")
     ```

---

### Additional Recommendations:
- **Set a Default SL**: Since the position lacked an SL initially, consider implementing a default SL (e.g., 2 * ATR below entry) when opening a position to mitigate risk, especially with 20x leverage.
- **Review BE Logic**: The BE SL was set at 4.0618, slightly above the entry (4.0616). Ensure this accounts for trading fees to avoid a loss if the SL is hit.
- **API Documentation**: Regularly check Bybits API changelog (https://bybit-exchange.github.io/docs/v5/changelog) for updates to endpoints or requirements.
- **Error Notifications**: Implement a notification system (e.g., email, Telegram) to alert you when critical errors like this occur, ensuring timely intervention.

---

### Summary:
The bot failed to set a break-even stop-loss at 4.0618 for the DOT/USDT:USDT long position due to an `AttributeError` caused by a missing or incorrect API method (`privatePostV5PositionSetTradingStop`). The issue likely stems from an outdated `ccxt` library, incorrect method name, or API version mismatch. To resolve it, verify the correct API method, update `ccxt`, ensure proper API initialization, and add error handling. Testing in a sandbox and implementing a fallback method will help prevent recurrence.

If you need help with specific code changes, testing the fix, or further debugging (e.g., inspecting the `ccxt` version or `params`), please provide additional details (e.g., the bots codebase snippet, `ccxt` version, or Bybit API setup), and I can tailor the solution further!
# livebot7.1.py
# Enhanced version focusing on stop-loss/take-profit mechanisms,
# including break-even logic and MA cross exit condition.

import hashlib
import hmac
import json
import logging
import math
import os
import time
from datetime import datetime
from decimal import Decimal, ROUND_DOWN, ROUND_UP, getcontext
from logging.handlers import RotatingFileHandler
from typing import Any, Dict, Optional, Tuple, List, Union

import ccxt
import numpy as np
import pandas as pd
import pandas_ta as ta  # Import pandas_ta
import requests
from colorama import Fore, Style, init
from dotenv import load_dotenv
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
from zoneinfo import ZoneInfo

# Initialize colorama and set precision
getcontext().prec = 28  # Increased precision for financial calculations
init(autoreset=True)
load_dotenv()

# Neon Color Scheme
NEON_GREEN = Fore.LIGHTGREEN_EX
NEON_BLUE = Fore.CYAN
NEON_PURPLE = Fore.MAGENTA
NEON_YELLOW = Fore.YELLOW
NEON_RED = Fore.LIGHTRED_EX
NEON_CYAN = Fore.CYAN
RESET = Style.RESET_ALL

# --- Constants ---
API_KEY = os.getenv("BYBIT_API_KEY")
API_SECRET = os.getenv("BYBIT_API_SECRET")
if not API_KEY or not API_SECRET:
    raise ValueError("BYBIT_API_KEY and BYBIT_API_SECRET must be set in .env")

CONFIG_FILE = "config.json"
LOG_DIRECTORY = "bot_logs"
# Timezone for logging and display (adjust as needed)
TIMEZONE = ZoneInfo("America/Chicago") # e.g., "America/New_York", "Europe/London", "Asia/Tokyo"
MAX_API_RETRIES = 3 # Max retries for recoverable API errors
RETRY_DELAY_SECONDS = 5 # Delay between retries
VALID_INTERVALS = ["1", "3", "5", "15", "30", "60", "120", "240", "D", "W", "M"] # Intervals supported by the bot's logic
CCXT_INTERVAL_MAP = { # Map our intervals to ccxt's expected format
    "1": "1m", "3": "3m", "5": "5m", "15": "15m", "30": "30m",
    "60": "1h", "120": "2h", "240": "4h", "D": "1d", "W": "1w", "M": "1M"
}
RETRY_ERROR_CODES = [429, 500, 502, 503, 504] # HTTP status codes considered retryable
# Default periods (can be overridden by config.json)
DEFAULT_ATR_PERIOD = 14
DEFAULT_CCI_WINDOW = 20
DEFAULT_WILLIAMS_R_WINDOW = 14
DEFAULT_MFI_WINDOW = 14
DEFAULT_STOCH_RSI_WINDOW = 14 # Window for Stoch RSI calculation itself
DEFAULT_STOCH_WINDOW = 12     # Window for underlying RSI in StochRSI
DEFAULT_K_WINDOW = 3          # K period for StochRSI
DEFAULT_D_WINDOW = 3          # D period for StochRSI
DEFAULT_RSI_WINDOW = 14
DEFAULT_BOLLINGER_BANDS_PERIOD = 20
DEFAULT_BOLLINGER_BANDS_STD_DEV = 2.0 # Ensure float
DEFAULT_SMA_10_WINDOW = 10
DEFAULT_EMA_SHORT_PERIOD = 9
DEFAULT_EMA_LONG_PERIOD = 21
DEFAULT_MOMENTUM_PERIOD = 7
DEFAULT_VOLUME_MA_PERIOD = 15
DEFAULT_FIB_WINDOW = 50
DEFAULT_PSAR_AF = 0.02
DEFAULT_PSAR_MAX_AF = 0.2

FIB_LEVELS = [0.0, 0.236, 0.382, 0.5, 0.618, 0.786, 1.0] # Standard Fibonacci levels
LOOP_DELAY_SECONDS = 15 # Time between the end of one cycle and the start of the next
POSITION_CONFIRM_DELAY = 10 # Seconds to wait after placing order before checking position status
# QUOTE_CURRENCY dynamically loaded from config

os.makedirs(LOG_DIRECTORY, exist_ok=True)


class SensitiveFormatter(logging.Formatter):
    """Formatter to redact sensitive information (API keys) from logs."""
    def format(self, record: logging.LogRecord) -> str:
        msg = super().format(record)
        if API_KEY:
            msg = msg.replace(API_KEY, "***API_KEY***")
        if API_SECRET:
            msg = msg.replace(API_SECRET, "***API_SECRET***")
        return msg


def load_config(filepath: str) -> Dict[str, Any]:
    """Load configuration from JSON file, creating default if not found,
       and ensuring all default keys are present."""
    default_config = {
        "interval": "5", # Default to 5 minute interval (string format for our logic)
        "retry_delay": 5,
        "atr_period": DEFAULT_ATR_PERIOD,
        "ema_short_period": DEFAULT_EMA_SHORT_PERIOD,
        "ema_long_period": DEFAULT_EMA_LONG_PERIOD,
        "rsi_period": DEFAULT_RSI_WINDOW,
        "bollinger_bands_period": DEFAULT_BOLLINGER_BANDS_PERIOD,
        "bollinger_bands_std_dev": DEFAULT_BOLLINGER_BANDS_STD_DEV,
        "cci_window": DEFAULT_CCI_WINDOW,
        "williams_r_window": DEFAULT_WILLIAMS_R_WINDOW,
        "mfi_window": DEFAULT_MFI_WINDOW,
        "stoch_rsi_window": DEFAULT_STOCH_RSI_WINDOW,
        "stoch_rsi_rsi_window": DEFAULT_STOCH_WINDOW,
        "stoch_rsi_k": DEFAULT_K_WINDOW,
        "stoch_rsi_d": DEFAULT_D_WINDOW,
        "psar_af": DEFAULT_PSAR_AF,
        "psar_max_af": DEFAULT_PSAR_MAX_AF,
        "sma_10_window": DEFAULT_SMA_10_WINDOW,
        "momentum_period": DEFAULT_MOMENTUM_PERIOD,
        "volume_ma_period": DEFAULT_VOLUME_MA_PERIOD,
        "orderbook_limit": 25, # Depth of orderbook to fetch
        "signal_score_threshold": 1.5, # Score needed to trigger BUY/SELL signal
        "stoch_rsi_oversold_threshold": 25,
        "stoch_rsi_overbought_threshold": 75,
        "stop_loss_multiple": 1.8, # ATR multiple for initial SL (used for sizing)
        "take_profit_multiple": 0.7, # ATR multiple for TP
        "volume_confirmation_multiplier": 1.5, # How much higher volume needs to be than MA
        "scalping_signal_threshold": 2.5, # Separate threshold for 'scalping' weight set
        "fibonacci_window": DEFAULT_FIB_WINDOW,
        "enable_trading": False, # SAFETY FIRST: Default to False, enable consciously
        "use_sandbox": True,     # SAFETY FIRST: Default to True (testnet), disable consciously
        "risk_per_trade": 0.01, # Risk 1% of account balance per trade
        "leverage": 20,          # Set desired leverage (check exchange limits)
        "max_concurrent_positions": 1, # Limit open positions for this symbol (common strategy) - Currently informational, not enforced
        "quote_currency": "USDT", # Currency for balance check and sizing
        # --- MA Cross Exit Config ---
        "enable_ma_cross_exit": True, # Enable closing position on adverse EMA cross
        # --- Trailing Stop Loss Config ---
        "enable_trailing_stop": True, # Default to enabling TSL (exchange TSL)
        # Trail distance as a percentage of the activation/high-water-mark price (e.g., 0.5%)
        # Bybit API expects absolute distance, this percentage is used for calculation.
        "trailing_stop_callback_rate": 0.005, # Example: 0.5% trail distance relative to entry/activation
        # Activate TSL when price moves this percentage in profit from entry (e.g., 0.3%)
        # Set to 0 for immediate TSL activation upon entry.
        "trailing_stop_activation_percentage": 0.003, # Example: Activate when 0.3% in profit
        # --- Break-Even Stop Config ---
        "enable_break_even": True,              # Enable moving SL to break-even
        # Move SL when profit (in price points) reaches X * Current ATR
        "break_even_trigger_atr_multiple": 1.0, # Example: Trigger BE when profit = 1x ATR
        # Place BE SL this many minimum price increments (ticks) beyond entry price
        # E.g., 2 ticks to cover potential commission/slippage on exit
        "break_even_offset_ticks": 2,
        # --- End Protection Config ---
        "indicators": { # Control which indicators are calculated and contribute to score
            "ema_alignment": True, "momentum": True, "volume_confirmation": True,
            "stoch_rsi": True, "rsi": True, "bollinger_bands": True, "vwap": True,
            "cci": True, "wr": True, "psar": True, "sma_10": True, "mfi": True,
            "orderbook": True, # Flag to enable fetching and scoring orderbook data
        },
        "weight_sets": { # Define different weighting strategies
            "scalping": { # Example weighting for a fast scalping strategy
                "ema_alignment": 0.2, "momentum": 0.3, "volume_confirmation": 0.2,
                "stoch_rsi": 0.6, "rsi": 0.2, "bollinger_bands": 0.3, "vwap": 0.4,
                "cci": 0.3, "wr": 0.3, "psar": 0.2, "sma_10": 0.1, "mfi": 0.2, "orderbook": 0.15,
            },
            "default": { # A more balanced weighting strategy
                "ema_alignment": 0.3, "momentum": 0.2, "volume_confirmation": 0.1,
                "stoch_rsi": 0.4, "rsi": 0.3, "bollinger_bands": 0.2, "vwap": 0.3,
                "cci": 0.2, "wr": 0.2, "psar": 0.3, "sma_10": 0.1, "mfi": 0.2, "orderbook": 0.1,
            }
        },
        "active_weight_set": "default" # Choose which weight set to use ("default" or "scalping")
    }

    if not os.path.exists(filepath):
        try:
            with open(filepath, "w", encoding="utf-8") as f:
                json.dump(default_config, f, indent=4)
            print(f"{NEON_YELLOW}Created default config file: {filepath}{RESET}")
            return default_config
        except IOError as e:
            print(f"{NEON_RED}Error creating default config file {filepath}: {e}{RESET}")
            # Return default config anyway if file creation fails
            return default_config

    try:
        with open(filepath, encoding="utf-8") as f:
            config_from_file = json.load(f)
            # Ensure all default keys exist in the loaded config recursively
            updated_config = _ensure_config_keys(config_from_file, default_config)
            # Save back if keys were added during the update
            if updated_config != config_from_file:
                try:
                    with open(filepath, "w", encoding="utf-8") as f_write:
                        json.dump(updated_config, f_write, indent=4)
                    print(f"{NEON_YELLOW}Updated config file with missing default keys: {filepath}{RESET}")
                except IOError as e:
                    print(f"{NEON_RED}Error writing updated config file {filepath}: {e}{RESET}")
            return updated_config
    except (FileNotFoundError, json.JSONDecodeError) as e:
        print(f"{NEON_RED}Error loading config file {filepath}: {e}. Using default config.{RESET}")
        # Attempt to create default if loading failed badly
        try:
            with open(filepath, "w", encoding="utf-8") as f:
                json.dump(default_config, f, indent=4)
            print(f"{NEON_YELLOW}Created default config file: {filepath}{RESET}")
        except IOError as e_create:
            print(f"{NEON_RED}Error creating default config file after load error: {e_create}{RESET}")
        return default_config


def _ensure_config_keys(config: Dict[str, Any], default_config: Dict[str, Any]) -> Dict[str, Any]:
    """Recursively ensures all keys from the default config are present in the loaded config."""
    updated_config = config.copy()
    for key, default_value in default_config.items():
        if key not in updated_config:
            updated_config[key] = default_value
        elif isinstance(default_value, dict) and isinstance(updated_config.get(key), dict):
            # Recursively check nested dictionaries
            updated_config[key] = _ensure_config_keys(updated_config[key], default_value)
        # Optional: Handle type mismatches if needed
        # elif type(default_value) != type(updated_config.get(key)):
        #     print(f"Warning: Type mismatch for key '{key}'. Default: {type(default_value)}, Loaded: {type(updated_config.get(key))}. Using default.")
        #     updated_config[key] = default_value
    return updated_config

CONFIG = load_config(CONFIG_FILE)
QUOTE_CURRENCY = CONFIG.get("quote_currency", "USDT") # Get quote currency from config
console_log_level = logging.INFO # Default console level, can be changed in main()

# --- Logger Setup ---
def setup_logger(symbol: str) -> logging.Logger:
    """Sets up a logger for the given symbol with file and console handlers."""
    # Clean symbol for filename (replace / and : which are invalid in filenames)
    safe_symbol = symbol.replace('/', '_').replace(':', '-')
    logger_name = f"livebot_{safe_symbol}" # Use safe symbol in logger name
    log_filename = os.path.join(LOG_DIRECTORY, f"{logger_name}.log")
    logger = logging.getLogger(logger_name)

    # Avoid adding handlers multiple times if logger already exists
    if logger.hasHandlers():
        # Ensure existing handlers have the correct level (e.g., if changed dynamically)
        for handler in logger.handlers:
             if isinstance(handler, logging.StreamHandler):
                  handler.setLevel(console_log_level) # Update console level
        return logger

    # Set base logging level to DEBUG to capture everything
    logger.setLevel(logging.DEBUG)

    # File Handler (writes DEBUG and above, includes line numbers)
    try:
        file_handler = RotatingFileHandler(
            log_filename, maxBytes=10 * 1024 * 1024, backupCount=5, encoding='utf-8'
        )
        # Add line number to file logs for easier debugging
        file_formatter = SensitiveFormatter("%(asctime)s - %(levelname)s - [%(name)s:%(lineno)d] - %(message)s")
        file_handler.setFormatter(file_formatter)
        file_handler.setLevel(logging.DEBUG) # Log everything to the file
        logger.addHandler(file_handler)
    except Exception as e:
        print(f"{NEON_RED}Error setting up file logger for {log_filename}: {e}{RESET}")


    # Stream Handler (console, writes INFO and above by default for cleaner output)
    stream_handler = logging.StreamHandler()
    stream_formatter = SensitiveFormatter(
        f"{NEON_BLUE}%(asctime)s{RESET} - {NEON_YELLOW}%(levelname)-8s{RESET} - {NEON_PURPLE}[%(name)s]{RESET} - %(message)s",
        datefmt='%Y-%m-%d %H:%M:%S' # Add timestamp format to console
    )
    stream_handler.setFormatter(stream_formatter)
    # Set console level based on global variable
    stream_handler.setLevel(console_log_level)
    logger.addHandler(stream_handler)

    # Prevent logs from propagating to the root logger (avoids duplicate outputs)
    logger.propagate = False

    return logger

# --- CCXT Exchange Setup ---
def initialize_exchange(logger: logging.Logger) -> Optional[ccxt.Exchange]:
    """Initializes the CCXT Bybit exchange object with error handling."""
    try:
        exchange_options = {
            'apiKey': API_KEY,
            'secret': API_SECRET,
            'enableRateLimit': True, # Let ccxt handle basic rate limiting
            'options': {
                'defaultType': 'linear', # Assume linear contracts (USDT margined) - adjust if needed
                'adjustForTimeDifference': True, # Auto-sync time with server
                # Connection timeouts (milliseconds)
                'fetchTickerTimeout': 10000, # 10 seconds
                'fetchBalanceTimeout': 15000, # 15 seconds
                'createOrderTimeout': 20000, # Timeout for placing orders
                'fetchOrderTimeout': 15000,  # Timeout for fetching orders
                'fetchPositionsTimeout': 15000, # Timeout for fetching positions
                # Add any exchange-specific options if needed
                # 'recvWindow': 10000, # Example for Binance if needed
                'brokerId': 'livebot71', # Example: Add a broker ID for Bybit if desired
            }
        }

        # Select Bybit class
        exchange_class = ccxt.bybit
        exchange = exchange_class(exchange_options)

        # Set sandbox mode if configured
        if CONFIG.get('use_sandbox'):
            logger.warning(f"{NEON_YELLOW}USING SANDBOX MODE (Testnet){RESET}")
            exchange.set_sandbox_mode(True)

        # Test connection by fetching markets (essential for market info)
        logger.info(f"Loading markets for {exchange.id}...")
        exchange.load_markets()
        logger.info(f"CCXT exchange initialized ({exchange.id}). Sandbox: {CONFIG.get('use_sandbox')}")
        logger.info(f"CCXT version: {ccxt.__version__}") # Log CCXT version

        # Test API credentials and permissions by fetching balance
        # Specify account type for Bybit V5 (CONTRACT for linear/USDT, UNIFIED if using that)
        account_type_to_test = 'CONTRACT' # Or 'UNIFIED' based on your account
        logger.info(f"Attempting initial balance fetch (Account Type: {account_type_to_test})...")
        try:
            # Use our enhanced balance function
            balance_decimal = fetch_balance(exchange, QUOTE_CURRENCY, logger)
            if balance_decimal is not None:
                 logger.info(f"{NEON_GREEN}Successfully connected and fetched initial balance.{RESET} ({QUOTE_CURRENCY} available: {balance_decimal:.4f})")
            else:
                 logger.warning(f"{NEON_YELLOW}Initial balance fetch returned None. Check API permissions/account type if trading fails.{RESET}")
        except ccxt.AuthenticationError as auth_err:
            logger.error(f"{NEON_RED}CCXT Authentication Error during initial balance fetch: {auth_err}{RESET}")
            logger.error(f"{NEON_RED}>> Ensure API keys are correct, have necessary permissions (Read, Trade), match the account type (Real/Testnet), and IP whitelist is correctly set if enabled on Bybit.{RESET}")
            return None # Critical failure, cannot proceed
        except ccxt.ExchangeError as balance_err:
            # Handle potential errors if account type is wrong etc.
            logger.warning(f"{NEON_YELLOW}Exchange error during initial balance fetch ({account_type_to_test}): {balance_err}. Continuing, but check API permissions/account type if trading fails.{RESET}")
        except Exception as balance_err:
            logger.warning(f"{NEON_YELLOW}Could not perform initial balance fetch: {balance_err}. Continuing, but check API permissions/account type if trading fails.{RESET}")

        return exchange

    except ccxt.AuthenticationError as e:
        logger.error(f"{NEON_RED}CCXT Authentication Error during initialization: {e}{RESET}")
        logger.error(f"{NEON_RED}>> Check API keys, permissions, IP whitelist, and Real/Testnet selection.{RESET}")
    except ccxt.ExchangeError as e:
        logger.error(f"{NEON_RED}CCXT Exchange Error initializing: {e}{RESET}")
    except ccxt.NetworkError as e:
        logger.error(f"{NEON_RED}CCXT Network Error initializing: {e}{RESET}")
    except Exception as e:
        logger.error(f"{NEON_RED}Failed to initialize CCXT exchange: {e}{RESET}", exc_info=True)

    return None


# --- CCXT Data Fetching ---
def fetch_current_price_ccxt(exchange: ccxt.Exchange, symbol: str, logger: logging.Logger) -> Optional[Decimal]:
    """Fetch the current price of a trading symbol using CCXT ticker with fallbacks."""
    lg = logger
    try:
        lg.debug(f"Fetching ticker for {symbol}...")
        ticker = exchange.fetch_ticker(symbol)
        lg.debug(f"Ticker data for {symbol}: {ticker}")

        price = None
        last_price = ticker.get('last')
        bid_price = ticker.get('bid')
        ask_price = ticker.get('ask')

        # 1. Try 'last' price first, ensure it's positive
        if last_price is not None:
            try:
                last_decimal = Decimal(str(last_price))
                if last_decimal > 0:
                    price = last_decimal
                    lg.debug(f"Using 'last' price for {symbol}: {price}")
                else:
                    lg.warning(f"'Last' price ({last_decimal}) is not positive for {symbol}.")
            except Exception as e:
                lg.warning(f"Could not parse 'last' price ({last_price}) for {symbol}: {e}")

        # 2. If 'last' is invalid, try bid/ask midpoint
        if price is None and bid_price is not None and ask_price is not None:
            try:
                bid_decimal = Decimal(str(bid_price))
                ask_decimal = Decimal(str(ask_price))
                if bid_decimal > 0 and ask_decimal > 0:
                    # Ensure bid is not higher than ask (can happen in volatile/illiquid moments)
                    if bid_decimal <= ask_decimal:
                        price = (bid_decimal + ask_decimal) / 2
                        lg.debug(f"Using bid/ask midpoint for {symbol}: {price} (Bid: {bid_decimal}, Ask: {ask_decimal})")
                    else:
                        lg.warning(f"Invalid ticker state: Bid ({bid_decimal}) > Ask ({ask_decimal}) for {symbol}. Using 'ask' as fallback.")
                        price = ask_decimal # Use ask as a safer fallback in this case
                else:
                    lg.warning(f"Bid ({bid_decimal}) or Ask ({ask_decimal}) price is not positive for {symbol}.")
            except Exception as e:
                lg.warning(f"Could not parse bid/ask prices ({bid_price}, {ask_price}) for {symbol}: {e}")

        # 3. If midpoint fails or wasn't used, try ask price (potentially better for market buy estimate)
        if price is None and ask_price is not None:
            try:
                ask_decimal = Decimal(str(ask_price))
                if ask_decimal > 0:
                    price = ask_decimal
                    lg.warning(f"Using 'ask' price as fallback for {symbol}: {price}")
                else:
                    lg.warning(f"'Ask' price ({ask_decimal}) is not positive for {symbol}.")
            except Exception as e:
                lg.warning(f"Could not parse 'ask' price ({ask_price}) for {symbol}: {e}")

        # 4. If ask fails, try bid price (potentially better for market sell estimate)
        if price is None and bid_price is not None:
            try:
                bid_decimal = Decimal(str(bid_price))
                if bid_decimal > 0:
                    price = bid_decimal
                    lg.warning(f"Using 'bid' price as fallback for {symbol}: {price}")
                else:
                    lg.warning(f"'Bid' price ({bid_decimal}) is not positive for {symbol}.")
            except Exception as e:
                lg.warning(f"Could not parse 'bid' price ({bid_price}) for {symbol}: {e}")


        # --- Final Check ---
        if price is not None and price > 0:
            return price
        else:
            lg.error(f"{NEON_RED}Failed to fetch a valid positive current price for {symbol} from ticker.{RESET}")
            return None

    except ccxt.NetworkError as e:
        lg.error(f"{NEON_RED}Network error fetching price for {symbol}: {e}{RESET}")
    except ccxt.ExchangeError as e:
        lg.error(f"{NEON_RED}Exchange error fetching price for {symbol}: {e}{RESET}")
    except Exception as e:
        lg.error(f"{NEON_RED}Unexpected error fetching price for {symbol}: {e}{RESET}", exc_info=True)
    return None

def fetch_klines_ccxt(exchange: ccxt.Exchange, symbol: str, timeframe: str, limit: int = 250, logger: logging.Logger = None) -> pd.DataFrame:
    """Fetch OHLCV kline data using CCXT with retries and basic validation."""
    lg = logger or logging.getLogger(__name__)
    try:
        if not exchange.has['fetchOHLCV']:
            lg.error(f"Exchange {exchange.id} does not support fetchOHLCV.")
            return pd.DataFrame()

        ohlcv = None
        for attempt in range(MAX_API_RETRIES + 1):
            try:
                lg.debug(f"Fetching klines for {symbol}, {timeframe}, limit={limit} (Attempt {attempt+1}/{MAX_API_RETRIES + 1})")
                ohlcv = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
                if ohlcv is not None and len(ohlcv) > 0: # Basic check if data was returned and not empty
                    break # Success
                else:
                    lg.warning(f"fetch_ohlcv returned {type(ohlcv)} (length {len(ohlcv) if ohlcv is not None else 'N/A'}) for {symbol} (Attempt {attempt+1}). Retrying...")
                    # Optional: Add a small delay even on None/empty return if it might be transient
                    time.sleep(1)

            except (ccxt.NetworkError, ccxt.RequestTimeout, requests.exceptions.ConnectionError, requests.exceptions.Timeout) as e:
                if attempt < MAX_API_RETRIES:
                    lg.warning(f"Network error fetching klines for {symbol} (Attempt {attempt + 1}/{MAX_API_RETRIES + 1}): {e}. Retrying in {RETRY_DELAY_SECONDS}s...")
                    time.sleep(RETRY_DELAY_SECONDS)
                else:
                    lg.error(f"{NEON_RED}Max retries reached fetching klines for {symbol} after network errors.{RESET}")
                    raise e # Re-raise the last error
            except ccxt.RateLimitExceeded as e:
                wait_time = RETRY_DELAY_SECONDS * 5 # Default wait time
                try:
                     # Try to parse recommended wait time from Bybit/other exchange messages
                     if 'try again in' in str(e).lower():
                         wait_time_ms_str = str(e).lower().split('try again in')[1].split('ms')[0].strip()
                         wait_time = int(wait_time_ms_str) / 1000
                         wait_time = max(1, int(wait_time + 1)) # Add a buffer and ensure minimum 1s
                     elif 'rate limit' in str(e).lower(): # Generic rate limit message
                         # Try to extract number before 'ms' or 's'
                         import re
                         match = re.search(r'(\d+)\s*(ms|s)', str(e).lower())
                         if match:
                             num = int(match.group(1))
                             unit = match.group(2)
                             wait_time = num / 1000 if unit == 'ms' else num
                             wait_time = max(1, int(wait_time + 1))
                except Exception:
                     pass # Use default if parsing fails
                lg.warning(f"Rate limit exceeded fetching klines for {symbol}. Retrying in {wait_time}s... (Attempt {attempt+1})")
                time.sleep(wait_time)
            except ccxt.ExchangeError as e:
                lg.error(f"{NEON_RED}Exchange error fetching klines for {symbol}: {e}{RESET}")
                # Depending on the error, might not be retryable
                raise e # Re-raise non-network errors immediately

        if not ohlcv: # Check if list is empty or still None after retries
            lg.warning(f"{NEON_YELLOW}No kline data returned for {symbol} {timeframe} after retries.{RESET}")
            return pd.DataFrame()

        # --- Data Processing ---
        df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        if df.empty:
            lg.warning(f"{NEON_YELLOW}Kline data DataFrame is empty for {symbol} {timeframe} immediately after creation.{RESET}")
            return df

        # Convert timestamp to datetime and set as index
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms', errors='coerce')
        df.dropna(subset=['timestamp'], inplace=True) # Drop rows with invalid timestamps
        if df.empty:
            lg.warning(f"{NEON_YELLOW}Kline data DataFrame empty after timestamp conversion for {symbol} {timeframe}.{RESET}")
            return df
        df.set_index('timestamp', inplace=True)

        # Ensure numeric types, coerce errors to NaN
        for col in ['open', 'high', 'low', 'close', 'volume']:
            df[col] = pd.to_numeric(df[col], errors='coerce')

        # --- Data Cleaning ---
        initial_len = len(df)
        # Drop rows with any NaN in critical price columns
        df.dropna(subset=['open', 'high', 'low', 'close'], inplace=True)
        # Drop rows with non-positive close price (invalid data)
        df = df[df['close'] > 0]
        # Optional: Drop rows with zero volume if it indicates bad data
        # df = df[df['volume'] > 0]

        rows_dropped = initial_len - len(df)
        if rows_dropped > 0:
            lg.debug(f"Dropped {rows_dropped} rows with NaN/invalid price/volume data for {symbol}.")

        if df.empty:
            lg.warning(f"{NEON_YELLOW}Kline data for {symbol} {timeframe} was empty after processing/cleaning.{RESET}")
            return pd.DataFrame()

        # Optional: Sort index just in case data isn't perfectly ordered (though fetch_ohlcv usually is)
        df.sort_index(inplace=True)

        lg.info(f"Successfully fetched and processed {len(df)} klines for {symbol} {timeframe}")
        return df

    except ccxt.NetworkError as e: # Catch error if retries fail
        lg.error(f"{NEON_RED}Network error fetching klines for {symbol} after retries: {e}{RESET}")
    except ccxt.ExchangeError as e:
        lg.error(f"{NEON_RED}Exchange error processing klines for {symbol}: {e}{RESET}")
    except Exception as e:
        lg.error(f"{NEON_RED}Unexpected error processing klines for {symbol}: {e}{RESET}", exc_info=True)
    return pd.DataFrame()

def fetch_orderbook_ccxt(exchange: ccxt.Exchange, symbol: str, limit: int, logger: logging.Logger) -> Optional[Dict]:
    """Fetch orderbook data using ccxt with retries and basic validation."""
    lg = logger
    attempts = 0
    while attempts <= MAX_API_RETRIES:
        try:
            if not exchange.has['fetchOrderBook']:
                lg.error(f"Exchange {exchange.id} does not support fetchOrderBook.")
                return None

            lg.debug(f"Fetching order book for {symbol}, limit={limit} (Attempt {attempts+1}/{MAX_API_RETRIES + 1})")
            orderbook = exchange.fetch_order_book(symbol, limit=limit)

            # --- Validation ---
            if not orderbook:
                lg.warning(f"fetch_order_book returned None or empty data for {symbol} (Attempt {attempts+1}).")
                # Continue to retry logic
            elif not isinstance(orderbook.get('bids'), list) or not isinstance(orderbook.get('asks'), list):
                lg.warning(f"{NEON_YELLOW}Invalid orderbook structure (bids/asks not lists) for {symbol}. Attempt {attempts + 1}. Response: {orderbook}{RESET}")
                 # Treat as potentially retryable issue
            elif not orderbook['bids'] and not orderbook['asks']:
                 # Exchange might return empty lists if orderbook is thin or during low liquidity
                 lg.warning(f"{NEON_YELLOW}Orderbook received but bids and asks lists are both empty for {symbol}. (Attempt {attempts + 1}).{RESET}")
                 return orderbook # Return the empty book, signal generation needs to handle this
            else:
                 # Looks valid
                 lg.debug(f"Successfully fetched orderbook for {symbol} with {len(orderbook['bids'])} bids, {len(orderbook['asks'])} asks.")
                 return orderbook

        except (ccxt.NetworkError, ccxt.RequestTimeout, requests.exceptions.ConnectionError, requests.exceptions.Timeout) as e:
            lg.warning(f"{NEON_YELLOW}Orderbook fetch network error for {symbol}: {e}. Retrying in {RETRY_DELAY_SECONDS}s... (Attempt {attempts + 1}/{MAX_API_RETRIES + 1}){RESET}")
        except ccxt.RateLimitExceeded as e:
            wait_time = RETRY_DELAY_SECONDS * 5 # Default wait time
            try:
                 if 'try again in' in str(e).lower():
                     wait_time_ms_str = str(e).lower().split('try again in')[1].split('ms')[0].strip()
                     wait_time = int(wait_time_ms_str) / 1000
                     wait_time = max(1, int(wait_time + 1))
                 elif 'rate limit' in str(e).lower():
                     import re
                     match = re.search(r'(\d+)\s*(ms|s)', str(e).lower())
                     if match:
                         num = int(match.group(1))
                         unit = match.group(2)
                         wait_time = num / 1000 if unit == 'ms' else num
                         wait_time = max(1, int(wait_time + 1))
            except Exception: pass
            lg.warning(f"Rate limit exceeded fetching orderbook for {symbol}. Retrying in {wait_time}s... (Attempt {attempts+1})")
            time.sleep(wait_time) # Use delay from error msg if possible
            # Increment attempt counter here so it doesn't bypass retry limit due to sleep
            attempts += 1
            continue # Skip the standard delay at the end
        except ccxt.ExchangeError as e:
            lg.error(f"{NEON_RED}Exchange error fetching orderbook for {symbol}: {e}{RESET}")
            # Don't retry on definitive exchange errors (e.g., bad symbol) unless specifically handled
            return None
        except Exception as e:
            lg.error(f"{NEON_RED}Unexpected error fetching orderbook for {symbol}: {e}{RESET}", exc_info=True)
            return None # Don't retry on unexpected errors

        # Increment attempt counter and wait before retrying network/validation issues
        attempts += 1
        if attempts <= MAX_API_RETRIES:
            time.sleep(RETRY_DELAY_SECONDS)

    lg.error(f"{NEON_RED}Max retries reached fetching orderbook for {symbol}.{RESET}")
    return None

# --- Trading Analyzer Class (Using pandas_ta) ---
class TradingAnalyzer:
    """Analyzes trading data using pandas_ta and generates weighted signals."""

    def __init__(
        self,
        df: pd.DataFrame,
        logger: logging.Logger,
        config: Dict[str, Any],
        market_info: Dict[str, Any], # Pass market info for precision etc.
    ) -> None:
        self.df = df # Expects index 'timestamp' and columns 'open', 'high', 'low', 'close', 'volume'
        self.logger = logger
        self.config = config
        # Ensure market_info is provided
        if not market_info:
            raise ValueError("TradingAnalyzer requires valid market_info.")
        self.market_info = market_info
        self.symbol = market_info.get('symbol', 'UNKNOWN_SYMBOL')
        self.interval = config.get("interval", "UNKNOWN_INTERVAL")
        self.ccxt_interval = CCXT_INTERVAL_MAP.get(self.interval, "UNKNOWN_INTERVAL")
        self.indicator_values: Dict[str, float] = {} # Stores latest indicator float values
        self.signals: Dict[str, int] = {"BUY": 0, "SELL": 0, "HOLD": 0} # Simple signal state
        self.active_weight_set_name = config.get("active_weight_set", "default")
        self.weights = config.get("weight_sets",{}).get(self.active_weight_set_name, {})
        self.fib_levels_data: Dict[str, Decimal] = {} # Stores calculated fib levels (as Decimals)
        self.ta_column_names: Dict[str, Optional[str]] = {} # Stores actual column names generated by pandas_ta

        if not self.weights:
            logger.error(f"Active weight set '{self.active_weight_set_name}' not found or empty in config for {self.symbol}. Indicator weighting will not work.")

        # Calculate indicators immediately on initialization
        self._calculate_all_indicators()
        # Update latest values immediately after calculation
        self._update_latest_indicator_values()
        # Calculate Fibonacci levels (can be done after indicators)
        self.calculate_fibonacci_levels()

    def _get_ta_col_name(self, base_name: str, result_df: pd.DataFrame) -> Optional[str]:
        """Helper to find the actual column name generated by pandas_ta, handling variations."""
        # Common prefixes/suffixes used by pandas_ta
        # Examples: ATRr_14, EMA_10, MOM_10, CCI_20_0.015, WILLR_14, MFI_14, VWAP,
        # PSARl_0.02_0.2, PSARs_0.02_0.2, SMA_10, STOCHRSIk_14_14_3_3, STOCHRSId_14_14_3_3,
        # RSI_14, BBL_20_2.0, BBM_20_2.0, BBU_20_2.0, VOL_SMA_15 (custom)
        # Prioritize exact match or expected patterns
        cfg = self.config # Shortcut
        try:
            # Ensure float conversion for std dev is safe
            bb_std_dev = float(cfg.get('bollinger_bands_std_dev', DEFAULT_BOLLINGER_BANDS_STD_DEV))
        except (ValueError, TypeError):
            self.logger.warning(f"Invalid bollinger_bands_std_dev '{cfg.get('bollinger_bands_std_dev')}' in config. Using default {DEFAULT_BOLLINGER_BANDS_STD_DEV}.")
            bb_std_dev = DEFAULT_BOLLINGER_BANDS_STD_DEV

        expected_patterns = {
            "ATR": [f"ATRr_{cfg.get('atr_period', DEFAULT_ATR_PERIOD)}", f"ATR_{cfg.get('atr_period', DEFAULT_ATR_PERIOD)}"], # Added ATR_ variation
            "EMA_Short": [f"EMA_{cfg.get('ema_short_period', DEFAULT_EMA_SHORT_PERIOD)}"],
            "EMA_Long": [f"EMA_{cfg.get('ema_long_period', DEFAULT_EMA_LONG_PERIOD)}"],
            "Momentum": [f"MOM_{cfg.get('momentum_period', DEFAULT_MOMENTUM_PERIOD)}"],
            "CCI": [f"CCI_{cfg.get('cci_window', DEFAULT_CCI_WINDOW)}_0.015"], # Default const suffix
            "Williams_R": [f"WILLR_{cfg.get('williams_r_window', DEFAULT_WILLIAMS_R_WINDOW)}"],
            "MFI": [f"MFI_{cfg.get('mfi_window', DEFAULT_MFI_WINDOW)}"],
            "VWAP": ["VWAP", "VWAP_D"], # Handle potential suffix like _D for daily reset
            "PSAR_long": [f"PSARl_{cfg.get('psar_af', DEFAULT_PSAR_AF)}_{cfg.get('psar_max_af', DEFAULT_PSAR_MAX_AF)}"],
            "PSAR_short": [f"PSARs_{cfg.get('psar_af', DEFAULT_PSAR_AF)}_{cfg.get('psar_max_af', DEFAULT_PSAR_MAX_AF)}"],
            "SMA10": [f"SMA_{cfg.get('sma_10_window', DEFAULT_SMA_10_WINDOW)}"],
            "StochRSI_K": [f"STOCHRSIk_{cfg.get('stoch_rsi_window', DEFAULT_STOCH_RSI_WINDOW)}_{cfg.get('stoch_rsi_rsi_window', DEFAULT_STOCH_WINDOW)}_{cfg.get('stoch_rsi_k', DEFAULT_K_WINDOW)}_{cfg.get('stoch_rsi_d', DEFAULT_D_WINDOW)}"],
            "StochRSI_D": [f"STOCHRSId_{cfg.get('stoch_rsi_window', DEFAULT_STOCH_RSI_WINDOW)}_{cfg.get('stoch_rsi_rsi_window', DEFAULT_STOCH_WINDOW)}_{cfg.get('stoch_rsi_k', DEFAULT_K_WINDOW)}_{cfg.get('stoch_rsi_d', DEFAULT_D_WINDOW)}"],
            "RSI": [f"RSI_{cfg.get('rsi_period', DEFAULT_RSI_WINDOW)}"],
            "BB_Lower": [f"BBL_{cfg.get('bollinger_bands_period', DEFAULT_BOLLINGER_BANDS_PERIOD)}_{bb_std_dev:.1f}"],
            "BB_Middle": [f"BBM_{cfg.get('bollinger_bands_period', DEFAULT_BOLLINGER_BANDS_PERIOD)}_{bb_std_dev:.1f}"],
            "BB_Upper": [f"BBU_{cfg.get('bollinger_bands_period', DEFAULT_BOLLINGER_BANDS_PERIOD)}_{bb_std_dev:.1f}"],
            "Volume_MA": [f"VOL_SMA_{cfg.get('volume_ma_period', DEFAULT_VOLUME_MA_PERIOD)}"] # Custom name
        }
        patterns = expected_patterns.get(base_name, [])
        for pattern in patterns:
            if pattern in result_df.columns:
                return pattern
            # Check variation without const suffix (e.g., CCI)
            base_pattern_parts = pattern.split('_')
            if len(base_pattern_parts) > 2 and base_pattern_parts[-1].replace('.','').isdigit():
                pattern_no_suffix = '_'.join(base_pattern_parts[:-1])
                if pattern_no_suffix in result_df.columns:
                    self.logger.debug(f"Found column '{pattern_no_suffix}' for base '{base_name}' (without const suffix).")
                    return pattern_no_suffix

        # Check for common parameter-less suffix variations if specific pattern not found
        for pattern in patterns:
             base_pattern = pattern.split('_')[0] # e.g., "ATRr" -> "ATRr"
             if base_pattern in result_df.columns:
                  self.logger.debug(f"Found column '{base_pattern}' for base '{base_name}' (parameter-less variation).")
                  return base_pattern
             # Try base name itself (e.g., "CCI" if "CCI_20_0.015" not found)
             if base_name.upper() in result_df.columns:
                  self.logger.debug(f"Found column '{base_name.upper()}' for base '{base_name}'.")
                  return base_name.upper()


        # Fallback: search for base name (case-insensitive) if specific pattern not found
        # This is less reliable but might catch variations
        for col in result_df.columns:
            # More specific check: starts with base name + underscore (e.g., "CCI_")
            if col.lower().startswith(base_name.lower() + "_"):
                 self.logger.debug(f"Found column '{col}' for base '{base_name}' using prefix fallback search.")
                 return col
            # Less specific check: contains base name
            if base_name.lower() in col.lower():
                self.logger.debug(f"Found column '{col}' for base '{base_name}' using basic fallback search.")
                return col

        self.logger.warning(f"Could not find column name for indicator '{base_name}' in DataFrame columns: {result_df.columns.tolist()}")
        return None


    def _calculate_all_indicators(self):
        """Calculates all enabled indicators using pandas_ta and stores column names."""
        if self.df.empty:
            self.logger.warning(f"{NEON_YELLOW}DataFrame is empty, cannot calculate indicators for {self.symbol}.{RESET}")
            return

        # Check for sufficient data length
        periods_needed = []
        cfg = self.config
        indi_cfg = cfg.get("indicators", {})
        if True: periods_needed.append(cfg.get("atr_period", DEFAULT_ATR_PERIOD)) # Always calc ATR
        if indi_cfg.get("ema_alignment") or cfg.get("enable_ma_cross_exit"): # Need EMAs if alignment OR MA cross exit enabled
            periods_needed.append(cfg.get("ema_long_period", DEFAULT_EMA_LONG_PERIOD))
        if indi_cfg.get("momentum"): periods_needed.append(cfg.get("momentum_period", DEFAULT_MOMENTUM_PERIOD))
        if indi_cfg.get("cci"): periods_needed.append(cfg.get("cci_window", DEFAULT_CCI_WINDOW))
        if indi_cfg.get("wr"): periods_needed.append(cfg.get("williams_r_window", DEFAULT_WILLIAMS_R_WINDOW))
        if indi_cfg.get("mfi"): periods_needed.append(cfg.get("mfi_window", DEFAULT_MFI_WINDOW))
        if indi_cfg.get("sma_10"): periods_needed.append(cfg.get("sma_10_window", DEFAULT_SMA_10_WINDOW))
        if indi_cfg.get("stoch_rsi"): periods_needed.append(cfg.get("stoch_rsi_window", DEFAULT_STOCH_RSI_WINDOW) + cfg.get("stoch_rsi_rsi_window", DEFAULT_STOCH_WINDOW))
        if indi_cfg.get("rsi"): periods_needed.append(cfg.get("rsi_period", DEFAULT_RSI_WINDOW))
        if indi_cfg.get("bollinger_bands"): periods_needed.append(cfg.get("bollinger_bands_period", DEFAULT_BOLLINGER_BANDS_PERIOD))
        if indi_cfg.get("volume_confirmation"): periods_needed.append(cfg.get("volume_ma_period", DEFAULT_VOLUME_MA_PERIOD))
        # VWAP doesn't have a fixed period in the same way, relies on session/day start

        min_required_data = max(periods_needed) + 20 if periods_needed else 50 # Add buffer

        if len(self.df) < min_required_data:
            self.logger.warning(f"{NEON_YELLOW}Insufficient data ({len(self.df)} points) for {self.symbol} to calculate all indicators (min recommended: {min_required_data}). Results may be inaccurate or NaN.{RESET}")
             # Continue calculation, but expect NaNs

        try:
            df_calc = self.df.copy() # Work on a copy

            # --- Calculate indicators using pandas_ta ---
            indicators_config = self.config.get("indicators", {})
            calculate_emas = indicators_config.get("ema_alignment", False) or self.config.get("enable_ma_cross_exit", False)

            # Always calculate ATR
            atr_period = self.config.get("atr_period", DEFAULT_ATR_PERIOD)
            df_calc.ta.atr(length=atr_period, append=True)
            self.ta_column_names["ATR"] = self._get_ta_col_name("ATR", df_calc)

            # Calculate other indicators based on config flags
            if calculate_emas: # Calculate EMAs if needed for alignment or MA cross exit
                ema_short = self.config.get("ema_short_period", DEFAULT_EMA_SHORT_PERIOD)
                ema_long = self.config.get("ema_long_period", DEFAULT_EMA_LONG_PERIOD)
                df_calc.ta.ema(length=ema_short, append=True)
                self.ta_column_names["EMA_Short"] = self._get_ta_col_name("EMA_Short", df_calc)
                df_calc.ta.ema(length=ema_long, append=True)
                self.ta_column_names["EMA_Long"] = self._get_ta_col_name("EMA_Long", df_calc)

            if indicators_config.get("momentum", False):
                mom_period = self.config.get("momentum_period", DEFAULT_MOMENTUM_PERIOD)
                df_calc.ta.mom(length=mom_period, append=True)
                self.ta_column_names["Momentum"] = self._get_ta_col_name("Momentum", df_calc)

            if indicators_config.get("cci", False):
                cci_period = self.config.get("cci_window", DEFAULT_CCI_WINDOW)
                df_calc.ta.cci(length=cci_period, append=True)
                self.ta_column_names["CCI"] = self._get_ta_col_name("CCI", df_calc)

            if indicators_config.get("wr", False):
                wr_period = self.config.get("williams_r_window", DEFAULT_WILLIAMS_R_WINDOW)
                df_calc.ta.willr(length=wr_period, append=True)
                self.ta_column_names["Williams_R"] = self._get_ta_col_name("Williams_R", df_calc)

            if indicators_config.get("mfi", False):
                mfi_period = self.config.get("mfi_window", DEFAULT_MFI_WINDOW)
                df_calc.ta.mfi(length=mfi_period, append=True)
                self.ta_column_names["MFI"] = self._get_ta_col_name("MFI", df_calc)

            if indicators_config.get("vwap", False):
                # VWAP calculation might depend on the frequency (e.g., daily reset)
                # pandas_ta vwap usually assumes daily reset based on timestamp index
                df_calc.ta.vwap(append=True)
                self.ta_column_names["VWAP"] = self._get_ta_col_name("VWAP", df_calc)

            if indicators_config.get("psar", False):
                psar_af = self.config.get("psar_af", DEFAULT_PSAR_AF)
                psar_max_af = self.config.get("psar_max_af", DEFAULT_PSAR_MAX_AF)
                psar_result = df_calc.ta.psar(af=psar_af, max_af=psar_max_af)
                if psar_result is not None and not psar_result.empty:
                    # Append safely, avoiding duplicate columns if they somehow exist
                    for col in psar_result.columns:
                        if col not in df_calc.columns:
                            df_calc[col] = psar_result[col]
                        else:
                             self.logger.debug(f"Column {col} from PSAR result already exists in DataFrame. Overwriting.")
                             df_calc[col] = psar_result[col] # Overwrite if exists
                    self.ta_column_names["PSAR_long"] = self._get_ta_col_name("PSAR_long", df_calc)
                    self.ta_column_names["PSAR_short"] = self._get_ta_col_name("PSAR_short", df_calc)
                else:
                    self.logger.warning(f"PSAR calculation returned empty result for {self.symbol}.")

            if indicators_config.get("sma_10", False):
                sma10_period = self.config.get("sma_10_window", DEFAULT_SMA_10_WINDOW)
                df_calc.ta.sma(length=sma10_period, append=True)
                self.ta_column_names["SMA10"] = self._get_ta_col_name("SMA10", df_calc)

            if indicators_config.get("stoch_rsi", False):
                stoch_rsi_len = self.config.get("stoch_rsi_window", DEFAULT_STOCH_RSI_WINDOW)
                stoch_rsi_rsi_len = self.config.get("stoch_rsi_rsi_window", DEFAULT_STOCH_WINDOW)
                stoch_rsi_k = self.config.get("stoch_rsi_k", DEFAULT_K_WINDOW)
                stoch_rsi_d = self.config.get("stoch_rsi_d", DEFAULT_D_WINDOW)
                stochrsi_result = df_calc.ta.stochrsi(length=stoch_rsi_len, rsi_length=stoch_rsi_rsi_len, k=stoch_rsi_k, d=stoch_rsi_d)
                if stochrsi_result is not None and not stochrsi_result.empty:
                    # Append safely
                    for col in stochrsi_result.columns:
                        if col not in df_calc.columns:
                            df_calc[col] = stochrsi_result[col]
                        else:
                             self.logger.debug(f"Column {col} from StochRSI result already exists. Overwriting.")
                             df_calc[col] = stochrsi_result[col]
                    self.ta_column_names["StochRSI_K"] = self._get_ta_col_name("StochRSI_K", df_calc)
                    self.ta_column_names["StochRSI_D"] = self._get_ta_col_name("StochRSI_D", df_calc)
                else:
                    self.logger.warning(f"StochRSI calculation returned empty result for {self.symbol}.")


            if indicators_config.get("rsi", False):
                rsi_period = self.config.get("rsi_period", DEFAULT_RSI_WINDOW)
                df_calc.ta.rsi(length=rsi_period, append=True)
                self.ta_column_names["RSI"] = self._get_ta_col_name("RSI", df_calc)

            if indicators_config.get("bollinger_bands", False):
                bb_period = self.config.get("bollinger_bands_period", DEFAULT_BOLLINGER_BANDS_PERIOD)
                bb_std = self.config.get("bollinger_bands_std_dev", DEFAULT_BOLLINGER_BANDS_STD_DEV)
                bb_std_float = float(bb_std) # Ensure float
                bbands_result = df_calc.ta.bbands(length=bb_period, std=bb_std_float)
                if bbands_result is not None and not bbands_result.empty:
                     # Append safely
                    for col in bbands_result.columns:
                        if col not in df_calc.columns:
                            df_calc[col] = bbands_result[col]
                        else:
                             self.logger.debug(f"Column {col} from BBands result already exists. Overwriting.")
                             df_calc[col] = bbands_result[col]
                    self.ta_column_names["BB_Lower"] = self._get_ta_col_name("BB_Lower", df_calc)
                    self.ta_column_names["BB_Middle"] = self._get_ta_col_name("BB_Middle", df_calc)
                    self.ta_column_names["BB_Upper"] = self._get_ta_col_name("BB_Upper", df_calc)
                else:
                    self.logger.warning(f"Bollinger Bands calculation returned empty result for {self.symbol}.")


            if indicators_config.get("volume_confirmation", False):
                vol_ma_period = self.config.get("volume_ma_period", DEFAULT_VOLUME_MA_PERIOD)
                vol_ma_col_name = f"VOL_SMA_{vol_ma_period}" # Custom name
                # Calculate SMA on volume column, handle potential NaNs in volume
                df_calc[vol_ma_col_name] = ta.sma(df_calc['volume'].fillna(0), length=vol_ma_period) # Use ta.sma directly
                self.ta_column_names["Volume_MA"] = vol_ma_col_name


            # Assign the df with calculated indicators back to self.df
            self.df = df_calc
            self.logger.debug(f"Finished indicator calculations for {self.symbol}. Final DF columns: {self.df.columns.tolist()}")

        except AttributeError as e:
            self.logger.error(f"{NEON_RED}AttributeError calculating indicators for {self.symbol} (check pandas_ta method name/version?): {e}{RESET}", exc_info=True)
             # self.df remains the original data without calculated indicators
        except Exception as e:
            self.logger.error(f"{NEON_RED}Error calculating indicators with pandas_ta for {self.symbol}: {e}{RESET}", exc_info=True)
            # Decide how to handle - clear df or keep original? Keep original for now.

        # Note: _update_latest_indicator_values is called after this in __init__


    def _update_latest_indicator_values(self):
        """Updates the indicator_values dict with the latest float values from self.df."""
        if self.df.empty:
            self.logger.warning(f"Cannot update latest values: DataFrame is empty for {self.symbol}.")
            self.indicator_values = {k: np.nan for k in list(self.ta_column_names.keys()) + ["Close", "Volume", "High", "Low"]}
            return
        # Check if the last row contains any non-NaN values before proceeding
        try:
            if self.df.iloc[-1].isnull().all():
                self.logger.warning(f"{NEON_YELLOW}Cannot update latest values: Last row of DataFrame contains all NaNs for {self.symbol}.{RESET}")
                self.indicator_values = {k: np.nan for k in list(self.ta_column_names.keys()) + ["Close", "Volume", "High", "Low"]}
                return
        except IndexError:
             self.logger.error(f"Error accessing latest row (iloc[-1]) for {self.symbol}. DataFrame might be unexpectedly empty or too short.")
             self.indicator_values = {k: np.nan for k in list(self.ta_column_names.keys()) + ["Close", "Volume", "High", "Low"]} # Reset values
             return

        try:
            latest = self.df.iloc[-1]
            updated_values = {}

            # Use the dynamically stored column names from self.ta_column_names
            for key, col_name in self.ta_column_names.items():
                if col_name and col_name in latest.index: # Check if column name exists and is valid
                    value = latest[col_name]
                    if pd.notna(value):
                        try:
                            updated_values[key] = float(value) # Store as float
                        except (ValueError, TypeError):
                            self.logger.warning(f"Could not convert value for {key} ('{col_name}': {value}) to float for {self.symbol}.")
                            updated_values[key] = np.nan
                    else:
                        updated_values[key] = np.nan # Value is NaN in DataFrame
                else:
                    # If col_name is None or not in index, store NaN
                    # Log only if the indicator was supposed to be calculated (i.e., key exists)
                    # Check if the indicator was intended to be calculated based on config
                    indicator_enabled_or_needed = False
                    if key == "ATR": indicator_enabled_or_needed = True # Always needed
                    elif key == "EMA_Short" or key == "EMA_Long": indicator_enabled_or_needed = self.config.get("indicators", {}).get("ema_alignment", False) or self.config.get("enable_ma_cross_exit", False)
                    else:
                        # Map internal key back to config key (handle potential naming differences)
                        config_key_map = {
                            "Momentum": "momentum", "CCI": "cci", "Williams_R": "wr", "MFI": "mfi", "VWAP": "vwap",
                            "PSAR_long": "psar", "PSAR_short": "psar", "SMA10": "sma_10", "StochRSI_K": "stoch_rsi",
                            "StochRSI_D": "stoch_rsi", "RSI": "rsi", "BB_Lower": "bollinger_bands",
                            "BB_Middle": "bollinger_bands", "BB_Upper": "bollinger_bands", "Volume_MA": "volume_confirmation"
                        }
                        config_key = config_key_map.get(key)
                        if config_key:
                            indicator_enabled_or_needed = self.config.get("indicators", {}).get(config_key, False)

                    if indicator_enabled_or_needed: # Only log if it was supposed to be calculated
                        self.logger.debug(f"Indicator column '{col_name}' for key '{key}' not found or invalid in latest data for {self.symbol}. Storing NaN.")
                    updated_values[key] = np.nan


            # Add essential price/volume data from the original DataFrame columns
            for base_col in ['close', 'volume', 'high', 'low']:
                value = latest.get(base_col, np.nan)
                key_name = base_col.capitalize() # e.g., 'Close'
                if pd.notna(value):
                    try:
                        updated_values[key_name] = float(value)
                    except (ValueError, TypeError):
                        self.logger.warning(f"Could not convert base value for '{base_col}' ({value}) to float for {self.symbol}.")
                        updated_values[key_name] = np.nan
                else:
                    updated_values[key_name] = np.nan


            self.indicator_values = updated_values
            # Filter out NaN for debug log brevity
            valid_values = {k: f"{v:.5f}" if isinstance(v, float) else v for k, v in self.indicator_values.items() if pd.notna(v)}
            self.logger.debug(f"Latest indicator float values updated for {self.symbol}: {valid_values}")

        except IndexError: # Catch again just in case df became empty between checks
            self.logger.error(f"Error accessing latest row (iloc[-1]) for {self.symbol}. DataFrame might be unexpectedly empty or too short.")
            self.indicator_values = {k: np.nan for k in list(self.ta_column_names.keys()) + ["Close", "Volume", "High", "Low"]} # Reset values
        except Exception as e:
            self.logger.error(f"Unexpected error updating latest indicator values for {self.symbol}: {e}", exc_info=True)
            self.indicator_values = {k: np.nan for k in list(self.ta_column_names.keys()) + ["Close", "Volume", "High", "Low"]} # Reset values


    # --- Fibonacci Calculation ---
    def calculate_fibonacci_levels(self, window: Optional[int] = None) -> Dict[str, Decimal]:
        """Calculates Fibonacci retracement levels over a specified window using Decimal."""
        window = window or self.config.get("fibonacci_window", DEFAULT_FIB_WINDOW)
        if len(self.df) < window:
            self.logger.debug(f"Not enough data ({len(self.df)}) for Fibonacci window ({window}) on {self.symbol}. Skipping.")
            self.fib_levels_data = {}
            return {}

        df_slice = self.df.tail(window)
        try:
            # Ensure high/low are valid numbers before converting to Decimal
            high_price_raw = df_slice["high"].dropna().max()
            low_price_raw = df_slice["low"].dropna().min()

            if pd.isna(high_price_raw) or pd.isna(low_price_raw):
                self.logger.warning(f"Could not find valid high/low in the last {window} periods for Fibonacci on {self.symbol}.")
                self.fib_levels_data = {}
                return {}

            high = Decimal(str(high_price_raw))
            low = Decimal(str(low_price_raw))
            diff = high - low

            levels = {}
            min_tick = self.get_min_tick_size()
            if min_tick <= 0:
                self.logger.warning(f"Invalid min_tick_size ({min_tick}) for Fibonacci quantization on {self.symbol}. Levels will not be quantized.")
                min_tick = None # Disable quantization if tick size is invalid

            if diff > 0:
                for level_pct in FIB_LEVELS:
                    level_name = f"Fib_{level_pct * 100:.1f}%"
                    # Calculate level: High - (Range * Pct) for downtrend assumption (standard)
                    # Or Low + (Range * Pct) for uptrend assumption
                    # Using High - diff * level assumes retracement from High towards Low
                    level_price = (high - (diff * Decimal(str(level_pct))))

                    # Quantize the result to the market's price precision (using tick size) if possible
                    if min_tick:
                        level_price_quantized = (level_price / min_tick).quantize(Decimal('1'), rounding=ROUND_DOWN) * min_tick
                    else:
                        level_price_quantized = level_price # Use raw value if quantization fails

                    levels[level_name] = level_price_quantized
            else:
                 # If high == low, all levels will be the same
                 self.logger.debug(f"Fibonacci range is zero (High={high}, Low={low}) for {self.symbol} in window {window}. Setting levels to high/low.")
                 if min_tick and min_tick > 0: # Check min_tick again
                     level_price_quantized = (high / min_tick).quantize(Decimal('1'), rounding=ROUND_DOWN) * min_tick
                 else:
                     level_price_quantized = high # Use raw if quantization fails
                 for level_pct in FIB_LEVELS:
                     levels[f"Fib_{level_pct * 100:.1f}%"] = level_price_quantized

            self.fib_levels_data = levels
            self.logger.debug(f"Calculated Fibonacci levels for {self.symbol}: { {k: str(v) for k,v in levels.items()} }") # Log as strings
            return levels
        except Exception as e:
            self.logger.error(f"{NEON_RED}Fibonacci calculation error for {self.symbol}: {e}{RESET}", exc_info=True)
            self.fib_levels_data = {}
            return {}

    def get_price_precision(self) -> int:
        """Gets price precision (number of decimal places) from market info, using min_tick_size as primary source."""
        try:
            min_tick = self.get_min_tick_size() # Rely on tick size first
            if min_tick > 0:
                # Calculate decimal places from tick size
                # Use normalize() to handle trailing zeros, then get exponent
                precision = abs(min_tick.normalize().as_tuple().exponent)
                # self.logger.debug(f"Derived price precision {precision} from min tick size {min_tick} for {self.symbol}")
                return precision
            else:
                 self.logger.warning(f"Min tick size ({min_tick}) is invalid for {self.symbol}. Attempting fallback precision methods.")

        except Exception as e:
            self.logger.warning(f"Error getting/using min tick size for precision derivation ({self.symbol}): {e}. Attempting fallback methods.")

        # Fallback 1: Use 'precision' -> 'price' if it's an integer (decimal places)
        try:
            precision_info = self.market_info.get('precision', {})
            price_precision_val = precision_info.get('price')
            if isinstance(price_precision_val, int) and price_precision_val >= 0:
                self.logger.debug(f"Using price precision from market_info['precision']['price']: {price_precision_val} for {self.symbol}")
                return price_precision_val
        except Exception as e_prec:
            self.logger.warning(f"Could not parse precision.price for fallback: {e_prec}")


        # Fallback 2: Infer from last close price format if tick size and precision.price failed
        try:
            last_close = self.indicator_values.get("Close") # Uses float value
            if last_close and pd.notna(last_close) and last_close > 0:
                try:
                    s_close = format(Decimal(str(last_close)), 'f') # Format to avoid scientific notation
                    if '.' in s_close:
                        precision = len(s_close.split('.')[-1])
                        self.logger.debug(f"Inferring price precision from last close price ({s_close}) as {precision} for {self.symbol}.")
                        return precision
                    else:
                        return 0 # No decimal places
                except Exception as e_close:
                    self.logger.warning(f"Error inferring precision from close price {last_close}: {e_close}")
        except Exception as e_outer:
            self.logger.warning(f"Could not access/parse close price for precision fallback: {e_outer}")

        # Default fallback precision
        default_precision = 4 # Common default for USDT pairs, adjust if needed
        self.logger.warning(f"Using default price precision {default_precision} for {self.symbol}.")
        return default_precision


    def get_min_tick_size(self) -> Decimal:
        """Gets the minimum price increment (tick size) from market info as Decimal."""
        try:
            # CCXT precision structure often contains tick size directly or indirectly
            precision_info = self.market_info.get('precision', {})
            # Prefer 'tick' if available (often string or float representation of tick size)
            tick_val = precision_info.get('tick')
            if tick_val is not None:
                try:
                    tick_size = Decimal(str(tick_val))
                    if tick_size > 0:
                        # self.logger.debug(f"Using tick size from precision.tick: {tick_size} for {self.symbol}")
                        return tick_size
                except Exception:
                    self.logger.debug(f"Could not parse precision.tick '{tick_val}' as Decimal for {self.symbol}. Trying other methods.")

            # Fallback 1: Use precision.price if it's a float/string (interpreted as tick size)
            price_precision_val = precision_info.get('price')
            if isinstance(price_precision_val, (float, str)):
                try:
                    tick_size_from_price = Decimal(str(price_precision_val))
                    if tick_size_from_price > 0:
                         # Only use if it looks like a tick size (e.g., 0.01, 0.5), not decimal places (e.g., 4)
                         # Heuristic: if it's < 1 or has decimal point, likely tick size.
                         if tick_size_from_price < 1 or '.' in str(price_precision_val):
                             self.logger.debug(f"Using tick size from precision.price: {tick_size_from_price} for {self.symbol}")
                             return tick_size_from_price
                         else:
                             self.logger.debug(f"Precision.price '{price_precision_val}' looks like decimal places, not tick size. Skipping.")
                except Exception:
                     self.logger.debug(f"Could not parse precision.price '{price_precision_val}' as Decimal tick size for {self.symbol}.")

            # Fallback 2: Check limits.price.min (sometimes this represents tick size)
            limits_info = self.market_info.get('limits', {})
            price_limits = limits_info.get('price', {})
            min_price_val = price_limits.get('min')
            if min_price_val is not None:
                try:
                    min_tick_from_limit = Decimal(str(min_price_val))
                    if min_tick_from_limit > 0:
                        self.logger.debug(f"Using tick size from limits.price.min: {min_tick_from_limit} for {self.symbol}")
                        return min_tick_from_limit
                except Exception:
                    self.logger.debug(f"Could not parse limits.price.min '{min_price_val}' as Decimal for {self.symbol}.")

            # Fallback 3: Check Bybit specific 'tickSize' in info (V5)
            info_dict = self.market_info.get('info', {})
            bybit_tick_size = info_dict.get('tickSize')
            if bybit_tick_size is not None:
                 try:
                      tick_size_bybit = Decimal(str(bybit_tick_size))
                      if tick_size_bybit > 0:
                          self.logger.debug(f"Using tick size from market_info['info']['tickSize']: {tick_size_bybit} for {self.symbol}")
                          return tick_size_bybit
                 except Exception:
                      self.logger.debug(f"Could not parse info['tickSize'] '{bybit_tick_size}' as Decimal for {self.symbol}.")


        except Exception as e:
            self.logger.warning(f"Could not determine min tick size for {self.symbol} from market info: {e}. Using default fallback.")

        # Absolute fallback: A very small number if everything else fails
        fallback_tick = Decimal('0.00000001') # Small default
        self.logger.warning(f"Using extremely small fallback tick size for {self.symbol}: {fallback_tick}. Price quantization may be inaccurate.")
        return fallback_tick


    def get_nearest_fibonacci_levels(
        self, current_price: Decimal, num_levels: int = 5
    ) -> list[Tuple[str, Decimal]]:
        """Finds the N nearest Fibonacci levels (name, price) to the current price."""
        if not self.fib_levels_data:
            # Don't recalculate here, rely on initial calculation
            # self.logger.debug(f"Fibonacci levels not calculated or empty for {self.symbol}. Cannot find nearest.")
            return []

        if current_price is None or not isinstance(current_price, Decimal) or pd.isna(current_price) or current_price <= 0:
            self.logger.warning(f"Invalid current price ({current_price}) for Fibonacci comparison on {self.symbol}.")
            return []

        try:
            level_distances = []
            for name, level_price in self.fib_levels_data.items():
                if isinstance(level_price, Decimal): # Ensure level is Decimal
                    distance = abs(current_price - level_price)
                    level_distances.append({'name': name, 'level': level_price, 'distance': distance})
                else:
                    self.logger.warning(f"Non-decimal value found in fib_levels_data for {self.symbol}: {name}={level_price} ({type(level_price)})")

            # Sort by distance (ascending)
            level_distances.sort(key=lambda x: x['distance'])

            # Return the names and levels of the nearest N
            return [(item['name'], item['level']) for item in level_distances[:num_levels]]
        except Exception as e:
            self.logger.error(f"{NEON_RED}Error finding nearest Fibonacci levels for {self.symbol}: {e}{RESET}", exc_info=True)
            return []

    # --- EMA Alignment Calculation ---
    def calculate_ema_alignment_score(self) -> float:
        """Calculates EMA alignment score based on latest values. Returns float score or NaN."""
        # Relies on 'EMA_Short', 'EMA_Long', 'Close' being in self.indicator_values
        ema_short = self.indicator_values.get("EMA_Short", np.nan)
        ema_long = self.indicator_values.get("EMA_Long", np.nan)
        current_price = self.indicator_values.get("Close", np.nan)

        if pd.isna(ema_short) or pd.isna(ema_long) or pd.isna(current_price):
            # self.logger.debug(f"EMA alignment check skipped for {self.symbol}: Missing required values.")
            return np.nan # Return NaN if data is missing

        # Bullish alignment: Price > Short EMA > Long EMA
        if current_price > ema_short > ema_long:
            return 1.0
        # Bearish alignment: Price < Short EMA < Long EMA
        elif current_price < ema_short < ema_long:
            return -1.0
        # Other cases are neutral or mixed signals
        else:
            return 0.0

    # --- Signal Generation & Scoring ---
    def generate_trading_signal(
        self, current_price: Decimal, orderbook_data: Optional[Dict]
    ) -> str:
        """Generates a trading signal (BUY/SELL/HOLD) based on weighted indicator scores."""
        self.signals = {"BUY": 0, "SELL": 0, "HOLD": 0} # Reset signals
        final_signal_score = Decimal("0.0")
        total_weight_applied = Decimal("0.0")
        active_indicator_count = 0
        nan_indicator_count = 0
        debug_scores = {} # For logging individual scores

        # --- Essential Data Checks ---
        if not self.indicator_values:
            self.logger.warning(f"{NEON_YELLOW}Cannot generate signal for {self.symbol}: Indicator values dictionary is empty.{RESET}")
            return "HOLD"
        # Check if *any* core indicator value (excluding price/vol) is non-NaN
        core_indicators_present = any(pd.notna(v) for k, v in self.indicator_values.items() if k not in ['Close', 'Volume', 'High', 'Low', 'EMA_Short', 'EMA_Long']) # Exclude EMAs if only used for exit
        if not core_indicators_present and not self.config.get("indicators", {}).get("ema_alignment", False): # Only require core if EMA align not used for score
             self.logger.warning(f"{NEON_YELLOW}Cannot generate signal for {self.symbol}: All score-contributing indicator values are NaN.{RESET}")
             return "HOLD"

        if current_price is None or pd.isna(current_price) or current_price <= 0:
            self.logger.warning(f"{NEON_YELLOW}Cannot generate signal for {self.symbol}: Invalid current price ({current_price}).{RESET}")
            return "HOLD"

        # --- Get Active Weights ---
        active_weights = self.config.get("weight_sets", {}).get(self.active_weight_set_name)
        if not active_weights:
            self.logger.error(f"Active weight set '{self.active_weight_set_name}' is missing or empty in config for {self.symbol}. Cannot generate signal.")
            return "HOLD"

        # --- Iterate Through Enabled Indicators with Weights ---
        for indicator_key, enabled in self.config.get("indicators", {}).items():
            if not enabled: continue # Skip disabled indicators

            weight_str = active_weights.get(indicator_key)
            if weight_str is None: continue # Skip if no weight defined for this enabled indicator

            try:
                weight = Decimal(str(weight_str))
                if weight == 0: continue # Skip if weight is zero
            except Exception:
                self.logger.warning(f"Invalid weight format '{weight_str}' for indicator '{indicator_key}' in weight set '{self.active_weight_set_name}'. Skipping.")
                continue

            # Find and call the check method
            check_method_name = f"_check_{indicator_key}"
            if hasattr(self, check_method_name) and callable(getattr(self, check_method_name)):
                method = getattr(self, check_method_name)
                indicator_score = np.nan # Default to NaN
                try:
                    # Pass specific arguments if needed (e.g., orderbook)
                    if indicator_key == "orderbook":
                        if orderbook_data: # Only call if data exists
                            indicator_score = method(orderbook_data, current_price)
                        else:
                            self.logger.debug(f"Orderbook data not available for {self.symbol}, skipping orderbook check.")
                            indicator_score = np.nan # Treat as NaN if data missing
                    else:
                        indicator_score = method() # Returns float score or np.nan

                except Exception as e:
                    self.logger.error(f"Error calling check method {check_method_name} for {self.symbol}: {e}", exc_info=True)
                    indicator_score = np.nan # Treat as NaN on error

                # --- Process Score ---
                debug_scores[indicator_key] = f"{indicator_score:.2f}" if pd.notna(indicator_score) else "NaN"
                if pd.notna(indicator_score):
                    try:
                        score_decimal = Decimal(str(indicator_score)) # Convert float score to Decimal
                        # Clamp score between -1 and 1 before applying weight
                        clamped_score = max(Decimal("-1.0"), min(Decimal("1.0"), score_decimal))
                        score_contribution = clamped_score * weight
                        final_signal_score += score_contribution
                        total_weight_applied += weight
                        active_indicator_count += 1
                        # Detailed debug log inside the loop can be verbose, moved summary outside
                    except Exception as calc_err:
                        self.logger.error(f"Error processing score for {indicator_key} ({indicator_score}): {calc_err}")
                        nan_indicator_count += 1
                else:
                    nan_indicator_count += 1
            else:
                self.logger.warning(f"Check method '{check_method_name}' not found or not callable for enabled/weighted indicator: {indicator_key} ({self.symbol})")


        # --- Determine Final Signal ---
        if total_weight_applied == 0:
            self.logger.warning(f"No indicators contributed to the signal score for {self.symbol} (Total Weight Applied = 0). Defaulting to HOLD.")
            final_signal = "HOLD"
        else:
            # Normalize score? Optional. threshold works on weighted sum.
            # normalized_score = final_signal_score / total_weight_applied
            threshold = Decimal(str(self.config.get("signal_score_threshold", 1.5)))

            if final_signal_score >= threshold:
                final_signal = "BUY"
            elif final_signal_score <= -threshold:
                final_signal = "SELL"
            else:
                final_signal = "HOLD"

        # --- Log Summary ---
        # Format score contributions for logging
        score_details = ", ".join([f"{k}: {v}" for k, v in debug_scores.items()])
        price_precision = self.get_price_precision() # Get precision for logging current price
        log_msg = (
            f"Signal Calculation Summary ({self.symbol} @ {current_price:.{price_precision}f}):\n"
            f"  Weight Set: {self.active_weight_set_name}\n"
            # f"  Scores: {score_details}\n" # Can be very long, log at DEBUG if needed
            f"  Indicators Used: {active_indicator_count} ({nan_indicator_count} NaN)\n"
            f"  Total Weight Applied: {total_weight_applied:.3f}\n"
            f"  Final Weighted Score: {final_signal_score:.4f}\n"
            f"  Signal Threshold: +/- {threshold:.3f}\n"
            f"  ==> Final Signal: {NEON_GREEN if final_signal == 'BUY' else NEON_RED if final_signal == 'SELL' else NEON_YELLOW}{final_signal}{RESET}"
        )
        self.logger.info(log_msg)
        if console_log_level <= logging.DEBUG: # Only log detailed scores if console level is DEBUG
            self.logger.debug(f"  Detailed Scores: {score_details}")

        # Update internal signal state
        if final_signal in self.signals:
            self.signals[final_signal] = 1

        return final_signal


    # --- Indicator Check Methods ---
    # Each method should return a float score between -1.0 and 1.0, or np.nan if data invalid/missing

    def _check_ema_alignment(self) -> float:
        """Checks EMA alignment. Relies on calculate_ema_alignment_score."""
        # Ensure the indicator was calculated if this check is enabled
        if "EMA_Short" not in self.indicator_values or "EMA_Long" not in self.indicator_values:
            self.logger.debug(f"EMA Alignment check skipped for {self.symbol}: EMAs not in indicator_values.")
            return np.nan
        # calculate_ema_alignment_score already handles NaNs internally
        return self.calculate_ema_alignment_score()

    def _check_momentum(self) -> float:
        """Checks Momentum indicator."""
        momentum = self.indicator_values.get("Momentum", np.nan)
        if pd.isna(momentum): return np.nan
        # Normalize score based on momentum magnitude (simple example)
        # These thresholds might need tuning based on typical MOM values for the asset/interval
        # Example: If MOM is typically +/- 0.5, scale based on that range
        # Let's assume a typical range of +/- 0.2 for this example scaling
        scale_factor = 5.0 # Scales 0.2 to 1.0
        score = momentum * scale_factor
        return max(-1.0, min(1.0, score)) # Clamp score between -1 and 1

    def _check_volume_confirmation(self) -> float:
        """Checks if current volume supports potential move (relative to MA). Score is direction-neutral."""
        current_volume = self.indicator_values.get("Volume", np.nan)
        volume_ma = self.indicator_values.get("Volume_MA", np.nan)
        multiplier = float(self.config.get("volume_confirmation_multiplier", 1.5)) # Use float

        if pd.isna(current_volume) or pd.isna(volume_ma) or volume_ma <= 0:
            return np.nan

        try:
            if current_volume > volume_ma * multiplier:
                # High volume suggests stronger conviction or potential climax/exhaustion.
                # Positive score indicates significance, not direction.
                return 0.7 # Strong confirmation/significance
            elif current_volume < volume_ma / multiplier:
                # Low volume suggests lack of interest or consolidation.
                return -0.4 # Negative score indicates lack of confirmation
            else:
                return 0.0 # Neutral volume
        except Exception as e:
            self.logger.warning(f"{NEON_YELLOW}Volume confirmation check calculation failed for {self.symbol}: {e}{RESET}")
            return np.nan

    def _check_stoch_rsi(self) -> float:
        """Checks Stochastic RSI K and D lines."""
        k = self.indicator_values.get("StochRSI_K", np.nan)
        d = self.indicator_values.get("StochRSI_D", np.nan)
        if pd.isna(k) or pd.isna(d): return np.nan

        oversold = float(self.config.get("stoch_rsi_oversold_threshold", 25))
        overbought = float(self.config.get("stoch_rsi_overbought_threshold", 75))

        # --- Scoring Logic ---
        score = 0.0
        # 1. Extreme Zones (strongest signals)
        if k < oversold and d < oversold:
            score = 1.0 # Both deep oversold -> Strong bullish
        elif k > overbought and d > overbought:
            score = -1.0 # Both deep overbought -> Strong bearish

        # 2. K vs D Relationship (momentum indication)
        # Give higher weight to K crossing D than just K being above/below D
        # Requires previous state, approximating: if K is significantly different from D
        diff = k - d
        if abs(diff) > 5: # Threshold for significant difference/cross potential
            if diff > 0: # K moved above D (or is significantly above)
                score = max(score, 0.6) if score >= 0 else 0.6 # Bullish momentum, higher score if not already bearish
            else: # K moved below D (or is significantly below)
                score = min(score, -0.6) if score <= 0 else -0.6 # Bearish momentum, higher score if not already bullish
        else: # K and D are close
            if k > d : score = max(score, 0.2) # Weak bullish
            elif k < d: score = min(score, -0.2) # Weak bearish

        # 3. Consider position within range (0-100) - less important than extremes/crosses
        if oversold <= k <= overbought: # Inside normal range
            # Optionally scale based on proximity to mid-point (50)
            # Ensure divisor isn't zero if thresholds are equal
            range_width = overbought - oversold
            if range_width > 0:
                 mid_range_score = (k - (oversold + range_width / 2)) / (range_width / 2) # Scales -1 to 1 within the range
                 # Combine with existing score (e.g., average or weighted average)
                 score = (score + mid_range_score * 0.3) / 1.3 # Give mid-range position less weight
            # else: score remains unchanged if range is zero

        return max(-1.0, min(1.0, score)) # Clamp final score

    def _check_rsi(self) -> float:
        """Checks RSI indicator."""
        rsi = self.indicator_values.get("RSI", np.nan)
        if pd.isna(rsi): return np.nan

        if rsi <= 30: return 1.0
        if rsi >= 70: return -1.0
        if rsi < 40: return 0.5 # Leaning oversold/bullish
        if rsi > 60: return -0.5 # Leaning overbought/bearish
        # Smoother transition in the middle
        if 40 <= rsi <= 60:
            # Linear scale from +0.5 (at 40) to -0.5 (at 60)
            return 0.5 - (rsi - 40) * (1.0 / 20.0)
        return 0.0 # Fallback

    def _check_cci(self) -> float:
        """Checks CCI indicator."""
        cci = self.indicator_values.get("CCI", np.nan)
        if pd.isna(cci): return np.nan
        # CCI extremes often signal reversal potential
        if cci <= -150: return 1.0 # Strong Oversold -> Bullish
        if cci >= 150: return -1.0 # Strong Overbought -> Bearish
        if cci < -80: return 0.6 # Moderately Oversold
        if cci > 80: return -0.6 # Moderately Overbought
        # Trend confirmation near zero line - scale based on value
        if -80 <= cci <= 80:
            # Linear scale from +0.6 (at -80) to -0.6 (at 80)
             return - (cci / 80.0) * 0.6
        return 0.0 # Fallback

    def _check_wr(self) -> float: # Williams %R
        """Checks Williams %R indicator."""
        wr = self.indicator_values.get("Williams_R", np.nan)
        if pd.isna(wr): return np.nan
        # WR: -100 (most oversold) to 0 (most overbought)
        if wr <= -80: return 1.0 # Oversold -> Bullish
        if wr >= -20: return -1.0 # Overbought -> Bearish
        # Scale linearly in the middle range (-80 to -20)
        if -80 < wr < -20:
            # Scale from +1.0 (at -80) to -1.0 (at -20)
            return 1.0 - (wr - (-80.0)) * (2.0 / 60.0)
        # Handle edge cases (exactly -80 or -20) or values outside range
        elif wr == -80: return 1.0
        elif wr == -20: return -1.0
        elif wr < -80: return 1.0 # Treat below -80 as 1.0
        elif wr > -20: return -1.0 # Treat above -20 as -1.0
        return 0.0 # Fallback (shouldn't be reached with above logic)


    def _check_psar(self) -> float:
        """Checks Parabolic SAR relative to price."""
        psar_l = self.indicator_values.get("PSAR_long", np.nan)
        psar_s = self.indicator_values.get("PSAR_short", np.nan)
        # PSAR values themselves indicate the stop level.
        # The signal comes from which one is active (non-NaN).
        if pd.notna(psar_l) and pd.isna(psar_s):
            # PSAR is below price (long value is active) -> Uptrend
            return 1.0
        elif pd.notna(psar_s) and pd.isna(psar_l):
            # PSAR is above price (short value is active) -> Downtrend
            return -1.0
        else:
            # Both NaN (start of data) or both have values (shouldn't happen with ta.psar)
            # self.logger.debug(f"PSAR state ambiguous/NaN for {self.symbol} (PSAR_long={psar_l}, PSAR_short={psar_s})")
            return 0.0 # Neutral or undetermined

    def _check_sma_10(self) -> float: # Example using SMA10
        """Checks price relative to SMA10."""
        sma_10 = self.indicator_values.get("SMA10", np.nan)
        last_close = self.indicator_values.get("Close", np.nan)
        if pd.isna(sma_10) or pd.isna(last_close): return np.nan
        # Simple crossover score
        if last_close > sma_10: return 0.6 # Price above SMA -> Bullish bias
        if last_close < sma_10: return -0.6 # Price below SMA -> Bearish bias
        return 0.0

    def _check_vwap(self) -> float:
        """Checks price relative to VWAP."""
        vwap = self.indicator_values.get("VWAP", np.nan)
        last_close = self.indicator_values.get("Close", np.nan)
        if pd.isna(vwap) or pd.isna(last_close): return np.nan
        # VWAP acts as a dynamic support/resistance or fair value indicator
        if last_close > vwap: return 0.7 # Price above VWAP -> Bullish intraday sentiment
        if last_close < vwap: return -0.7 # Price below VWAP -> Bearish intraday sentiment
        return 0.0

    def _check_mfi(self) -> float:
        """Checks Money Flow Index."""
        mfi = self.indicator_values.get("MFI", np.nan)
        if pd.isna(mfi): return np.nan
        # MFI combines price and volume for overbought/oversold signals
        if mfi <= 20: return 1.0 # Oversold -> Bullish potential
        if mfi >= 80: return -1.0 # Overbought -> Bearish potential
        if mfi < 40: return 0.4 # Leaning oversold/accumulation
        if mfi > 60: return -0.4 # Leaning overbought/distribution
        # Scale linearly in the middle range (40 to 60)
        if 40 <= mfi <= 60:
            # Scale from +0.4 (at 40) to -0.4 (at 60)
            return 0.4 - (mfi - 40) * (0.8 / 20.0)
        return 0.0 # Fallback

    def _check_bollinger_bands(self) -> float:
        """Checks price relative to Bollinger Bands."""
        bb_lower = self.indicator_values.get("BB_Lower", np.nan)
        bb_upper = self.indicator_values.get("BB_Upper", np.nan)
        bb_middle = self.indicator_values.get("BB_Middle", np.nan)
        last_close = self.indicator_values.get("Close", np.nan)
        if pd.isna(bb_lower) or pd.isna(bb_upper) or pd.isna(bb_middle) or pd.isna(last_close):
            return np.nan

        # 1. Price relative to outer bands (mean reversion signals)
        if last_close < bb_lower: return 1.0 # Below lower band -> Strong bullish potential
        if last_close > bb_upper: return -1.0 # Above upper band -> Strong bearish potential

        # 2. Price relative to middle band (trend confirmation)
        # Bandwidth calculation for volatility context could also be added
        band_width = (bb_upper - bb_lower)
        if band_width <= 0: return 0.0 # Avoid division by zero if bands are flat

        # Avoid division by zero if middle band = upper/lower band
        upper_range = bb_upper - bb_middle
        lower_range = bb_middle - bb_lower

        if last_close > bb_middle:
            # Price above middle band -> weaker bullish signal (already in upper half)
            # Scale score based on proximity to upper band: closer to upper band -> weaker bullish / stronger bearish potential
            # Example: Score from +0.5 (at middle) to -0.5 (at upper band)
            proximity_to_upper = (last_close - bb_middle) / upper_range if upper_range > 0 else 0
            score = 0.5 - proximity_to_upper # Max +0.5, min -0.5 (approx)
            return max(-0.5, min(0.5, score)) # Clamp result

        if last_close < bb_middle:
            # Price below middle band -> weaker bearish signal
            # Scale score based on proximity to lower band: closer to lower band -> weaker bearish / stronger bullish potential
            # Example: Score from -0.5 (at middle) to +0.5 (at lower band)
            proximity_to_lower = (bb_middle - last_close) / lower_range if lower_range > 0 else 0
            score = -0.5 + proximity_to_lower # Max +0.5, min -0.5 (approx)
            return max(-0.5, min(0.5, score)) # Clamp result

        return 0.0 # Exactly on middle band


    def _check_orderbook(self, orderbook_data: Optional[Dict], current_price: Decimal) -> float:
        """Analyzes order book depth for immediate pressure. Returns float score or NaN."""
        if not orderbook_data:
            self.logger.debug(f"Orderbook check skipped for {self.symbol}: No data provided.")
            return np.nan

        try:
            bids = orderbook_data.get('bids', []) # List of [price (str), volume (str)]
            asks = orderbook_data.get('asks', []) # List of [price (str), volume (str)]

            if not bids or not asks:
                self.logger.debug(f"Orderbook check skipped for {self.symbol}: Bids or asks list is empty.")
                return np.nan # Need both sides for imbalance calculation

            # --- Simple Order Book Imbalance (OBI) within N levels ---
            # Alternative: Use % range around current price
            num_levels_to_check = 10 # Check top N levels
            bid_volume_sum = sum(Decimal(str(bid[1])) for bid in bids[:num_levels_to_check])
            ask_volume_sum = sum(Decimal(str(ask[1])) for ask in asks[:num_levels_to_check])

            total_volume = bid_volume_sum + ask_volume_sum
            if total_volume == 0:
                self.logger.debug(f"Orderbook check: No volume within top {num_levels_to_check} levels for {self.symbol}.")
                return 0.0 # Neutral if no volume

            # Calculate Order Book Imbalance (OBI) ratio: (Bids - Asks) / Total
            obi = (bid_volume_sum - ask_volume_sum) / total_volume

            # Scale OBI to a score between -1 and 1
            # Direct scaling: OBI already ranges from -1 to 1
            score = float(obi)

            # Optional: Make the score more sensitive to strong imbalances
            # Example: score = float(obi) ** 3 # Cube enhances values closer to +/- 1

            self.logger.debug(f"Orderbook check ({self.symbol}): Top {num_levels_to_check} Levels: "
                              f"BidVol={bid_volume_sum:.4f}, AskVol={ask_volume_sum:.4f}, "
                              f"OBI={obi:.4f}, Score={score:.4f}")
            return score

        except Exception as e:
            self.logger.warning(f"{NEON_YELLOW}Orderbook analysis failed for {self.symbol}: {e}{RESET}", exc_info=True)
            return np.nan # Return NaN on error


    # --- Risk Management Calculations ---
    def calculate_entry_tp_sl(
        self, entry_price: Decimal, signal: str
    ) -> Tuple[Optional[Decimal], Optional[Decimal], Optional[Decimal]]:
        """
        Calculates potential take profit (TP) and initial stop loss (SL) levels
        based on the provided entry price, ATR, and configured multipliers. Uses Decimal precision.
        The initial SL calculated here is primarily used for position sizing and setting the initial protection.
        Returns (entry_price, take_profit, stop_loss), all as Decimal or None.
        """
        if signal not in ["BUY", "SELL"]:
            return entry_price, None, None # No TP/SL needed for HOLD

        atr_val_float = self.indicator_values.get("ATR") # Get float ATR value
        if atr_val_float is None or pd.isna(atr_val_float) or atr_val_float <= 0:
            self.logger.warning(f"{NEON_YELLOW}Cannot calculate TP/SL for {self.symbol}: ATR is invalid ({atr_val_float}).{RESET}")
            return entry_price, None, None
        if entry_price is None or pd.isna(entry_price) or entry_price <= 0:
            self.logger.warning(f"{NEON_YELLOW}Cannot calculate TP/SL for {self.symbol}: Provided entry price is invalid ({entry_price}).{RESET}")
            return entry_price, None, None

        try:
            atr = Decimal(str(atr_val_float)) # Convert valid float ATR to Decimal

            # Get multipliers from config, convert to Decimal
            tp_multiple = Decimal(str(self.config.get("take_profit_multiple", 1.0)))
            sl_multiple = Decimal(str(self.config.get("stop_loss_multiple", 1.5)))

            # Get market precision for logging
            price_precision = self.get_price_precision()
            # Get minimum price increment (tick size) for quantization
            min_tick = self.get_min_tick_size()
            if min_tick <= 0:
                 self.logger.error(f"Cannot calculate TP/SL for {self.symbol}: Invalid min tick size ({min_tick}).")
                 return entry_price, None, None


            take_profit = None
            stop_loss = None

            if signal == "BUY":
                tp_offset = atr * tp_multiple
                sl_offset = atr * sl_multiple
                take_profit_raw = entry_price + tp_offset
                stop_loss_raw = entry_price - sl_offset
                # Quantize TP UP, SL DOWN to the nearest tick size
                take_profit = (take_profit_raw / min_tick).quantize(Decimal('1'), rounding=ROUND_UP) * min_tick
                stop_loss = (stop_loss_raw / min_tick).quantize(Decimal('1'), rounding=ROUND_DOWN) * min_tick

            elif signal == "SELL":
                tp_offset = atr * tp_multiple
                sl_offset = atr * sl_multiple
                take_profit_raw = entry_price - tp_offset
                stop_loss_raw = entry_price + sl_offset
                # Quantize TP DOWN, SL UP to the nearest tick size
                take_profit = (take_profit_raw / min_tick).quantize(Decimal('1'), rounding=ROUND_DOWN) * min_tick
                stop_loss = (stop_loss_raw / min_tick).quantize(Decimal('1'), rounding=ROUND_UP) * min_tick


            # --- Validation ---
            # Ensure SL is actually beyond entry by at least one tick
            min_sl_distance = min_tick # Minimum distance from entry for SL
            if signal == "BUY" and stop_loss >= entry_price:
                adjusted_sl = (entry_price - min_sl_distance).quantize(min_tick, rounding=ROUND_DOWN)
                self.logger.warning(f"{NEON_YELLOW}BUY signal SL calculation ({stop_loss}) is too close to or above entry ({entry_price}). Adjusting SL down to {adjusted_sl}.{RESET}")
                stop_loss = adjusted_sl
            elif signal == "SELL" and stop_loss <= entry_price:
                adjusted_sl = (entry_price + min_sl_distance).quantize(min_tick, rounding=ROUND_UP)
                self.logger.warning(f"{NEON_YELLOW}SELL signal SL calculation ({stop_loss}) is too close to or below entry ({entry_price}). Adjusting SL up to {adjusted_sl}.{RESET}")
                stop_loss = adjusted_sl

            # Ensure TP is potentially profitable relative to entry (at least one tick away)
            min_tp_distance = min_tick # Minimum distance from entry for TP
            if signal == "BUY" and take_profit <= entry_price:
                adjusted_tp = (entry_price + min_tp_distance).quantize(min_tick, rounding=ROUND_UP)
                self.logger.warning(f"{NEON_YELLOW}BUY signal TP calculation ({take_profit}) resulted in non-profitable level. Adjusting TP up to {adjusted_tp}.{RESET}")
                take_profit = adjusted_tp
            elif signal == "SELL" and take_profit >= entry_price:
                adjusted_tp = (entry_price - min_tp_distance).quantize(min_tick, rounding=ROUND_DOWN)
                self.logger.warning(f"{NEON_YELLOW}SELL signal TP calculation ({take_profit}) resulted in non-profitable level. Adjusting TP down to {adjusted_tp}.{RESET}")
                take_profit = adjusted_tp

            # Final checks: Ensure SL/TP are still valid (positive price) after adjustments
            if stop_loss is not None and stop_loss <= 0:
                self.logger.error(f"{NEON_RED}Stop loss calculation resulted in zero or negative price ({stop_loss}) for {self.symbol}. Cannot set SL.{RESET}")
                stop_loss = None
            if take_profit is not None and take_profit <= 0:
                self.logger.error(f"{NEON_RED}Take profit calculation resulted in zero or negative price ({take_profit}) for {self.symbol}. Cannot set TP.{RESET}")
                take_profit = None

            # Format for logging
            tp_log = f"{take_profit:.{price_precision}f}" if take_profit else 'N/A'
            sl_log = f"{stop_loss:.{price_precision}f}" if stop_loss else 'N/A'
            atr_log = f"{atr:.{price_precision+1}f}" if atr else 'N/A'
            entry_log = f"{entry_price:.{price_precision}f}" if entry_price else 'N/A'

            self.logger.debug(f"Calculated TP/SL for {self.symbol} {signal}: Entry={entry_log}, TP={tp_log}, SL={sl_log}, ATR={atr_log}")
            return entry_price, take_profit, stop_loss

        except Exception as e:
            self.logger.error(f"{NEON_RED}Error calculating TP/SL for {self.symbol}: {e}{RESET}", exc_info=True)
            return entry_price, None, None

# --- Trading Logic Helper Functions ---

def fetch_balance(exchange: ccxt.Exchange, currency: str, logger: logging.Logger) -> Optional[Decimal]:
    """Fetches the available balance for a specific currency, handling Bybit V5 structures."""
    lg = logger
    try:
        balance_info = None
        # For Bybit V5, specify the account type relevant to the market (e.g., CONTRACT, UNIFIED)
        # Let's prioritize 'CONTRACT' for derivatives, then 'UNIFIED', then default.
        account_types_to_try = ['CONTRACT', 'UNIFIED']

        for acc_type in account_types_to_try:
            try:
                lg.debug(f"Fetching balance using params={{'accountType': '{acc_type}'}} for {currency}...") # Use accountType for V5
                # Note: Some CCXT versions might still use 'type', others 'accountType' in params
                # Testing with 'accountType' first as per Bybit V5 docs
                balance_info = exchange.fetch_balance(params={'accountType': acc_type})
                # Store the attempted param for later parsing logic
                balance_info['params'] = {'accountType': acc_type}

                # Check if the desired currency is present in this balance info structure
                # Standard ccxt check:
                if currency in balance_info:
                    lg.debug(f"Found currency '{currency}' in balance structure using accountType '{acc_type}'.")
                    # Need to check if 'free' or equivalent exists within this structure
                    if balance_info[currency].get('free') is not None:
                         break # Found balance info with free balance directly
                    # Fallback: Check if 'info' structure has the currency data (Bybit V5 case)
                    elif 'info' in balance_info and 'result' in balance_info['info'] and 'list' in balance_info['info']['result']:
                        balance_list = balance_info['info']['result']['list']
                        if isinstance(balance_list, list):
                            found_in_nested = False
                            for account in balance_list:
                                # Match the account type explicitly if possible
                                if account.get('accountType') == acc_type:
                                    coin_list = account.get('coin')
                                    if isinstance(coin_list, list):
                                        if any(coin_data.get('coin') == currency for coin_data in coin_list):
                                            lg.debug(f"Currency '{currency}' confirmed in nested V5 balance structure (accountType: {acc_type}).")
                                            found_in_nested = True
                                            break # Found in this account's coin list
                            if found_in_nested:
                                break # Break outer loop too
                    # If neither standard 'free' nor nested V5 found, continue to next type
                    lg.debug(f"Currency '{currency}' found in balance structure (accountType '{acc_type}'), but missing 'free' or V5 nested data. Trying next type.")
                    balance_info = None # Reset to try next type

                # Check nested Bybit V5 structure directly if currency not top-level key
                elif 'info' in balance_info and 'result' in balance_info['info'] and 'list' in balance_info['info']['result']:
                    balance_list = balance_info['info']['result']['list']
                    if isinstance(balance_list, list):
                        found_in_nested = False
                        for account in balance_list:
                             # Match the account type explicitly if possible
                            if account.get('accountType') == acc_type:
                                coin_list = account.get('coin')
                                if isinstance(coin_list, list):
                                    if any(coin_data.get('coin') == currency for coin_data in coin_list):
                                        lg.debug(f"Found currency '{currency}' in nested V5 balance structure using accountType '{acc_type}'.")
                                        found_in_nested = True
                                        break # Found in this account's coin list
                        if found_in_nested:
                            lg.debug(f"Using balance_info from successful nested check (accountType: {acc_type})")
                            break # Break outer loop too

                lg.debug(f"Currency '{currency}' not found in balance structure using accountType '{acc_type}'. Trying next.")
                balance_info = None # Reset if currency not found in this structure

            except ccxt.ExchangeError as e:
                # Ignore errors indicating the account type doesn't exist, try the next one
                if "account type not support" in str(e).lower() or "invalid account type" in str(e).lower():
                    lg.debug(f"Account type '{acc_type}' not supported or error fetching: {e}. Trying next.")
                    continue
                else:
                    lg.warning(f"Exchange error fetching balance for account type {acc_type}: {e}. Trying next.")
                    continue # Try next type on other exchange errors too? Maybe safer.
            except Exception as e:
                lg.warning(f"Unexpected error fetching balance for account type {acc_type}: {e}. Trying next.")
                continue

        # If specific account types failed, try default fetch_balance without params
        if not balance_info:
            lg.debug(f"Fetching balance using default parameters for {currency}...")
            try:
                balance_info = exchange.fetch_balance()
                balance_info['params'] = {} # Mark as default fetch
            except Exception as e:
                lg.error(f"{NEON_RED}Failed to fetch balance using default parameters: {e}{RESET}")
                return None


        # --- Parse the balance_info ---
        available_balance_str = None

        # 1. Standard CCXT structure: balance_info[currency]['free']
        if currency in balance_info and 'free' in balance_info[currency] and balance_info[currency]['free'] is not None:
            available_balance_str = str(balance_info[currency]['free'])
            lg.debug(f"Found balance via standard ccxt structure ['{currency}']['free']: {available_balance_str}")

        # 2. Bybit V5 structure (often nested): Check 'info' -> 'result' -> 'list'
        elif 'info' in balance_info and 'result' in balance_info['info'] and isinstance(balance_info['info']['result'].get('list'), list):
            balance_list = balance_info['info']['result']['list']
            # Determine which account type was likely successful or used for default fetch
            successful_acc_type = balance_info.get('params',{}).get('accountType') # Get type used in the successful call

            for account in balance_list:
                current_account_type = account.get('accountType')
                # If we know the successful type, only check that.
                # If default fetch was used (successful_acc_type is None), check all accounts in the list.
                if successful_acc_type is None or current_account_type == successful_acc_type:
                    coin_list = account.get('coin')
                    if isinstance(coin_list, list):
                        for coin_data in coin_list:
                            if coin_data.get('coin') == currency:
                                # Prefer Bybit V5 'availableToWithdraw' or 'availableBalance'
                                free = coin_data.get('availableToWithdraw')
                                if free is None: free = coin_data.get('availableBalance') # Bybit's preferred field for V5 Contract/Unified
                                # Fallback to walletBalance only if others are missing (might include unrealized PnL)
                                if free is None: free = coin_data.get('walletBalance')

                                if free is not None:
                                    available_balance_str = str(free)
                                    lg.debug(f"Found balance via Bybit V5 nested structure: {available_balance_str} {currency} (Account: {current_account_type or 'N/A'})")
                                    break # Found the currency
                        if available_balance_str is not None: break # Stop searching accounts
            if available_balance_str is None:
                lg.warning(f"{currency} not found within Bybit V5 'info.result.list[].coin[]' structure for relevant account type(s).")

        # 3. Fallback: Check top-level 'free' dictionary if present
        elif 'free' in balance_info and currency in balance_info['free'] and balance_info['free'][currency] is not None:
            available_balance_str = str(balance_info['free'][currency])
            lg.debug(f"Found balance via top-level 'free' dictionary: {available_balance_str} {currency}")

        # 4. Last Resort: Check 'total' balance if 'free' is still missing
        if available_balance_str is None:
            total_balance = None
            if currency in balance_info and 'total' in balance_info[currency] and balance_info[currency]['total'] is not None:
                total_balance = balance_info[currency]['total']
            # Add check for Bybit nested total if primary failed
            elif 'info' in balance_info and 'result' in balance_info['info'] and isinstance(balance_info['info']['result'].get('list'), list):
                 balance_list = balance_info['info']['result']['list']
                 successful_acc_type = balance_info.get('params',{}).get('accountType') # Re-check successful type
                 for account in balance_list:
                    current_account_type = account.get('accountType')
                    if successful_acc_type is None or current_account_type == successful_acc_type:
                        coin_list = account.get('coin')
                        if isinstance(coin_list, list):
                            for coin_data in coin_list:
                                if coin_data.get('coin') == currency:
                                    total_balance = coin_data.get('walletBalance') # Use walletBalance as total proxy
                                    if total_balance is not None: break
                            if total_balance is not None: break
                 if total_balance is not None:
                      lg.debug(f"Using 'walletBalance' ({total_balance}) from nested structure as 'total' fallback.")


            if total_balance is not None:
                lg.warning(f"{NEON_YELLOW}Could not determine 'free'/'available' balance for {currency}. Using 'total' balance ({total_balance}) as fallback. This might include collateral/unrealized PnL.{RESET}")
                available_balance_str = str(total_balance)
            else:
                lg.error(f"{NEON_RED}Could not determine any balance for {currency}. Balance info structure not recognized or currency missing.{RESET}")
                lg.debug(f"Full balance_info structure: {balance_info}") # Log structure for debugging
                return None

        # --- Convert to Decimal ---
        try:
            final_balance = Decimal(available_balance_str)
            if final_balance >= 0: # Allow zero balance
                lg.info(f"Available {currency} balance: {final_balance:.4f}")
                return final_balance
            else:
                lg.error(f"Parsed balance for {currency} is negative ({final_balance}). Returning None.")
                return None
        except Exception as e:
            lg.error(f"Failed to convert balance string '{available_balance_str}' to Decimal for {currency}: {e}")
            return None

    except ccxt.AuthenticationError as e:
        lg.error(f"{NEON_RED}Authentication error fetching balance: {e}. Check API key permissions.{RESET}")
        return None
    except ccxt.NetworkError as e:
        lg.error(f"{NEON_RED}Network error fetching balance: {e}{RESET}")
        # Consider if balance fetch should be retried or if failure is critical
        return None
    except ccxt.ExchangeError as e:
        lg.error(f"{NEON_RED}Exchange error fetching balance: {e}{RESET}")
        return None
    except Exception as e:
        lg.error(f"{NEON_RED}Unexpected error fetching balance: {e}{RESET}", exc_info=True)
        return None

def get_market_info(exchange: ccxt.Exchange, symbol: str, logger: logging.Logger) -> Optional[Dict]:
    """Gets market information like precision, limits, contract type, ensuring markets are loaded."""
    lg = logger
    try:
        # Ensure markets are loaded; reload if symbol is missing
        if not exchange.markets or symbol not in exchange.markets:
            lg.info(f"Market info for {symbol} not loaded or symbol missing, reloading markets...")
            exchange.load_markets(reload=True) # Force reload

        # Check again after reloading
        if symbol not in exchange.markets:
            lg.error(f"{NEON_RED}Market {symbol} still not found after reloading markets. Check symbol spelling and availability on {exchange.id}.{RESET}")
            return None

        market = exchange.market(symbol)
        if market:
            # Log key details for confirmation and debugging
            market_type = market.get('type', 'unknown') # spot, swap, future etc.
            contract_type = "Linear" if market.get('linear') else "Inverse" if market.get('inverse') else "N/A"
            # Add contract flag for easier checking later
            market['is_contract'] = market.get('contract', False) or market_type in ['swap', 'future']

            # --- Derive tick size if missing using TradingAnalyzer helper ---
            # This adds the tick size to the market dict for later use
            if market.get('precision', {}).get('tick') is None:
                 lg.debug(f"Attempting to derive missing tick size for {symbol}...")
                 # Use a temporary analyzer instance just for the helper method
                 # Requires a valid DataFrame structure even if empty
                 dummy_df = pd.DataFrame(columns=['open', 'high', 'low', 'close', 'volume'])
                 dummy_df.index.name = 'timestamp'
                 try:
                     # Pass market info to the temporary analyzer
                     analyzer_temp = TradingAnalyzer(dummy_df, lg, {}, market)
                     min_tick = analyzer_temp.get_min_tick_size() # Use the robust helper
                     if min_tick > 0:
                         if 'precision' not in market: market['precision'] = {}
                         # Store as float for consistency with how ccxt often represents it
                         market['precision']['tick'] = float(min_tick)
                         lg.debug(f"Added derived min tick size {min_tick} to market info precision.")
                     else:
                         lg.warning(f"Could not derive a valid positive tick size for {symbol}.")
                 except ValueError as ve: # Catch error if market_info was invalid
                      lg.warning(f"Could not derive min tick size due to issue with market info: {ve}")
                 except Exception as e_tick:
                      lg.warning(f"Error deriving min tick size: {e_tick}")

            # --- Log derived info ---
            # Safely get precision values for logging
            precision_dict = market.get('precision', {})
            price_prec = precision_dict.get('price')
            amount_prec = precision_dict.get('amount')
            tick_prec = precision_dict.get('tick', 'N/A') # Use the derived value if available

            # Safely get limit values for logging
            limits_dict = market.get('limits', {})
            amount_limits = limits_dict.get('amount', {})
            cost_limits = limits_dict.get('cost', {})
            min_amount = amount_limits.get('min')
            max_amount = amount_limits.get('max')
            min_cost = cost_limits.get('min')
            max_cost = cost_limits.get('max')

            lg.debug(
                f"Market Info for {symbol}: ID={market.get('id')}, Type={market_type}, Contract={contract_type}, "
                f"Precision(Price/Amount/Tick): {price_prec}/{amount_prec}/{tick_prec}, "
                f"Limits(Amount Min/Max): {min_amount}/{max_amount}, "
                f"Limits(Cost Min/Max): {min_cost}/{max_cost}, "
                f"Contract Size: {market.get('contractSize', 'N/A')}"
            )
            return market
        else:
            # Should have been caught by the 'in exchange.markets' check, but safeguard
            lg.error(f"{NEON_RED}Market dictionary not found for {symbol} even after checking exchange.markets.{RESET}")
            return None
    except ccxt.BadSymbol as e:
        lg.error(f"{NEON_RED}Symbol '{symbol}' is not supported by {exchange.id} or is incorrectly formatted: {e}{RESET}")
        return None
    except ccxt.NetworkError as e:
        lg.error(f"{NEON_RED}Network error loading markets info for {symbol}: {e}{RESET}")
        return None
    except ccxt.ExchangeError as e:
        lg.error(f"{NEON_RED}Exchange error loading markets info for {symbol}: {e}{RESET}")
        return None
    except Exception as e:
        lg.error(f"{NEON_RED}Unexpected error getting market info for {symbol}: {e}{RESET}", exc_info=True)
        return None

def calculate_position_size(
    balance: Decimal,
    risk_per_trade: float,
    initial_stop_loss_price: Decimal, # The calculated initial SL price (Decimal)
    entry_price: Decimal, # Estimated entry price (e.g., current market price) (Decimal)
    market_info: Dict,
    exchange: ccxt.Exchange, # Pass exchange object for formatting helpers
    logger: Optional[logging.Logger] = None
) -> Optional[Decimal]:
    """
    Calculates position size based on risk percentage, initial SL distance, balance,
    and market constraints (min/max size, precision, contract size). Returns Decimal size or None.
    """
    lg = logger or logging.getLogger(__name__)
    if not market_info:
        lg.error(f"Position sizing failed: Missing market_info.")
        return None
    symbol = market_info.get('symbol', 'UNKNOWN_SYMBOL')
    quote_currency = market_info.get('quote', QUOTE_CURRENCY)
    base_currency = market_info.get('base', 'BASE')
    is_contract = market_info.get('is_contract', False)
    size_unit = "Contracts" if is_contract else base_currency

    # --- Input Validation ---
    if balance is None or balance <= 0:
        lg.error(f"Position sizing failed for {symbol}: Invalid or zero balance ({balance} {quote_currency}).")
        return None
    if not (0 < risk_per_trade < 1):
        lg.error(f"Position sizing failed for {symbol}: Invalid risk_per_trade ({risk_per_trade}). Must be between 0 and 1 (exclusive).")
        return None
    if initial_stop_loss_price is None or entry_price is None or entry_price <= 0:
        lg.error(f"Position sizing failed for {symbol}: Missing or invalid entry_price ({entry_price}) or initial_stop_loss_price ({initial_stop_loss_price}).")
        return None
    if initial_stop_loss_price == entry_price:
        lg.error(f"Position sizing failed for {symbol}: Stop loss price ({initial_stop_loss_price}) cannot be the same as entry price ({entry_price}).")
        return None
    # Allow zero or negative stop loss price if it resulted from calculation, but warn
    if initial_stop_loss_price <= 0:
        lg.warning(f"Position sizing for {symbol}: Calculated initial stop loss price ({initial_stop_loss_price}) is zero or negative. Ensure SL calculation is correct.")
        # Do not return None here, let the distance calculation handle it

    if 'limits' not in market_info or 'precision' not in market_info:
        lg.error(f"Position sizing failed for {symbol}: Market info missing 'limits' or 'precision'. Market: {market_info}")
        return None

    try:
        # --- Calculate Risk Amount and Initial Size ---
        risk_amount_quote = balance * Decimal(str(risk_per_trade))
        sl_distance_per_unit = abs(entry_price - initial_stop_loss_price)

        if sl_distance_per_unit <= 0:
            lg.error(f"Position sizing failed for {symbol}: Stop loss distance is zero or negative ({sl_distance_per_unit}). Entry={entry_price}, SL={initial_stop_loss_price}")
            return None

        # Get contract size (usually 1 for linear/spot, can vary for inverse/options)
        contract_size_str = market_info.get('contractSize', '1')
        try:
            contract_size = Decimal(str(contract_size_str))
            if contract_size <= 0: raise ValueError("Contract size must be positive")
        except Exception:
            lg.warning(f"Could not parse contract size '{contract_size_str}' for {symbol}. Defaulting to 1.")
            contract_size = Decimal('1')


        # --- Calculate Size based on Market Type ---
        # For Linear contracts (Base/Quote, e.g., BTC/USDT) or Spot:
        # Size (in Base units or Contracts) = Risk Amount (Quote) / (SL Distance per Unit (Quote/Base) * Contract Size (Base/Contract))
        # For Inverse contracts (Quote/Base, e.g., USD/BTC -> BTC value per contract):
        # **WARNING**: Inverse calculation below is a simplified placeholder and likely needs exchange-specific adjustment.
        # It assumes `contractSize` represents the QUOTE value per contract (e.g., 1 for 1 USD).
        calculated_size = Decimal('0')
        if market_info.get('linear', True) or not is_contract: # Treat spot as linear type
            # Denominator represents risk per unit (base/contract) in quote currency
            risk_per_unit_quote = sl_distance_per_unit * contract_size
            if risk_per_unit_quote <= 0:
                lg.error(f"Position sizing failed for {symbol}: Risk per unit is zero or negative ({risk_per_unit_quote}). Check SL distance or contract size.")
                return None
            calculated_size = risk_amount_quote / risk_per_unit_quote
            lg.debug(f"  Linear/Spot Sizing: RiskAmt={risk_amount_quote:.4f} / (SLDist={sl_distance_per_unit} * ContSize={contract_size}) = {calculated_size}")
        else: # Potential Inverse contract logic
            lg.warning(f"{NEON_YELLOW}Inverse contract detected for {symbol}. Sizing calculation assumes `contractSize` ({contract_size}) is the Quote value per contract. VERIFY THIS LOGIC FOR {exchange.id}!{RESET}")
            # Formula: Size (Contracts) = Risk Amount (Quote) / Risk per Contract (Quote)
            # Risk per Contract (Quote) = SL Distance (Quote/Base) * Contract Value (Base/Contract)
            # Contract Value (Base/Contract) = Contract Value (Quote/Contract) / Entry Price (Quote/Base)
            # Here, assume Contract Value (Quote/Contract) IS the `contract_size` field from market_info.
            contract_value_quote = contract_size
            if entry_price > 0:
                 # Risk per contract in quote currency = size_of_1_contract_in_base * sl_distance_in_quote
                 # size_of_1_contract_in_base = contract_value_quote / entry_price
                 size_of_1_contract_in_base = contract_value_quote / entry_price
                 risk_per_contract_quote = size_of_1_contract_in_base * sl_distance_per_unit

                 if risk_per_contract_quote > 0:
                     calculated_size = risk_amount_quote / risk_per_contract_quote
                     lg.debug(f"  Inverse Sizing: Size1Base={size_of_1_contract_in_base}, RiskPerContQuote={risk_per_contract_quote}")
                     lg.debug(f"  Inverse Sizing: RiskAmt={risk_amount_quote:.4f} / RiskPerContQuote={risk_per_contract_quote} = {calculated_size}")
                 else:
                     lg.error(f"Position sizing failed for inverse contract {symbol}: Risk per contract calculation is zero or negative ({risk_per_contract_quote}).")
                     return None
            else:
                 lg.error(f"Position sizing failed for inverse contract {symbol}: Entry price is zero.")
                 return None


        lg.info(f"Position Sizing ({symbol}): Balance={balance:.2f} {quote_currency}, Risk={risk_per_trade:.2%}, Risk Amount={risk_amount_quote:.4f} {quote_currency}")
        lg.info(f"  Entry={entry_price}, SL={initial_stop_loss_price}, SL Distance={sl_distance_per_unit}")
        lg.info(f"  Contract Size={contract_size}, Initial Calculated Size = {calculated_size:.8f} {size_unit}")


        # --- Apply Market Limits and Precision ---
        limits = market_info.get('limits', {})
        amount_limits = limits.get('amount', {})
        cost_limits = limits.get('cost', {}) # Cost = size * price
        precision = market_info.get('precision', {})
        amount_precision_val = precision.get('amount') # Can be int (decimals) or float (step size)

        # Get min/max amount limits (size limits)
        min_amount_str = amount_limits.get('min')
        max_amount_str = amount_limits.get('max')
        min_amount = Decimal(str(min_amount_str)) if min_amount_str is not None else Decimal('0')
        max_amount = Decimal(str(max_amount_str)) if max_amount_str is not None else Decimal('inf')

        # Get min/max cost limits (value limits in quote currency)
        min_cost_str = cost_limits.get('min')
        max_cost_str = cost_limits.get('max')
        min_cost = Decimal(str(min_cost_str)) if min_cost_str is not None else Decimal('0')
        max_cost = Decimal(str(max_cost_str)) if max_cost_str is not None else Decimal('inf')


        # 1. Adjust size based on MIN/MAX AMOUNT limits
        adjusted_size = calculated_size
        if adjusted_size < min_amount:
            lg.warning(f"{NEON_YELLOW}Calculated size {adjusted_size:.8f} {size_unit} is below minimum amount {min_amount:.8f} {size_unit}. Adjusting to minimum.{RESET}")
            adjusted_size = min_amount
        elif adjusted_size > max_amount:
            lg.warning(f"{NEON_YELLOW}Calculated size {adjusted_size:.8f} {size_unit} exceeds maximum amount {max_amount:.8f} {size_unit}. Capping at maximum.{RESET}")
            adjusted_size = max_amount

        # 2. Check COST limits with the amount-adjusted size
        # Cost = Size * Entry Price * Contract Size (Contract size handles units -> quote value for linear)
        # For inverse, Cost = Size (Contracts) * Contract Value (Quote/Contract)
        current_cost = Decimal('0')
        if market_info.get('linear', True) or not is_contract:
            current_cost = adjusted_size * entry_price * contract_size
        else: # Inverse Cost (Size in Contracts * Contract Value in Quote)
            contract_value_quote = contract_size # Assumes contractSize holds the quote value
            current_cost = adjusted_size * contract_value_quote
            lg.debug(f"  Inverse Cost Calculation: Size={adjusted_size} * ContractValueQuote={contract_value_quote} = {current_cost}")


        lg.debug(f"  Cost Check: Amount-Adjusted Size={adjusted_size:.8f} {size_unit}, Estimated Cost={current_cost:.4f} {quote_currency}")
        lg.debug(f"  Cost Limits: Min={min_cost}, Max={max_cost}")

        if min_cost > 0 and current_cost < min_cost :
            lg.warning(f"{NEON_YELLOW}Estimated cost {current_cost:.4f} {quote_currency} (Size: {adjusted_size:.8f}) is below minimum cost {min_cost:.4f} {quote_currency}. Attempting to increase size.{RESET}")
            # Calculate required size to meet min cost
            required_size_for_min_cost = Decimal('0')
            if market_info.get('linear', True) or not is_contract:
                if entry_price > 0 and contract_size > 0:
                    required_size_for_min_cost = min_cost / (entry_price * contract_size)
                else:
                    lg.error("Cannot calculate size for min cost (linear) due to invalid entry price or contract size.")
                    return None
            else: # Inverse
                contract_value_quote = contract_size # Use contract_size as value
                if contract_value_quote > 0:
                     required_size_for_min_cost = min_cost / contract_value_quote
                else:
                     lg.error("Cannot calculate size for min cost (inverse) due to invalid contract value.")
                     return None

            lg.info(f"  Required size for min cost: {required_size_for_min_cost:.8f} {size_unit}")

            # Check if this required size is feasible (within amount limits)
            if required_size_for_min_cost > max_amount:
                lg.error(f"{NEON_RED}Cannot meet minimum cost {min_cost:.4f} without exceeding maximum amount {max_amount:.8f}. Trade aborted.{RESET}")
                return None
            # Check if required size is now below min_amount (conflicting limits)
            elif required_size_for_min_cost < min_amount:
                 lg.error(f"{NEON_RED}Conflicting limits: Min cost requires size {required_size_for_min_cost:.8f}, but min amount is {min_amount:.8f}. Trade aborted.{RESET}")
                 return None
            else:
                 lg.info(f"  Adjusting size to meet min cost: {required_size_for_min_cost:.8f} {size_unit}")
                 adjusted_size = required_size_for_min_cost
                 # Re-calculate cost for logging/final checks
                 if market_info.get('linear', True) or not is_contract:
                    current_cost = adjusted_size * entry_price * contract_size
                 else: # Inverse
                    contract_value_quote = contract_size # Use contract_size as value
                    current_cost = adjusted_size * contract_value_quote

        elif max_cost > 0 and current_cost > max_cost:
            lg.warning(f"{NEON_YELLOW}Estimated cost {current_cost:.4f} {quote_currency} exceeds maximum cost {max_cost:.4f} {quote_currency}. Reducing size.{RESET}")
            adjusted_size_for_max_cost = Decimal('0')
            if market_info.get('linear', True) or not is_contract:
                if entry_price > 0 and contract_size > 0:
                    adjusted_size_for_max_cost = max_cost / (entry_price * contract_size)
                else:
                    lg.error("Cannot calculate size for max cost (linear) due to invalid entry price or contract size.")
                    return None
            else: # Inverse
                contract_value_quote = contract_size # Use contract_size as value
                if contract_value_quote > 0:
                    adjusted_size_for_max_cost = max_cost / contract_value_quote
                else:
                    lg.error("Cannot calculate size for max cost (inverse) due to invalid contract value.")
                    return None


            lg.info(f"  Reduced size to meet max cost: {adjusted_size_for_max_cost:.8f} {size_unit}")

            # Check if this reduced size is now below min amount
            if adjusted_size_for_max_cost < min_amount:
                lg.error(f"{NEON_RED}Size reduced for max cost ({adjusted_size_for_max_cost:.8f}) is now below minimum amount {min_amount:.8f}. Cannot meet conflicting limits. Trade aborted.{RESET}")
                return None
            else:
                adjusted_size = adjusted_size_for_max_cost


        # 3. Apply Amount Precision/Step Size (using ccxt helper ideally, rounding DOWN)
        final_size = Decimal('0')
        try:
            # amount_to_precision usually expects a float input
            # Use exchange.amount_to_precision with TRUNCATE (equivalent to floor/ROUND_DOWN for positive numbers)
            # to ensure we don't exceed balance/risk due to rounding up size.
            formatted_size_str = exchange.amount_to_precision(symbol, float(adjusted_size), padding_mode=exchange.TRUNCATE)
            final_size = Decimal(formatted_size_str)
            lg.info(f"Applied amount precision/step (Truncated): {adjusted_size:.8f} -> {final_size} {size_unit} using exchange helper.")
        except Exception as fmt_err:
            lg.warning(f"{NEON_YELLOW}Could not use exchange.amount_to_precision for {symbol} ({fmt_err}). Using manual rounding (ROUND_DOWN) based on precision.{RESET}")
            # Fallback to manual rounding based on decimal places or step size derived from precision
            if amount_precision_val is not None:
                num_decimals = None
                step_size = None
                if isinstance(amount_precision_val, int):
                    num_decimals = amount_precision_val
                elif isinstance(amount_precision_val, (float, str)): # Assume it's step size
                    try:
                        step_size = Decimal(str(amount_precision_val))
                        if step_size <= 0: step_size = None # Invalidate non-positive step size
                        else:
                            # Infer decimals from step size for quantization
                            num_decimals = abs(step_size.normalize().as_tuple().exponent)
                    except Exception: pass # Ignore error if step size is invalid

                if step_size is not None and step_size > 0:
                    # Round down to the nearest step size increment
                    final_size = (adjusted_size // step_size) * step_size
                    lg.info(f"Applied manual amount step size ({step_size}), rounded down: {adjusted_size:.8f} -> {final_size} {size_unit}")
                elif num_decimals is not None and num_decimals >= 0:
                    rounding_factor = Decimal('1e-' + str(num_decimals))
                    # Important: Round DOWN for position size
                    final_size = adjusted_size.quantize(rounding_factor, rounding=ROUND_DOWN)
                    lg.info(f"Applied manual amount precision ({num_decimals} decimals), rounded down: {adjusted_size:.8f} -> {final_size} {size_unit}")
                else:
                    lg.warning(f"{NEON_YELLOW}Amount precision value ('{amount_precision_val}') invalid for {symbol}. Using size adjusted only for limits: {adjusted_size:.8f}{RESET}")
                    final_size = adjusted_size # Use the size adjusted for limits only
            else:
                lg.warning(f"{NEON_YELLOW}Amount precision not defined for {symbol}. Using size adjusted only for limits: {adjusted_size:.8f}{RESET}")
                final_size = adjusted_size

        # --- Final Validation ---
        if final_size <= 0:
            lg.error(f"{NEON_RED}Position size became zero or negative ({final_size}) after adjustments/rounding for {symbol}. Trade aborted.{RESET}")
            return None

        # Final check against min amount AFTER formatting/rounding
        if final_size < min_amount:
            # Use a small tolerance to account for potential float/decimal precision issues during comparison
            if not math.isclose(float(final_size), float(min_amount), rel_tol=1e-9):
                 lg.error(f"{NEON_RED}Final formatted size {final_size} {size_unit} is below minimum amount {min_amount} {size_unit} for {symbol}. Trade aborted.{RESET}")
                 return None
            else:
                 lg.warning(f"Final formatted size {final_size} is extremely close to min amount {min_amount}. Proceeding cautiously.")


        # Final check against min cost AFTER formatting/rounding
        final_cost = Decimal('0')
        if market_info.get('linear', True) or not is_contract:
            final_cost = final_size * entry_price * contract_size
        else: # Inverse placeholder
            contract_value_quote = contract_size # Use contract_size as value
            final_cost = final_size * contract_value_quote

        if min_cost > 0 and final_cost < min_cost:
             # Check if it's close enough due to rounding? Use tolerance.
            if not math.isclose(float(final_cost), float(min_cost), rel_tol=1e-6):
                 lg.error(f"{NEON_RED}Final formatted size {final_size} {size_unit} results in cost {final_cost:.4f} {quote_currency} which is below minimum cost {min_cost:.4f} {quote_currency} for {symbol}. Trade aborted.{RESET}")
                 return None
            else:
                 lg.warning(f"Final cost {final_cost} is very close to min cost {min_cost}. Proceeding cautiously.")


        lg.info(f"{NEON_GREEN}Final calculated position size for {symbol}: {final_size} {size_unit}{RESET}")
        return final_size

    except KeyError as e:
        lg.error(f"{NEON_RED}Position sizing error for {symbol}: Missing market info key {e}. Market: {market_info}{RESET}")
        return None
    except Exception as e:
        lg.error(f"{NEON_RED}Unexpected error calculating position size for {symbol}: {e}{RESET}", exc_info=True)
        return None

def get_open_position(exchange: ccxt.Exchange, symbol: str, logger: logging.Logger) -> Optional[Dict]:
    """
    Checks for an open position for the given symbol using fetch_positions.
    Returns the unified position dictionary from CCXT if an active position exists, otherwise None.
    Handles variations in position reporting (size > 0, side field, different API versions).
    Enhances the returned dict with SL/TP/TSL info parsed from the 'info' dict if available.
    """
    lg = logger
    try:
        lg.debug(f"Fetching positions for symbol: {symbol}")
        positions: List[Dict] = []
        market = None # Fetch market info for context

        # Bybit V5: fetch_positions usually requires the symbol
        # Some older APIs/exchanges might fetch all if symbol omitted
        fetch_all = False
        try:
            # Try fetching specific symbol first
            # Use params for Bybit V5 if needed (e.g., category)
            params = {}
            if 'bybit' in exchange.id.lower():
                 try:
                     market = get_market_info(exchange, symbol, lg) # Use helper to get market info
                     if not market: raise ValueError("Failed to get market info")
                 except Exception as e:
                     lg.warning(f"Error fetching market info for {symbol} within get_open_position: {e}. Assuming 'linear'.")
                     market = {'linear': True, 'symbol': symbol, 'id': symbol.replace('/', '')} # Create dummy market info

                 category = 'linear' if market and market.get('linear', True) else 'inverse'
                 params['category'] = category
                 # Use exchange ID (e.g., BTCUSDT) for Bybit V5 symbol param in fetch_positions
                 params['symbol'] = market['id']
                 lg.debug(f"Using params for fetch_positions: {params}")

            # Fetch positions for the specific symbol(s) using the derived params
            # Note: ccxt fetch_positions `symbols` arg might override params['symbol'] or vice-versa depending on version
            # Providing both might be redundant but safer. Using only params is often preferred for V5.
            positions = exchange.fetch_positions(symbols=None, params=params) # Pass symbols=None to rely on params

        except ccxt.ArgumentsRequired:
            lg.warning(f"Exchange {exchange.id} requires fetching all positions, then filtering. Fetching all...")
            fetch_all = True
        except ccxt.ExchangeError as e:
            # Handle errors like "symbol not found" if fetching single symbol failed
            if "symbol not found" in str(e).lower() or "instrument not found" in str(e).lower() or "invalid symbol" in str(e).lower():
                lg.warning(f"Symbol {symbol} not found when fetching position: {e}. Assuming no position.")
                return None
            # Handle Bybit V5 specific "no position found" error codes if fetching single
            # Bybit V5 can return retCode 0 but empty list, or specific error codes if symbol has NO position history
            # Example: 110021: Position is closed or does not exist
            no_pos_codes_v5 = [110021]
            bybit_code = getattr(e, 'code', None)
            if bybit_code in no_pos_codes_v5:
                lg.info(f"No position found for {symbol} (Exchange error code: {bybit_code} - {e}).")
                return None
            # Re-raise other exchange errors during single fetch
            lg.error(f"Exchange error fetching single position for {symbol}: {e}", exc_info=True)
            # Fallback to fetch_all might be risky, return None here.
            return None
        except Exception as e:
            lg.error(f"Error fetching single position for {symbol}: {e}", exc_info=True)
            # Fallback to fetching all? Assume failure for now.
            return None

        # Fetch all positions if required or as fallback
        if fetch_all:
            try:
                all_positions = exchange.fetch_positions()
                # Filter for the specific symbol (using ccxt 'symbol' field)
                positions = [p for p in all_positions if p.get('symbol') == symbol]
                lg.debug(f"Fetched {len(all_positions)} total positions, found {len(positions)} matching {symbol}.")
            except Exception as e:
                lg.error(f"Error fetching all positions for {symbol}: {e}", exc_info=True)
                return None # Cannot determine position state if fetch_all fails


        # --- Process the fetched positions (should be 0 or 1 for the symbol in One-Way mode) ---
        active_position = None
        if not positions:
            lg.info(f"No position entries returned for {symbol}.")
            return None

        for pos in positions:
            # Standardized field for size is 'contracts' (float or string)
            # Fallbacks: 'contractSize' (less common), 'info' dict specifics
            pos_size_str = None
            if pos.get('contracts') is not None: pos_size_str = str(pos['contracts'])
            elif pos.get('info', {}).get('size') is not None: pos_size_str = str(pos['info']['size']) # Bybit V5 'size'
            elif pos.get('contractSize') is not None: pos_size_str = str(pos['contractSize'])
            elif pos.get('info', {}).get('positionAmt') is not None: pos_size_str = str(pos['info']['positionAmt']) # Binance 'positionAmt'

            if pos_size_str is None:
                lg.debug(f"Could not find position size field in position data for {symbol}: {pos}")
                continue # Skip this entry if size cannot be determined

            # Check if size is valid and meaningfully non-zero
            try:
                position_size = Decimal(pos_size_str)
                # Use a small threshold based on minimum contract size if available, else small number
                min_size_threshold = Decimal('1e-9') # Default threshold
                if market: # Use market info fetched earlier if available
                    try:
                        min_amt = market.get('limits', {}).get('amount', {}).get('min')
                        if min_amt is not None:
                            # Use a fraction of min size, or a small absolute value if min_amt is tiny
                            min_size_threshold = max(Decimal('1e-9'), Decimal(str(min_amt)) * Decimal('0.01'))
                    except Exception: pass # Ignore errors fetching min size

                # Bybit V5 'size' is positive, side is in 'side' field. Older APIs might use signed size.
                # Check absolute size against threshold.
                if abs(position_size) > min_size_threshold:
                    # Found an active position
                    active_position = pos
                    lg.debug(f"Found potential active position entry for {symbol} with size {position_size}.")
                    break # Stop after finding the first active position entry
                else:
                    lg.debug(f"Position entry size {position_size} is not greater than threshold {min_size_threshold} for {symbol}. Skipping.")

            except Exception as e:
                lg.warning(f"Could not parse position size '{pos_size_str}' as Decimal for {symbol}. Skipping entry. Error: {e}")
                continue

        # --- Post-Process the found active position (if any) ---
        if active_position:
            # --- Determine Side ---
            side = active_position.get('side') # Standard 'long' or 'short'
            size_decimal = Decimal('0')
            try:
                # Try to get size from standard field or info dict again for side inference
                size_str_for_side = active_position.get('contracts', active_position.get('info',{}).get('size', '0'))
                size_decimal = Decimal(str(size_str_for_side))
            except Exception: pass # Ignore errors, fallback below

            size_threshold = Decimal('1e-9') # Re-define here for clarity

            # Infer side from size sign if 'side' field is missing, 'none', or ambiguous
            # Bybit V5: 'side' in info dict can be 'Buy', 'Sell', or 'None'
            if side not in ['long', 'short']:
                info_side = active_position.get('info', {}).get('side', 'None')
                if info_side == 'Buy': side = 'long'
                elif info_side == 'Sell': side = 'short'
                # If still not determined, use size sign (less reliable for V5)
                elif size_decimal > size_threshold: # Use threshold again
                    side = 'long'
                    lg.debug(f"Inferred side as 'long' from positive size {size_decimal} for {symbol}.")
                elif size_decimal < -size_threshold: # Use threshold again
                    side = 'short'
                    lg.debug(f"Inferred side as 'short' from negative size {size_decimal} for {symbol}.")
                    # CCXT often stores the absolute size in 'contracts' even for short.
                    # Ensure 'contracts' field holds the absolute value if we modify it.
                    # Bybit V5 'size' is usually positive, side is in 'side' field.
                    if 'contracts' in active_position:
                         active_position['contracts'] = abs(size_decimal) # Standardize 'contracts' field to positive
                else:
                    # This case should ideally not happen if size check passed, but handle defensively
                    lg.warning(f"Position size {size_decimal} is close to zero, could not determine side for {symbol}. Treating as no position.")
                    return None # Treat as no position if side cannot be reliably determined

                # Add inferred side back to the dictionary for consistency
                active_position['side'] = side

            # Ensure 'contracts' field is positive float/Decimal if it exists
            if active_position.get('contracts') is not None:
                 try:
                      current_contracts = Decimal(str(active_position['contracts']))
                      if current_contracts < 0:
                           active_position['contracts'] = abs(current_contracts)
                           lg.debug(f"Standardized 'contracts' field to positive value: {active_position['contracts']}")
                 except Exception: pass # Ignore if conversion fails


            # --- Enhance with SL/TP/TSL info directly if available ---
            # CCXT aims to standardize 'stopLossPrice', 'takeProfitPrice'
            # Check 'info' dict for exchange-specific fields (e.g., Bybit V5)
            info_dict = active_position.get('info', {})

            # Helper to extract and validate price from info dict, returning Decimal or None
            def get_valid_decimal_price_from_info(key: str) -> Optional[Decimal]:
                val_str = info_dict.get(key)
                # Bybit uses '0' or '0.0' for inactive, check non-empty and not just '0' variants
                if val_str and str(val_str).strip() and Decimal(str(val_str).strip()) != 0:
                    try:
                        price_dec = Decimal(str(val_str).strip())
                        if price_dec > 0:
                            return price_dec
                    except Exception: pass # Ignore conversion errors
                return None

            # Populate standard fields if missing, using validated values from info
            if active_position.get('stopLossPrice') is None:
                sl_val_dec = get_valid_decimal_price_from_info('stopLoss')
                if sl_val_dec: active_position['stopLossPrice'] = float(sl_val_dec) # CCXT expects float

            if active_position.get('takeProfitPrice') is None:
                tp_val_dec = get_valid_decimal_price_from_info('takeProfit')
                if tp_val_dec: active_position['takeProfitPrice'] = float(tp_val_dec) # CCXT expects float

            # Add TSL info if available - distance/value and activation price
            # Bybit V5: 'trailingStop' is the distance/value, 'activePrice' is TSL activation price
            # Store them even if '0' (inactive) for clarity
            # Convert to Decimal for internal use, store original string too?
            tsl_dist_str = info_dict.get('trailingStop', '0')
            tsl_act_str = info_dict.get('activePrice', '0')
            active_position['trailingStopLossDistance'] = tsl_dist_str # Store raw string
            active_position['tslActivationPrice'] = tsl_act_str # Store raw string

            # Add parsed Decimal versions for easier checks later
            try:
                 # Ensure distance is non-negative
                 tsl_dist_val = Decimal(tsl_dist_str) if tsl_dist_str else Decimal('0')
                 active_position['trailingStopLossDistanceDecimal'] = max(Decimal(0), tsl_dist_val)
            except Exception:
                 active_position['trailingStopLossDistanceDecimal'] = Decimal('0')
            try:
                 # Activation can be 0, ensure non-negative
                 tsl_act_val = Decimal(tsl_act_str) if tsl_act_str else Decimal('0')
                 active_position['tslActivationPriceDecimal'] = max(Decimal(0), tsl_act_val)
            except Exception:
                 active_position['tslActivationPriceDecimal'] = Decimal('0')


            # Helper function to format price/value for logging, handling None, '0', errors
            def format_log_value(key: str, value: Union[str, float, Decimal, None], precision: int = 6) -> str:
                if value is None or str(value).strip() == '': return 'N/A'
                try:
                    d_value = Decimal(str(value))
                    # Allow zero only for specific fields like TSL distance/activation if inactive
                    if d_value > 0:
                         # Dynamically determine precision if possible
                         if '.' in str(d_value):
                             num_decimals = abs(d_value.normalize().as_tuple().exponent)
                             precision = max(precision, num_decimals) # Use more precision if needed
                         return f"{d_value:.{precision}f}"
                    elif d_value == 0 and ('trailingstop' in key.lower() or 'tslactivation' in key.lower()):
                         return '0.0 (Inactive)' # Show inactive TSL as 0.0
                    elif d_value == 0:
                         return 'N/A' # Treat 0 as N/A for SL/TP/Entry etc. unless TSL field
                    else: # Negative values
                        # For PnL, format negative. For Size/Contracts, format absolute. For others, treat as invalid?
                        if 'pnl' in key.lower():
                             return f"{d_value:.{precision}f}"
                        elif key.lower() in ['size', 'contracts']:
                            return f"{abs(d_value):.{precision}f}" # Show absolute size
                        else:
                             return 'Invalid (<0)'
                except Exception:
                    return str(value) # Return raw if conversion fails

            # --- Log Position Details ---
            # Re-fetch market info if it wasn't available earlier
            if not market:
                 try:
                     market = get_market_info(exchange, symbol, lg)
                 except Exception: pass # Ignore errors, use defaults

            log_precision = 8 # Default price precision if market info fails
            amount_precision = 8 # Default amount precision
            if market:
                # Use the more robust get_price_precision helper
                try:
                    # Need a dummy analyzer instance to call the helper
                    dummy_df = pd.DataFrame(columns=['open', 'high', 'low', 'close', 'volume'])
                    dummy_df.index.name = 'timestamp'
                    analyzer_temp = TradingAnalyzer(dummy_df, lg, {}, market)
                    log_precision = analyzer_temp.get_price_precision()
                except Exception: pass
                 # Handle amount precision being int (decimals) or float (step size)
                amount_precision_val = market.get('precision', {}).get('amount')
                try:
                    if amount_precision_val is not None:
                        if isinstance(amount_precision_val, int):
                             amount_precision = amount_precision_val
                        else: # Assume float/string step size
                             amount_precision = abs(Decimal(str(amount_precision_val)).normalize().as_tuple().exponent)
                except Exception: pass


            entry_price_val = active_position.get('entryPrice', info_dict.get('avgPrice'))
            entry_price = format_log_value('entryPrice', entry_price_val, log_precision)
            contracts_val = active_position.get('contracts', info_dict.get('size'))
            contracts = format_log_value('contracts', contracts_val, amount_precision)
            liq_price = format_log_value('liquidationPrice', active_position.get('liquidationPrice'), log_precision)
            leverage_str = active_position.get('leverage', info_dict.get('leverage'))
            leverage = f"{Decimal(str(leverage_str)):.1f}x" if leverage_str is not None else 'N/A'
            pnl_val = active_position.get('unrealizedPnl')
            pnl = format_log_value('unrealizedPnl', pnl_val, 4)
            sl_price = format_log_value('stopLossPrice', active_position.get('stopLossPrice'), log_precision)
            tp_price = format_log_value('takeProfitPrice', active_position.get('takeProfitPrice'), log_precision)
            # Use the parsed Decimal for check, format the string for log
            is_tsl_active_log = active_position.get('trailingStopLossDistanceDecimal', Decimal(0)) > 0
            tsl_dist_log = format_log_value('trailingStopLossDistance', active_position.get('trailingStopLossDistance'), log_precision)
            tsl_act_log = format_log_value('tslActivationPrice', active_position.get('tslActivationPrice'), log_precision)


            logger.info(f"{NEON_GREEN}Active {side.upper()} position found for {symbol}:{RESET} "
                        f"Size={contracts}, Entry={entry_price}, Liq={liq_price}, "
                        f"Leverage={leverage}, PnL={pnl}, SL={sl_price}, TP={tp_price}, "
                        f"TSL Active: {is_tsl_active_log} (Dist={tsl_dist_log}/Act={tsl_act_log})")
            logger.debug(f"Full position details for {symbol}: {active_position}")
            return active_position
        else:
            # If loop completes without finding a non-zero position
            logger.info(f"No active open position found for {symbol}.")
            return None

    except ccxt.AuthenticationError as e:
        lg.error(f"{NEON_RED}Authentication error fetching positions for {symbol}: {e}{RESET}")
    except ccxt.NetworkError as e:
        lg.error(f"{NEON_RED}Network error fetching positions for {symbol}: {e}{RESET}")
    except ccxt.ExchangeError as e:
        # Handle errors that might indicate no position gracefully (e.g., Bybit V5 retCode != 0)
        no_pos_msgs = ['position idx not exist', 'no position found', 'position does not exist']
        no_pos_codes = [110021] # Bybit V5: Position is closed or does not exist
        err_str = str(e).lower()
        err_code = getattr(e, 'code', None)

        if any(msg in err_str for msg in no_pos_msgs) or (err_code in no_pos_codes):
            lg.info(f"No open position found for {symbol} (Confirmed by exchange error: {e}).")
            return None
        # Bybit V5 might return success (retCode 0) but an empty list if no position - handled by the loop logic above.
        lg.error(f"{NEON_RED}Unhandled Exchange error fetching positions for {symbol}: {e} (Code: {err_code}){RESET}")
    except Exception as e:
        lg.error(f"{NEON_RED}Unexpected error fetching positions for {symbol}: {e}{RESET}", exc_info=True)

    return None


def set_leverage_ccxt(exchange: ccxt.Exchange, symbol: str, leverage: int, market_info: Dict, logger: logging.Logger) -> bool:
    """Sets leverage for a symbol using CCXT, handling Bybit V5 specifics and verification hints."""
    lg = logger
    if not market_info:
        lg.error(f"Leverage setting failed for {symbol}: Missing market_info.")
        return False
    is_contract = market_info.get('is_contract', False)

    if not is_contract:
        lg.info(f"Leverage setting skipped for {symbol} (Not a contract market).")
        return True # Success if not applicable

    if leverage <= 0:
        lg.warning(f"Leverage setting skipped for {symbol}: Invalid leverage value ({leverage}). Must be > 0.")
        return False

    # --- Check exchange capability ---
    if not exchange.has.get('setLeverage'):
        lg.error(f"{NEON_RED}Exchange {exchange.id} does not support set_leverage method via CCXT capabilities.{RESET}")
        # TODO: Could implement direct API call here if needed as a fallback.
        return False

    try:
        lg.info(f"Attempting to set leverage for {symbol} to {leverage}x...")

        # --- Prepare Bybit V5 specific parameters (if applicable) ---
        # Bybit V5 often requires setting buy and sell leverage, especially for Isolated Margin.
        # For Cross Margin, setting just one might suffice, but setting both is safer.
        # Assume we need to set both for robustness unless we know margin mode.
        params = {}
        if 'bybit' in exchange.id.lower():
            # Fetch current margin mode if possible to avoid errors
            margin_mode = None
            try:
                # Using fetch_position for margin mode info (might be in 'info')
                # Need to handle case where there's NO position yet
                pos_info = get_open_position(exchange, symbol, lg) # Use our enhanced function
                if pos_info:
                    margin_mode = pos_info.get('marginMode') # Standard ccxt field
                    if margin_mode is None:
                        trade_mode_val = pos_info.get('info', {}).get('tradeMode') # Bybit V5 'tradeMode' (0: Cross, 1: Isolated)
                        if trade_mode_val == 0: margin_mode = 'cross'
                        elif trade_mode_val == 1: margin_mode = 'isolated'
                    lg.debug(f"Detected margin mode from existing position for {symbol}: {margin_mode}")
                else:
                    # If no position, we can't reliably get the *symbol's* current margin mode.
                    # Assume the user has set it correctly on the exchange.
                    lg.debug(f"No existing position for {symbol}, cannot detect margin mode automatically. Assuming Isolated/Cross based on account default.")

            except Exception as e:
                lg.warning(f"Could not reliably fetch margin mode for {symbol} before setting leverage: {e}. Proceeding cautiously.")

            # Bybit V5 set_leverage endpoint seems to require buy/sell for both modes now.
            # Use string representation for leverage in params for Bybit.
            params = {
                'buyLeverage': str(leverage),
                'sellLeverage': str(leverage),
                # 'positionIdx': 0 # Not needed for setLeverage endpoint usually
            }
            # Category might be needed depending on ccxt version/implementation
            category = 'linear' if market_info.get('linear', True) else 'inverse'
            params['category'] = category
            lg.debug(f"Using Bybit V5 specific params for set_leverage: {params}")


        # --- Call set_leverage ---
        # The `leverage` argument is the primary value, `params` provides extra details
        response = exchange.set_leverage(leverage=leverage, symbol=symbol, params=params)

        # Log response for debugging, but success isn't guaranteed by non-exception response
        lg.debug(f"Set leverage raw response for {symbol}: {response}")

        # --- Verification ---
        # A successful response (no exception, or specific success code/message) implies success.
        # Bybit V5 response might contain retCode=0 on success.
        verified = False
        if response is not None:
            if isinstance(response, dict):
                 # Check Bybit V5 specific response structure
                 ret_code = response.get('retCode', response.get('info', {}).get('retCode')) # Check top level or nested info
                 if ret_code == 0:
                     lg.debug(f"Set leverage call for {symbol} confirmed success (retCode 0).")
                     verified = True
                 elif ret_code is not None: # Got a non-zero retCode
                      # Check for "leverage not modified" code
                      if ret_code == 110045:
                          lg.info(f"{NEON_YELLOW}Leverage for {symbol} already set to {leverage}x (Exchange confirmation: Code {ret_code}).{RESET}")
                          verified = True # Treat as success
                      else:
                          ret_msg = response.get('retMsg', response.get('info', {}).get('retMsg', 'Unknown Error'))
                          lg.warning(f"Set leverage call for {symbol} returned non-zero retCode {ret_code} ({ret_msg}). Treating as failure.")
                          verified = False # Treat as failure if non-zero code returned
                 else:
                      # No retCode found, rely on lack of exception
                      lg.debug(f"Set leverage call for {symbol} returned a response (no retCode found). Assuming success if no error.")
                      verified = True
            else:
                 # Response is not a dict, rely on lack of exception
                 lg.debug(f"Set leverage call for {symbol} returned non-dict response. Assuming success if no error.")
                 verified = True
        else:
            # If response is None, it *might* still be okay, but less certain.
            # Bybit V5 setLeverage might return None on success via ccxt sometimes. Rely on no exception.
            lg.debug(f"Set leverage call for {symbol} returned None. Assuming success as no error was raised.")
            verified = True # Tentative


        if verified:
            lg.info(f"{NEON_GREEN}Leverage for {symbol} successfully set/requested to {leverage}x.{RESET}")
            return True
        else:
            lg.error(f"{NEON_RED}Leverage setting failed for {symbol} based on response analysis.{RESET}")
            return False


    except ccxt.NetworkError as e:
        lg.error(f"{NEON_RED}Network error setting leverage for {symbol}: {e}{RESET}")
    except ccxt.ExchangeError as e:
        err_str = str(e).lower()
        bybit_code = getattr(e, 'code', None) # CCXT often maps Bybit retCode to e.code
        lg.error(f"{NEON_RED}Exchange error setting leverage for {symbol}: {e} (Code: {bybit_code}){RESET}")

        # --- Handle Common Bybit V5 Leverage Errors ---
        # Code 110045: Leverage not modified (already set to the target value)
        if bybit_code == 110045 or "leverage not modified" in err_str:
            lg.info(f"{NEON_YELLOW}Leverage for {symbol} already set to {leverage}x (Exchange confirmation: Code {bybit_code}).{RESET}")
            return True # Treat as success

        # Code 110028: Need to set margin mode first (e.g., switch to Isolated)
        elif bybit_code == 110028 or "set margin mode first" in err_str or "switch margin mode" in err_str:
            lg.error(f"{NEON_YELLOW} >> Hint: Ensure Margin Mode (Isolated/Cross) is set correctly for {symbol} *before* setting leverage. Check Bybit Account Settings. Cannot set Isolated leverage in Cross mode.{RESET}")

        # Code 110044: Leverage exceeds risk limit tier
        elif bybit_code == 110044 or "risk limit" in err_str:
            lg.error(f"{NEON_YELLOW} >> Hint: Leverage {leverage}x might exceed the risk limit for your account tier or selected margin mode. Check Bybit Risk Limit documentation.{RESET}")

        # Code 110009: Position is in cross margin mode (when trying to set Isolated?)
        elif bybit_code == 110009 or "position is in cross margin mode" in err_str:
            lg.error(f"{NEON_YELLOW} >> Hint: Cannot set leverage individually if symbol is using Cross Margin. Switch symbol to Isolated first, or set cross leverage for the whole account margin coin.{RESET}")

        # Code 110013: Parameter error (e.g., invalid leverage value for market)
        elif bybit_code == 110013 or "parameter error" in err_str:
            lg.error(f"{NEON_YELLOW} >> Hint: Leverage value {leverage}x might be invalid for this specific symbol {symbol}. Check allowed leverage range on Bybit.{RESET}")

        # Other common messages
        elif "available balance not enough" in err_str:
            lg.error(f"{NEON_YELLOW} >> Hint: May indicate insufficient available margin if using Isolated Margin and increasing leverage requires more margin allocation possibility, although less common for just setting leverage.{RESET}")

    except Exception as e:
        lg.error(f"{NEON_RED}Unexpected error setting leverage for {symbol}: {e}{RESET}", exc_info=True)

    return False


def place_trade(
    exchange: ccxt.Exchange,
    symbol: str,
    trade_signal: str, # "BUY" or "SELL"
    position_size: Decimal, # Size calculated previously (Decimal)
    market_info: Dict,
    logger: Optional[logging.Logger] = None,
    reduce_only: bool = False # Added flag for closing trades
) -> Optional[Dict]:
    """
    Places a market order using CCXT. Can be used for opening or closing (with reduce_only=True).
    Returns the order dictionary on success, None on failure.
    SL/TP/TSL should be set *after* opening trades and verifying position.
    """
    lg = logger or logging.getLogger(__name__)
    if not market_info:
        lg.error(f"Trade aborted ({symbol}): Missing market_info.")
        return None
    side = 'buy' if trade_signal == "BUY" else 'sell'
    order_type = 'market'
    base_currency = market_info.get('base', '')
    is_contract = market_info.get('is_contract', False)
    size_unit = "Contracts" if is_contract else base_currency

    # Convert Decimal size to float for ccxt create_order amount parameter
    try:
        # Use absolute size for amount, side determines direction
        amount_float = float(abs(position_size))
        if amount_float <= 0:
            lg.error(f"Trade aborted ({symbol} {side} reduce={reduce_only}): Invalid position size for order amount ({amount_float}). Must be positive.")
            return None
    except Exception as e:
        lg.error(f"Trade aborted ({symbol} {side} reduce={reduce_only}): Failed to convert position size {position_size} to float: {e}")
        return None

    # --- Prepare Order Parameters ---
    params = {
        # Bybit V5: Specify position index for One-Way vs Hedge mode
        # Assuming One-Way mode (positionIdx=0) is default/required
        'positionIdx': 0,
        'reduceOnly': reduce_only, # Use the passed flag
        # 'timeInForce': 'IOC', # Optional: Market orders usually fill quickly anyway
        # 'closeOnTrigger': False, # Default is False
    }
    # Add category for Bybit V5
    if 'bybit' in exchange.id.lower():
        category = 'linear' if market_info.get('linear', True) else 'inverse'
        params['category'] = category

    action = "Closing" if reduce_only else "Opening"
    lg.info(f"Attempting to place {side.upper()} {order_type} order ({action}) for {symbol}:")
    lg.info(f"  Size: {amount_float:.8f} {size_unit}")
    lg.info(f"  Params: {params}")

    try:
        # --- Execute Market Order ---
        order = exchange.create_order(
            symbol=symbol,
            type=order_type,
            side=side,
            amount=amount_float,
            price=None, # Market order doesn't need price
            params=params
        )

        # --- Log Success and Basic Order Details ---
        order_id = order.get('id', 'N/A')
        order_status = order.get('status', 'N/A') # Market orders might be 'closed' quickly or 'open' initially
        lg.info(f"{NEON_GREEN}Trade Order Placed Successfully ({action})! Order ID: {order_id}, Initial Status: {order_status}{RESET}")
        lg.debug(f"Raw order response ({symbol} {side} reduce={reduce_only}): {order}") # Log the full order response

        # IMPORTANT: Market orders might not fill instantly or exactly at the desired price.
        # The calling function MUST wait and verify the resulting position using get_open_position
        # especially after opening trades, to get the actual entry price before setting protection.
        # For closing trades, verification is also good practice.
        return order # Return the order dictionary

    # --- Error Handling ---
    except ccxt.InsufficientFunds as e:
        lg.error(f"{NEON_RED}Insufficient funds to place {side} order ({action}) for {symbol}: {e}{RESET}")
        bybit_code = getattr(e, 'code', None)
        # Log balance info if possible
        try:
            balance = fetch_balance(exchange, QUOTE_CURRENCY, lg)
            lg.error(f"  Available {QUOTE_CURRENCY} balance: {balance}")
            # Hint based on Bybit codes
            if bybit_code == 110007:
                lg.error(f"{NEON_YELLOW} >> Hint (Code {bybit_code}): Check available margin balance, leverage, and if order cost exceeds balance. Cost ~ Size * Price / Leverage.{RESET}")
        except Exception as bal_err:
            lg.error(f"  Could not fetch balance for context: {bal_err}")

    except ccxt.InvalidOrder as e:
        lg.error(f"{NEON_RED}Invalid order parameters for {symbol} ({action}): {e}{RESET}")
        bybit_code = getattr(e, 'code', None)
        lg.error(f"  Size: {amount_float}, Type: {order_type}, Side: {side}, Params: {params}")
        lg.error(f"  Market Limits: Amount={market_info.get('limits',{}).get('amount')}, Cost={market_info.get('limits',{}).get('cost')}")
        lg.error(f"  Market Precision: Amount={market_info.get('precision',{}).get('amount')}, Price={market_info.get('precision',{}).get('price')}")
        # Hint based on Bybit codes
        if bybit_code == 10001 and "parameter error" in str(e).lower():
            lg.error(f"{NEON_YELLOW} >> Hint (Code {bybit_code}): Check if size/price violates precision or limits.{RESET}")
        elif bybit_code == 110017: # Order quantity exceeds limit
            lg.error(f"{NEON_YELLOW} >> Hint (Code {bybit_code}): Order size {amount_float} might violate exchange's min/max quantity per order.{RESET}")
        elif bybit_code == 110040: # Order size is less than the minimum order size
             lg.error(f"{NEON_YELLOW} >> Hint (Code {bybit_code}): Order size {amount_float} is below the minimum allowed. Check `calculate_position_size` logic and market limits.{RESET}")
        elif bybit_code == 110014 and reduce_only: # Reduce-only order failed
             lg.error(f"{NEON_YELLOW} >> Hint (Code {bybit_code}): Reduce-only close order failed. Size ({amount_float}) might exceed open position, position already closed, or API issue?{RESET}")

    except ccxt.NetworkError as e:
        lg.error(f"{NEON_RED}Network error placing order ({action}) for {symbol}: {e}{RESET}")
        # Order placement is critical, might need specific retry/state handling here,
        # but for now, we assume failure if network error occurs during placement.

    except ccxt.ExchangeError as e:
        # Handle specific Bybit V5 error codes for better diagnostics
        bybit_code = getattr(e, 'code', None) # CCXT often maps retCode to e.code
        err_str = str(e).lower()
        lg.error(f"{NEON_RED}Exchange error placing order ({action}) for {symbol}: {e} (Code: {bybit_code}){RESET}")

        # --- Bybit V5 Specific Error Hints ---
        if bybit_code == 110007: # Insufficient margin/balance (already handled by InsufficientFunds, but double check)
            lg.error(f"{NEON_YELLOW} >> Hint (Code {bybit_code}): Insufficient balance/margin. Check available balance, leverage. Cost ~ Size * Price / Leverage.{RESET}")
        elif bybit_code == 110043: # Order cost not available / exceeds limit
            lg.error(f"{NEON_YELLOW} >> Hint (Code {bybit_code}): Order cost likely exceeds available balance or risk limits. Check Cost ~ Size * Price / Leverage.{RESET}")
        elif bybit_code == 110044: # Position size has exceeded the risk limit
            lg.error(f"{NEON_YELLOW} >> Hint (Code {bybit_code}): Opening this position (size {amount_float}) would exceed Bybit's risk limit tier for the current leverage. Check Bybit risk limit docs or reduce size/leverage.{RESET}")
        elif bybit_code == 110014 and not reduce_only: # Reduce-only order failed (shouldn't happen here unless reduceOnly=True)
            lg.error(f"{NEON_YELLOW} >> Hint (Code {bybit_code}): Reduce-only flag might be incorrectly set? Ensure 'reduceOnly' is False when opening/increasing.{RESET}")
        elif bybit_code == 110055: # Position idx not match position mode
            lg.error(f"{NEON_YELLOW} >> Hint (Code {bybit_code}): Mismatch between 'positionIdx' parameter ({params.get('positionIdx')}) and account's Position Mode (must be One-Way, not Hedge). Check Bybit account trade settings.{RESET}")
        elif bybit_code == 10005 or "order link id exists" in err_str: # Duplicate Order ID
            lg.warning(f"{NEON_YELLOW}Duplicate order ID detected (Code {bybit_code}). May indicate a network issue causing retry, or order was already placed. Check position status manually!{RESET}")
            # Treat as failure for now, requires manual check
            return None
        elif "risk limit can't be place order" in err_str: # Another risk limit message
            lg.error(f"{NEON_YELLOW} >> Hint: Order blocked by risk limits. Check Bybit risk limit tiers vs leverage/position size.{RESET}")
        elif bybit_code == 110025 and reduce_only: # Position not found when trying to close
             lg.warning(f"{NEON_YELLOW} >> Hint (Code 110025): Position not found when attempting to close (reduceOnly=True). Might have already been closed by SL/TP or manually.{RESET}")
             # Treat this potentially as success (position is already closed)
             return {'id': 'N/A', 'status': 'closed', 'info': {'reason': 'Position not found on close attempt'}} # Return dummy success


    except Exception as e:
        lg.error(f"{NEON_RED}Unexpected error placing order ({action}) for {symbol}: {e}{RESET}", exc_info=True)

    return None # Return None if order failed for any reason


def _set_position_protection(
    exchange: ccxt.Exchange,
    symbol: str,
    market_info: Dict,
    position_info: Dict, # Confirmed position dict from get_open_position
    logger: logging.Logger,
    stop_loss_price: Optional[Union[Decimal, str]] = None, # Allow '0' for cancel
    take_profit_price: Optional[Union[Decimal, str]] = None, # Allow '0' for cancel
    trailing_stop_distance: Optional[Union[Decimal, str]] = None, # Trailing distance in price points (Decimal or '0')
    tsl_activation_price: Optional[Union[Decimal, str]] = None, # Price to activate TSL (Decimal or '0')
) -> bool:
    """
    Internal helper to set SL, TP, or TSL for an existing position using Bybit's V5 API
    (`/v5/position/trading-stop`) via CCXT's specific method.
    Returns True on success, False on failure.
    Note: Setting a fixed SL (`stop_loss_price`) will likely cancel an active TSL on Bybit,
          and vice-versa. This function prioritizes TSL if both valid TSL and SL are provided (unless TSL is '0').
          To cancel SL/TP/TSL, pass '0' as a string for the respective parameter (Bybit API behavior).
    """
    lg = logger
    if not market_info:
        lg.error(f"Cannot set protection for {symbol}: Missing market_info.")
        return False
    is_contract = market_info.get('is_contract', False)
    if not is_contract:
        lg.warning(f"Position protection (SL/TP/TSL) is typically for contract markets. Skipping for {symbol}.")
        return True # Not applicable, not a failure

    # --- Validate Inputs ---
    if not position_info:
        lg.error(f"Cannot set protection for {symbol}: Missing position information.")
        return False

    # Get side and size from position_info (needed for context/logging, not API params here)
    pos_side = position_info.get('side')
    pos_size_str = position_info.get('contracts', position_info.get('info', {}).get('size'))
    if pos_side not in ['long', 'short'] or pos_size_str is None:
        lg.error(f"Cannot set protection for {symbol}: Invalid or missing position side ('{pos_side}') or size in position_info.")
        return False

    # Check if provided values are valid Decimal (>=0) or the explicit cancel string '0'
    def is_valid_or_cancel(val: Optional[Union[Decimal, str]]) -> bool:
        if val is None: return False # No value provided
        if isinstance(val, str) and val == '0': return True # Explicit cancel
        if isinstance(val, Decimal): return val >= 0 # Valid price/distance (>=0)
        return False # Invalid type

    has_sl_intent = stop_loss_price is not None
    has_tp_intent = take_profit_price is not None
    has_tsl_intent = trailing_stop_distance is not None # Activation price can be 0 for immediate TSL

    is_sl_valid = has_sl_intent and is_valid_or_cancel(stop_loss_price)
    is_tp_valid = has_tp_intent and is_valid_or_cancel(take_profit_price)
    # TSL validation: distance must be valid or '0', activation price must be valid or '0'
    is_tsl_valid = has_tsl_intent and is_valid_or_cancel(trailing_stop_distance) and is_valid_or_cancel(tsl_activation_price)


    if not is_sl_valid and not is_tp_valid and not is_tsl_valid:
        lg.info(f"No valid protection parameters (SL, TP, TSL >= 0 or '0' for cancel) provided for {symbol}. No protection set/modified.")
        # Consider this success as no API call was intended/needed
        return True

    # --- Prepare API Parameters for /v5/position/set-trading-stop ---
    # Determine category ('linear' or 'inverse')
    category = 'linear' if market_info.get('linear', True) else 'inverse'

    # Get position index from position_info, default to 0 (One-Way)
    position_idx = 0 # Default for One-Way mode
    try:
        # Attempt to get positionIdx from the 'info' dict if available
        pos_idx_val = position_info.get('info', {}).get('positionIdx')
        if pos_idx_val is not None:
            position_idx = int(pos_idx_val)
    except (ValueError, TypeError):
        lg.warning(f"Could not parse positionIdx '{pos_idx_val}' from position info for {symbol}. Defaulting to {position_idx}.")


    params = {
        'category': category,
        'symbol': market_info['id'], # Use exchange-specific ID (e.g., BTCUSDT)
        'tpslMode': 'Full', # Apply to the whole position ('Partial' needs size param)
        # Trigger price type (LastPrice, MarkPrice, IndexPrice) - Use LastPrice for simplicity unless Mark is required
        'slTriggerBy': 'LastPrice',
        'tpTriggerBy': 'LastPrice',
        # Order type when triggered (Market is usually preferred for SL/TP)
        'slOrderType': 'Market',
        'tpOrderType': 'Market',
        'positionIdx': position_idx
    }

    log_parts = [f"Attempting to set protection for {symbol} ({pos_side.upper()} position, Idx: {position_idx}):"]

    # --- Format and Add Parameters using exchange helpers ---
    tsl_added_to_params = False
    sl_added_to_params = False
    tp_added_to_params = False
    try:
        # Helper to format price using exchange's precision rules
        # Handles Decimal input and '0' string for cancellation
        def format_price(price_val: Optional[Union[Decimal, str]]) -> Optional[str]:
            if price_val is None: return None
            if isinstance(price_val, str) and price_val == '0': return '0' # Pass cancel signal directly
            if isinstance(price_val, Decimal):
                if price_val < 0: return None # Invalid price
                if price_val == 0: return '0' # Treat Decimal 0 as cancel signal
                try:
                    # Use price_to_precision (expects float input)
                    formatted = exchange.price_to_precision(symbol, float(price_val))
                    lg.debug(f"Formatted price {price_val} -> {formatted}")
                    return formatted
                except Exception as fmt_err:
                    lg.warning(f"Could not format price {price_val} using exchange.price_to_precision: {fmt_err}. Skipping this parameter.")
                    return None
            return None # Invalid type

        # Helper to format distance (which is a price difference) - use price precision
        # Handles Decimal input and '0' string for cancellation
        def format_distance(dist_val: Optional[Union[Decimal, str]]) -> Optional[str]:
            if dist_val is None: return None
            if isinstance(dist_val, str) and dist_val == '0': return '0' # Pass cancel signal directly
            if isinstance(dist_val, Decimal):
                if dist_val < 0: return None # Invalid distance
                if dist_val == 0: return '0' # Treat Decimal 0 as cancel signal
                try:
                    # Use price_to_precision, as distance is formatted like a price
                    # Important: Bybit API expects TSL distance as a positive value
                    formatted = exchange.price_to_precision(symbol, float(abs(dist_val)))
                    lg.debug(f"Formatted distance {dist_val} -> {formatted}")
                    return formatted
                except Exception as fmt_err:
                    lg.warning(f"Could not format distance {dist_val} using exchange.price_to_precision: {fmt_err}. Skipping this parameter.")
                    return None
            return None # Invalid type

        # Trailing Stop Loss (Set first, as it might override fixed SL)
        if is_tsl_valid:
            formatted_tsl_distance = format_distance(trailing_stop_distance)
            formatted_activation_price = format_price(tsl_activation_price) # Handles '0' or Decimal

            if formatted_tsl_distance is not None and formatted_activation_price is not None:
                params['trailingStop'] = formatted_tsl_distance
                params['activePrice'] = formatted_activation_price
                # TSL uses 'slTriggerBy' and 'slOrderType' defined earlier
                log_parts.append(f"  Trailing SL: Distance={formatted_tsl_distance}, Activation={formatted_activation_price}")
                tsl_added_to_params = True
            else:
                lg.error(f"Failed to format valid TSL parameters for {symbol} (Dist: {trailing_stop_distance}, Act: {tsl_activation_price}). Cannot set TSL.")
                is_tsl_valid = False # Mark TSL as failed


        # Fixed Stop Loss - Only add if TSL was NOT successfully added OR if TSL is being cancelled ('0')
        if is_sl_valid and (not tsl_added_to_params or params.get('trailingStop') == '0'):
            formatted_sl = format_price(stop_loss_price)
            if formatted_sl is not None:
                params['stopLoss'] = formatted_sl
                log_parts.append(f"  Fixed SL: {formatted_sl}")
                sl_added_to_params = True
            else:
                # If formatting failed but intent was there, mark as invalid
                if has_sl_intent: is_sl_valid = False
        elif has_sl_intent and tsl_added_to_params and params.get('trailingStop') != '0':
             lg.warning(f"Both valid 'stopLoss' and active 'trailingStop' provided for {symbol}. Prioritizing TSL. Fixed 'stopLoss' parameter ignored.")
             is_sl_valid = False # Mark fixed SL as not set


        # Fixed Take Profit
        if is_tp_valid:
            formatted_tp = format_price(take_profit_price)
            if formatted_tp is not None:
                params['takeProfit'] = formatted_tp
                log_parts.append(f"  Fixed TP: {formatted_tp}")
                tp_added_to_params = True
            else:
                # If formatting failed but intent was there, mark as invalid
                if has_tp_intent: is_tp_valid = False

    except Exception as fmt_err:
        lg.error(f"Error processing/formatting protection parameters for {symbol}: {fmt_err}", exc_info=True)
        return False

    # Check if any protection is actually being set after formatting and prioritization
    if not sl_added_to_params and not tp_added_to_params and not tsl_added_to_params:
        lg.warning(f"No valid protection parameters could be formatted or remain after adjustments for {symbol}. No API call made.")
        # If nothing was intended, return True (success). If something was intended but failed formatting, return False.
        if has_sl_intent or has_tp_intent or has_tsl_intent: # Check original intent
             # If intent was present but formatting failed for all, consider it a failure
             if not is_sl_valid and not is_tp_valid and not is_tsl_valid:
                 return False
             else: # Something valid remained but wasn't added (e.g., SL ignored due to TSL) - treat as success
                 return True
        else:
            return True # Nothing was intended

    # Log the final parameters being sent (excluding sensitive info)
    lg.info("\n".join(log_parts))
    lg.debug(f"  API Call: privatePostV5PositionSetTradingStop(params={params})")

    # --- Make the API Call ---
    try:
        # Use the correct CCXT method name (camelCase) for Bybit V5 API
        # Ensure the exchange object has this method available (might require updated ccxt)
        if not hasattr(exchange, 'privatePostV5PositionSetTradingStop'):
             lg.error(f"{NEON_RED}Exchange object does not have 'privatePostV5PositionSetTradingStop' method. CCXT version might be outdated or method name incorrect.{RESET}")
             return False

        response = exchange.privatePostV5PositionSetTradingStop(params)
        lg.debug(f"Set protection raw response for {symbol}: {response}")

        # --- Check Response ---
        # Bybit V5 standard response structure
        ret_code = response.get('retCode')
        ret_msg = response.get('retMsg', 'Unknown Error')
        ret_ext = response.get('retExtInfo', {}) # Contains extra details on failure

        if ret_code == 0:
            # Check for specific non-error messages that indicate no change
            # Bybit message: "Stop loss, take profit and trailing stop were not modified"
            no_change_msg_fragments = ["not modified", "werenotmodified"]
            processed_ret_msg = ret_msg.lower().replace(",", "").replace(".", "").replace("and", "").replace(" ", "")
            if any(frag in processed_ret_msg for frag in no_change_msg_fragments):
                lg.info(f"{NEON_YELLOW}Position protection already set to target values for {symbol} (Exchange confirmation).{RESET}")
            else:
                lg.info(f"{NEON_GREEN}Position protection (SL/TP/TSL) set/updated successfully for {symbol}.{RESET}")
            return True
        else:
            # Log specific error hints based on Bybit V5 documentation/codes
            lg.error(f"{NEON_RED}Failed to set protection for {symbol}: {ret_msg} (Code: {ret_code}) Ext: {ret_ext}{RESET}")
            # --- Add hints based on common error codes for this endpoint ---
            if ret_code == 110043: # Set tpsl failed
                lg.error(f"{NEON_YELLOW} >> Hint (110043): Ensure 'tpslMode' ('Full'/'Partial') is correct. Check trigger prices (e.g., SL below entry for long?). Check `retExtInfo`.{RESET}")
            elif ret_code == 110025: # Position not found / size is zero
                lg.error(f"{NEON_YELLOW} >> Hint (110025): Position might have closed or changed size unexpectedly. Or `positionIdx` ({params.get('positionIdx')}) mismatch?{RESET}")
            elif ret_code == 110044: # Risk limit related
                lg.error(f"{NEON_YELLOW} >> Hint (110044): Protection settings might conflict with risk limits? Unlikely but possible.{RESET}")
            elif ret_code == 110055: # Position idx not match position mode
                lg.error(f"{NEON_YELLOW} >> Hint (110055): Ensure 'positionIdx' ({params.get('positionIdx')}) matches account's Position Mode (One-Way vs Hedge).{RESET}")
            elif ret_code == 110013: # Parameter Error
                lg.error(f"{NEON_YELLOW} >> Hint (110013): Check parameters: Is SL/TP/TSL value valid (non-zero, respects tick size)? Is `activePrice` valid for TSL? Are SL/TP on the wrong side of entry?{RESET}")
            elif ret_code == 110036: # Active price is invalid (for TSL)
                lg.error(f"{NEON_YELLOW} >> Hint (110036): TSL Activation price ({params.get('activePrice')}) might be invalid (e.g., too close, wrong side, already passed).{RESET}")
            elif ret_code == 110086: # SL/TP price cannot be the same
                lg.error(f"{NEON_YELLOW} >> Hint (110086): Stop loss price cannot be the same as Take profit price.{RESET}")
            elif "trailing stop value invalid" in ret_msg.lower():
                lg.error(f"{NEON_YELLOW} >> Hint: TSL distance ({params.get('trailingStop')}) might be invalid (too small/large, tick size).{RESET}")
            elif "stop loss price is invalid" in ret_msg.lower() or "sl price invalid" in ret_msg.lower():
                lg.error(f"{NEON_YELLOW} >> Hint: Fixed SL price ({params.get('stopLoss')}) might be invalid (wrong side, too close/far, tick size).{RESET}")
            elif "take profit price is invalid" in ret_msg.lower() or "tp price invalid" in ret_msg.lower():
                lg.error(f"{NEON_YELLOW} >> Hint: Fixed TP price ({params.get('takeProfit')}) might be invalid (wrong side, too close/far, tick size).{RESET}")
            # Add more specific codes as encountered
            return False

    except ccxt.NetworkError as e:
        lg.error(f"{NEON_RED}Network error setting protection for {symbol}: {e}{RESET}")
    except ccxt.ExchangeError as e: # Catch potential errors from the call itself if not parsed above
        lg.error(f"{NEON_RED}Exchange error during protection API call for {symbol}: {e}{RESET}")
    except ccxt.BaseError as e: # Catch any CCXT specific error
        lg.error(f"{NEON_RED}CCXT BaseError setting protection for {symbol}: {e}{RESET}")
    except KeyError as e:
        lg.error(f"{NEON_RED}Error setting protection for {symbol}: Missing expected key {e} in market/position info.{RESET}")
    except Exception as e:
        lg.error(f"{NEON_RED}Unexpected error setting protection for {symbol}: {e}{RESET}", exc_info=True)

    return False


def set_trailing_stop_loss(
    exchange: ccxt.Exchange,
    symbol: str,
    market_info: Dict,
    position_info: Dict, # Pass the confirmed position info
    config: Dict[str, Any],
    logger: logging.Logger,
    take_profit_price: Optional[Decimal] = None # Allow passing pre-calculated TP price
) -> bool:
    """
    Calculates TSL parameters (activation price, distance) based on config and position,
    then calls the internal `_set_position_protection` helper function to set TSL (and optionally TP).
    Returns True if the protection API call is attempted successfully, False otherwise.
    """
    lg = logger
    if not config.get("enable_trailing_stop", False):
        lg.info(f"Trailing Stop Loss is disabled in config for {symbol}. Skipping TSL setup.")
        # This function's purpose is only TSL, so return False indicating TSL wasn't set.
        return False
    if not market_info:
        lg.error(f"Cannot set TSL for {symbol}: Missing market_info.")
        return False
    if not position_info:
        lg.error(f"Cannot set TSL for {symbol}: Missing position_info.")
        return False

    # --- Get TSL parameters from config ---
    try:
        # Use Decimal for calculations
        callback_rate = Decimal(str(config.get("trailing_stop_callback_rate", 0.005)))
        activation_percentage = Decimal(str(config.get("trailing_stop_activation_percentage", 0.003)))
    except Exception as e:
        lg.error(f"{NEON_RED}Invalid TSL parameter format in config for {symbol}: {e}. Cannot calculate TSL.{RESET}")
        return False

    if callback_rate <= 0:
        lg.error(f"{NEON_RED}Invalid trailing_stop_callback_rate ({callback_rate}) in config for {symbol}. Must be positive.{RESET}")
        return False
    # Activation percentage can be zero if TSL should be active immediately
    if activation_percentage < 0:
        lg.error(f"{NEON_RED}Invalid trailing_stop_activation_percentage ({activation_percentage}) in config for {symbol}. Must be non-negative.{RESET}")
        return False

    # --- Extract required position details ---
    try:
        # Use reliable fields from CCXT unified position structure
        entry_price_str = position_info.get('entryPrice')
        # Fallback to info dict if standard field missing (e.g., Bybit V5 'avgPrice')
        if entry_price_str is None: entry_price_str = position_info.get('info', {}).get('avgPrice')

        side = position_info.get('side') # Should be 'long' or 'short'

        if entry_price_str is None or side not in ['long', 'short']:
            lg.error(f"{NEON_RED}Missing required position info (entryPrice, side) to calculate TSL for {symbol}. Position: {position_info}{RESET}")
            return False

        entry_price = Decimal(str(entry_price_str))
        if entry_price <= 0:
            lg.error(f"{NEON_RED}Invalid entry price ({entry_price}) from position info for {symbol}. Cannot calculate TSL.{RESET}")
            return False

    except (TypeError, ValueError, KeyError) as e:
        lg.error(f"{NEON_RED}Error parsing position info for TSL calculation ({symbol}): {e}. Position: {position_info}{RESET}")
        return False

    # --- Calculate TSL parameters for Bybit API ---
    try:
        # Create a temporary analyzer instance just to use utility methods
        # We need a valid DataFrame structure for initialization, even if empty
        dummy_df = pd.DataFrame(columns=['open', 'high', 'low', 'close', 'volume'])
        dummy_df.index.name = 'timestamp'
        temp_analyzer = TradingAnalyzer(df=dummy_df, logger=lg, config=config, market_info=market_info)
        price_precision = temp_analyzer.get_price_precision()
        min_tick_size = temp_analyzer.get_min_tick_size()
        if min_tick_size <= 0:
            lg.error(f"Cannot calculate TSL: Invalid min tick size ({min_tick_size}) for {symbol}.")
            return False

        # 1. Calculate Activation Price
        activation_price = None
        if activation_percentage > 0:
            activation_offset = entry_price * activation_percentage
            if side == 'long':
                # Activate when price moves UP by the percentage
                raw_activation = entry_price + activation_offset
                # Round UP away from entry price for activation, respecting ticks
                activation_price = (raw_activation / min_tick_size).quantize(Decimal('1'), rounding=ROUND_UP) * min_tick_size
                # Ensure activation is strictly above entry by at least one tick
                if activation_price <= entry_price:
                    activation_price = (entry_price + min_tick_size).quantize(min_tick_size, rounding=ROUND_UP)
            else: # side == 'short'
                # Activate when price moves DOWN by the percentage
                raw_activation = entry_price - activation_offset
                # Round DOWN away from entry price for activation, respecting ticks
                activation_price = (raw_activation / min_tick_size).quantize(Decimal('1'), rounding=ROUND_DOWN) * min_tick_size
                # Ensure activation is strictly below entry by at least one tick
                if activation_price >= entry_price:
                    activation_price = (entry_price - min_tick_size).quantize(min_tick_size, rounding=ROUND_DOWN)
        else:
            # Activate immediately (use activation price '0')
            activation_price = Decimal('0')
            lg.info(f"TSL activation percentage is zero for {symbol}, setting immediate activation (API value '0').")

        # Ensure activation price is non-negative (can be zero)
        if activation_price is None or activation_price < 0:
            lg.error(f"{NEON_RED}Calculated TSL activation price ({activation_price}) is invalid for {symbol}. Cannot set TSL.{RESET}")
            return False


        # 2. Calculate Trailing Stop Distance (in price points)
        # Bybit API: trailingStop is the absolute price distance (e.g., 10 for $10 trail)
        # Calculate this based on the callback rate applied to the entry price (or activation price if preferred)
        # Using entry price provides a consistent distance initially.
        trailing_distance_raw = entry_price * callback_rate
        # Round distance UP to ensure it's at least the calculated value, respecting tick size
        trailing_distance = (trailing_distance_raw / min_tick_size).quantize(Decimal('1'), rounding=ROUND_UP) * min_tick_size


        # Ensure minimum distance respects tick size and is positive
        if trailing_distance < min_tick_size:
            lg.warning(f"{NEON_YELLOW}Calculated TSL distance {trailing_distance} is smaller than min tick size {min_tick_size} for {symbol}. Adjusting to min tick size.{RESET}")
            trailing_distance = min_tick_size
        elif trailing_distance <= 0:
            lg.error(f"{NEON_RED}Calculated TSL distance is zero or negative ({trailing_distance}) for {symbol}. Check callback rate ({callback_rate}) and entry price ({entry_price}).{RESET}")
            return False

        # Format prices/distances for logging
        act_price_log = f"{activation_price:.{price_precision}f}" if activation_price > 0 else '0 (Immediate)'
        trail_dist_log = f"{trailing_distance:.{price_precision}f}"
        tp_log = f"{take_profit_price:.{price_precision}f}" if take_profit_price and take_profit_price > 0 else "N/A"

        lg.info(f"Calculated TSL Params for {symbol} ({side.upper()}):")
        lg.info(f"  Entry Price: {entry_price:.{price_precision}f}")
        lg.info(f"  Callback Rate: {callback_rate:.3%}")
        lg.info(f"  Activation Pct: {activation_percentage:.3%}")
        lg.info(f"  => Activation Price (API): {act_price_log}")
        lg.info(f"  => Trailing Distance (API): {trail_dist_log}")
        lg.info(f"  Take Profit (Optional): {tp_log}")


        # 3. Call the helper function to set TSL (and TP if provided)
        # Pass the VALIDATED & CALCULATED TSL parameters
        return _set_position_protection(
            exchange=exchange,
            symbol=symbol,
            market_info=market_info,
            position_info=position_info, # Pass the full position info dict
            logger=lg,
            stop_loss_price=None, # Explicitly do not set fixed SL when setting TSL
            take_profit_price=take_profit_price if isinstance(take_profit_price, Decimal) and take_profit_price > 0 else None,
            trailing_stop_distance=trailing_distance, # Pass calculated distance
            tsl_activation_price=activation_price # Pass calculated activation price (can be 0)
        )
    except ValueError as ve: # Catch specific value errors from data prep
        lg.error(f"Error during TSL calculation pre-check for {symbol}: {ve}")
        return False
    except Exception as e:
        lg.error(f"{NEON_RED}Unexpected error calculating/setting TSL parameters for {symbol}: {e}{RESET}", exc_info=True)
        return False


# --- Main Analysis and Trading Loop ---

def analyze_and_trade_symbol(exchange: ccxt.Exchange, symbol: str, config: Dict[str, Any], logger: logging.Logger) -> None:
    """Analyzes a single symbol and executes/manages trades based on signals and config."""

    lg = logger # Use the symbol-specific logger
    lg.info(f"---== Analyzing {symbol} ({config['interval']}) Cycle Start ==---")
    cycle_start_time = time.monotonic()

    # --- 1. Fetch Market Info & Data ---
    market_info = get_market_info(exchange, symbol, lg)
    if not market_info:
        lg.error(f"{NEON_RED}Failed to get market info for {symbol}. Skipping analysis cycle.{RESET}")
        return

    ccxt_interval = CCXT_INTERVAL_MAP.get(config["interval"])
    if not ccxt_interval:
        lg.error(f"Invalid interval '{config['interval']}' in config. Cannot map to CCXT timeframe for {symbol}.")
        return

    # Determine required kline history (can be refined)
    kline_limit = 500 # Ensure enough for long lookbacks + indicator buffer

    klines_df = fetch_klines_ccxt(exchange, symbol, ccxt_interval, limit=kline_limit, logger=lg)
    if klines_df.empty or len(klines_df) < 50: # Need a reasonable minimum history
        lg.error(f"{NEON_RED}Failed to fetch sufficient kline data for {symbol} (fetched {len(klines_df)}). Skipping analysis cycle.{RESET}")
        return

    # Fetch current price
    current_price = fetch_current_price_ccxt(exchange, symbol, lg)
    if current_price is None:
        lg.warning(f"{NEON_YELLOW}Failed to fetch current ticker price for {symbol}. Using last close from klines as fallback.{RESET}")
        try:
            # Ensure last close is valid Decimal
            last_close_val = klines_df['close'].iloc[-1]
            if pd.notna(last_close_val) and last_close_val > 0:
                current_price = Decimal(str(last_close_val))
                lg.info(f"Using last close price: {current_price}")
            else:
                lg.error(f"{NEON_RED}Last close price ({last_close_val}) is also invalid. Cannot proceed for {symbol}.{RESET}")
                return
        except (IndexError, ValueError, TypeError) as e:
            lg.error(f"{NEON_RED}Error getting last close price for {symbol}: {e}. Cannot proceed.{RESET}")
            return

    # Fetch order book if enabled and weighted
    orderbook_data = None
    active_weights = config.get("weight_sets", {}).get(config.get("active_weight_set", "default"), {})
    if config.get("indicators",{}).get("orderbook", False) and Decimal(str(active_weights.get("orderbook", 0))) != 0:
        orderbook_data = fetch_orderbook_ccxt(exchange, symbol, config["orderbook_limit"], lg)


    # --- 2. Analyze Data & Generate Signal ---
    try:
        analyzer = TradingAnalyzer(
            df=klines_df.copy(), # Pass a copy to avoid modification issues
            logger=lg,
            config=config,
            market_info=market_info
        )
    except ValueError as e_analyzer:
        lg.error(f"{NEON_RED}Failed to initialize TradingAnalyzer for {symbol}: {e_analyzer}. Skipping analysis cycle.{RESET}")
        return


    # Check if analyzer initialized correctly (indicators calculated)
    if not analyzer.indicator_values:
        lg.error(f"{NEON_RED}Indicator calculation failed or produced no values for {symbol}. Skipping signal generation.{RESET}")
        return

    # Generate the trading signal
    signal = analyzer.generate_trading_signal(current_price, orderbook_data)

    # Calculate potential initial SL/TP based on *current* price and ATR (used for sizing and potential fixed protection IF NO POSITION EXISTS)
    # Note: If a position exists, SL/TP should be based on the *entry* price.
    _, tp_potential, sl_potential = analyzer.calculate_entry_tp_sl(current_price, signal)
    # Get other analysis results if needed
    # fib_levels = analyzer.get_nearest_fibonacci_levels(current_price)
    price_precision = analyzer.get_price_precision()
    min_tick_size = analyzer.get_min_tick_size()
    current_atr_float = analyzer.indicator_values.get("ATR") # Get float ATR


    # --- 3. Log Analysis Summary ---
    # (Signal logging is handled within generate_trading_signal now)
    atr_log = f"{current_atr_float:.{price_precision+1}f}" if current_atr_float and pd.notna(current_atr_float) else 'N/A'
    sl_pot_log = f"{sl_potential:.{price_precision}f}" if sl_potential else 'N/A'
    tp_pot_log = f"{tp_potential:.{price_precision}f}" if tp_potential else 'N/A'

    lg.info(f"ATR: {atr_log}")
    lg.info(f"Potential Initial SL (for new trade sizing): {sl_pot_log}")
    lg.info(f"Potential Initial TP (for new trade): {tp_pot_log}")
    # lg.info(f"Nearest Fib Levels: " + ", ".join([f"{name}={level:.{price_precision}f}" for name, level in fib_levels[:3]]))
    tsl_enabled = config.get('enable_trailing_stop')
    be_enabled = config.get('enable_break_even')
    ma_exit_enabled = config.get('enable_ma_cross_exit')
    lg.info(f"Trailing Stop: {'Enabled' if tsl_enabled else 'Disabled'} | Break Even: {'Enabled' if be_enabled else 'Disabled'} | MA Cross Exit: {'Enabled' if ma_exit_enabled else 'Disabled'}")


    # --- 4. Check Position & Execute/Manage ---
    if not config.get("enable_trading", False):
        lg.debug(f"Trading disabled. Analysis complete for {symbol}.")
        # Log cycle time even if not trading
        cycle_end_time = time.monotonic()
        lg.debug(f"---== Analysis Cycle End for {symbol} ({cycle_end_time - cycle_start_time:.2f}s) ==---")
        return

    # --- Get Current Position Status ---
    # This is a critical step, ensure it's robust and includes SL/TP/TSL info
    open_position = get_open_position(exchange, symbol, lg) # Returns enhanced position dict or None

    # --- Scenario 1: No Open Position ---
    if open_position is None:
        if signal in ["BUY", "SELL"]:
            lg.info(f"*** {signal} Signal & No Open Position: Initiating Trade Sequence for {symbol} ***")

            # --- Pre-Trade Checks & Setup ---
            # a) Check Balance
            balance = fetch_balance(exchange, QUOTE_CURRENCY, lg)
            if balance is None: # fetch_balance returns None on critical errors
                lg.error(f"{NEON_RED}Trade Aborted ({symbol} {signal}): Cannot proceed, failed to fetch balance for {QUOTE_CURRENCY}.{RESET}")
                return
            if balance <= 0: # Check if balance is actually positive
                lg.error(f"{NEON_RED}Trade Aborted ({symbol} {signal}): Insufficient balance ({balance} {QUOTE_CURRENCY}).{RESET}")
                return

            # b) Check if potential SL calculation succeeded (needed for sizing)
            if sl_potential is None:
                lg.error(f"{NEON_RED}Trade Aborted ({symbol} {signal}): Cannot proceed, Potential Initial Stop Loss calculation failed (ATR valid?). Risk cannot be determined.{RESET}")
                return

            # c) Set Leverage (only for contracts)
            if market_info.get('is_contract', False):
                leverage = int(config.get("leverage", 1))
                if leverage > 0:
                    if not set_leverage_ccxt(exchange, symbol, leverage, market_info, lg):
                        # Decide if failure to set leverage is critical
                        lg.error(f"{NEON_RED}Trade Aborted ({symbol} {signal}): Failed to set/confirm leverage to {leverage}x. Cannot proceed safely.{RESET}")
                        return # Abort trade if leverage setting fails
                else:
                    lg.warning(f"Leverage setting skipped for {symbol}: Configured leverage is zero or negative ({leverage}).")
            else:
                lg.info(f"Leverage setting skipped for {symbol} (Spot market).")


            # d) Calculate Position Size using potential SL
            position_size = calculate_position_size(
                balance=balance,
                risk_per_trade=config["risk_per_trade"],
                initial_stop_loss_price=sl_potential, # Use potential SL based on current price for sizing
                entry_price=current_price, # Use current price as entry estimate for sizing
                market_info=market_info,
                exchange=exchange, # Pass exchange for formatting helpers
                logger=lg
            )

            if position_size is None or position_size <= 0:
                lg.error(f"{NEON_RED}Trade Aborted ({symbol} {signal}): Invalid position size calculated ({position_size}). Check balance, risk, SL, market limits, and logs.{RESET}")
                return

            # --- Place Initial Market Order ---
            lg.info(f"==> Placing {signal} market order for {symbol} | Size: {position_size} <==")
            trade_order = place_trade(
                exchange=exchange,
                symbol=symbol,
                trade_signal=signal,
                position_size=position_size, # Pass Decimal size
                market_info=market_info,
                logger=lg,
                reduce_only=False # Opening trade
            )

            # --- Post-Order: Verify Position and Set Protection ---
            if trade_order and trade_order.get('id'):
                order_id = trade_order['id']
                lg.info(f"Order {order_id} placed for {symbol}. Waiting {POSITION_CONFIRM_DELAY}s for position confirmation...")

                # Wait for exchange to potentially process the order and update position state
                time.sleep(POSITION_CONFIRM_DELAY)

                # Attempt to confirm the position *after* the delay
                lg.info(f"Attempting to confirm position for {symbol} after order {order_id}...")
                confirmed_position = get_open_position(exchange, symbol, lg) # Use enhanced function

                if confirmed_position:
                    # --- Position Confirmed ---
                    try:
                        entry_price_actual_str = confirmed_position.get('entryPrice', confirmed_position.get('info', {}).get('avgPrice'))
                        pos_size_actual_str = confirmed_position.get('contracts', confirmed_position.get('info', {}).get('size'))
                        entry_price_actual = Decimal('0')
                        pos_size_actual = Decimal('0')
                        valid_entry = False

                        # Validate actual entry price and size
                        if entry_price_actual_str and pos_size_actual_str:
                            try:
                                entry_price_actual = Decimal(str(entry_price_actual_str))
                                pos_size_actual = Decimal(str(pos_size_actual_str))
                                # Use a small threshold for size validation
                                min_size_threshold = Decimal('1e-9')
                                if market_info:
                                    try:
                                        min_amt = market_info.get('limits', {}).get('amount', {}).get('min')
                                        if min_amt is not None:
                                            min_size_threshold = max(Decimal('1e-9'), Decimal(str(min_amt)) * Decimal('0.1')) # e.g., 10% of min size
                                    except Exception: pass

                                if entry_price_actual > 0 and abs(pos_size_actual) >= min_size_threshold:
                                    valid_entry = True
                                else:
                                    lg.error(f"Confirmed position has invalid entry price ({entry_price_actual}) or size ({pos_size_actual} < {min_size_threshold}).")
                            except Exception as parse_err:
                                lg.error(f"Error parsing confirmed position entry/size: {parse_err}")
                        else:
                            lg.error("Confirmed position missing entryPrice or size information.")


                        if valid_entry:
                            lg.info(f"{NEON_GREEN}Position Confirmed for {symbol}! Actual Entry: ~{entry_price_actual:.{price_precision}f}, Actual Size: {pos_size_actual}{RESET}")

                            # --- Recalculate SL/TP based on ACTUAL entry price ---
                            _, tp_actual, sl_actual = analyzer.calculate_entry_tp_sl(entry_price_actual, signal)

                            # --- Set Protection based on Config (TSL or Fixed SL/TP) ---
                            protection_set_success = False
                            if config.get("enable_trailing_stop", False):
                                lg.info(f"Setting Trailing Stop Loss for {symbol} (TP target: {tp_actual})...")
                                protection_set_success = set_trailing_stop_loss(
                                    exchange=exchange,
                                    symbol=symbol,
                                    market_info=market_info,
                                    position_info=confirmed_position, # Pass the fetched position dict
                                    config=config,
                                    logger=lg,
                                    take_profit_price=tp_actual # Pass optional TP based on actual entry
                                )
                            else:
                                # Set Fixed SL and TP using the helper function
                                lg.info(f"Setting Fixed Stop Loss ({sl_actual}) and Take Profit ({tp_actual}) for {symbol}...")
                                if sl_actual or tp_actual: # Only call if at least one is valid
                                    protection_set_success = _set_position_protection(
                                        exchange=exchange,
                                        symbol=symbol,
                                        market_info=market_info,
                                        position_info=confirmed_position,
                                        logger=lg,
                                        stop_loss_price=sl_actual,
                                        take_profit_price=tp_actual,
                                        trailing_stop_distance='0', # Ensure TSL is cancelled if fixed SL is set
                                        tsl_activation_price='0'
                                    )
                                else:
                                    lg.warning(f"{NEON_YELLOW}Fixed SL/TP calculation based on actual entry failed or resulted in None for {symbol}. No fixed protection set.{RESET}")
                                    # Consider if no protection is acceptable or if trade should be closed
                                    protection_set_success = True # Treat as 'success' in terms of not failing, but no protection set

                            # --- Final Status Log ---
                            if protection_set_success:
                                lg.info(f"{NEON_GREEN}=== TRADE ENTRY & PROTECTION SETUP COMPLETE for {symbol} ({signal}) ===")
                            else:
                                lg.error(f"{NEON_RED}=== TRADE placed BUT FAILED TO SET/CONFIRM PROTECTION (SL/TP/TSL) for {symbol} ({signal}) ===")
                                lg.warning(f"{NEON_YELLOW}Position is open without automated protection. Manual monitoring/intervention may be required!{RESET}")
                        else:
                            lg.error(f"{NEON_RED}Trade placed, but confirmed position data is invalid. Cannot set protection.{RESET}")
                            lg.warning(f"{NEON_YELLOW}Position may be open without protection. Manual check needed!{RESET}")

                    except Exception as post_trade_err:
                        lg.error(f"{NEON_RED}Error during post-trade processing (protection setting) for {symbol}: {post_trade_err}{RESET}", exc_info=True)
                        lg.warning(f"{NEON_YELLOW}Position may be open without protection. Manual check needed!{RESET}")

                else:
                    # --- Position NOT Confirmed ---
                    lg.error(f"{NEON_RED}Trade order {order_id} placed, but FAILED TO CONFIRM open position for {symbol} after {POSITION_CONFIRM_DELAY}s delay!{RESET}")
                    lg.warning(f"{NEON_YELLOW}Order might have failed to fill, filled partially, rejected, or there's a significant delay/API issue.{RESET}")
                    lg.warning(f"{NEON_YELLOW}No protection will be set. Manual investigation of order {order_id} and position status required!{RESET}")
                    # Optional: Try fetching the order status itself for more info
                    try:
                        order_status = exchange.fetch_order(order_id, symbol)
                        lg.info(f"Status of order {order_id}: {order_status}")
                    except Exception as fetch_order_err:
                        lg.warning(f"Could not fetch status for order {order_id}: {fetch_order_err}")

            else:
                # place_trade function returned None (order failed)
                lg.error(f"{NEON_RED}=== TRADE EXECUTION FAILED for {symbol} ({signal}). See previous logs for details. ===")
        else:
            # No open position, and signal is HOLD
            lg.info(f"Signal is HOLD and no open position for {symbol}. No trade action taken.")


    # --- Scenario 2: Existing Open Position Found ---
    else: # open_position is not None
        pos_side = open_position.get('side', 'unknown')
        pos_size_str = open_position.get('contracts', open_position.get('info',{}).get('size', 'N/A'))
        entry_price_str = open_position.get('entryPrice', open_position.get('info', {}).get('avgPrice', 'N/A'))
        # Use the enhanced get_open_position which pulls SL/TP/TSL info
        # Note: CCXT might return float or None, enhanced dict adds Decimal versions
        current_sl_price_val = open_position.get('stopLossPrice') # Can be None or float
        current_tp_price_val = open_position.get('takeProfitPrice') # Can be None or float
        tsl_distance_dec = open_position.get('trailingStopLossDistanceDecimal', Decimal(0)) # Use parsed Decimal
        is_tsl_active = tsl_distance_dec > 0

        # Log current state including TSL status
        sl_log_str = f"{current_sl_price_val:.{price_precision}f}" if current_sl_price_val else 'N/A'
        tp_log_str = f"{current_tp_price_val:.{price_precision}f}" if current_tp_price_val else 'N/A'
        lg.info(f"Existing {pos_side.upper()} position found for {symbol}. Size: {pos_size_str}, Entry: {entry_price_str}, SL: {sl_log_str}, TP: {tp_log_str}, TSL Active: {is_tsl_active}")


        # --- ** Check Exit Conditions ** ---
        # Priority: 1. Main Signal, 2. MA Cross (if enabled)
        # Note: Exchange SL/TP/TSL trigger independently

        # Condition 1: Main signal opposes the current position direction
        exit_signal_triggered = False
        if (pos_side == 'long' and signal == "SELL") or \
           (pos_side == 'short' and signal == "BUY"):
            exit_signal_triggered = True
            lg.warning(f"{NEON_YELLOW}*** EXIT Signal Triggered: New signal ({signal}) opposes existing {pos_side} position for {symbol}. ***{RESET}")

        # Condition 2: MA Cross exit (if enabled)
        ma_cross_exit = False
        if not exit_signal_triggered and config.get("enable_ma_cross_exit", False):
            ema_short = analyzer.indicator_values.get("EMA_Short")
            ema_long = analyzer.indicator_values.get("EMA_Long")

            if pd.notna(ema_short) and pd.notna(ema_long):
                # Check for adverse cross based on position side
                if pos_side == 'long' and ema_short < ema_long:
                    ma_cross_exit = True
                    lg.warning(f"{NEON_YELLOW}*** MA CROSS EXIT (Bearish): Short EMA ({ema_short:.{price_precision}f}) crossed below Long EMA ({ema_long:.{price_precision}f}). Closing LONG position. ***{RESET}")
                elif pos_side == 'short' and ema_short > ema_long:
                    ma_cross_exit = True
                    lg.warning(f"{NEON_YELLOW}*** MA CROSS EXIT (Bullish): Short EMA ({ema_short:.{price_precision}f}) crossed above Long EMA ({ema_long:.{price_precision}f}). Closing SHORT position. ***{RESET}")
            else:
                lg.warning("MA cross exit check skipped: EMA values not available.")


        # --- Execute Position Close if Exit Condition Met ---
        if exit_signal_triggered or ma_cross_exit:
            lg.info(f"Attempting to close {pos_side} position for {symbol} with a market order...")
            close_order = None
            try:
                # Determine the side needed to close the position
                close_side_signal = "SELL" if pos_side == 'long' else "BUY"
                # Ensure we have the correct size to close from the position info
                size_to_close_str = open_position.get('contracts', open_position.get('info',{}).get('size'))
                if size_to_close_str is None:
                    raise ValueError(f"Could not determine size of existing {pos_side} position for {symbol} to close.")

                # Use absolute value of the size for the closing order amount
                size_to_close = abs(Decimal(str(size_to_close_str)))
                if size_to_close <= 0:
                    raise ValueError(f"Existing position size {size_to_close_str} is zero or invalid. Cannot close.")

                # --- Place Closing Market Order (reduceOnly=True) ---
                close_order = place_trade(
                    exchange=exchange,
                    symbol=symbol,
                    trade_signal=close_side_signal, # Side opposite to position
                    position_size=size_to_close,    # Absolute size
                    market_info=market_info,
                    logger=lg,
                    reduce_only=True # CRITICAL for closing
                )

                if close_order:
                     order_id = close_order.get('id', 'N/A')
                     # If place_trade returned the dummy success for 'position not found', log differently
                     if close_order.get('info',{}).get('reason') == 'Position not found on close attempt':
                          lg.info(f"{NEON_GREEN}Position CLOSE for {symbol} confirmed (was likely already closed).{RESET}")
                     else:
                          lg.info(f"{NEON_GREEN}Position CLOSE order placed successfully for {symbol}. Order ID: {order_id}{RESET}")
                          lg.info(f"{NEON_YELLOW}Position should be closed. Verify on exchange if necessary.{RESET}")
                     # We assume the reduceOnly market order will close the position.
                     # Future: Add a check after delay to confirm position is None.
                else:
                     # place_trade failed
                     lg.error(f"{NEON_RED}Failed to place position CLOSE order for {symbol}. Manual intervention required!{RESET}")


            except ValueError as ve:
                lg.error(f"{NEON_RED}Error preparing to close position for {symbol}: {ve}{RESET}")
            except Exception as e: # Catch any other errors during close attempt
                lg.error(f"{NEON_RED}Unexpected error closing position {symbol}: {e}{RESET}", exc_info=True)
                lg.warning(f"{NEON_YELLOW}Manual check/closure of position {symbol} may be required!{RESET}")

        # --- Manage Existing Position (No Exit Signal) ---
        elif signal == "HOLD" or (signal == "BUY" and pos_side == 'long') or (signal == "SELL" and pos_side == 'short'):
            lg.info(f"Signal ({signal}) allows holding existing {pos_side} position for {symbol}.")

            # --- ** Break-Even Stop Logic ** ---
            # Only run BE logic if enabled, if there's a position, and if TSL is NOT currently active
            if config.get("enable_break_even", False) and not is_tsl_active:
                lg.debug(f"Checking Break-Even conditions for {symbol}...")
                try:
                    # --- Gather necessary data for BE check ---
                    # Ensure entry price is valid Decimal
                    if not entry_price_str or str(entry_price_str).lower() == 'n/a':
                        raise ValueError("Missing or invalid entry price for BE check")
                    entry_price = Decimal(str(entry_price_str))
                    if entry_price <= 0: raise ValueError(f"Invalid entry price ({entry_price}) for BE check")

                    # Ensure current ATR is valid float/Decimal
                    if current_atr_float is None or pd.isna(current_atr_float) or current_atr_float <= 0:
                        lg.warning("Cannot check break-even: Invalid ATR value.")
                        raise ValueError("Invalid ATR for BE check") # Skip BE check if ATR invalid
                    current_atr_decimal = Decimal(str(current_atr_float))

                    # Get BE config parameters
                    profit_target_atr_multiple = Decimal(str(config.get("break_even_trigger_atr_multiple", 1.0)))
                    offset_ticks = int(config.get("break_even_offset_ticks", 2))

                    # Calculate profit/loss in price points
                    price_diff = Decimal('0')
                    if pos_side == 'long':
                        price_diff = current_price - entry_price
                    else: # short
                        price_diff = entry_price - current_price

                    # Check if profit target (in price points) is reached
                    profit_target_price_diff = profit_target_atr_multiple * current_atr_decimal

                    lg.debug(f"BE Check: Price Diff={price_diff:.{price_precision}f}, Target Diff={profit_target_price_diff:.{price_precision}f} ({profit_target_atr_multiple}*ATR)")

                    # Check if profit target is reached
                    if price_diff >= profit_target_price_diff:
                        lg.info(f"Break-Even profit target reached for {symbol}.")
                        # Calculate target break-even SL price
                        be_stop_price = None
                        if min_tick_size <= 0: raise ValueError(f"Invalid min_tick_size ({min_tick_size}) for BE calculation.")
                        tick_offset = min_tick_size * offset_ticks
                        if pos_side == 'long':
                            # BE SL is entry + offset, rounded UP to nearest tick
                            be_stop_price = (entry_price + tick_offset).quantize(min_tick_size, rounding=ROUND_UP)
                        else: # short
                            # BE SL is entry - offset, rounded DOWN to nearest tick
                            be_stop_price = (entry_price - tick_offset).quantize(min_tick_size, rounding=ROUND_DOWN)

                        # Get current SL price as Decimal (handle None, 0, errors)
                        current_sl_price_dec = None
                        if current_sl_price_val is not None and float(current_sl_price_val) > 0:
                            try:
                                current_sl_price_dec_temp = Decimal(str(current_sl_price_val))
                                if current_sl_price_dec_temp > 0:
                                     current_sl_price_dec = current_sl_price_dec_temp
                            except Exception:
                                lg.warning(f"Could not parse current SL price '{current_sl_price_val}' for BE comparison.")

                        # Determine if update is needed:
                        # - No current SL is set OR
                        # - Target BE SL is better (higher for long, lower for short) than current SL
                        update_be = False
                        if be_stop_price is not None and be_stop_price > 0: # Ensure target BE is valid
                            if current_sl_price_dec is None: # No current SL, set BE SL
                                update_be = True
                                lg.info(f"Profit target hit. No current SL found. Setting BE SL.")
                            elif pos_side == 'long' and be_stop_price > current_sl_price_dec: # Move SL up to BE
                                update_be = True
                                lg.info(f"Profit target hit. Current SL {current_sl_price_dec} < Target BE SL {be_stop_price}. Moving SL to BE.")
                            elif pos_side == 'short' and be_stop_price < current_sl_price_dec: # Move SL down to BE
                                update_be = True
                                lg.info(f"Profit target hit. Current SL {current_sl_price_dec} > Target BE SL {be_stop_price}. Moving SL to BE.")
                            else:
                                lg.debug(f"BE Triggered, but current SL ({current_sl_price_dec}) is already at or better than target BE SL ({be_stop_price}). No update needed.")
                        else:
                            lg.warning(f"Calculated BE Stop Price ({be_stop_price}) is invalid. Cannot update.")


                        # Execute the update if needed
                        if update_be:
                            lg.warning(f"{NEON_PURPLE}*** Moving Stop Loss to Break-Even for {symbol} at {be_stop_price} ***{RESET}")
                            # Fetch current TP to preserve it when setting SL
                            current_tp_price_dec = None
                            if current_tp_price_val is not None and float(current_tp_price_val) > 0:
                                try:
                                    current_tp_price_dec_temp = Decimal(str(current_tp_price_val))
                                    if current_tp_price_dec_temp > 0:
                                        current_tp_price_dec = current_tp_price_dec_temp
                                except Exception: pass

                            success = _set_position_protection(
                                exchange=exchange,
                                symbol=symbol,
                                market_info=market_info,
                                position_info=open_position, # Pass the full position dict
                                logger=lg,
                                stop_loss_price=be_stop_price,
                                take_profit_price=current_tp_price_dec, # Preserve existing TP (pass Decimal or None)
                                trailing_stop_distance='0', # Ensure TSL is cancelled/overridden by passing '0'
                                tsl_activation_price='0'    # Ensure TSL activation is also cancelled
                            )
                            if success:
                                lg.info(f"{NEON_GREEN}Break-Even SL successfully set/updated for {symbol}.{RESET}")
                                # Future: Optionally update internal state or re-fetch position info
                            else:
                                lg.error(f"{NEON_RED}Failed to set Break-Even SL for {symbol}. Check logs.{RESET}")
                    else:
                        lg.debug(f"Profit target for break-even not yet reached ({price_diff:.{price_precision}f} < {profit_target_price_diff:.{price_precision}f}).")

                except ValueError as ve: # Catch specific value errors from data prep
                    lg.warning(f"Skipping BE check due to invalid data: {ve}")
                except Exception as be_err:
                    lg.error(f"{NEON_RED}Error during break-even check/execution for {symbol}: {be_err}{RESET}", exc_info=True)
            elif is_tsl_active:
                lg.info(f"Break-even check skipped for {symbol}: Trailing Stop Loss is already active.")
            elif not config.get("enable_break_even", False):
                lg.debug(f"Break-even check skipped for {symbol}: Disabled in config.")


            # --- Other Management Logic (Placeholder) ---
            # TODO: Add logic here to:
            # 1. Check if TSL/Fixed SL was *supposed* to be active but isn't. Retry setting?
            # 2. Monitor proximity to Liq price and potentially reduce risk?
            # 3. Add pyramiding logic if signal matches position strongly? (High Risk, requires careful sizing)
            # 4. Update TP target based on new analysis? (e.g., if price moves significantly)
            lg.debug(f"No other position management actions taken for {symbol} this cycle.")

    # --- Cycle End Logging ---
    cycle_end_time = time.monotonic()
    lg.debug(f"---== Analysis Cycle End for {symbol} ({cycle_end_time - cycle_start_time:.2f}s) ==---")


def main() -> None:
    """Main function to initialize the bot and run the analysis loop."""
    global CONFIG, QUOTE_CURRENCY, console_log_level # Allow main loop to potentially reload config

    # Use a generic logger for initial setup, then switch to symbol-specific logger
    # Ensure the 'init' logger is set up using setup_logger
    setup_logger("init") # Creates handlers for 'init' logger name
    init_logger = logging.getLogger("init") # Get the logger instance
    # Access console handler to potentially change level later
    console_handler = None
    for handler in init_logger.handlers:
        if isinstance(handler, logging.StreamHandler):
            console_handler = handler
            break
    # Set console level based on global variable (initially INFO)
    # console_log_level is already defined globally
    if console_handler:
        console_handler.setLevel(console_log_level)


    init_logger.info(f"--- Starting LiveBot 7.1 ({datetime.now(TIMEZONE).strftime('%Y-%m-%d %H:%M:%S %Z')}) ---")
    init_logger.info(f"Loading configuration from {CONFIG_FILE}...")
    # Reload config here in case defaults were created/updated
    CONFIG = load_config(CONFIG_FILE)
    QUOTE_CURRENCY = CONFIG.get("quote_currency", "USDT") # Ensure quote currency is set globally
    init_logger.info(f"Configuration loaded. Quote Currency: {QUOTE_CURRENCY}")
    # Display key versions
    init_logger.info(f"Using CCXT Version: {ccxt.__version__}")
    init_logger.info(f"Using Pandas Version: {pd.__version__}")
    try:
        init_logger.info(f"Using Pandas TA Version: {ta.version() if callable(ta.version) else getattr(ta, '__version__', 'N/A')}")
    except Exception:
        init_logger.warning("Could not determine pandas_ta version.")


    # --- Safety Checks & User Confirmation ---
    if CONFIG.get("enable_trading"):
        init_logger.warning(f"{NEON_YELLOW}!!! LIVE TRADING IS ENABLED in {CONFIG_FILE} !!!{RESET}")
        if CONFIG.get("use_sandbox"):
            init_logger.warning(f"{NEON_YELLOW}Using SANDBOX environment (Testnet). No real funds at risk.{RESET}")
        else:
            init_logger.warning(f"{NEON_RED}!!! USING REAL MONEY ENVIRONMENT !!! Ensure configuration and risk settings are correct!{RESET}")
        init_logger.warning(f"Key Settings: Risk Per Trade: {CONFIG.get('risk_per_trade', 0)*100:.2f}%, Leverage: {CONFIG.get('leverage', 0)}x, TSL: {'Enabled' if CONFIG.get('enable_trailing_stop') else 'Disabled'}, BE: {'Enabled' if CONFIG.get('enable_break_even') else 'Disabled'}, MA Exit: {'Enabled' if CONFIG.get('enable_ma_cross_exit') else 'Disabled'}")

        try:
            print("-" * 60)
            confirm = input(f">>> Review settings above. Press {NEON_GREEN}Enter{RESET} to continue, or {NEON_RED}Ctrl+C{RESET} to abort... ")
            print("-" * 60)
            init_logger.info("User acknowledged live trading settings. Proceeding...")
        except KeyboardInterrupt:
            init_logger.info("User aborted startup. Exiting.")
            return
    else:
        init_logger.info(f"{NEON_YELLOW}Trading is disabled ('enable_trading': false in config). Running in analysis-only mode.{RESET}")


    # --- Initialize Exchange ---
    init_logger.info("Initializing exchange connection...")
    exchange = initialize_exchange(init_logger)
    if not exchange:
        init_logger.critical(f"{NEON_RED}Failed to initialize exchange. Exiting.{RESET}")
        return
    init_logger.info(f"Exchange {exchange.id} initialized successfully.")

    # --- Symbol and Interval Selection ---
    target_symbol = None
    market_info = None
    while True:
        try:
            symbol_input_raw = input(f"{NEON_YELLOW}Enter symbol to trade (e.g., BTC/USDT, ETH/USDT:USDT): {RESET}").strip()
            if not symbol_input_raw: continue

            # Normalize input: Convert to uppercase, replace common separators if needed
            symbol_input = symbol_input_raw.upper().replace('-', '/')

            # CCXT prefers BASE/QUOTE format, or BASE/QUOTE:QUOTE for linear swaps on some exchanges
            # Try fetching market info directly with the input
            init_logger.info(f"Validating symbol '{symbol_input}'...")
            market_info = get_market_info(exchange, symbol_input, init_logger)

            if market_info:
                target_symbol = market_info['symbol'] # Use the exact symbol confirmed by ccxt
                market_type_desc = "Contract" if market_info.get('is_contract', False) else "Spot"
                init_logger.info(f"Validated Symbol: {NEON_GREEN}{target_symbol}{RESET} (Type: {market_type_desc})")
                break # Symbol validated
            else:
                # If direct match fails, try common variations
                variations = []
                base_curr = ""
                quote_curr = QUOTE_CURRENCY # Assume default quote if not specified
                if '/' in symbol_input:
                    parts = symbol_input.split('/')
                    base_curr = parts[0]
                    if len(parts) > 1: quote_curr = parts[1].split(':')[0] # Handle optional :XXX part
                else: # Assume symbol like BTCUSDT
                    if symbol_input.endswith(quote_curr):
                        base_curr = symbol_input[:-len(quote_curr)]
                    else:
                        base_curr = symbol_input # Guess base

                if base_curr:
                    # Try BASE/QUOTE
                    variations.append(f"{base_curr}/{quote_curr}")
                    # Try BASE/QUOTE:QUOTE (common for linear perps)
                    variations.append(f"{base_curr}/{quote_curr}:{quote_curr}")
                    # Try BASEQUOTE (e.g., BTCUSDT)
                    variations.append(f"{base_curr}{quote_curr}")


                found_variation = False
                if variations:
                    init_logger.info(f"Symbol '{symbol_input}' not found directly. Trying variations: {variations}")
                    for sym_var in variations:
                        init_logger.debug(f"Trying variation '{sym_var}'...")
                        market_info = get_market_info(exchange, sym_var, init_logger)
                        if market_info:
                            target_symbol = market_info['symbol']
                            market_type_desc = "Contract" if market_info.get('is_contract', False) else "Spot"
                            init_logger.info(f"Validated Symbol: {NEON_GREEN}{target_symbol}{RESET} (Type: {market_type_desc})")
                            found_variation = True
                            break

                if found_variation:
                    break # Variation validated
                else:
                    init_logger.error(f"{NEON_RED}Symbol '{symbol_input_raw}' and common variations could not be validated on {exchange.id}. Please check the symbol and try again.{RESET}")
                    # Optional: List some available derivative markets for guidance
                    try:
                        markets = exchange.load_markets()
                        deriv_symbols = [s for s, m in markets.items() if m.get('contract', False) and QUOTE_CURRENCY in s]
                        init_logger.info(f"Sample available {QUOTE_CURRENCY} derivative symbols: {deriv_symbols[:10]}")
                    except Exception as e:
                        init_logger.warning(f"Could not fetch available symbols: {e}")

        except Exception as e:
            init_logger.error(f"Error during symbol validation: {e}", exc_info=True)


    # --- Interval Selection ---
    selected_interval = None
    while True:
        interval_input = input(f"{NEON_YELLOW}Enter analysis interval [{'/'.join(VALID_INTERVALS)}] (current default: {CONFIG['interval']}): {RESET}").strip()
        if not interval_input: # Use default if empty
            interval_input = CONFIG['interval']
            init_logger.info(f"Using default interval from config: {interval_input}")

        if interval_input in VALID_INTERVALS and interval_input in CCXT_INTERVAL_MAP:
            selected_interval = interval_input
            # Update config in memory for this run (doesn't save back to file)
            CONFIG["interval"] = selected_interval
            ccxt_tf = CCXT_INTERVAL_MAP[selected_interval]
            init_logger.info(f"Using analysis interval: {selected_interval} (CCXT: {ccxt_tf})")
            break
        else:
            init_logger.error(f"{NEON_RED}Invalid interval: '{interval_input}'. Please choose from {VALID_INTERVALS} or press Enter for default.{RESET}")


    # --- Setup Logger for the specific symbol ---
    # Use the validated target_symbol which might include ':'
    symbol_logger = setup_logger(target_symbol) # Get logger instance for this symbol
    # Ensure symbol logger's console handler also uses the correct level
    if console_handler:
        for handler in symbol_logger.handlers:
             if isinstance(handler, logging.StreamHandler):
                  handler.setLevel(console_log_level)
                  break

    symbol_logger.info(f"---=== Starting Trading Loop for {target_symbol} ({CONFIG['interval']}) ===---")
    symbol_logger.info(f"Using Configuration: Risk={CONFIG['risk_per_trade']:.2%}, Lev={CONFIG['leverage']}x, TSL={'ON' if CONFIG['enable_trailing_stop'] else 'OFF'}, BE={'ON' if CONFIG['enable_break_even'] else 'OFF'}, MA Exit={'ON' if CONFIG['enable_ma_cross_exit'] else 'OFF'}, Trading={'ENABLED' if CONFIG['enable_trading'] else 'DISABLED'}")


    # --- Main Execution Loop ---
    try:
        while True:
            loop_start_time = time.time()
            symbol_logger.debug(f">>> New Loop Cycle Starting at {datetime.now(TIMEZONE).strftime('%Y-%m-%d %H:%M:%S')}")

            try:
                # --- Optional: Reload config each loop? ---
                # Useful for dynamic adjustments without restarting the bot
                # CONFIG = load_config(CONFIG_FILE)
                # QUOTE_CURRENCY = CONFIG.get("quote_currency", "USDT") # Reload quote currency too
                # symbol_logger.debug("Config reloaded.")
                # --- End Optional Reload ---

                # Perform analysis and potentially trade/manage position
                analyze_and_trade_symbol(exchange, target_symbol, CONFIG, symbol_logger)

            # --- Handle Specific Errors within the loop ---
            except ccxt.RateLimitExceeded as e:
                # Extract wait time from error message if possible
                wait_time = RETRY_DELAY_SECONDS * 5 # Default wait time
                try:
                     if 'try again in' in str(e).lower():
                         wait_time_ms_str = str(e).lower().split('try again in')[1].split('ms')[0].strip()
                         wait_time = int(wait_time_ms_str) / 1000
                         wait_time = max(1, int(wait_time + 1))
                     elif 'rate limit' in str(e).lower():
                         import re
                         match = re.search(r'(\d+)\s*(ms|s)', str(e).lower())
                         if match:
                             num = int(match.group(1))
                             unit = match.group(2)
                             wait_time = num / 1000 if unit == 'ms' else num
                             wait_time = max(1, int(wait_time + 1))
                except Exception: pass
                symbol_logger.warning(f"{NEON_YELLOW}Rate limit exceeded: {
