{
  "runSettings": {
    "temperature": 1.0,
    "model": "models/gemini-2.5-pro-preview-03-25",
    "topP": 0.95,
    "topK": 64,
    "maxOutputTokens": 65536,
    "safetySettings": [{
      "category": "HARM_CATEGORY_HARASSMENT",
      "threshold": "OFF"
    }, {
      "category": "HARM_CATEGORY_HATE_SPEECH",
      "threshold": "OFF"
    }, {
      "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
      "threshold": "OFF"
    }, {
      "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
      "threshold": "OFF"
    }],
    "responseMimeType": "text/plain",
    "enableCodeExecution": false,
    "enableSearchAsATool": false,
    "enableBrowseAsATool": false,
    "enableAutoFunctionResponse": false
  },
  "systemInstruction": {
    "text": "termux coding wizard "
  },
  "chunkedPrompt": {
    "chunks": [{
      "text": "Okay, let\u0027s analyze the two provided Python scripts, identify areas for improvement and optimization, merge the best parts, and create an enhanced, upgraded bot.\n\n**Analysis of Provided Scripts:**\n\n*   **Script 1 (pasted_text_0.txt):**\n    *   **Strengths:** Robust `fetch_balance` trying multiple account types, detailed V5 parameter handling in fetch functions (though sometimes redundant), explicit rate limit parsing (`_handle_rate_limit`), good `TradingAnalyzer` structure with individual indicator checks, extensive use of `Decimal`, `SensitiveFormatter` for logging.\n    *   **Weaknesses:** Lacks explicit multi-symbol loop structure, calculates indicators individually (less efficient than `pandas_ta.Strategy`), missing Trailing Stop Loss (TSL) / Break-Even (BE) implementation logic (though config exists), incomplete manual rounding function.\n*   **Script 2 (pasted_text_1.txt):**\n    *   **Strengths:** Explicit multi-symbol design mentioned (config/comments), uses `pandas_ta.Strategy` (significant optimization), includes `symbol_state` management within `TradingAnalyzer` (good for BE), has TSL/BE configuration options, periodic market reloading, refined market info helper functions (`get_..._from_market`).\n    *   **Weaknesses:** `fetch_balance` is simpler, TSL/BE implementation logic is missing from the main loop structure, rate limit handling relies more on CCXT defaults.\n\n**Key Improvements and Optimizations Plan:**\n\n1.  **Merge Configuration:** Combine all config options, prioritizing File 2\u0027s multi-symbol structure (`symbols`) and TSL/BE options. Ensure `_ensure_config_keys` handles the superset.\n2.  **Adopt `pandas_ta.Strategy`:** Use File 2\u0027s approach for efficient indicator calculation within `TradingAnalyzer`.\n3.  **Enhance CCXT Interaction:**\n    *   Use File 2\u0027s explicit `versions` dictionary in `initialize_exchange` for better V5 targeting.\n    *   Keep File 1\u0027s timeouts and `brokerId`.\n    *   Incorporate File 2\u0027s periodic market reloading.\n    *   Use File 1\u0027s robust `fetch_balance`.\n    *   Standardize V5 `category` parameter usage in all fetch functions using `market_info`.\n    *   Implement robust CCXT wrapper functions (`fetch_positions_ccxt`, `create_order_ccxt`, `set_protection_ccxt`, etc.) with proper error handling, retries, and V5 parameters.\n4.  **Refine Market Info:** Use File 2\u0027s `get_market_info` and its helper functions (`get_min_tick_size_from_market`, etc.) for better precision/limit handling.\n5.  **Implement Multi-Symbol Loop:** Create a main loop that iterates through configured symbols, managing state for each.\n6.  **Implement Trading Logic:**\n    *   Add logic to check for existing positions.\n    *   Implement position sizing based on risk percentage.\n    *   Implement order placement (entry, SL, TP, TSL) using the new CCXT wrappers.\n    *   Implement position management (BE trigger, MA cross exit).\n7.  **State Management:** Use File 2\u0027s `symbol_state` concept, managed by the main loop and passed to `TradingAnalyzer`.\n8.  **Logging:** Keep `SensitiveFormatter`. Use File 2\u0027s idea of managed loggers per symbol.\n9.  **Precision:** Continue using `Decimal` for all financial calculations and ensure proper quantization using market info.\n10. **Command-Line Arguments:** Add `argparse` for flexibility (symbol override, debug level, live mode toggle).\n11. **Code Structure \u0026 Readability:** Improve organization, add type hints, docstrings, and comments.\n\n**Merged and Enhanced Code:**\n\n```python\n# -*- coding: utf-8 -*-\n\"\"\"\nEnhanced Multi-Symbol Trading Bot for Bybit (V5 API)\nMerges features, optimizations, and best practices from previous versions.\nIncludes: pandas_ta.Strategy, Decimal precision, robust CCXT interaction,\n          multi-symbol support, state management, TSL/BE logic, MA cross exit.\n\"\"\"\n\nimport argparse\nimport json\nimport logging\nimport math\nimport os\nimport sys\nimport time\nfrom datetime import datetime, timedelta\nfrom decimal import ROUND_DOWN, ROUND_UP, Decimal, InvalidOperation, getcontext\nfrom logging.handlers import RotatingFileHandler\nfrom typing import Any, Dict, List, Optional, Tuple, Union\nfrom zoneinfo import ZoneInfo  # Preferred over pytz\n\n# Third-party libraries - alphabetized\nimport ccxt\nimport numpy as np # pandas_ta might require numpy\nimport pandas as pd\nimport pandas_ta as ta\nfrom colorama import Fore, Style, init\nfrom dotenv import load_dotenv\n\n# --- Initialization ---\ngetcontext().prec \u003d 28  # Set precision for Decimal calculations\ninit(autoreset\u003dTrue)    # Initialize colorama\nload_dotenv()           # Load environment variables from .env file\n\n# --- Neon Color Scheme ---\nNEON_GREEN \u003d Fore.LIGHTGREEN_EX\nNEON_BLUE \u003d Fore.CYAN\nNEON_PURPLE \u003d Fore.MAGENTA\nNEON_YELLOW \u003d Fore.YELLOW\nNEON_RED \u003d Fore.LIGHTRED_EX\nNEON_CYAN \u003d Fore.CYAN\nRESET \u003d Style.RESET_ALL\n\n# --- Environment Variable Loading and Validation ---\nAPI_KEY \u003d os.getenv(\"BYBIT_API_KEY\")\nAPI_SECRET \u003d os.getenv(\"BYBIT_API_SECRET\")\nif not API_KEY or not API_SECRET:\n    # Use print as logger might not be set up yet\n    print(f\"{NEON_RED}FATAL: BYBIT_API_KEY and BYBIT_API_SECRET must be set in .env file{RESET}\")\n    sys.exit(1) # Exit if keys are missing\n\n# --- Configuration File and Constants ---\nCONFIG_FILE \u003d \"config.json\"\nLOG_DIRECTORY \u003d \"bot_logs\"\nSTATE_FILE \u003d \"bot_state.json\" # File to persist state like break-even triggers\n\n# Ensure log directory exists\nos.makedirs(LOG_DIRECTORY, exist_ok\u003dTrue)\n\n# Timezone for logging and display\ntry:\n    TZ_NAME \u003d os.getenv(\"BOT_TIMEZONE\", \"America/Chicago\") # Default timezone\n    TIMEZONE \u003d ZoneInfo(TZ_NAME)\nexcept Exception as tz_err:\n    print(f\"{NEON_YELLOW}Warning: Could not load timezone \u0027{TZ_NAME}\u0027: {tz_err}. Defaulting to UTC.{RESET}\")\n    TIMEZONE \u003d ZoneInfo(\"UTC\")\n\n# --- API Interaction Constants ---\nMAX_API_RETRIES \u003d 4 # Increased max retries slightly\nRETRY_DELAY_SECONDS \u003d 5 # Base delay between retries\nRATE_LIMIT_BUFFER_SECONDS \u003d 0.5 # Add small buffer to rate limit waits\nMARKET_RELOAD_INTERVAL_SECONDS \u003d 3600 # Reload markets every hour\nPOSITION_CONFIRM_DELAY \u003d 10 # Seconds to wait after placing order before checking position status\n\n# Intervals supported by the bot\u0027s internal logic (ensure config matches)\nVALID_INTERVALS \u003d [\"1\", \"3\", \"5\", \"15\", \"30\", \"60\", \"120\", \"240\", \"D\", \"W\", \"M\"]\n# Map bot intervals to ccxt\u0027s expected timeframe format\nCCXT_INTERVAL_MAP \u003d {\n    \"1\": \"1m\", \"3\": \"3m\", \"5\": \"5m\", \"15\": \"15m\", \"30\": \"30m\",\n    \"60\": \"1h\", \"120\": \"2h\", \"240\": \"4h\", \"D\": \"1d\", \"W\": \"1w\", \"M\": \"1M\"\n}\n\n# --- Default Indicator/Strategy Parameters (can be overridden by config.json) ---\nDEFAULT_ATR_PERIOD \u003d 14\nDEFAULT_CCI_WINDOW \u003d 20\nDEFAULT_WILLIAMS_R_WINDOW \u003d 14\nDEFAULT_MFI_WINDOW \u003d 14\nDEFAULT_STOCH_RSI_WINDOW \u003d 14 # Window for Stoch RSI calculation itself\nDEFAULT_STOCH_WINDOW \u003d 14     # Window for underlying RSI in StochRSI\nDEFAULT_K_WINDOW \u003d 3          # K period for StochRSI\nDEFAULT_D_WINDOW \u003d 3          # D period for StochRSI\nDEFAULT_RSI_WINDOW \u003d 14\nDEFAULT_BOLLINGER_BANDS_PERIOD \u003d 20\nDEFAULT_BOLLINGER_BANDS_STD_DEV \u003d 2.0 # Ensure float for calculations\nDEFAULT_SMA_10_WINDOW \u003d 10\nDEFAULT_EMA_SHORT_PERIOD \u003d 9\nDEFAULT_EMA_LONG_PERIOD \u003d 21\nDEFAULT_MOMENTUM_PERIOD \u003d 7\nDEFAULT_VOLUME_MA_PERIOD \u003d 15\nDEFAULT_FIB_WINDOW \u003d 50\nDEFAULT_PSAR_AF \u003d 0.02\nDEFAULT_PSAR_MAX_AF \u003d 0.2\nFIB_LEVELS \u003d [0.0, 0.236, 0.382, 0.5, 0.618, 0.786, 1.0] # Standard Fibonacci levels\n\n# --- Bot Timing and Delays ---\nDEFAULT_LOOP_DELAY_SECONDS \u003d 15 # Default time between full cycles\n\n# --- Global Variables ---\nloggers: Dict[str, logging.Logger] \u003d {} # Dictionary to hold logger instances\nconsole_log_level \u003d logging.INFO # Default, can be changed by args\nQUOTE_CURRENCY \u003d \"USDT\" # Default, updated from config\nLOOP_DELAY_SECONDS \u003d DEFAULT_LOOP_DELAY_SECONDS # Default, updated from config\n\n# --- Logger Setup ---\nclass SensitiveFormatter(logging.Formatter):\n    \"\"\"Custom formatter to redact sensitive information (API keys) from logs.\"\"\"\n    def format(self, record: logging.LogRecord) -\u003e str:\n        original_message \u003d super().format(record)\n        redacted_message \u003d original_message\n        if API_KEY:\n            redacted_message \u003d redacted_message.replace(API_KEY, \"***API_KEY***\")\n        if API_SECRET:\n            redacted_message \u003d redacted_message.replace(API_SECRET, \"***API_SECRET***\")\n        return redacted_message\n\nclass LocalTimeFormatter(SensitiveFormatter):\n    \"\"\"Formatter that uses the configured local timezone for console output.\"\"\"\n    converter \u003d lambda *args: datetime.now(TIMEZONE).timetuple()\n\ndef setup_logger(name: str, is_symbol_logger: bool \u003d False) -\u003e logging.Logger:\n    \"\"\"Sets up a logger with rotating file and timezone-aware console handlers.\"\"\"\n    global console_log_level # Access global console level setting\n\n    if name in loggers:\n        logger \u003d loggers[name]\n        # Update existing console handler level if needed\n        for handler in logger.handlers:\n            if isinstance(handler, logging.StreamHandler):\n                handler.setLevel(console_log_level)\n        # logger.debug(f\"Logger \u0027{name}\u0027 already configured. Console level set to {logging.getLevelName(console_log_level)}.\")\n        return logger\n\n    safe_name \u003d name.replace(\u0027/\u0027, \u0027_\u0027).replace(\u0027:\u0027, \u0027-\u0027) if is_symbol_logger else name\n    logger_instance_name \u003d f\"livebot_{safe_name}\"\n    log_filename \u003d os.path.join(LOG_DIRECTORY, f\"{logger_instance_name}.log\")\n    logger \u003d logging.getLogger(logger_instance_name)\n\n    logger.setLevel(logging.DEBUG) # Capture all levels\n\n    # --- File Handler (UTC Timestamps) ---\n    try:\n        file_handler \u003d RotatingFileHandler(\n            log_filename, maxBytes\u003d10 * 1024 * 1024, backupCount\u003d5, encoding\u003d\u0027utf-8\u0027\n        )\n        # Use UTC for file logs\n        file_formatter \u003d SensitiveFormatter(\n            \"%(asctime)s.%(msecs)03d UTC - %(levelname)s - [%(name)s:%(lineno)d] - %(message)s\",\n            datefmt\u003d\u0027%Y-%m-%d %H:%M:%S\u0027\n        )\n        logging.Formatter.converter \u003d time.gmtime # Set converter for this formatter\n        file_handler.setFormatter(file_formatter)\n        file_handler.setLevel(logging.DEBUG) # Log everything to the file\n        logger.addHandler(file_handler)\n    except Exception as e:\n        print(f\"{NEON_RED}Error setting up file logger for {log_filename}: {e}{RESET}\")\n\n    # --- Stream Handler (Local Time Timestamps) ---\n    stream_handler \u003d logging.StreamHandler(sys.stdout) # Explicitly use stdout\n    stream_formatter \u003d LocalTimeFormatter(\n        f\"{NEON_BLUE}%(asctime)s{RESET} {TIMEZONE.tzname(datetime.now(TIMEZONE))} - {NEON_YELLOW}%(levelname)-8s{RESET} - {NEON_PURPLE}[%(name)s]{RESET} - %(message)s\",\n        datefmt\u003d\u0027%Y-%m-%d %H:%M:%S\u0027\n    )\n    stream_handler.setFormatter(stream_formatter)\n    stream_handler.setLevel(console_log_level) # Set level from global variable\n    logger.addHandler(stream_handler)\n\n    logger.propagate \u003d False # Prevent duplicate logs in parent/root logger\n    loggers[name] \u003d logger\n    logger.info(f\"Logger \u0027{logger_instance_name}\u0027 initialized. File: \u0027{log_filename}\u0027, Console Level: {logging.getLevelName(console_log_level)}\")\n    return logger\n\ndef get_logger(name: str, is_symbol_logger: bool \u003d False) -\u003e logging.Logger:\n    \"\"\"Retrieves or creates a logger instance.\"\"\"\n    return setup_logger(name, is_symbol_logger)\n\n# --- Configuration Management ---\ndef _ensure_config_keys(config: Dict[str, Any], default_config: Dict[str, Any]) -\u003e Tuple[Dict[str, Any], bool]:\n    \"\"\"Recursively ensures all keys from the default config are present in the loaded config.\"\"\"\n    updated_config \u003d config.copy()\n    keys_added \u003d False\n    for key, default_value in default_config.items():\n        if key not in updated_config:\n            updated_config[key] \u003d default_value\n            keys_added \u003d True\n            print(f\"{NEON_YELLOW}Config Warning: Missing key \u0027{key}\u0027. Added default value: {default_value}{RESET}\")\n        elif isinstance(default_value, dict) and isinstance(updated_config.get(key), dict):\n            nested_updated_config, nested_keys_added \u003d _ensure_config_keys(updated_config[key], default_value)\n            if nested_keys_added:\n                updated_config[key] \u003d nested_updated_config\n                keys_added \u003d True\n        # Optional: Type mismatch check (allow int for float default, but warn otherwise)\n        elif type(default_value) !\u003d type(updated_config.get(key)) and updated_config.get(key) is not None:\n             if not (isinstance(default_value, (float, Decimal)) and isinstance(updated_config.get(key), int)):\n                 # Allow loading int if float/Decimal is default\n                 if not (isinstance(default_value, int) and isinstance(updated_config.get(key), (float, Decimal))):\n                    print(f\"{NEON_YELLOW}Config Warning: Type mismatch for key \u0027{key}\u0027. Expected {type(default_value)}, got {type(updated_config.get(key))}. Using loaded value \u0027{updated_config.get(key)}\u0027.{RESET}\")\n\n    return updated_config, keys_added\n\ndef load_config(filepath: str) -\u003e Dict[str, Any]:\n    \"\"\"Load config, create default if missing, ensure keys exist, save updates.\"\"\"\n    default_config \u003d {\n        \"symbols\": [\"BTC/USDT:USDT\"], # List of CCXT symbols (e.g., BASE/QUOTE:SETTLE)\n        \"interval\": \"5\", # Default interval (string, ensure it\u0027s in VALID_INTERVALS)\n        \"loop_delay\": DEFAULT_LOOP_DELAY_SECONDS,\n        \"quote_currency\": \"USDT\",\n        \"enable_trading\": False, # SAFETY FIRST: Default to False\n        \"use_sandbox\": True,     # SAFETY FIRST: Default to True (testnet)\n        \"risk_per_trade\": 0.01, # Risk 1% (as float)\n        \"leverage\": 20,          # Desired leverage (check exchange limits!)\n        \"max_concurrent_positions_total\": 1, # Global limit across all symbols\n        \"position_mode\": \"One-Way\", # \"One-Way\" or \"Hedge\" - MUST MATCH EXCHANGE SETTING\n        # --- Indicator Periods \u0026 Settings ---\n        \"atr_period\": DEFAULT_ATR_PERIOD,\n        \"ema_short_period\": DEFAULT_EMA_SHORT_PERIOD,\n        \"ema_long_period\": DEFAULT_EMA_LONG_PERIOD,\n        \"rsi_period\": DEFAULT_RSI_WINDOW,\n        \"bollinger_bands_period\": DEFAULT_BOLLINGER_BANDS_PERIOD,\n        \"bollinger_bands_std_dev\": DEFAULT_BOLLINGER_BANDS_STD_DEV,\n        \"cci_window\": DEFAULT_CCI_WINDOW,\n        \"williams_r_window\": DEFAULT_WILLIAMS_R_WINDOW,\n        \"mfi_window\": DEFAULT_MFI_WINDOW,\n        \"stoch_rsi_window\": DEFAULT_STOCH_RSI_WINDOW,\n        \"stoch_rsi_rsi_window\": DEFAULT_STOCH_WINDOW,\n        \"stoch_rsi_k\": DEFAULT_K_WINDOW,\n        \"stoch_rsi_d\": DEFAULT_D_WINDOW,\n        \"psar_af\": DEFAULT_PSAR_AF,\n        \"psar_max_af\": DEFAULT_PSAR_MAX_AF,\n        \"sma_10_window\": DEFAULT_SMA_10_WINDOW,\n        \"momentum_period\": DEFAULT_MOMENTUM_PERIOD,\n        \"volume_ma_period\": DEFAULT_VOLUME_MA_PERIOD,\n        \"fibonacci_window\": DEFAULT_FIB_WINDOW,\n        # --- Signal Generation \u0026 Thresholds ---\n        \"orderbook_limit\": 25,\n        \"signal_score_threshold\": 1.5, # Use float\n        \"stoch_rsi_oversold_threshold\": 25.0, # Use float\n        \"stoch_rsi_overbought_threshold\": 75.0, # Use float\n        \"volume_confirmation_multiplier\": 1.5, # Use float\n        \"scalping_signal_threshold\": 2.5, # Use float (for \u0027scalping\u0027 weight set)\n        # --- Risk Management Multipliers (based on ATR) ---\n        \"stop_loss_multiple\": 1.8, # Use float (for initial SL sizing)\n        \"take_profit_multiple\": 0.7, # Use float\n        # --- Exit Strategies ---\n        \"enable_ma_cross_exit\": True,\n        # --- Trailing Stop Loss Config (Exchange-based TSL) ---\n        \"enable_trailing_stop\": True,\n        # Trail distance as a percentage of entry price (e.g., 0.005 for 0.5%)\n        # This percentage is used to calculate the absolute \u0027trailingStop\u0027 value for Bybit API\n        \"trailing_stop_callback_rate\": 0.005, # Use float\n        # Activate TSL when price moves this percentage in profit (e.g., 0.003 for 0.3%)\n        # Set to 0 for immediate activation (API value \u00270\u0027). Calculated into \u0027activePrice\u0027 for Bybit API.\n        \"trailing_stop_activation_percentage\": 0.003, # Use float\n        # --- Break-Even Stop Config ---\n        \"enable_break_even\": True,\n        \"break_even_trigger_atr_multiple\": 1.0, # Use float (Trigger BE when profit \u003d X * ATR)\n        \"break_even_offset_ticks\": 2, # Use integer (Place BE SL N ticks beyond entry)\n        \"break_even_force_fixed_sl\": True, # Cancel TSL and set fixed SL at BE price? (Safer for Bybit V5)\n        # --- Indicator Enable/Disable Flags ---\n        \"indicators\": {\n            \"ema_alignment\": True, \"momentum\": True, \"volume_confirmation\": True,\n            \"stoch_rsi\": True, \"rsi\": True, \"bollinger_bands\": True, \"vwap\": True,\n            \"cci\": True, \"wr\": True, \"psar\": True, \"sma_10\": True, \"mfi\": True,\n            \"orderbook\": True,\n        },\n        # --- Indicator Weighting Sets ---\n        \"weight_sets\": {\n            \"scalping\": {\n                \"ema_alignment\": 0.2, \"momentum\": 0.3, \"volume_confirmation\": 0.2,\n                \"stoch_rsi\": 0.6, \"rsi\": 0.2, \"bollinger_bands\": 0.3, \"vwap\": 0.4,\n                \"cci\": 0.3, \"wr\": 0.3, \"psar\": 0.2, \"sma_10\": 0.1, \"mfi\": 0.2, \"orderbook\": 0.15,\n            },\n            \"default\": {\n                \"ema_alignment\": 0.3, \"momentum\": 0.2, \"volume_confirmation\": 0.1,\n                \"stoch_rsi\": 0.4, \"rsi\": 0.3, \"bollinger_bands\": 0.2, \"vwap\": 0.3,\n                \"cci\": 0.2, \"wr\": 0.2, \"psar\": 0.3, \"sma_10\": 0.1, \"mfi\": 0.2, \"orderbook\": 0.1,\n            }\n        },\n        \"active_weight_set\": \"default\" # Which weight set to use\n    }\n\n    # --- File Handling ---\n    if not os.path.exists(filepath):\n        print(f\"{NEON_YELLOW}Config file not found at \u0027{filepath}\u0027. Creating default config...{RESET}\")\n        try:\n            with open(filepath, \"w\", encoding\u003d\"utf-8\") as f:\n                json.dump(default_config, f, indent\u003d4, sort_keys\u003dTrue)\n            print(f\"{NEON_GREEN}Created default config file: {filepath}{RESET}\")\n            return default_config\n        except IOError as e:\n            print(f\"{NEON_RED}Error creating default config file {filepath}: {e}. Using in-memory defaults.{RESET}\")\n            return default_config\n\n    # --- Load Existing Config and Merge Defaults ---\n    try:\n        with open(filepath, \"r\", encoding\u003d\"utf-8\") as f:\n            config_from_file \u003d json.load(f)\n        updated_config, keys_added \u003d _ensure_config_keys(config_from_file, default_config)\n        if keys_added:\n            print(f\"{NEON_YELLOW}Updating config file \u0027{filepath}\u0027 with missing/changed default keys...{RESET}\")\n            try:\n                with open(filepath, \"w\", encoding\u003d\"utf-8\") as f_write:\n                    json.dump(updated_config, f_write, indent\u003d4, sort_keys\u003dTrue)\n                print(f\"{NEON_GREEN}Config file updated successfully.{RESET}\")\n            except IOError as e:\n                print(f\"{NEON_RED}Error writing updated config file {filepath}: {e}{RESET}\")\n        return updated_config\n    except (FileNotFoundError, json.JSONDecodeError) as e:\n        print(f\"{NEON_RED}Error loading config file {filepath}: {e}. Using default config.{RESET}\")\n        try: # Attempt to recreate default if loading failed\n            with open(filepath, \"w\", encoding\u003d\"utf-8\") as f:\n                json.dump(default_config, f, indent\u003d4, sort_keys\u003dTrue)\n            print(f\"{NEON_GREEN}Recreated default config file: {filepath}{RESET}\")\n        except IOError as e_create:\n            print(f\"{NEON_RED}Error recreating default config file after load error: {e_create}{RESET}\")\n        return default_config\n    except Exception as e:\n        print(f\"{NEON_RED}Unexpected error loading configuration: {e}. Using defaults.{RESET}\")\n        return default_config\n\n# --- State Management ---\ndef load_state(filepath: str, logger: logging.Logger) -\u003e Dict[str, Any]:\n    \"\"\"Loads the bot\u0027s state from a JSON file.\"\"\"\n    if os.path.exists(filepath):\n        try:\n            with open(filepath, \u0027r\u0027, encoding\u003d\u0027utf-8\u0027) as f:\n                state \u003d json.load(f)\n                logger.info(f\"Loaded previous state from {filepath}\")\n                return state\n        except (json.JSONDecodeError, IOError) as e:\n            logger.error(f\"Error loading state file {filepath}: {e}. Starting with empty state.\")\n            return {}\n        except Exception as e:\n            logger.error(f\"Unexpected error loading state: {e}. Starting with empty state.\", exc_info\u003dTrue)\n            return {}\n    else:\n        logger.info(\"No previous state file found. Starting with empty state.\")\n        return {}\n\ndef save_state(filepath: str, state: Dict[str, Any], logger: logging.Logger):\n    \"\"\"Saves the bot\u0027s state to a JSON file.\"\"\"\n    try:\n        with open(filepath, \u0027w\u0027, encoding\u003d\u0027utf-8\u0027) as f:\n            json.dump(state, f, indent\u003d4)\n        logger.debug(f\"Saved current state to {filepath}\")\n    except (IOError, TypeError) as e:\n        logger.error(f\"Error saving state file {filepath}: {e}\")\n    except Exception as e:\n        logger.error(f\"Unexpected error saving state: {e}\", exc_info\u003dTrue)\n\n# --- CCXT Exchange Setup ---\ndef initialize_exchange(config: Dict[str, Any], logger: logging.Logger) -\u003e Optional[ccxt.Exchange]:\n    \"\"\"Initializes the CCXT Bybit exchange object with V5 settings, error handling, and tests.\"\"\"\n    lg \u003d logger\n    global QUOTE_CURRENCY # Allow updating global quote currency\n\n    try:\n        # Update global quote currency from config\n        QUOTE_CURRENCY \u003d config.get(\"quote_currency\", \"USDT\")\n        lg.info(f\"Using Quote Currency: {QUOTE_CURRENCY}\")\n\n        exchange_options \u003d {\n            \u0027apiKey\u0027: API_KEY,\n            \u0027secret\u0027: API_SECRET,\n            \u0027enableRateLimit\u0027: True, # Let ccxt handle basic rate limiting\n            \u0027options\u0027: {\n                \u0027defaultType\u0027: \u0027linear\u0027, # Assume linear contracts (USDT margined)\n                \u0027adjustForTimeDifference\u0027: True, # Auto-sync time with server\n                # Connection timeouts (milliseconds)\n                \u0027fetchTickerTimeout\u0027: 10000, # 10 seconds\n                \u0027fetchBalanceTimeout\u0027: 15000, # 15 seconds\n                \u0027createOrderTimeout\u0027: 20000, # Timeout for placing orders\n                \u0027fetchOrderTimeout\u0027: 15000,  # Timeout for fetching orders\n                \u0027fetchPositionsTimeout\u0027: 15000, # Timeout for fetching positions\n                \u0027cancelOrderTimeout\u0027: 15000, # Timeout for cancelling orders\n                \u0027recvWindow\u0027: 10000, # Bybit default is 5000, 10000 is safer\n                \u0027brokerId\u0027: \u0027EnhancedWhale71\u0027, # Add a broker ID for Bybit tracking\n                # Explicitly request V5 API for relevant endpoints using \u0027versions\u0027\n                \u0027versions\u0027: {\n                    \u0027public\u0027: {\n                        \u0027GET\u0027: {\n                            \u0027market/tickers\u0027: \u0027v5\u0027,\n                            \u0027market/kline\u0027: \u0027v5\u0027,\n                            \u0027market/orderbook\u0027: \u0027v5\u0027,\n                        },\n                    },\n                    \u0027private\u0027: {\n                        \u0027GET\u0027: {\n                            \u0027position/list\u0027: \u0027v5\u0027,\n                            \u0027account/wallet-balance\u0027: \u0027v5\u0027,\n                            \u0027order/realtime\u0027: \u0027v5\u0027, # For fetching open orders\n                            \u0027order/history\u0027: \u0027v5\u0027, # For fetching historical orders\n                        },\n                        \u0027POST\u0027: {\n                            \u0027order/create\u0027: \u0027v5\u0027,\n                            \u0027order/cancel\u0027: \u0027v5\u0027,\n                            \u0027position/set-leverage\u0027: \u0027v5\u0027,\n                            \u0027position/trading-stop\u0027: \u0027v5\u0027, # For SL/TP/TSL\n                        },\n                    },\n                },\n                 # Fallback default options (may be redundant with \u0027versions\u0027)\n                 \u0027default_options\u0027: {\n                    \u0027adjustForTimeDifference\u0027: True,\n                    \u0027warnOnFetchOpenOrdersWithoutSymbol\u0027: False,\n                    \u0027recvWindow\u0027: 10000,\n                    \u0027fetchPositions\u0027: \u0027v5\u0027,\n                    \u0027fetchBalance\u0027: \u0027v5\u0027,\n                    \u0027createOrder\u0027: \u0027v5\u0027,\n                    \u0027fetchOrder\u0027: \u0027v5\u0027,\n                    \u0027fetchTicker\u0027: \u0027v5\u0027,\n                    \u0027fetchOHLCV\u0027: \u0027v5\u0027,\n                    \u0027fetchOrderBook\u0027: \u0027v5\u0027,\n                    \u0027setLeverage\u0027: \u0027v5\u0027,\n                    \u0027private_post_v5_position_trading_stop\u0027: \u0027v5\u0027,\n                },\n                \u0027accounts\u0027: { # Define V5 account types\n                    \u0027future\u0027: {\u0027linear\u0027: \u0027CONTRACT\u0027, \u0027inverse\u0027: \u0027CONTRACT\u0027},\n                    \u0027swap\u0027: {\u0027linear\u0027: \u0027CONTRACT\u0027, \u0027inverse\u0027: \u0027CONTRACT\u0027},\n                    \u0027option\u0027: {\u0027unified\u0027: \u0027OPTION\u0027},\n                    \u0027spot\u0027: {\u0027unified\u0027: \u0027SPOT\u0027, \u0027spot\u0027: \u0027SPOT\u0027}, # Allow both\n                    \u0027unified\u0027: {\u0027linear\u0027: \u0027UNIFIED\u0027, \u0027inverse\u0027: \u0027UNIFIED\u0027, \u0027spot\u0027: \u0027UNIFIED\u0027, \u0027option\u0027: \u0027UNIFIED\u0027},\n                    \u0027contract\u0027: {\u0027contract\u0027: \u0027CONTRACT\u0027}, # Explicit contract type\n                },\n                \u0027bybit\u0027: { # Bybit specific options\n                     \u0027defaultSettleCoin\u0027: QUOTE_CURRENCY,\n                }\n            }\n        }\n\n        exchange_id \u003d \u0027bybit\u0027\n        exchange_class \u003d getattr(ccxt, exchange_id)\n        exchange \u003d exchange_class(exchange_options)\n\n        if config.get(\u0027use_sandbox\u0027, True):\n            lg.warning(f\"{NEON_YELLOW}USING SANDBOX MODE (Testnet){RESET}\")\n            exchange.set_sandbox_mode(True)\n        else:\n            lg.warning(f\"{NEON_RED}--- USING LIVE TRADING MODE (Real Money) ---{RESET}\")\n\n        # --- Test Connection \u0026 Load Markets ---\n        lg.info(f\"Connecting to {exchange.id} (Sandbox: {config.get(\u0027use_sandbox\u0027, True)})...\")\n        lg.info(f\"Loading markets for {exchange.id}...\")\n        try:\n            # Load all relevant categories initially\n            categories_to_load \u003d [\u0027linear\u0027, \u0027spot\u0027] # Add \u0027inverse\u0027, \u0027option\u0027 if needed\n            for category in categories_to_load:\n                try:\n                    lg.debug(f\"Loading {category} markets...\")\n                    exchange.load_markets(params\u003d{\u0027category\u0027: category})\n                except Exception as market_load_err:\n                    lg.warning(f\"Could not pre-load {category} markets: {market_load_err}. Relying on default load.\")\n            # Ensure markets are loaded if category loading failed\n            if not exchange.markets:\n                exchange.load_markets()\n\n            exchange.last_load_markets_timestamp \u003d time.time()\n            lg.info(f\"Markets loaded successfully for {exchange.id}. CCXT Version: {ccxt.__version__}\")\n        except (ccxt.NetworkError, ccxt.ExchangeError, Exception) as e:\n            lg.error(f\"{NEON_RED}Error loading markets: {e}. Check connection/API settings.{RESET}\", exc_info\u003dTrue)\n            return None\n\n        # --- Test API Credentials \u0026 Permissions (Fetch Balance) ---\n        lg.info(f\"Attempting initial balance fetch for {QUOTE_CURRENCY}...\")\n        try:\n            # Use the robust fetch_balance function\n            balance_decimal \u003d fetch_balance(exchange, QUOTE_CURRENCY, lg)\n\n            if balance_decimal is not None:\n                 lg.info(f\"{NEON_GREEN}Successfully connected and fetched initial balance.{RESET} ({QUOTE_CURRENCY} available: {balance_decimal:.4f})\")\n            else:\n                 lg.warning(f\"{NEON_YELLOW}Initial balance fetch returned None or failed. Check logs. Ensure API keys have \u0027Read\u0027 permissions and correct account type (CONTRACT/UNIFIED/SPOT) is accessible for {QUOTE_CURRENCY}.{RESET}\")\n                 if config.get(\"enable_trading\"):\n                     lg.error(f\"{NEON_RED}Cannot verify balance. Trading is enabled, aborting initialization for safety.{RESET}\")\n                     return None\n                 else:\n                     lg.warning(\"Continuing in non-trading mode despite balance fetch issue.\")\n\n        except ccxt.AuthenticationError as auth_err:\n            lg.error(f\"{NEON_RED}CCXT Authentication Error during initial balance fetch: {auth_err}{RESET}\")\n            lg.error(f\"{NEON_RED}\u003e\u003e Ensure API keys are correct, have necessary permissions (Read, Trade), match the account type (Real/Testnet), and IP whitelist is correctly set if enabled on Bybit.{RESET}\")\n            return None\n        except Exception as balance_err:\n            lg.warning(f\"{NEON_YELLOW}Warning during initial balance fetch: {balance_err}. Continuing, but check API permissions/account type if trading fails.{RESET}\")\n            if config.get(\"enable_trading\"):\n                 lg.error(f\"{NEON_RED}Aborting initialization due to balance fetch error in trading mode.{RESET}\")\n                 return None\n\n        return exchange\n\n    except (ccxt.AuthenticationError, ccxt.ExchangeError, ccxt.NetworkError, Exception) as e:\n        lg.error(f\"{NEON_RED}Failed to initialize CCXT exchange: {e}{RESET}\", exc_info\u003dTrue)\n        return None\n\n# --- CCXT API Call Helper with Retries ---\ndef safe_ccxt_call(\n    exchange: ccxt.Exchange,\n    method_name: str,\n    logger: logging.Logger,\n    max_retries: int \u003d MAX_API_RETRIES,\n    retry_delay: int \u003d RETRY_DELAY_SECONDS,\n    *args, **kwargs\n) -\u003e Any:\n    \"\"\"Safely calls a CCXT method with retry logic for network errors and rate limits.\"\"\"\n    lg \u003d logger\n    last_exception \u003d None\n    for attempt in range(max_retries + 1):\n        try:\n            method \u003d getattr(exchange, method_name)\n            lg.debug(f\"Calling {method_name} (Attempt {attempt + 1}/{max_retries + 1}) Args: {args}, Kwargs: {kwargs}\")\n            result \u003d method(*args, **kwargs)\n            lg.debug(f\"{method_name} call successful.\")\n            return result\n        except ccxt.RateLimitExceeded as e:\n            last_exception \u003d e\n            wait_time \u003d RETRY_DELAY_SECONDS * (2 ** attempt) # Exponential backoff\n            try: # Try parsing suggested wait time\n                import re\n                error_msg \u003d str(e).lower()\n                match_ms \u003d re.search(r\u0027(?:try again in|retry after)\\s*(\\d+)\\s*ms\u0027, error_msg)\n                match_s \u003d re.search(r\u0027(?:try again in|retry after)\\s*(\\d+)\\s*s\u0027, error_msg)\n                if match_ms: wait_time \u003d max(1, math.ceil(int(match_ms.group(1)) / 1000) + RATE_LIMIT_BUFFER_SECONDS)\n                elif match_s: wait_time \u003d max(1, int(match_s.group(1)) + RATE_LIMIT_BUFFER_SECONDS)\n            except Exception: pass # Ignore parsing errors, use default backoff\n            lg.warning(f\"Rate limit hit calling {method_name}. Retrying in {wait_time:.2f}s... (Attempt {attempt + 1})\")\n            time.sleep(wait_time)\n        except (ccxt.NetworkError, ccxt.RequestTimeout, ccxt.DDoSProtection) as e:\n            last_exception \u003d e\n            wait_time \u003d retry_delay * (2 ** attempt) # Exponential backoff\n            lg.warning(f\"Network/DDoS error calling {method_name}: {e}. Retrying in {wait_time}s... (Attempt {attempt + 1})\")\n            time.sleep(wait_time)\n        except ccxt.AuthenticationError as e:\n            lg.error(f\"{NEON_RED}Authentication Error calling {method_name}: {e}. Check API keys/permissions. Not retrying.{RESET}\")\n            raise e # Re-raise critical auth errors\n        except ccxt.ExchangeError as e:\n            # Check for specific non-retryable exchange errors if needed\n            # Example: Bybit order placement errors like insufficient margin (code 110007?)\n            bybit_code \u003d getattr(e, \u0027code\u0027, None)\n            lg.error(f\"{NEON_RED}Exchange Error calling {method_name}: {e} (Code: {bybit_code}). Not retrying.{RESET}\")\n            raise e # Re-raise other exchange errors\n        except Exception as e:\n            lg.error(f\"{NEON_RED}Unexpected Error calling {method_name}: {e}. Not retrying.{RESET}\", exc_info\u003dTrue)\n            raise e # Re-raise unexpected errors\n\n    lg.error(f\"{NEON_RED}Max retries ({max_retries}) reached for {method_name}. Last error: {last_exception}{RESET}\")\n    raise last_exception # Re-raise the last exception after exhausting retries\n\n# --- Market Info Helper Functions ---\ndef _determine_category(market_info: Dict, logger: logging.Logger) -\u003e Optional[str]:\n    \"\"\"Helper to determine Bybit V5 category from market info.\"\"\"\n    if not market_info: return None\n    market_type \u003d market_info.get(\u0027type\u0027) # spot, swap, future, option\n    is_linear \u003d market_info.get(\u0027linear\u0027, False)\n    is_inverse \u003d market_info.get(\u0027inverse\u0027, False)\n    is_contract \u003d market_info.get(\u0027contract\u0027, False)\n    is_spot \u003d market_info.get(\u0027spot\u0027, False)\n    is_option \u003d market_info.get(\u0027option\u0027, False)\n    symbol \u003d market_info.get(\u0027symbol\u0027, \u0027N/A\u0027)\n\n    # Explicit types first\n    if market_type \u003d\u003d \u0027swap\u0027 or market_type \u003d\u003d \u0027future\u0027 or is_contract:\n        if is_linear: return \u0027linear\u0027\n        if is_inverse: return \u0027inverse\u0027\n        # Fallback guess for contracts based on settle currency\n        settle \u003d market_info.get(\u0027settle\u0027, \u0027\u0027).upper()\n        if settle \u003d\u003d \u0027USDT\u0027 or settle \u003d\u003d \u0027USDC\u0027: return \u0027linear\u0027\n        if settle \u003d\u003d market_info.get(\u0027base\u0027, \u0027\u0027).upper(): return \u0027inverse\u0027\n        logger.warning(f\"Could not determine linear/inverse for contract {symbol}. Defaulting to linear.\")\n        return \u0027linear\u0027 # Default guess\n    elif market_type \u003d\u003d \u0027spot\u0027 or is_spot:\n        return \u0027spot\u0027\n    elif market_type \u003d\u003d \u0027option\u0027 or is_option:\n        return \u0027option\u0027\n    # Fallback based on flags if type is missing/unknown\n    elif is_linear: return \u0027linear\u0027\n    elif is_inverse: return \u0027inverse\u0027\n    else:\n        logger.warning(f\"Could not determine category for market {symbol}. Market Type: {market_type}, Flags: L\u003d{is_linear},I\u003d{is_inverse},C\u003d{is_contract},S\u003d{is_spot},O\u003d{is_option}. Defaulting to None.\")\n        return None # Cannot determine\n\ndef get_market_info(exchange: ccxt.Exchange, symbol: str, logger: logging.Logger) -\u003e Optional[Dict]:\n    \"\"\"Fetches and returns enhanced market information for a symbol, handling reloads.\"\"\"\n    lg \u003d logger\n    try:\n        # Reload markets periodically or if info is missing/stale\n        reload_needed \u003d False\n        if not hasattr(exchange, \u0027last_load_markets_timestamp\u0027):\n            reload_needed \u003d True\n            lg.info(\"Initial market load timestamp missing.\")\n        elif time.time() - exchange.last_load_markets_timestamp \u003e MARKET_RELOAD_INTERVAL_SECONDS:\n            reload_needed \u003d True\n            lg.info(f\"Market info older than {MARKET_RELOAD_INTERVAL_SECONDS}s. Reloading...\")\n        elif symbol not in exchange.markets:\n             reload_needed \u003d True\n             lg.warning(f\"Symbol {symbol} not found in cached markets. Reloading...\")\n\n        if reload_needed:\n            try:\n                # Use safe call for loading markets\n                safe_ccxt_call(exchange, \u0027load_markets\u0027, lg, reload\u003dTrue)\n                exchange.last_load_markets_timestamp \u003d time.time()\n                lg.info(\"Markets reloaded successfully.\")\n            except Exception as load_err:\n                 lg.error(f\"{NEON_RED}Failed to reload markets: {load_err}{RESET}\")\n                 # Attempt to use potentially stale data if available\n                 if symbol not in exchange.markets:\n                     return None # Cannot proceed without market info\n\n        # Get market data\n        market \u003d exchange.market(symbol)\n        if not market: # Should not happen if load_markets worked, but check anyway\n             lg.error(f\"{NEON_RED}Market data for {symbol} is unexpectedly None after load/check.{RESET}\")\n             return None\n\n        # --- Enhance market dict with standardized/derived info ---\n        market[\u0027category\u0027] \u003d _determine_category(market, lg)\n        market[\u0027min_tick_size\u0027] \u003d get_min_tick_size_from_market(market, lg)\n        market[\u0027price_precision_digits\u0027] \u003d get_price_precision_digits_from_market(market, lg)\n        market[\u0027amount_precision_digits\u0027] \u003d get_amount_precision_digits_from_market(market, lg)\n        market[\u0027min_order_amount\u0027] \u003d get_min_order_amount_from_market(market, lg)\n        market[\u0027min_order_cost\u0027] \u003d get_min_order_cost_from_market(market, lg)\n        market[\u0027contract_size\u0027] \u003d get_contract_size_from_market(market, lg)\n        market[\u0027is_contract\u0027] \u003d market.get(\u0027contract\u0027, False) or market.get(\u0027type\u0027) in [\u0027swap\u0027, \u0027future\u0027]\n\n        # Log key derived values\n        lg.debug(f\"Enhanced Market Info ({symbol}): Category\u003d{market[\u0027category\u0027]}, Tick\u003d{market[\u0027min_tick_size\u0027]}, \"\n                 f\"PricePrec\u003d{market[\u0027price_precision_digits\u0027]}, AmtPrec\u003d{market[\u0027amount_precision_digits\u0027]}, \"\n                 f\"MinAmt\u003d{market[\u0027min_order_amount\u0027]}, MinCost\u003d{market[\u0027min_order_cost\u0027]}, \"\n                 f\"ContractSize\u003d{market[\u0027contract_size\u0027]}, IsContract\u003d{market[\u0027is_contract\u0027]}\")\n\n        return market\n\n    except ccxt.BadSymbol:\n        lg.error(f\"{NEON_RED}Symbol \u0027{symbol}\u0027 is not valid or not supported by {exchange.id}.{RESET}\")\n    except (ccxt.NetworkError, ccxt.ExchangeError) as e:\n        lg.error(f\"{NEON_RED}API error fetching market info for {symbol}: {e}{RESET}\")\n    except Exception as e:\n        lg.error(f\"{NEON_RED}Unexpected error fetching market info for {symbol}: {e}{RESET}\", exc_info\u003dTrue)\n    return None\n\ndef get_min_tick_size_from_market(market: Dict, logger: logging.Logger) -\u003e Optional[Decimal]:\n    \"\"\"Extracts minimum price increment (tick size) from CCXT market structure.\"\"\"\n    symbol \u003d market.get(\u0027symbol\u0027, \u0027N/A\u0027)\n    try:\n        precision_info \u003d market.get(\u0027precision\u0027, {})\n        tick_size_raw \u003d precision_info.get(\u0027price\u0027)\n\n        if tick_size_raw is None:\n             info \u003d market.get(\u0027info\u0027, {})\n             # Bybit V5 structure\n             tick_size_raw \u003d info.get(\u0027priceFilter\u0027, {}).get(\u0027tickSize\u0027)\n             if tick_size_raw is None: tick_size_raw \u003d info.get(\u0027tickSize\u0027) # Older?\n\n        if tick_size_raw is not None:\n            tick_size \u003d Decimal(str(tick_size_raw))\n            if tick_size \u003e 0: return tick_size\n            else: logger.warning(f\"Parsed tick size is not positive ({tick_size_raw} -\u003e {tick_size}) for {symbol}.\"); return None\n        else:\n             # Try inferring from precision digits\n             digits \u003d get_price_precision_digits_from_market(market, logger)\n             if digits is not None: return Decimal(\u00271\u0027) / (Decimal(\u002710\u0027) ** digits)\n             logger.warning(f\"Could not find or infer price tick size for {symbol}.\")\n             return None\n    except (InvalidOperation, ValueError, TypeError, KeyError) as e:\n        logger.error(f\"Error determining min tick size for {symbol}: {e}\")\n        return None\n\ndef get_price_precision_digits_from_market(market: Dict, logger: logging.Logger) -\u003e Optional[int]:\n    \"\"\"Extracts number of decimal places for price from CCXT market structure.\"\"\"\n    symbol \u003d market.get(\u0027symbol\u0027, \u0027N/A\u0027)\n    try:\n        precision_info \u003d market.get(\u0027precision\u0027, {})\n        price_prec_raw \u003d precision_info.get(\u0027price\u0027) # Could be digits or tick size\n\n        if price_prec_raw is not None:\n            price_prec_dec \u003d Decimal(str(price_prec_raw))\n            # If it looks like a tick size (0 \u003c x \u003c 1)\n            if 0 \u003c price_prec_dec \u003c 1:\n                return abs(price_prec_dec.normalize().as_tuple().exponent)\n            # If it looks like integer digits (\u003e\u003d 0)\n            elif price_prec_dec \u003e\u003d 0 and price_prec_dec \u003d\u003d price_prec_dec.to_integral_value():\n                return int(price_prec_dec)\n            else: logger.warning(f\"Unusual price precision value \u0027{price_prec_raw}\u0027 for {symbol}. Trying tick size.\")\n\n        # If not found or unusual, try inferring from tick size\n        min_tick \u003d get_min_tick_size_from_market(market, logger)\n        if min_tick is not None and min_tick \u003e 0:\n            return abs(min_tick.normalize().as_tuple().exponent)\n\n        logger.warning(f\"Could not determine price precision digits for {symbol}. Defaulting to 8.\")\n        return 8 # Fallback default\n    except (InvalidOperation, ValueError, TypeError, KeyError) as e:\n        logger.error(f\"Error determining price precision digits for {symbol}: {e}\")\n        return 8 # Fallback default\n\ndef get_amount_precision_digits_from_market(market: Dict, logger: logging.Logger) -\u003e Optional[int]:\n    \"\"\"Extracts number of decimal places for amount/quantity from CCXT market structure.\"\"\"\n    symbol \u003d market.get(\u0027symbol\u0027, \u0027N/A\u0027)\n    try:\n        precision_info \u003d market.get(\u0027precision\u0027, {})\n        amount_prec_raw \u003d precision_info.get(\u0027amount\u0027) # Usually digits\n\n        if amount_prec_raw is not None:\n            # Sometimes amount precision is given as a step size (e.g., 0.001)\n            amount_prec_dec \u003d Decimal(str(amount_prec_raw))\n            if 0 \u003c amount_prec_dec \u003c\u003d 1: # Looks like step size\n                 # Handle cases like 1 (means 0 digits)\n                 if amount_prec_dec \u003d\u003d 1: return 0\n                 return abs(amount_prec_dec.normalize().as_tuple().exponent)\n            elif amount_prec_dec \u003e\u003d 0 and amount_prec_dec \u003d\u003d amount_prec_dec.to_integral_value(): # Looks like digits\n                 return int(amount_prec_dec)\n            else: logger.warning(f\"Unusual amount precision value \u0027{amount_prec_raw}\u0027 for {symbol}. Trying info.\")\n\n        # Fallback: check Bybit specific info if available\n        info \u003d market.get(\u0027info\u0027, {})\n        step_size_raw \u003d info.get(\u0027lotSizeFilter\u0027, {}).get(\u0027qtyStep\u0027) # V5 name\n        if step_size_raw is None: step_size_raw \u003d info.get(\u0027minOrderQty\u0027) # Older?\n\n        if step_size_raw is not None:\n            step_size \u003d Decimal(str(step_size_raw))\n            if step_size \u003e 0:\n                if step_size \u003d\u003d 1: return 0\n                return abs(step_size.normalize().as_tuple().exponent)\n            else: logger.warning(f\"Parsed amount step size is not positive ({step_size_raw} -\u003e {step_size}) for {symbol}.\")\n\n        logger.warning(f\"Could not determine amount precision digits for {symbol}. Defaulting to 8.\")\n        return 8 # Fallback default\n    except (InvalidOperation, ValueError, TypeError, KeyError) as e:\n        logger.error(f\"Error determining amount precision digits for {symbol}: {e}\")\n        return 8 # Fallback default\n\ndef get_min_order_amount_from_market(market: Dict, logger: logging.Logger) -\u003e Optional[Decimal]:\n    \"\"\"Extracts minimum order amount/quantity from CCXT market structure.\"\"\"\n    symbol \u003d market.get(\u0027symbol\u0027, \u0027N/A\u0027)\n    try:\n        limits_info \u003d market.get(\u0027limits\u0027, {}).get(\u0027amount\u0027, {})\n        min_amount_raw \u003d limits_info.get(\u0027min\u0027)\n\n        if min_amount_raw is None:\n             info \u003d market.get(\u0027info\u0027, {})\n             # Bybit V5 structure\n             min_amount_raw \u003d info.get(\u0027lotSizeFilter\u0027, {}).get(\u0027minOrderQty\u0027)\n             if min_amount_raw is None: min_amount_raw \u003d info.get(\u0027min_trading_qty\u0027) # Spot?\n\n        if min_amount_raw is not None:\n            min_amount \u003d Decimal(str(min_amount_raw))\n            if min_amount \u003e 0: return min_amount\n            else: logger.warning(f\"Parsed min amount is not positive ({min_amount_raw} -\u003e {min_amount}) for {symbol}.\"); return None\n        else:\n             logger.warning(f\"Could not find minimum order amount for {symbol}.\")\n             return None\n    except (InvalidOperation, ValueError, TypeError, KeyError) as e:\n        logger.error(f\"Error determining min order amount for {symbol}: {e}\")\n        return None\n\ndef get_min_order_cost_from_market(market: Dict, logger: logging.Logger) -\u003e Optional[Decimal]:\n    \"\"\"Extracts minimum order cost (value) from CCXT market structure.\"\"\"\n    symbol \u003d market.get(\u0027symbol\u0027, \u0027N/A\u0027)\n    try:\n        limits_info \u003d market.get(\u0027limits\u0027, {}).get(\u0027cost\u0027, {})\n        min_cost_raw \u003d limits_info.get(\u0027min\u0027)\n\n        if min_cost_raw is None:\n             info \u003d market.get(\u0027info\u0027, {})\n             # Bybit V5 structure (often not explicitly minimum cost, but min amount * price)\n             # May need calculation based on min_amount and current price if not directly available\n             # Check for specific fields if they exist\n             min_cost_raw \u003d info.get(\u0027lotSizeFilter\u0027, {}).get(\u0027minOrderAmt\u0027) # Some spot markets have this\n\n        if min_cost_raw is not None:\n            min_cost \u003d Decimal(str(min_cost_raw))\n            if min_cost \u003e 0: return min_cost\n            else: logger.warning(f\"Parsed min cost is not positive ({min_cost_raw} -\u003e {min_cost}) for {symbol}.\"); return None\n        else:\n             # logger.debug(f\"Minimum order cost not directly specified for {symbol}. May need calculation.\")\n             return None # Indicate not directly available\n    except (InvalidOperation, ValueError, TypeError, KeyError) as e:\n        logger.error(f\"Error determining min order cost for {symbol}: {e}\")\n        return None\n\ndef get_contract_size_from_market(market: Dict, logger: logging.Logger) -\u003e Decimal:\n    \"\"\"Extracts contract size from market info, defaulting to 1.\"\"\"\n    symbol \u003d market.get(\u0027symbol\u0027, \u0027N/A\u0027)\n    try:\n        # Standard CCXT field\n        contract_size_raw \u003d market.get(\u0027contractSize\u0027)\n        if contract_size_raw is None:\n            # Bybit specific field in \u0027info\u0027\n            contract_size_raw \u003d market.get(\u0027info\u0027, {}).get(\u0027contractSize\u0027)\n\n        if contract_size_raw is not None:\n            contract_size \u003d Decimal(str(contract_size_raw))\n            if contract_size \u003e 0:\n                return contract_size\n            else:\n                logger.warning(f\"Parsed contract size is not positive ({contract_size_raw} -\u003e {contract_size}) for {symbol}. Defaulting to 1.\")\n        else:\n            # logger.debug(f\"Contract size not specified for {symbol}. Defaulting to 1.\")\n            pass\n\n    except (InvalidOperation, ValueError, TypeError, KeyError) as e:\n        logger.error(f\"Error determining contract size for {symbol}: {e}. Defaulting to 1.\")\n\n    return Decimal(\u00271\u0027) # Default for spot or if not found\n\n# --- Data Fetching Wrappers ---\ndef fetch_current_price_ccxt(exchange: ccxt.Exchange, symbol: str, logger: logging.Logger, market_info: Dict) -\u003e Optional[Decimal]:\n    \"\"\"Fetch current price using safe_ccxt_call and market info.\"\"\"\n    lg \u003d logger\n    try:\n        params \u003d {}\n        category \u003d market_info.get(\u0027category\u0027)\n        if category and \u0027bybit\u0027 in exchange.id.lower():\n            params[\u0027category\u0027] \u003d category\n            lg.debug(f\"Using params for fetch_ticker ({symbol}): {params}\")\n\n        ticker \u003d safe_ccxt_call(exchange, \u0027fetch_ticker\u0027, lg, symbol\u003dsymbol, params\u003dparams)\n        if not ticker: return None\n\n        # Helper to safely convert to Decimal and check positivity\n        def safe_decimal(value: Any) -\u003e Optional[Decimal]:\n            if value is None: return None\n            try:\n                d_val \u003d Decimal(str(value))\n                return d_val if d_val \u003e 0 else None\n            except (InvalidOperation, ValueError, TypeError): return None\n\n        # Prioritize: last \u003e midpoint \u003e ask \u003e bid\n        price \u003d safe_decimal(ticker.get(\u0027last\u0027))\n        if price: lg.debug(f\"Using \u0027last\u0027 price: {price}\"); return price\n\n        bid \u003d safe_decimal(ticker.get(\u0027bid\u0027))\n        ask \u003d safe_decimal(ticker.get(\u0027ask\u0027))\n        if bid and ask and bid \u003c\u003d ask:\n            price \u003d (bid + ask) / Decimal(\u00272\u0027)\n            lg.debug(f\"Using bid/ask midpoint: {price} (Bid: {bid}, Ask: {ask})\")\n            return price\n\n        if ask: lg.warning(f\"Using \u0027ask\u0027 price as fallback: {ask}\"); return ask\n        if bid: lg.warning(f\"Using \u0027bid\u0027 price as last resort: {bid}\"); return bid\n\n        lg.error(f\"{NEON_RED}Failed to extract a valid positive price from ticker for {symbol}. Ticker: {ticker}{RESET}\")\n        return None\n\n    except Exception as e:\n        lg.error(f\"{NEON_RED}Error in fetch_current_price_ccxt for {symbol}: {e}{RESET}\", exc_info\u003dTrue)\n        return None\n\ndef fetch_klines_ccxt(exchange: ccxt.Exchange, symbol: str, timeframe: str, limit: int, logger: logging.Logger, market_info: Dict) -\u003e pd.DataFrame:\n    \"\"\"Fetch OHLCV klines using safe_ccxt_call and market info, returns processed DataFrame.\"\"\"\n    lg \u003d logger\n    ccxt_timeframe \u003d CCXT_INTERVAL_MAP.get(timeframe)\n    if not ccxt_timeframe:\n        lg.error(f\"Invalid timeframe \u0027{timeframe}\u0027 provided for {symbol}.\")\n        return pd.DataFrame()\n\n    try:\n        params \u003d {}\n        category \u003d market_info.get(\u0027category\u0027)\n        if category and \u0027bybit\u0027 in exchange.id.lower():\n            params[\u0027category\u0027] \u003d category\n            lg.debug(f\"Using params for fetch_ohlcv ({symbol}): {params}\")\n\n        # Use safe_ccxt_call for the API request\n        ohlcv \u003d safe_ccxt_call(exchange, \u0027fetch_ohlcv\u0027, lg, symbol\u003dsymbol, timeframe\u003dccxt_timeframe, limit\u003dlimit, params\u003dparams)\n\n        if ohlcv is None or len(ohlcv) \u003d\u003d 0:\n            lg.warning(f\"{NEON_YELLOW}No kline data returned for {symbol} {timeframe} after retries.{RESET}\")\n            return pd.DataFrame()\n\n        # --- Data Processing ---\n        df \u003d pd.DataFrame(ohlcv, columns\u003d[\u0027timestamp\u0027, \u0027open\u0027, \u0027high\u0027, \u0027low\u0027, \u0027close\u0027, \u0027volume\u0027])\n        if df.empty:\n            lg.warning(f\"{NEON_YELLOW}Kline DataFrame empty for {symbol} {timeframe} after creation.{RESET}\")\n            return df\n\n        df[\u0027timestamp\u0027] \u003d pd.to_datetime(df[\u0027timestamp\u0027], unit\u003d\u0027ms\u0027, errors\u003d\u0027coerce\u0027)\n        df.dropna(subset\u003d[\u0027timestamp\u0027], inplace\u003dTrue)\n        if df.empty:\n            lg.warning(f\"{NEON_YELLOW}Kline DataFrame empty after timestamp conversion for {symbol}.{RESET}\")\n            return df\n        df.set_index(\u0027timestamp\u0027, inplace\u003dTrue)\n\n        for col in [\u0027open\u0027, \u0027high\u0027, \u0027low\u0027, \u0027close\u0027, \u0027volume\u0027]:\n            df[col] \u003d pd.to_numeric(df[col], errors\u003d\u0027coerce\u0027)\n\n        initial_len \u003d len(df)\n        df.dropna(subset\u003d[\u0027open\u0027, \u0027high\u0027, \u0027low\u0027, \u0027close\u0027], inplace\u003dTrue)\n        df \u003d df[df[\u0027close\u0027] \u003e 0] # Require positive close price\n        # Optional: Fill NaN volume with 0 if needed by indicators\n        df[\u0027volume\u0027].fillna(0, inplace\u003dTrue)\n\n        rows_dropped \u003d initial_len - len(df)\n        if rows_dropped \u003e 0:\n            lg.debug(f\"Dropped {rows_dropped} rows with NaN/invalid data for {symbol}.\")\n\n        if df.empty:\n            lg.warning(f\"{NEON_YELLOW}Kline data empty after cleaning for {symbol}.{RESET}\")\n            return pd.DataFrame()\n\n        df.sort_index(inplace\u003dTrue)\n        lg.info(f\"Successfully fetched and processed {len(df)} klines for {symbol} {timeframe}\")\n        return df\n\n    except Exception as e:\n        lg.error(f\"{NEON_RED}Error in fetch_klines_ccxt for {symbol} {timeframe}: {e}{RESET}\", exc_info\u003dTrue)\n        return pd.DataFrame()\n\ndef fetch_orderbook_ccxt(exchange: ccxt.Exchange, symbol: str, limit: int, logger: logging.Logger, market_info: Dict) -\u003e Optional[Dict]:\n    \"\"\"Fetch orderbook using safe_ccxt_call and market info.\"\"\"\n    lg \u003d logger\n    try:\n        params \u003d {}\n        category \u003d market_info.get(\u0027category\u0027)\n        if category and \u0027bybit\u0027 in exchange.id.lower():\n            params[\u0027category\u0027] \u003d category\n            lg.debug(f\"Using params for fetch_order_book ({symbol}): {params}\")\n\n        orderbook \u003d safe_ccxt_call(exchange, \u0027fetch_order_book\u0027, lg, symbol\u003dsymbol, limit\u003dlimit, params\u003dparams)\n\n        # Basic validation\n        if not orderbook:\n            lg.warning(f\"fetch_order_book returned None/empty for {symbol}.\")\n            return None\n        elif not isinstance(orderbook.get(\u0027bids\u0027), list) or not isinstance(orderbook.get(\u0027asks\u0027), list):\n            lg.warning(f\"{NEON_YELLOW}Invalid orderbook structure for {symbol}. Response: {orderbook}{RESET}\")\n            return None\n        elif not orderbook[\u0027bids\u0027] and not orderbook[\u0027asks\u0027]:\n             lg.warning(f\"{NEON_YELLOW}Orderbook received but bids/asks lists are empty for {symbol}.{RESET}\")\n             # Return empty book, might be valid state\n        else:\n             lg.debug(f\"Successfully fetched orderbook for {symbol} with {len(orderbook[\u0027bids\u0027])} bids, {len(orderbook[\u0027asks\u0027])} asks.\")\n\n        return orderbook\n\n    except Exception as e:\n        lg.error(f\"{NEON_RED}Error in fetch_orderbook_ccxt for {symbol}: {e}{RESET}\", exc_info\u003dTrue)\n        return None\n\ndef fetch_balance(exchange: ccxt.Exchange, currency: str, logger: logging.Logger) -\u003e Optional[Decimal]:\n    \"\"\"Fetches available balance for a currency, handling Bybit V5 structures/retries.\"\"\"\n    lg \u003d logger\n    last_exception \u003d None\n    # Try common account types relevant for derivatives/spot\n    account_types_to_try \u003d [\u0027CONTRACT\u0027, \u0027UNIFIED\u0027, \u0027SPOT\u0027]\n\n    for attempt in range(MAX_API_RETRIES + 1):\n        successful_acc_type \u003d None\n        balance_info \u003d None\n\n        # Try specific account types first\n        for acc_type in account_types_to_try:\n            try:\n                params \u003d {\u0027accountType\u0027: acc_type}\n                # V5 often requires \u0027coin\u0027 param too for specific balance\n                if \u0027bybit\u0027 in exchange.id.lower(): params[\u0027coin\u0027] \u003d currency\n\n                lg.debug(f\"Fetching balance using params\u003d{params} for {currency} (Attempt {attempt + 1})\")\n                # Use safe_ccxt_call for the underlying fetch\n                balance_info \u003d safe_ccxt_call(exchange, \u0027fetch_balance\u0027, lg, max_retries\u003d0, params\u003dparams) # Don\u0027t retry inner call here\n                successful_acc_type \u003d acc_type\n\n                # Basic check if the response seems valid for this account type\n                if balance_info and (currency in balance_info or \u0027info\u0027 in balance_info):\n                     lg.debug(f\"Received balance structure using accountType \u0027{acc_type}\u0027.\")\n                     break # Proceed to parse this structure\n                else:\n                     lg.debug(f\"Balance structure for accountType \u0027{acc_type}\u0027 seems empty or invalid. Trying next.\")\n                     balance_info \u003d None # Reset to try next type\n\n            except ccxt.ExchangeError as e:\n                # Ignore \"account type not support\" errors and try the next type\n                ignore_msgs \u003d [\"account type not support\", \"invalid account type\", \"accounttype invalid\", \"10001\", \"30086\"] # Added Bybit codes\n                bybit_code \u003d getattr(e, \u0027code\u0027, None)\n                if any(msg in str(e).lower() for msg in ignore_msgs) or bybit_code in [10001, 30086]:\n                    lg.debug(f\"Account type \u0027{acc_type}\u0027 not supported or error fetching: {e}. Trying next.\")\n                    last_exception \u003d e\n                    continue\n                else:\n                    lg.warning(f\"Non-ignorable ExchangeError fetching balance with type {acc_type}: {e}\")\n                    last_exception \u003d e\n                    # Don\u0027t break, allow retry loop to handle it\n            except (ccxt.NetworkError, ccxt.RequestTimeout, ccxt.DDoSProtection, ccxt.RateLimitExceeded) as e:\n                 # Let the outer retry loop handle these\n                 lg.warning(f\"Network/RateLimit error during balance fetch attempt with type {acc_type}: {e}\")\n                 last_exception \u003d e\n                 break # Break inner loop, let outer loop retry\n            except Exception as e:\n                 lg.error(f\"Unexpected error during balance fetch attempt with type {acc_type}: {e}\", exc_info\u003dTrue)\n                 last_exception \u003d e\n                 break # Break inner loop, let outer loop retry\n\n        # If a valid structure was found with a specific type, break the outer loop too\n        if balance_info:\n             break\n\n        # If specific types failed, or network error occurred, wait and retry outer loop\n        if attempt \u003c MAX_API_RETRIES:\n             wait_time \u003d RETRY_DELAY_SECONDS * (2 ** attempt)\n             lg.warning(f\"Balance fetch attempt {attempt + 1} failed for all types or network error. Retrying in {wait_time}s...\")\n             time.sleep(wait_time)\n        else:\n             lg.error(f\"{NEON_RED}Max retries reached fetching balance for {currency}. Last error: {last_exception}{RESET}\")\n             return None # Exhausted retries\n\n    # --- Parse the balance_info ---\n    if not balance_info:\n         lg.error(f\"{NEON_RED}Failed to fetch any balance information for {currency} after all attempts.{RESET}\")\n         return None\n\n    available_balance_str \u003d None\n    # 1. Standard CCXT: balance_info[currency][\u0027free\u0027]\n    if currency in balance_info and isinstance(balance_info.get(currency), dict) and balance_info[currency].get(\u0027free\u0027) is not None:\n        available_balance_str \u003d str(balance_info[currency][\u0027free\u0027])\n        lg.debug(f\"Found balance via standard ccxt structure [\u0027{currency}\u0027][\u0027free\u0027]: {available_balance_str}\")\n    # 2. Bybit V5 Nested: info -\u003e result -\u003e list -\u003e coin[] (check relevant account type)\n    elif \u0027info\u0027 in balance_info and isinstance(balance_info[\u0027info\u0027].get(\u0027result\u0027, {}).get(\u0027list\u0027), list):\n        balance_list \u003d balance_info[\u0027info\u0027][\u0027result\u0027][\u0027list\u0027]\n        for account in balance_list:\n            # Match the successful account type OR check all if default fetch was used (shouldn\u0027t happen here)\n            # V5 structure often returns only the requested account type\u0027s balance list\n            coin_list \u003d account.get(\u0027coin\u0027)\n            if isinstance(coin_list, list):\n                for coin_data in coin_list:\n                    if coin_data.get(\u0027coin\u0027) \u003d\u003d currency:\n                        # Prefer \u0027availableToWithdraw\u0027 or \u0027availableBalance\u0027 (Bybit V5 names)\n                        free \u003d coin_data.get(\u0027availableToWithdraw\u0027, coin_data.get(\u0027availableBalance\u0027))\n                        if free is None: free \u003d coin_data.get(\u0027walletBalance\u0027) # Fallback to total wallet balance\n                        if free is not None:\n                            available_balance_str \u003d str(free)\n                            lg.debug(f\"Found balance via Bybit V5 nested structure: {available_balance_str} {currency} (Account: {account.get(\u0027accountType\u0027, \u0027Unknown\u0027)})\")\n                            break\n                if available_balance_str is not None: break\n        if available_balance_str is None:\n            lg.warning(f\"{currency} not found within Bybit V5 \u0027info.result.list[].coin[]\u0027 for account type \u0027{successful_acc_type}\u0027. Structure: {balance_info.get(\u0027info\u0027)}\")\n    # 3. Fallback: Top-level \u0027free\u0027 dictionary\n    elif \u0027free\u0027 in balance_info and isinstance(balance_info.get(\u0027free\u0027), dict) and currency in balance_info[\u0027free\u0027]:\n        available_balance_str \u003d str(balance_info[\u0027free\u0027][currency])\n        lg.debug(f\"Found balance via top-level \u0027free\u0027 dictionary: {available_balance_str} {currency}\")\n\n    # 4. Last Resort: Check \u0027total\u0027 balance if \u0027free\u0027 still missing\n    if available_balance_str is None:\n         total_str \u003d None\n         # Try standard total\n         if currency in balance_info and isinstance(balance_info.get(currency), dict):\n             total_str \u003d str(balance_info[currency].get(\u0027total\u0027, \u0027\u0027))\n         # Try Bybit V5 nested total (\u0027walletBalance\u0027) again if missed above\n         if not total_str and \u0027info\u0027 in balance_info and isinstance(balance_info[\u0027info\u0027].get(\u0027result\u0027, {}).get(\u0027list\u0027), list):\n             balance_list \u003d balance_info[\u0027info\u0027][\u0027result\u0027][\u0027list\u0027]\n             for account in balance_list:\n                 coin_list \u003d account.get(\u0027coin\u0027)\n                 if isinstance(coin_list, list):\n                     for coin_data in coin_list:\n                         if coin_data.get(\u0027coin\u0027) \u003d\u003d currency:\n                             total \u003d coin_data.get(\u0027walletBalance\u0027)\n                             if total is not None: total_str \u003d str(total); break\n                     if total_str: break\n                 if total_str: break\n\n         if total_str:\n             lg.warning(f\"{NEON_YELLOW}Using \u0027total\u0027 balance ({total_str}) as fallback for {currency}. This might include collateral.{RESET}\")\n             available_balance_str \u003d total_str\n         else:\n             lg.error(f\"{NEON_RED}Could not determine any balance for {currency}. Structure: {balance_info}{RESET}\")\n             return None # Critical failure\n\n    # --- Convert to Decimal ---\n    try:\n        final_balance \u003d Decimal(available_balance_str)\n        if final_balance \u003e\u003d 0:\n            lg.info(f\"Available {currency} balance: {final_balance:.4f}\")\n            return final_balance\n        else:\n            lg.error(f\"Parsed balance for {currency} is negative ({final_balance}).\"); return None\n    except (InvalidOperation, ValueError, TypeError) as e:\n        lg.error(f\"Failed to convert balance \u0027{available_balance_str}\u0027 to Decimal for {currency}: {e}.\"); return None\n\n# --- Trading Analyzer Class ---\nclass TradingAnalyzer:\n    \"\"\"\n    Analyzes trading data using pandas_ta.Strategy, generates weighted signals,\n    and provides risk management helpers. Uses Decimal for precision.\n    Manages state like break-even trigger status via a passed-in dictionary.\n    \"\"\"\n    def __init__(\n        self,\n        df: pd.DataFrame,\n        logger: logging.Logger,\n        config: Dict[str, Any],\n        market_info: Dict[str, Any],\n        symbol_state: Dict[str, Any], # Mutable state dict for this symbol\n    ) -\u003e None:\n        if df is None or not isinstance(df, pd.DataFrame) or df.empty:\n             raise ValueError(\"TradingAnalyzer requires a non-empty pandas DataFrame.\")\n        if not market_info or not isinstance(market_info, dict):\n            raise ValueError(\"TradingAnalyzer requires a valid market_info dictionary.\")\n        if symbol_state is None or not isinstance(symbol_state, dict):\n             raise ValueError(\"TradingAnalyzer requires a valid symbol_state dictionary.\")\n\n        self.df \u003d df\n        self.logger \u003d logger\n        self.config \u003d config\n        self.market_info \u003d market_info\n        self.symbol \u003d market_info.get(\u0027symbol\u0027, \u0027UNKNOWN_SYMBOL\u0027)\n        self.interval \u003d config.get(\"interval\", \"UNKNOWN_INTERVAL\")\n        self.symbol_state \u003d symbol_state # Store reference to the mutable state dict\n\n        self.indicator_values: Dict[str, Optional[float]] \u003d {} # Stores latest indicator float values (or None)\n        self.signals: Dict[str, int] \u003d {\"BUY\": 0, \"SELL\": 0, \"HOLD\": 1} # Simple signal state\n        self.active_weight_set_name \u003d config.get(\"active_weight_set\", \"default\")\n        self.weights \u003d config.get(\"weight_sets\",{}).get(self.active_weight_set_name, {})\n        self.fib_levels_data: Dict[str, Decimal] \u003d {} # Stores calculated fib levels (Decimal)\n        self.ta_strategy: Optional[ta.Strategy] \u003d None # Store the TA strategy object\n        self.ta_column_map: Dict[str, str] \u003d {} # Map generic name (e.g., \"EMA_short\") to actual column name\n\n        if not self.weights:\n            logger.error(f\"{NEON_RED}Active weight set \u0027{self.active_weight_set_name}\u0027 not found or empty in config for {self.symbol}. Weighting disabled.{RESET}\")\n\n        self._define_ta_strategy()\n        self._calculate_all_indicators()\n        self._update_latest_indicator_values()\n        self.calculate_fibonacci_levels()\n\n    @property\n    def break_even_triggered(self) -\u003e bool:\n        \"\"\"Gets the break-even status from the shared symbol state.\"\"\"\n        return self.symbol_state.get(\u0027break_even_triggered\u0027, False)\n\n    @break_even_triggered.setter\n    def break_even_triggered(self, value: bool):\n        \"\"\"Sets the break-even status in the shared symbol state.\"\"\"\n        if self.symbol_state.get(\u0027break_even_triggered\u0027) !\u003d value:\n            self.symbol_state[\u0027break_even_triggered\u0027] \u003d value\n            self.logger.info(f\"Break-even status for {self.symbol} set to: {value}\")\n\n    def _define_ta_strategy(self) -\u003e None:\n        \"\"\"Defines the pandas_ta Strategy based on config.\"\"\"\n        cfg \u003d self.config\n        indi_cfg \u003d cfg.get(\"indicators\", {})\n\n        # Get periods/windows/settings from config or use defaults\n        atr_p \u003d cfg.get(\"atr_period\", DEFAULT_ATR_PERIOD)\n        ema_s \u003d cfg.get(\"ema_short_period\", DEFAULT_EMA_SHORT_PERIOD)\n        ema_l \u003d cfg.get(\"ema_long_period\", DEFAULT_EMA_LONG_PERIOD)\n        rsi_p \u003d cfg.get(\"rsi_period\", DEFAULT_RSI_WINDOW)\n        bb_p \u003d cfg.get(\"bollinger_bands_period\", DEFAULT_BOLLINGER_BANDS_PERIOD)\n        bb_std \u003d float(cfg.get(\"bollinger_bands_std_dev\", DEFAULT_BOLLINGER_BANDS_STD_DEV))\n        cci_w \u003d cfg.get(\"cci_window\", DEFAULT_CCI_WINDOW)\n        wr_w \u003d cfg.get(\"williams_r_window\", DEFAULT_WILLIAMS_R_WINDOW)\n        mfi_w \u003d cfg.get(\"mfi_window\", DEFAULT_MFI_WINDOW)\n        stochrsi_w \u003d cfg.get(\"stoch_rsi_window\", DEFAULT_STOCH_RSI_WINDOW)\n        stochrsi_rsi_w \u003d cfg.get(\"stoch_rsi_rsi_window\", DEFAULT_STOCH_WINDOW)\n        stochrsi_k \u003d cfg.get(\"stoch_rsi_k\", DEFAULT_K_WINDOW)\n        stochrsi_d \u003d cfg.get(\"stoch_rsi_d\", DEFAULT_D_WINDOW)\n        psar_af \u003d float(cfg.get(\"psar_af\", DEFAULT_PSAR_AF))\n        psar_max \u003d float(cfg.get(\"psar_max_af\", DEFAULT_PSAR_MAX_AF))\n        sma10_w \u003d cfg.get(\"sma_10_window\", DEFAULT_SMA_10_WINDOW)\n        mom_p \u003d cfg.get(\"momentum_period\", DEFAULT_MOMENTUM_PERIOD)\n        vol_ma_p \u003d cfg.get(\"volume_ma_period\", DEFAULT_VOLUME_MA_PERIOD)\n\n        ta_list \u003d []\n        self.ta_column_map \u003d {} # Reset map\n\n        # Always add ATR (needed for risk management)\n        ta_list.append({\"kind\": \"atr\", \"length\": atr_p})\n        self.ta_column_map[\"ATR\"] \u003d f\"ATRr_{atr_p}\" # pandas_ta uses \u0027r\u0027 suffix for RMA smoothed ATR\n\n        # Add indicators based on config flags\n        if indi_cfg.get(\"ema_alignment\") or cfg.get(\"enable_ma_cross_exit\"):\n            ta_list.append({\"kind\": \"ema\", \"length\": ema_s})\n            self.ta_column_map[\"EMA_Short\"] \u003d f\"EMA_{ema_s}\"\n            ta_list.append({\"kind\": \"ema\", \"length\": ema_l})\n            self.ta_column_map[\"EMA_Long\"] \u003d f\"EMA_{ema_l}\"\n        if indi_cfg.get(\"momentum\"):\n            ta_list.append({\"kind\": \"mom\", \"length\": mom_p})\n            self.ta_column_map[\"Momentum\"] \u003d f\"MOM_{mom_p}\"\n        if indi_cfg.get(\"volume_confirmation\"):\n            # Calculate SMA of volume, prefix avoids collision with price SMA\n            ta_list.append({\"kind\": \"sma\", \"close\": \"volume\", \"length\": vol_ma_p, \"prefix\": \"VOL\"})\n            self.ta_column_map[\"Volume_MA\"] \u003d f\"VOL_SMA_{vol_ma_p}\"\n        if indi_cfg.get(\"stoch_rsi\"):\n            ta_list.append({\"kind\": \"stochrsi\", \"length\": stochrsi_w, \"rsi_length\": stochrsi_rsi_w, \"k\": stochrsi_k, \"d\": stochrsi_d})\n            self.ta_column_map[\"StochRSI_K\"] \u003d f\"STOCHRSIk_{stochrsi_w}_{stochrsi_rsi_w}_{stochrsi_k}_{stochrsi_d}\"\n            self.ta_column_map[\"StochRSI_D\"] \u003d f\"STOCHRSId_{stochrsi_w}_{stochrsi_rsi_w}_{stochrsi_k}_{stochrsi_d}\"\n        if indi_cfg.get(\"rsi\"):\n            ta_list.append({\"kind\": \"rsi\", \"length\": rsi_p})\n            self.ta_column_map[\"RSI\"] \u003d f\"RSI_{rsi_p}\"\n        if indi_cfg.get(\"bollinger_bands\"):\n            ta_list.append({\"kind\": \"bbands\", \"length\": bb_p, \"std\": bb_std})\n            # Note: std dev in column name might have limited precision (e.g., 2.0)\n            bb_std_str \u003d f\"{bb_std:.1f}\" # Format std dev consistently for column name\n            self.ta_column_map[\"BB_Lower\"] \u003d f\"BBL_{bb_p}_{bb_std_str}\"\n            self.ta_column_map[\"BB_Middle\"] \u003d f\"BBM_{bb_p}_{bb_std_str}\"\n            self.ta_column_map[\"BB_Upper\"] \u003d f\"BBU_{bb_p}_{bb_std_str}\"\n        if indi_cfg.get(\"vwap\"):\n            ta_list.append({\"kind\": \"vwap\"}) # VWAP often defaults to daily, check pandas_ta docs if specific TF needed\n            self.ta_column_map[\"VWAP\"] \u003d \"VWAP_D\" # Assuming daily VWAP default column name\n        if indi_cfg.get(\"cci\"):\n            ta_list.append({\"kind\": \"cci\", \"length\": cci_w})\n            self.ta_column_map[\"CCI\"] \u003d f\"CCI_{cci_w}_0.015\" # pandas_ta adds constant suffix\n        if indi_cfg.get(\"wr\"):\n            ta_list.append({\"kind\": \"willr\", \"length\": wr_w})\n            self.ta_column_map[\"WR\"] \u003d f\"WILLR_{wr_w}\"\n        if indi_cfg.get(\"psar\"):\n            ta_list.append({\"kind\": \"psar\", \"af\": psar_af, \"max_af\": psar_max})\n            # Format AF/MAX consistently for column names\n            psar_af_str \u003d f\"{psar_af}\".rstrip(\u00270\u0027).rstrip(\u0027.\u0027) if \u0027.\u0027 in f\"{psar_af}\" else f\"{psar_af}\"\n            psar_max_str \u003d f\"{psar_max}\".rstrip(\u00270\u0027).rstrip(\u0027.\u0027) if \u0027.\u0027 in f\"{psar_max}\" else f\"{psar_max}\"\n            self.ta_column_map[\"PSAR_Long\"] \u003d f\"PSARl_{psar_af_str}_{psar_max_str}\"\n            self.ta_column_map[\"PSAR_Short\"] \u003d f\"PSARs_{psar_af_str}_{psar_max_str}\"\n            self.ta_column_map[\"PSAR_AF\"] \u003d f\"PSARaf_{psar_af_str}_{psar_max_str}\" # Acceleration Factor\n            self.ta_column_map[\"PSAR_Reversal\"] \u003d f\"PSARr_{psar_af_str}_{psar_max_str}\" # Reversal points\n        if indi_cfg.get(\"sma_10\"):\n            ta_list.append({\"kind\": \"sma\", \"length\": sma10_w})\n            self.ta_column_map[\"SMA10\"] \u003d f\"SMA_{sma10_w}\"\n        if indi_cfg.get(\"mfi\"):\n            ta_list.append({\"kind\": \"mfi\", \"length\": mfi_w})\n            self.ta_column_map[\"MFI\"] \u003d f\"MFI_{mfi_w}\"\n        # Note: Orderbook is handled separately in signal generation\n\n        self.ta_strategy \u003d ta.Strategy(\n            name\u003d\"EnhancedMultiIndicator\",\n            description\u003d\"Calculates multiple TA indicators based on config\",\n            ta\u003dta_list\n        )\n        self.logger.debug(f\"Defined TA Strategy for {self.symbol} with {len(ta_list)} indicators.\")\n        self.logger.debug(f\"TA Column Map: {self.ta_column_map}\")\n\n    def _calculate_all_indicators(self):\n        \"\"\"Calculates all enabled indicators using the defined pandas_ta strategy.\"\"\"\n        if self.df.empty:\n            self.logger.warning(f\"DataFrame empty, cannot calculate indicators for {self.symbol}.\")\n            return\n        if not self.ta_strategy:\n            self.logger.error(f\"TA Strategy not defined for {self.symbol}. Cannot calculate indicators.\")\n            return\n\n        # Check for sufficient data length based on longest period needed\n        periods_needed \u003d [self.config.get(\"atr_period\", DEFAULT_ATR_PERIOD)]\n        # Add periods from the defined strategy\u0027s ta list\n        for indi in self.ta_strategy.ta:\n            if \u0027length\u0027 in indi: periods_needed.append(indi[\u0027length\u0027])\n            if \u0027rsi_length\u0027 in indi: periods_needed.append(indi[\u0027rsi_length\u0027]) # For StochRSI\n\n        min_required_data \u003d max(periods_needed) + 20 if periods_needed else 50 # Add buffer\n        if len(self.df) \u003c min_required_data:\n            self.logger.warning(f\"{NEON_YELLOW}Insufficient data ({len(self.df)} points) for {self.symbol} to calculate all indicators reliably (min recommended: {min_required_data}). Results may be inaccurate.{RESET}\")\n\n        try:\n            # Apply the strategy to the DataFrame (modifies it in place)\n            self.df.ta.strategy(self.ta_strategy)\n            self.logger.debug(f\"Finished indicator calculations for {self.symbol}. DF columns: {self.df.columns.tolist()}\")\n        except AttributeError as ae:\n             # Handle potential issue if df doesn\u0027t have \u0027ta\u0027 accessor (shouldn\u0027t happen if pandas_ta imported)\n             self.logger.error(f\"{NEON_RED}Pandas TA accessor \u0027.ta\u0027 not found on DataFrame for {self.symbol}. Is pandas_ta installed correctly? Error: {ae}{RESET}\", exc_info\u003dTrue)\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Error calculating indicators with pandas_ta strategy for {self.symbol}: {e}{RESET}\", exc_info\u003dTrue)\n            # Invalidate column map if calculation fails? Or just let _update_latest handle missing cols.\n\n    def _update_latest_indicator_values(self):\n        \"\"\"Updates the indicator_values dict with the latest float values from self.df.\"\"\"\n        if self.df.empty or len(self.df) \u003d\u003d 0:\n            self.logger.warning(f\"Cannot update latest values: DataFrame empty/short for {self.symbol}.\")\n            self.indicator_values \u003d {key: None for key in self.ta_column_map} # Set all to None\n            return\n\n        try:\n            latest \u003d self.df.iloc[-1]\n            if latest.isnull().all():\n                self.logger.warning(f\"Cannot update latest values: Last row is all NaNs for {self.symbol}.\")\n                self.indicator_values \u003d {key: None for key in self.ta_column_map}\n                return\n\n            updated_values \u003d {}\n            # Populate from calculated indicators using the map\n            for generic_name, actual_col_name in self.ta_column_map.items():\n                if actual_col_name and actual_col_name in latest.index:\n                    value \u003d latest[actual_col_name]\n                    # Store as float, converting NaN/None appropriately\n                    updated_values[generic_name] \u003d float(value) if pd.notna(value) else None\n                else:\n                    updated_values[generic_name] \u003d None # Store None if column missing/invalid\n\n            # Add essential price/volume data (use capitalized keys for consistency)\n            for base_col in [\u0027open\u0027, \u0027high\u0027, \u0027low\u0027, \u0027close\u0027, \u0027volume\u0027]:\n                value \u003d latest.get(base_col)\n                updated_values[base_col.capitalize()] \u003d float(value) if pd.notna(value) else None\n\n            self.indicator_values \u003d updated_values\n            # Log non-None values for debugging\n            valid_values \u003d {k: f\"{v:.5f}\" if isinstance(v, float) else v\n                            for k, v in self.indicator_values.items() if v is not None}\n            self.logger.debug(f\"Latest indicator float values updated for {self.symbol}: {valid_values}\")\n\n        except (IndexError, KeyError, Exception) as e:\n            self.logger.error(f\"Error updating latest indicator values for {self.symbol}: {e}\", exc_info\u003dTrue)\n            self.indicator_values \u003d {key: None for key in self.ta_column_map} # Reset on error\n\n    # --- Precision and Market Info Helpers (using market_info) ---\n    def get_min_tick_size(self) -\u003e Optional[Decimal]:\n        \"\"\"Gets the minimum price increment (tick size) from market info as Decimal.\"\"\"\n        return self.market_info.get(\u0027min_tick_size\u0027) # Use pre-calculated value\n\n    def get_price_precision_digits(self) -\u003e int:\n        \"\"\"Gets price precision (number of decimal places) from market info.\"\"\"\n        digits \u003d self.market_info.get(\u0027price_precision_digits\u0027)\n        return digits if digits is not None else 8 # Default fallback\n\n    def get_amount_precision_digits(self) -\u003e int:\n        \"\"\"Gets amount precision (number of decimal places) from market info.\"\"\"\n        digits \u003d self.market_info.get(\u0027amount_precision_digits\u0027)\n        return digits if digits is not None else 8 # Default fallback\n\n    def quantize_price(self, price: Union[Decimal, float, str]) -\u003e Optional[Decimal]:\n        \"\"\"Quantizes a price to the market\u0027s tick size.\"\"\"\n        min_tick \u003d self.get_min_tick_size()\n        if min_tick is None or min_tick \u003c\u003d 0:\n            self.logger.error(f\"Cannot quantize price for {self.symbol}: Invalid min_tick_size ({min_tick}).\")\n            return None\n        try:\n            price_decimal \u003d Decimal(str(price))\n            # Quantize DOWN to the nearest tick\n            quantized \u003d (price_decimal / min_tick).quantize(Decimal(\u00270\u0027), rounding\u003dROUND_DOWN) * min_tick\n            return quantized\n        except (InvalidOperation, ValueError, TypeError) as e:\n            self.logger.error(f\"Error quantizing price \u0027{price}\u0027 for {self.symbol}: {e}\")\n            return None\n\n    def quantize_amount(self, amount: Union[Decimal, float, str], rounding\u003dROUND_DOWN) -\u003e Optional[Decimal]:\n        \"\"\"Quantizes an amount to the market\u0027s amount precision (step size).\"\"\"\n        amount_digits \u003d self.get_amount_precision_digits()\n        if amount_digits is None:\n            self.logger.error(f\"Cannot quantize amount for {self.symbol}: Invalid amount_precision_digits.\")\n            return None\n        try:\n            amount_decimal \u003d Decimal(str(amount))\n            # Amount step size is 10^(-digits)\n            step_size \u003d Decimal(\u00271\u0027) / (Decimal(\u002710\u0027) ** amount_digits)\n            quantized \u003d (amount_decimal / step_size).quantize(Decimal(\u00270\u0027), rounding\u003drounding) * step_size\n            # Format to the correct number of decimal places to avoid trailing zeros beyond precision\n            return Decimal(f\"{quantized:.{amount_digits}f}\")\n        except (InvalidOperation, ValueError, TypeError) as e:\n            self.logger.error(f\"Error quantizing amount \u0027{amount}\u0027 for {self.symbol}: {e}\")\n            return None\n\n    # --- Fibonacci Calculation ---\n    def calculate_fibonacci_levels(self, window: Optional[int] \u003d None) -\u003e Dict[str, Decimal]:\n        \"\"\"Calculates Fibonacci retracement levels over a window using Decimal and quantization.\"\"\"\n        window \u003d window or self.config.get(\"fibonacci_window\", DEFAULT_FIB_WINDOW)\n        if len(self.df) \u003c window:\n            self.logger.debug(f\"Not enough data ({len(self.df)}) for Fib window ({window}) on {self.symbol}.\")\n            self.fib_levels_data \u003d {}; return {}\n\n        df_slice \u003d self.df.tail(window)\n        try:\n            high_raw \u003d df_slice[\"high\"].dropna().max(); low_raw \u003d df_slice[\"low\"].dropna().min()\n            if pd.isna(high_raw) or pd.isna(low_raw):\n                self.logger.warning(f\"No valid high/low in last {window} periods for Fib on {self.symbol}.\"); return {}\n\n            high \u003d Decimal(str(high_raw)); low \u003d Decimal(str(low_raw)); diff \u003d high - low\n            levels \u003d {}; min_tick \u003d self.get_min_tick_size()\n\n            if diff \u003e\u003d Decimal(\u00270\u0027) and min_tick is not None and min_tick \u003e 0:\n                for level_pct in FIB_LEVELS:\n                    level_price_raw \u003d high - (diff * Decimal(str(level_pct)))\n                    # Quantize DOWN to nearest tick\n                    level_price \u003d self.quantize_price(level_price_raw)\n                    if level_price is not None:\n                         levels[f\"Fib_{level_pct * 100:.1f}%\"] \u003d level_price\n                    else:\n                         self.logger.warning(f\"Failed to quantize Fib level {level_pct*100:.1f}% for {self.symbol}\")\n            elif min_tick is None or min_tick \u003c\u003d 0:\n                 self.logger.warning(f\"Invalid min_tick_size for Fib quantization on {self.symbol}. Using raw values.\")\n                 for level_pct in FIB_LEVELS:\n                     level_price_raw \u003d high - (diff * Decimal(str(level_pct)))\n                     levels[f\"Fib_{level_pct * 100:.1f}%\"] \u003d level_price_raw # Store raw Decimal\n            else: # Should not happen if diff \u003c 0, but handle defensively\n                 self.logger.warning(f\"Invalid range (high \u003c low?) for Fib on {self.symbol}. High\u003d{high}, Low\u003d{low}\")\n                 return {}\n\n            self.fib_levels_data \u003d levels\n            price_prec \u003d self.get_price_precision_digits()\n            log_levels \u003d {k: f\"{v:.{price_prec}f}\" for k, v in levels.items()}\n            self.logger.debug(f\"Calculated Fibonacci levels for {self.symbol}: {log_levels}\")\n            return levels\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Fibonacci calculation error for {self.symbol}: {e}{RESET}\", exc_info\u003dTrue)\n            self.fib_levels_data \u003d {}; return {}\n\n    # --- Indicator Check Methods (Return float score -1.0 to 1.0, or None if value missing) ---\n    # These methods now use self.indicator_values[GENERIC_NAME]\n    def _check_ema_alignment(self) -\u003e Optional[float]:\n        ema_short \u003d self.indicator_values.get(\"EMA_Short\")\n        ema_long \u003d self.indicator_values.get(\"EMA_Long\")\n        if ema_short is None or ema_long is None: return None\n        if ema_short \u003e ema_long: return 1.0\n        if ema_short \u003c ema_long: return -1.0\n        return 0.0\n\n    def _check_momentum(self) -\u003e Optional[float]:\n        mom \u003d self.indicator_values.get(\"Momentum\")\n        if mom is None: return None\n        # Simple scaling (adjust scale_factor based on typical range for asset/TF)\n        # Example: if typical MOM is +/- 5, scale_factor \u003d 0.2\n        scale_factor \u003d 0.1 # Example scale factor\n        return max(-1.0, min(1.0, mom * scale_factor))\n\n    def _check_volume_confirmation(self) -\u003e Optional[float]:\n        vol \u003d self.indicator_values.get(\"Volume\")\n        vol_ma \u003d self.indicator_values.get(\"Volume_MA\")\n        if vol is None or vol_ma is None or vol_ma \u003c\u003d 0: return None\n        try: mult \u003d float(self.config.get(\"volume_confirmation_multiplier\", 1.5))\n        except: mult \u003d 1.5\n        if vol \u003e vol_ma * mult: return 0.7 # High volume confirmation (positive signal only)\n        # if vol \u003c vol_ma / mult: return -0.4 # Low volume lack of confirmation (optional negative signal)\n        return 0.0 # Neutral\n\n    def _check_stoch_rsi(self) -\u003e Optional[float]:\n        k \u003d self.indicator_values.get(\"StochRSI_K\"); d \u003d self.indicator_values.get(\"StochRSI_D\")\n        if k is None or d is None: return None\n        try:\n            oversold \u003d float(self.config.get(\"stoch_rsi_oversold_threshold\", 25.0))\n            overbought \u003d float(self.config.get(\"stoch_rsi_overbought_threshold\", 75.0))\n        except: oversold, overbought \u003d 25.0, 75.0\n        score \u003d 0.0\n        if k \u003c oversold and d \u003c oversold and k \u003e d : score \u003d 1.0 # Crossing up from oversold\n        elif k \u003e overbought and d \u003e overbought and k \u003c d: score \u003d -1.0 # Crossing down from overbought\n        elif k \u003c oversold: score \u003d 0.6 # In oversold zone\n        elif k \u003e overbought: score \u003d -0.6 # In overbought zone\n        elif k \u003e d: score \u003d 0.3 # K over D bullish bias\n        elif k \u003c d: score \u003d -0.3 # K under D bearish bias\n        return max(-1.0, min(1.0, score))\n\n    def _check_rsi(self) -\u003e Optional[float]:\n        rsi \u003d self.indicator_values.get(\"RSI\")\n        if rsi is None: return None\n        if rsi \u003c\u003d 30: return 1.0 # Oversold -\u003e Buy signal\n        if rsi \u003e\u003d 70: return -1.0 # Overbought -\u003e Sell signal\n        # Linear scale between 30 and 70\n        if 30 \u003c rsi \u003c 70: return 1.0 - (rsi - 30.0) * (2.0 / 40.0)\n        return 0.0\n\n    def _check_cci(self) -\u003e Optional[float]:\n        cci \u003d self.indicator_values.get(\"CCI\")\n        if cci is None: return None\n        if cci \u003c\u003d -150: return 1.0;\n        if cci \u003e\u003d 150: return -1.0\n        if cci \u003c\u003d -100: return 0.6\n        if cci \u003e\u003d 100: return -0.6\n        # Linear scale between -100 and 100\n        if -100 \u003c cci \u003c 100: return - (cci / 100.0) * 0.6\n        return 0.0\n\n    def _check_wr(self) -\u003e Optional[float]: # Williams %R\n        wr \u003d self.indicator_values.get(\"WR\") # Note: WR is typically negative\n        if wr is None: return None\n        if wr \u003c\u003d -80: return 1.0 # Oversold -\u003e Buy signal\n        if wr \u003e\u003d -20: return -1.0 # Overbought -\u003e Sell signal\n        # Linear scale between -80 and -20\n        if -80 \u003c wr \u003c -20: return 1.0 - (wr - (-80.0)) * (2.0 / 60.0)\n        return 0.0\n\n    def _check_psar(self) -\u003e Optional[float]:\n        psar_l \u003d self.indicator_values.get(\"PSAR_Long\") # Below price if active\n        psar_s \u003d self.indicator_values.get(\"PSAR_Short\") # Above price if active\n        # PSAR values are NaN when not active for that direction\n        is_long_active \u003d psar_l is not None #and not math.isnan(psar_l)\n        is_short_active \u003d psar_s is not None #and not math.isnan(psar_s)\n\n        if is_long_active and not is_short_active: return 1.0 # Uptrend signal\n        if not is_long_active and is_short_active: return -1.0 # Downtrend signal\n\n        # Check for reversal signal (less common with pandas_ta output structure)\n        # reversal \u003d self.indicator_values.get(\"PSAR_Reversal\") # Check if reversal column exists and is non-zero\n        # if reversal is not None and reversal !\u003d 0:\n        #     return 1.0 if reversal \u003e 0 else -1.0 # Use reversal signal directly if available\n\n        return 0.0 # Neutral/Ambiguous (e.g., first few bars)\n\n    def _check_sma10(self) -\u003e Optional[float]:\n        sma \u003d self.indicator_values.get(\"SMA10\")\n        close \u003d self.indicator_values.get(\"Close\")\n        if sma is None or close is None: return None\n        if close \u003e sma: return 0.6 # Price above SMA10 -\u003e Weak Buy\n        if close \u003c sma: return -0.6 # Price below SMA10 -\u003e Weak Sell\n        return 0.0\n\n    def _check_vwap(self) -\u003e Optional[float]:\n        vwap \u003d self.indicator_values.get(\"VWAP\")\n        close \u003d self.indicator_values.get(\"Close\")\n        if vwap is None or close is None: return None\n        if close \u003e vwap: return 0.7 # Price above VWAP -\u003e Moderate Buy\n        if close \u003c vwap: return -0.7 # Price below VWAP -\u003e Moderate Sell\n        return 0.0\n\n    def _check_mfi(self) -\u003e Optional[float]:\n        mfi \u003d self.indicator_values.get(\"MFI\")\n        if mfi is None: return None\n        if mfi \u003c\u003d 20: return 1.0 # Oversold -\u003e Buy signal\n        if mfi \u003e\u003d 80: return -1.0 # Overbought -\u003e Sell signal\n        # Linear scale between 20 and 80\n        if 20 \u003c mfi \u003c 80: return 1.0 - (mfi - 20.0) * (2.0 / 60.0)\n        return 0.0\n\n    def _check_bollinger_bands(self) -\u003e Optional[float]:\n        bbl \u003d self.indicator_values.get(\"BB_Lower\")\n        bbu \u003d self.indicator_values.get(\"BB_Upper\")\n        close \u003d self.indicator_values.get(\"Close\")\n        if bbl is None or bbu is None or close is None: return None\n        if close \u003c\u003d bbl: return 1.0 # Touch/below lower -\u003e Bullish mean revert signal\n        if close \u003e\u003d bbu: return -1.0 # Touch/above upper -\u003e Bearish mean revert signal\n        # Optional: Add score based on proximity to bands or middle line\n        return 0.0 # Inside bands\n\n    def _check_orderbook(self, orderbook_data: Optional[Dict]) -\u003e Optional[float]:\n        \"\"\"Analyzes Order Book Imbalance (OBI).\"\"\"\n        if not orderbook_data: return None\n        try:\n            bids \u003d orderbook_data.get(\u0027bids\u0027, []); asks \u003d orderbook_data.get(\u0027asks\u0027, [])\n            if not bids or not asks: return 0.0 # Neutral if one side is empty\n\n            # Consider top N levels or volume within X% of mid-price\n            levels_to_check \u003d min(len(bids), len(asks), self.config.get(\"orderbook_limit\", 10))\n            if levels_to_check \u003d\u003d 0: return 0.0\n\n            bid_vol \u003d sum(Decimal(str(b[1])) for b in bids[:levels_to_check])\n            ask_vol \u003d sum(Decimal(str(a[1])) for a in asks[:levels_to_check])\n            total_vol \u003d bid_vol + ask_vol\n\n            if total_vol \u003c\u003d 0: return 0.0 # Neutral if no volume in checked levels\n\n            obi \u003d (bid_vol - ask_vol) / total_vol # OBI range: -1 to +1\n            # self.logger.debug(f\"OBI ({levels_to_check} levels): BidVol\u003d{bid_vol:.4f}, AskVol\u003d{ask_vol:.4f}, OBI\u003d{obi:.4f}\")\n\n            # Return OBI directly as score, clamped between -1 and 1\n            return float(max(Decimal(\"-1.0\"), min(Decimal(\"1.0\"), obi)))\n\n        except (InvalidOperation, ValueError, TypeError, IndexError) as e:\n            self.logger.warning(f\"Error calculating OBI for {self.symbol}: {e}\"); return None\n        except Exception as e: self.logger.error(f\"Unexpected OBI error: {e}\"); return None\n\n    # --- Signal Generation \u0026 Scoring ---\n    def generate_trading_signal(self, current_price: Decimal, orderbook_data: Optional[Dict]) -\u003e str:\n        \"\"\"Generates a trading signal (BUY/SELL/HOLD) based on weighted indicator scores.\"\"\"\n        self.signals \u003d {\"BUY\": 0, \"SELL\": 0, \"HOLD\": 1} # Reset signals, default HOLD\n        final_signal_score \u003d Decimal(\"0.0\")\n        total_weight_applied \u003d Decimal(\"0.0\")\n        active_indicator_count \u003d 0; nan_indicator_count \u003d 0\n        debug_scores \u003d {}\n\n        if not self.indicator_values or current_price is None or current_price \u003c\u003d 0:\n            self.logger.warning(f\"Cannot generate signal for {self.symbol}: Invalid inputs (indicators empty or price invalid).\")\n            return \"HOLD\"\n\n        active_weights \u003d self.config.get(\"weight_sets\", {}).get(self.active_weight_set_name)\n        if not active_weights:\n            self.logger.error(f\"Weight set \u0027{self.active_weight_set_name}\u0027 missing/empty for {self.symbol}. HOLDING.\")\n            return \"HOLD\"\n\n        # Map indicator keys from config to their check methods\n        indicator_check_methods \u003d {\n            \"ema_alignment\": self._check_ema_alignment,\n            \"momentum\": self._check_momentum,\n            \"volume_confirmation\": self._check_volume_confirmation,\n            \"stoch_rsi\": self._check_stoch_rsi,\n            \"rsi\": self._check_rsi,\n            \"bollinger_bands\": self._check_bollinger_bands,\n            \"vwap\": self._check_vwap,\n            \"cci\": self._check_cci,\n            \"wr\": self._check_wr,\n            \"psar\": self._check_psar,\n            \"sma_10\": self._check_sma10,\n            \"mfi\": self._check_mfi,\n            \"orderbook\": lambda: self._check_orderbook(orderbook_data), # Lambda for extra arg\n        }\n\n        for indicator_key, enabled in self.config.get(\"indicators\", {}).items():\n            if not enabled:\n                debug_scores[indicator_key] \u003d \"Disabled\"\n                continue\n\n            weight_str \u003d active_weights.get(indicator_key)\n            if weight_str is None:\n                debug_scores[indicator_key] \u003d \"No Weight\"\n                continue # Skip if no weight defined\n\n            try:\n                weight \u003d Decimal(str(weight_str))\n                if weight \u003d\u003d 0:\n                     debug_scores[indicator_key] \u003d \"Weight\u003d0\"\n                     continue # Skip zero weights\n            except (InvalidOperation, ValueError, TypeError):\n                self.logger.warning(f\"Invalid weight \u0027{weight_str}\u0027 for indicator \u0027{indicator_key}\u0027 in set \u0027{self.active_weight_set_name}\u0027. Skipping.\")\n                debug_scores[indicator_key] \u003d f\"Invalid Wt({weight_str})\"\n                continue\n\n            check_method \u003d indicator_check_methods.get(indicator_key)\n            if check_method and callable(check_method):\n                indicator_score_float \u003d None # Use None to indicate missing value\n                try:\n                    indicator_score_float \u003d check_method()\n                except Exception as e:\n                    self.logger.error(f\"Error in check method for {indicator_key} on {self.symbol}: {e}\", exc_info\u003dTrue)\n\n                if indicator_score_float is not None:\n                    try:\n                        # Clamp score between -1.0 and 1.0 before applying weight\n                        clamped_score \u003d max(-1.0, min(1.0, indicator_score_float))\n                        indicator_score_decimal \u003d Decimal(str(clamped_score))\n                        final_signal_score +\u003d indicator_score_decimal * weight\n                        total_weight_applied +\u003d abs(weight) # Use absolute weight for normalization denominator\n                        active_indicator_count +\u003d 1\n                        debug_scores[indicator_key] \u003d f\"{indicator_score_float:.2f} (Wt:{weight}\u003d\u003e{(indicator_score_decimal * weight):.3f})\"\n                    except (InvalidOperation, ValueError, TypeError) as calc_err:\n                        self.logger.error(f\"Error processing score for {indicator_key}: {calc_err}\")\n                        debug_scores[indicator_key] \u003d \"Calc Err\"\n                        nan_indicator_count +\u003d 1\n                else:\n                    debug_scores[indicator_key] \u003d \"NaN/None\"\n                    nan_indicator_count +\u003d 1\n            else:\n                self.logger.warning(f\"Check method not found or implemented for enabled indicator: {indicator_key}\")\n                debug_scores[indicator_key] \u003d \"No Method\"\n\n        # --- Determine Final Signal ---\n        final_signal \u003d \"HOLD\"\n        normalized_score \u003d Decimal(\"0.0\")\n\n        if total_weight_applied \u003e 0:\n            # Normalize the score by the sum of absolute weights applied\n            normalized_score \u003d final_signal_score / total_weight_applied\n        elif active_indicator_count \u003e 0:\n             self.logger.warning(f\"No non-zero weights applied for {active_indicator_count} active indicators on {self.symbol}. HOLDING.\")\n        else:\n             self.logger.warning(f\"No active indicators contributed to signal score for {self.symbol}. HOLDING.\")\n\n        # Use the appropriate threshold based on the active weight set\n        threshold_key \u003d \"scalping_signal_threshold\" if self.active_weight_set_name \u003d\u003d \"scalping\" else \"signal_score_threshold\"\n        default_threshold \u003d 2.5 if self.active_weight_set_name \u003d\u003d \"scalping\" else 1.5\n        try:\n            # Threshold applies to the *non-normalized* score (sum of weighted scores)\n            threshold \u003d Decimal(str(self.config.get(threshold_key, default_threshold)))\n        except (InvalidOperation, ValueError, TypeError):\n            threshold \u003d Decimal(str(default_threshold))\n            self.logger.warning(f\"Invalid threshold value for {threshold_key}. Using default: {threshold}\")\n\n        if final_signal_score \u003e\u003d threshold:\n            final_signal \u003d \"BUY\"\n        elif final_signal_score \u003c\u003d -threshold:\n            final_signal \u003d \"SELL\"\n\n        # --- Log Summary ---\n        price_prec \u003d self.get_price_precision_digits()\n        score_details \u003d \", \".join([f\"{k}: {v}\" for k, v in debug_scores.items()])\n        log_msg \u003d ( f\"Signal Calc ({self.symbol} @ {current_price:.{price_prec}f}): \"\n                    f\"Set\u003d{self.active_weight_set_name}, \"\n                    f\"Indicators(Active/NaN): {active_indicator_count}/{nan_indicator_count}, \"\n                    f\"TotalAbsWt: {total_weight_applied:.3f}, \"\n                    f\"Score: {final_signal_score:.4f}, NormScore: {normalized_score:.4f}, \"\n                    f\"Threshold: +/- {threshold:.3f} -\u003e \"\n                    f\"Signal: {NEON_GREEN if final_signal \u003d\u003d \u0027BUY\u0027 else NEON_RED if final_signal \u003d\u003d \u0027SELL\u0027 else NEON_YELLOW}{final_signal}{RESET}\")\n        self.logger.info(log_msg)\n        self.logger.debug(f\"  Detailed Scores: {score_details}\")\n\n        if final_signal in self.signals:\n            self.signals[final_signal] \u003d 1\n            if final_signal !\u003d \"HOLD\": self.signals[\"HOLD\"] \u003d 0\n\n        return final_signal\n\n    # --- Risk Management Calculations ---\n    def calculate_entry_tp_sl(\n        self, entry_price: Decimal, signal: str\n    ) -\u003e Tuple[Optional[Decimal], Optional[Decimal], Optional[Decimal]]:\n        \"\"\"\n        Calculates potential TP and initial SL based on entry, ATR, config, quantized to tick size.\n        Returns (quantized_entry, quantized_tp, quantized_sl).\n        \"\"\"\n        if signal not in [\"BUY\", \"SELL\"] or entry_price is None or entry_price \u003c\u003d 0:\n            return entry_price, None, None\n\n        atr_float \u003d self.indicator_values.get(\"ATR\")\n        if atr_float is None or atr_float \u003c\u003d 0:\n            self.logger.warning(f\"Cannot calculate TP/SL for {self.symbol}: Invalid ATR ({atr_float}).\")\n            return entry_price, None, None\n\n        try:\n            atr \u003d Decimal(str(atr_float))\n            tp_mult \u003d Decimal(str(self.config.get(\"take_profit_multiple\", 1.0)))\n            sl_mult \u003d Decimal(str(self.config.get(\"stop_loss_multiple\", 1.5)))\n            min_tick \u003d self.get_min_tick_size()\n\n            if min_tick is None or min_tick \u003c\u003d 0:\n                self.logger.error(f\"Cannot calculate TP/SL for {self.symbol}: Invalid min tick size ({min_tick}).\")\n                return entry_price, None, None\n\n            # Quantize entry price first (important for accurate offsets)\n            quantized_entry \u003d self.quantize_price(entry_price)\n            if quantized_entry is None:\n                 self.logger.error(f\"Failed to quantize entry price {entry_price} for TP/SL calc.\")\n                 return entry_price, None, None\n\n            tp_offset \u003d atr * tp_mult; sl_offset \u003d atr * sl_mult\n            take_profit, stop_loss \u003d None, None\n\n            # Calculate raw TP/SL based on *quantized* entry\n            if signal \u003d\u003d \"BUY\":\n                tp_raw \u003d quantized_entry + tp_offset; sl_raw \u003d quantized_entry - sl_offset\n                # Quantize TP UP, SL DOWN (away from entry)\n                take_profit \u003d (tp_raw / min_tick).quantize(Decimal(\u00271\u0027), rounding\u003dROUND_UP) * min_tick\n                stop_loss \u003d (sl_raw / min_tick).quantize(Decimal(\u00271\u0027), rounding\u003dROUND_DOWN) * min_tick\n            elif signal \u003d\u003d \"SELL\":\n                tp_raw \u003d quantized_entry - tp_offset; sl_raw \u003d quantized_entry + sl_offset\n                # Quantize TP DOWN, SL UP (away from entry)\n                take_profit \u003d (tp_raw / min_tick).quantize(Decimal(\u00271\u0027), rounding\u003dROUND_DOWN) * min_tick\n                stop_loss \u003d (sl_raw / min_tick).quantize(Decimal(\u00271\u0027), rounding\u003dROUND_UP) * min_tick\n\n            # --- Validation ---\n            # Ensure SL/TP are strictly beyond entry by \u003e\u003d 1 tick and positive\n            if signal \u003d\u003d \"BUY\":\n                if stop_loss \u003e\u003d quantized_entry: stop_loss \u003d (quantized_entry - min_tick).quantize(min_tick, rounding\u003dROUND_DOWN)\n                if take_profit \u003c\u003d quantized_entry: take_profit \u003d (quantized_entry + min_tick).quantize(min_tick, rounding\u003dROUND_UP)\n            elif signal \u003d\u003d \"SELL\":\n                if stop_loss \u003c\u003d quantized_entry: stop_loss \u003d (quantized_entry + min_tick).quantize(min_tick, rounding\u003dROUND_UP)\n                if take_profit \u003e\u003d quantized_entry: take_profit \u003d (quantized_entry - min_tick).quantize(min_tick, rounding\u003dROUND_DOWN)\n\n            # Final check for positive prices\n            if stop_loss is not None and stop_loss \u003c\u003d 0:\n                self.logger.error(f\"Calculated SL is zero/negative ({stop_loss}). Setting SL to None.\"); stop_loss \u003d None\n            if take_profit is not None and take_profit \u003c\u003d 0:\n                self.logger.error(f\"Calculated TP is zero/negative ({take_profit}). Setting TP to None.\"); take_profit \u003d None\n\n            prec \u003d self.get_price_precision_digits()\n            tp_log \u003d f\"{take_profit:.{prec}f}\" if take_profit else \u0027N/A\u0027\n            sl_log \u003d f\"{stop_loss:.{prec}f}\" if stop_loss else \u0027N/A\u0027\n            entry_log \u003d f\"{quantized_entry:.{prec}f}\"\n            atr_log \u003d f\"{atr:.{prec+1}f}\"\n\n            self.logger.debug(f\"Calculated TP/SL for {self.symbol} {signal}: Entry\u003d{entry_log}, TP\u003d{tp_log}, SL\u003d{sl_log} (ATR\u003d{atr_log})\")\n            return quantized_entry, take_profit, stop_loss\n\n        except (InvalidOperation, ValueError, TypeError, Exception) as e:\n            self.logger.error(f\"{NEON_RED}Error calculating TP/SL for {self.symbol}: {e}{RESET}\", exc_info\u003dTrue)\n            return entry_price, None, None # Return original entry on error\n\n# --- Position Sizing ---\ndef calculate_position_size(\n    balance: Decimal,\n    risk_per_trade: float,\n    entry_price: Decimal,\n    stop_loss_price: Decimal,\n    market_info: Dict,\n    logger: logging.Logger\n) -\u003e Optional[Decimal]:\n    \"\"\"Calculates position size based on balance, risk %, and SL distance.\"\"\"\n    lg \u003d logger\n    symbol \u003d market_info.get(\u0027symbol\u0027, \u0027N/A\u0027)\n    contract_size \u003d market_info.get(\u0027contract_size\u0027, Decimal(\u00271\u0027))\n    min_order_amount \u003d market_info.get(\u0027min_order_amount\u0027)\n    min_order_cost \u003d market_info.get(\u0027min_order_cost\u0027)\n    amount_digits \u003d market_info.get(\u0027amount_precision_digits\u0027)\n\n    if balance \u003c\u003d 0:\n        lg.error(f\"Cannot calculate position size for {symbol}: Balance is zero or negative ({balance}).\")\n        return None\n    if entry_price \u003c\u003d 0 or stop_loss_price \u003c\u003d 0:\n        lg.error(f\"Cannot calculate position size for {symbol}: Entry ({entry_price}) or SL ({stop_loss_price}) is invalid.\")\n        return None\n    if entry_price \u003d\u003d stop_loss_price:\n        lg.error(f\"Cannot calculate position size for {symbol}: Entry and SL prices are identical.\")\n        return None\n    if amount_digits is None:\n         lg.error(f\"Cannot calculate position size for {symbol}: Amount precision digits not found.\")\n         return None\n\n    try:\n        risk_amount \u003d balance * Decimal(str(risk_per_trade))\n        sl_distance_points \u003d abs(entry_price - stop_loss_price)\n\n        # Calculate value per point (depends on contract type)\n        # For linear contracts (quoted in USDT, settled in USDT): Value per point \u003d contract_size\n        # For inverse contracts (quoted in USD, settled in BASE): Value per point \u003d contract_size / entry_price (approx)\n        # Assuming linear contracts for simplicity here (adjust if needed)\n        # TODO: Add check for inverse contracts using market_info[\u0027inverse\u0027]\n        value_per_point \u003d contract_size # For linear contracts\n\n        if sl_distance_points \u003c\u003d 0 or value_per_point \u003c\u003d 0:\n             lg.error(f\"Cannot calculate position size for {symbol}: Invalid SL distance ({sl_distance_points}) or value per point ({value_per_point}).\")\n             return None\n\n        # Risk per contract \u003d SL distance in points * value per point\n        risk_per_contract \u003d sl_distance_points * value_per_point\n\n        if risk_per_contract \u003c\u003d 0:\n             lg.error(f\"Cannot calculate position size for {symbol}: Risk per contract is zero or negative ({risk_per_contract}).\")\n             return None\n\n        # Ideal size \u003d Total risk amount / Risk per contract\n        size_unquantized \u003d risk_amount / risk_per_contract\n        lg.debug(f\"Position Size Calc ({symbol}): Balance\u003d{balance:.2f}, RiskAmt\u003d{risk_amount:.4f}, SLDist\u003d{sl_distance_points}, ValPerPt\u003d{value_per_point}, RiskPerContr\u003d{risk_per_contract:.6f}, UnquantizedSize\u003d{size_unquantized:.8f}\")\n\n        # Quantize the size according to market rules (amount precision)\n        # Use the quantize_amount helper from TradingAnalyzer (or replicate logic here)\n        step_size \u003d Decimal(\u00271\u0027) / (Decimal(\u002710\u0027) ** amount_digits)\n        quantized_size \u003d (size_unquantized / step_size).quantize(Decimal(\u00270\u0027), rounding\u003dROUND_DOWN) * step_size\n        # Format to correct digits\n        quantized_size \u003d Decimal(f\"{quantized_size:.{amount_digits}f}\")\n\n\n        lg.debug(f\"Quantized Size ({symbol}): {quantized_size} (Step: {step_size})\")\n\n        # --- Validation against market limits ---\n        if quantized_size \u003c\u003d 0:\n            lg.warning(f\"{NEON_YELLOW}Calculated position size ({quantized_size}) is zero or negative for {symbol}. Cannot place trade.{RESET}\")\n            return None\n\n        # Check against minimum order amount\n        if min_order_amount is not None and quantized_size \u003c min_order_amount:\n            lg.warning(f\"{NEON_YELLOW}Calculated size {quantized_size} is below minimum order amount {min_order_amount} for {symbol}. Cannot place trade.{RESET}\")\n            return None\n\n        # Check against minimum order cost (if available and applicable)\n        # Cost \u003d size * entry_price / leverage (for margin) or size * entry_price (for spot)\n        # This check is complex and depends on leverage/margin mode.\n        # A simpler check is often done by the exchange API itself.\n        # if min_order_cost is not None:\n        #     order_cost \u003d quantized_size * entry_price # Approximate cost\n        #     if order_cost \u003c min_order_cost:\n        #         lg.warning(f\"{NEON_YELLOW}Estimated order cost {order_cost:.4f} is below minimum {min_order_cost} for {symbol}. Cannot place trade.{RESET}\")\n        #         return None\n\n        lg.info(f\"Calculated position size for {symbol}: {quantized_size}\")\n        return quantized_size\n\n    except (InvalidOperation, ValueError, TypeError, Exception) as e:\n        lg.error(f\"{NEON_RED}Error calculating position size for {symbol}: {e}{RESET}\", exc_info\u003dTrue)\n        return None\n\n# --- CCXT Trading Action Wrappers ---\n\ndef fetch_positions_ccxt(exchange: ccxt.Exchange, symbol: str, logger: logging.Logger, market_info: Dict) -\u003e Optional[Dict]:\n    \"\"\"Fetches open position for a specific symbol using V5 API.\"\"\"\n    lg \u003d logger\n    category \u003d market_info.get(\u0027category\u0027)\n    if not category or category not in [\u0027linear\u0027, \u0027inverse\u0027]: # Positions only for derivatives\n        lg.debug(f\"Skipping position check for non-derivative symbol {symbol} (Category: {category})\")\n        return None\n    if not exchange.has.get(\u0027fetchPositions\u0027):\n         lg.error(f\"Exchange {exchange.id} does not support fetchPositions(). Cannot check position.\")\n         return None\n\n    try:\n        params \u003d {\u0027category\u0027: category, \u0027symbol\u0027: market_info.get(\u0027id\u0027, symbol)} # Use market ID\n        lg.debug(f\"Fetching positions for {symbol} with params: {params}\")\n        # Note: fetchPositions might return multiple positions if symbol not specified or hedge mode\n        # We filter for the specific symbol after the call.\n        all_positions \u003d safe_ccxt_call(exchange, \u0027fetch_positions\u0027, lg, symbols\u003dNone, params\u003dparams) # Fetch for category\n\n        if all_positions is None: # Error handled by safe_ccxt_call\n            return None\n\n        # Filter for the specific symbol\n        # CCXT position structure: list of dicts, check \u0027symbol\u0027 key\n        for pos in all_positions:\n            if pos.get(\u0027symbol\u0027) \u003d\u003d symbol:\n                # Basic validation of position data\n                if pos.get(\u0027contracts\u0027) is not None and pos.get(\u0027side\u0027) is not None:\n                    pos_size_str \u003d pos.get(\u0027contracts\u0027)\n                    try:\n                         pos_size \u003d Decimal(str(pos_size_str))\n                         if pos_size \u003e 0:\n                              lg.info(f\"Found active position for {symbol}: Side\u003d{pos.get(\u0027side\u0027)}, Size\u003d{pos_size}, Entry\u003d{pos.get(\u0027entryPrice\u0027)}\")\n                              # Add market info to position dict for convenience\n                              pos[\u0027market_info\u0027] \u003d market_info\n                              return pos\n                         else:\n                              # Position exists but size is 0 (recently closed?)\n                              lg.debug(f\"Position found for {symbol} but size is {pos_size}. Treating as no active position.\")\n                              return None\n                    except (InvalidOperation, ValueError, TypeError):\n                         lg.error(f\"Could not parse position size \u0027{pos_size_str}\u0027 for {symbol}.\")\n                         return None # Treat as error / no position\n                else:\n                     lg.warning(f\"Position data for {symbol} missing \u0027contracts\u0027 or \u0027side\u0027. Data: {pos}\")\n                     return None # Invalid position data\n\n        lg.debug(f\"No active position found for {symbol}.\")\n        return None # No position found for this specific symbol\n\n    except Exception as e:\n        lg.error(f\"{NEON_RED}Error fetching or processing positions for {symbol}: {e}{RESET}\", exc_info\u003dTrue)\n        return None\n\ndef set_leverage_ccxt(exchange: ccxt.Exchange, symbol: str, leverage: int, logger: logging.Logger, market_info: Dict):\n    \"\"\"Sets leverage for a symbol using V5 API.\"\"\"\n    lg \u003d logger\n    category \u003d market_info.get(\u0027category\u0027)\n    market_id \u003d market_info.get(\u0027id\u0027, symbol)\n    if not category or category not in [\u0027linear\u0027, \u0027inverse\u0027]:\n        lg.warning(f\"Cannot set leverage for non-derivative symbol {symbol} (Category: {category})\")\n        return False\n    if not exchange.has.get(\u0027setLeverage\u0027):\n         lg.error(f\"Exchange {exchange.id} does not support setLeverage().\")\n         return False\n\n    try:\n        # Bybit V5 requires buyLeverage and sellLeverage, set both\n        params \u003d {\n            \u0027category\u0027: category,\n            \u0027buyLeverage\u0027: str(leverage),\n            \u0027sellLeverage\u0027: str(leverage)\n        }\n        lg.info(f\"Setting leverage for {symbol} to {leverage}x...\")\n        safe_ccxt_call(exchange, \u0027set_leverage\u0027, lg, leverage\u003dleverage, symbol\u003dsymbol, params\u003dparams)\n        lg.info(f\"Leverage set successfully for {symbol} to {leverage}x.\")\n        return True\n    except Exception as e:\n        lg.error(f\"{NEON_RED}Failed to set leverage for {symbol} to {leverage}x: {e}{RESET}\", exc_info\u003dTrue)\n        return False\n\ndef create_order_ccxt(\n    exchange: ccxt.Exchange,\n    symbol: str,\n    order_type: str, # \u0027market\u0027, \u0027limit\u0027\n    side: str,       # \u0027buy\u0027, \u0027sell\u0027\n    amount: Decimal,\n    price: Optional[Decimal] \u003d None, # Required for limit orders\n    params: Optional[Dict] \u003d None,\n    logger: Optional[logging.Logger] \u003d None,\n    market_info: Optional[Dict] \u003d None\n) -\u003e Optional[Dict]:\n    \"\"\"Creates an order using safe_ccxt_call with V5 parameters.\"\"\"\n    lg \u003d logger or get_logger(\u0027main\u0027) # Use main logger if none provided\n    if not market_info:\n         lg.error(f\"Market info required for create_order_ccxt ({symbol})\")\n         return None\n\n    category \u003d market_info.get(\u0027category\u0027)\n    market_id \u003d market_info.get(\u0027id\u0027, symbol)\n    if not category:\n         lg.error(f\"Cannot determine category for {symbol}. Cannot place order.\")\n         return None\n\n    # Prepare base parameters\n    order_params \u003d {\n        \u0027category\u0027: category,\n        # \u0027symbol\u0027: market_id, # CCXT usually handles symbol mapping\n        # Add other necessary V5 params like positionIdx for Hedge Mode if needed\n        # \u0027positionIdx\u0027: 0, # 0 for One-Way mode, 1 for Buy Hedge, 2 for Sell Hedge\n    }\n    # Add position mode if needed (though often set account-wide)\n    # position_mode \u003d config.get(\"position_mode\", \"One-Way\") # Get from global config\n    # if position_mode \u003d\u003d \"Hedge\": ... add positionIdx based on side ...\n\n    # Add user-provided params, overriding base ones if necessary\n    if params:\n        order_params.update(params)\n\n    # Validate required price for limit orders\n    if order_type.lower() \u003d\u003d \u0027limit\u0027 and price is None:\n        lg.error(f\"Price parameter is required for limit orders ({symbol}).\")\n        return None\n\n    # Format amount and price to strings\n    amount_str \u003d f\"{amount}\"\n    price_str \u003d f\"{price}\" if price is not None else None\n\n    try:\n        lg.info(f\"Attempting to create {side} {order_type} order for {amount_str} {symbol} @ {price_str or \u0027Market\u0027}...\")\n        lg.debug(f\"Order Params: {order_params}\")\n\n        order_result \u003d safe_ccxt_call(\n            exchange,\n            \u0027create_order\u0027,\n            lg,\n            symbol\u003dsymbol,\n            type\u003dorder_type,\n            side\u003dside,\n            amount\u003dfloat(amount_str), # CCXT often expects float for amount\n            price\u003dfloat(price_str) if price_str else None, # CCXT often expects float for price\n            params\u003dorder_params\n        )\n\n        if order_result:\n            lg.info(f\"{NEON_GREEN}Successfully created {side} {order_type} order for {symbol}. Order ID: {order_result.get(\u0027id\u0027)}{RESET}\")\n            # lg.debug(f\"Order Result: {order_result}\")\n            return order_result\n        else:\n            # safe_ccxt_call would have raised error if it failed after retries\n            lg.error(f\"Order placement call for {symbol} returned None unexpectedly.\")\n            return None\n\n    except Exception as e:\n        # Errors raised by safe_ccxt_call or validation steps\n        lg.error(f\"{NEON_RED}Failed to create order for {symbol}: {e}{RESET}\", exc_info\u003dTrue)\n        return None\n\ndef set_protection_ccxt(\n    exchange: ccxt.Exchange,\n    symbol: str,\n    stop_loss_price: Optional[Decimal] \u003d None,\n    take_profit_price: Optional[Decimal] \u003d None,\n    trailing_stop_price: Optional[Decimal] \u003d None, # Bybit V5: Absolute distance value\n    trailing_active_price: Optional[Decimal] \u003d None, # Bybit V5: Activation price\n    position_idx: int \u003d 0, # 0 for One-Way, 1 for Buy Hedge, 2 for Sell Hedge\n    logger: Optional[logging.Logger] \u003d None,\n    market_info: Optional[Dict] \u003d None\n) -\u003e bool:\n    \"\"\"Sets Stop Loss, Take Profit, and/or Trailing Stop using Bybit V5 position/trading-stop.\"\"\"\n    lg \u003d logger or get_logger(\u0027main\u0027)\n    if not market_info:\n         lg.error(f\"Market info required for set_protection_ccxt ({symbol})\")\n         return False\n\n    category \u003d market_info.get(\u0027category\u0027)\n    market_id \u003d market_info.get(\u0027id\u0027, symbol)\n    if not category or category not in [\u0027linear\u0027, \u0027inverse\u0027]:\n        lg.warning(f\"Cannot set SL/TP/TSL for non-derivative symbol {symbol} (Category: {category})\")\n        return False\n\n    # Check if the exchange explicitly supports this method via V5 endpoint\n    # This check might be complex depending on ccxt version. Assume available for Bybit.\n    # if not exchange.has ... check for \u0027private_post_v5_position_trading_stop\u0027 ...\n\n    params \u003d {\n        \u0027category\u0027: category,\n        \u0027symbol\u0027: market_id,\n        \u0027positionIdx\u0027: position_idx,\n        # V5 uses \u0027tpslMode\u0027: \u0027Full\u0027 for setting TP/SL on the entire position\n        # or \u0027Partial\u0027 (requires tpOrderType, slOrderType etc.) - Use \u0027Full\u0027 for simplicity\n        \u0027tpslMode\u0027: \u0027Full\u0027,\n    }\n\n    log_parts \u003d []\n    # Format prices to strings if provided\n    if stop_loss_price is not None and stop_loss_price \u003e 0:\n        params[\u0027stopLoss\u0027] \u003d f\"{stop_loss_price}\"\n        log_parts.append(f\"SL\u003d{stop_loss_price}\")\n    else: params[\u0027stopLoss\u0027] \u003d \"0\" # Send \"0\" to cancel existing SL\n\n    if take_profit_price is not None and take_profit_price \u003e 0:\n        params[\u0027takeProfit\u0027] \u003d f\"{take_profit_price}\"\n        log_parts.append(f\"TP\u003d{take_profit_price}\")\n    else: params[\u0027takeProfit\u0027] \u003d \"0\" # Send \"0\" to cancel existing TP\n\n    if trailing_stop_price is not None and trailing_stop_price \u003e 0:\n        # Bybit V5 \u0027trailingStop\u0027 is the distance value (e.g., 10 for $10 trail)\n        params[\u0027trailingStop\u0027] \u003d f\"{trailing_stop_price}\"\n        log_parts.append(f\"TSL_Dist\u003d{trailing_stop_price}\")\n        # \u0027activePrice\u0027 is the price at which the TSL activates\n        if trailing_active_price is not None and trailing_active_price \u003e 0:\n            params[\u0027activePrice\u0027] \u003d f\"{trailing_active_price}\"\n            log_parts.append(f\"TSL_Act\u003d{trailing_active_price}\")\n        else:\n             # If activation price is not set or 0, TSL activates immediately (or based on exchange rules)\n             # Sending \"0\" might explicitly mean immediate activation for Bybit V5\n             params[\u0027activePrice\u0027] \u003d \"0\"\n             log_parts.append(\"TSL_Act\u003dImmediate\")\n    else:\n        # To cancel TSL, send trailingStop \u003d \"0\"\n        params[\u0027trailingStop\u0027] \u003d \"0\"\n\n\n    if not log_parts:\n        lg.warning(f\"No valid protection levels provided for set_protection_ccxt ({symbol}). Nothing to set.\")\n        return False\n\n    try:\n        lg.info(f\"Setting protection for {symbol}: {\u0027, \u0027.join(log_parts)}\")\n        lg.debug(f\"Protection Params: {params}\")\n\n        # Use the specific V5 endpoint via private_post (or let ccxt handle if it maps set_trading_stop)\n        # Using safe_ccxt_call with the method name ccxt uses internally if available,\n        # otherwise construct the call manually.\n        # Check exchange.has for a method like \u0027setTradingStop\u0027 or similar first.\n        # If not found, use private_request or specific method if ccxt added one.\n        # Assuming ccxt might map it or we call directly:\n        # result \u003d safe_ccxt_call(exchange, \u0027set_trading_stop\u0027, lg, symbol\u003dsymbol, params\u003dparams) # Hypothetical method name\n        # OR direct call:\n        result \u003d safe_ccxt_call(exchange, \u0027private_post_position_trading_stop\u0027, lg, params\u003dparams)\n\n\n        if result:\n            # Bybit V5 success usually has retCode 0\n            ret_code \u003d result.get(\u0027retCode\u0027, -1)\n            ret_msg \u003d result.get(\u0027retMsg\u0027, \u0027Unknown\u0027)\n            if ret_code \u003d\u003d 0:\n                lg.info(f\"{NEON_GREEN}Successfully set protection for {symbol}.{RESET}\")\n                return True\n            else:\n                lg.error(f\"{NEON_RED}Failed to set protection for {symbol}. Exchange Response: Code\u003d{ret_code}, Msg\u003d\u0027{ret_msg}\u0027{RESET}\")\n                lg.debug(f\"Full protection result: {result}\")\n                return False\n        else:\n            lg.error(f\"Set protection call for {symbol} returned None unexpectedly.\")\n            return False\n\n    except Exception as e:\n        lg.error(f\"{NEON_RED}Failed to set protection for {symbol}: {e}{RESET}\", exc_info\u003dTrue)\n        return False\n\ndef close_position_ccxt(\n    exchange: ccxt.Exchange,\n    symbol: str,\n    position_data: Dict, # Pass the fetched position data\n    logger: Optional[logging.Logger] \u003d None,\n    market_info: Optional[Dict] \u003d None\n) -\u003e Optional[Dict]:\n    \"\"\"Closes an existing position by placing a market order in the opposite direction.\"\"\"\n    lg \u003d logger or get_logger(\u0027main\u0027)\n    if not market_info:\n         lg.error(f\"Market info required for close_position_ccxt ({symbol})\")\n         return None\n    if not position_data:\n         lg.error(f\"Position data required for close_position_ccxt ({symbol})\")\n         return None\n\n    try:\n        position_size_str \u003d position_data.get(\u0027contracts\u0027)\n        position_side \u003d position_data.get(\u0027side\u0027) # \u0027long\u0027 or \u0027short\u0027\n        position_size \u003d Decimal(str(position_size_str))\n\n        if position_size \u003c\u003d 0:\n            lg.warning(f\"Attempted to close position for {symbol}, but size is already {position_size}. No action needed.\")\n            return None # No position to close\n\n        close_side \u003d \u0027sell\u0027 if position_side \u003d\u003d \u0027long\u0027 else \u0027buy\u0027\n        amount_to_close \u003d position_size # Close the full position\n\n        lg.info(f\"Attempting to close {position_side} position for {symbol} (Size: {amount_to_close}) by placing a {close_side} market order...\")\n\n        # Add reduceOnly flag to ensure it only closes the position\n        params \u003d {\n            \u0027reduceOnly\u0027: True,\n            # Add positionIdx if using Hedge Mode\n            # \u0027positionIdx\u0027: position_data.get(\u0027info\u0027, {}).get(\u0027positionIdx\u0027, 0) # Get from position info if possible\n        }\n\n        close_order \u003d create_order_ccxt(\n            exchange\u003dexchange,\n            symbol\u003dsymbol,\n            order_type\u003d\u0027market\u0027,\n            side\u003dclose_side,\n            amount\u003damount_to_close,\n            params\u003dparams,\n            logger\u003dlg,\n            market_info\u003dmarket_info\n        )\n\n        if close_order:\n            lg.info(f\"{NEON_GREEN}Successfully placed market order to close position for {symbol}. Close Order ID: {close_order.get(\u0027id\u0027)}{RESET}\")\n            # Note: Market order execution isn\u0027t guaranteed instantly.\n            # Further checks might be needed to confirm closure.\n            return close_order\n        else:\n            lg.error(f\"{NEON_RED}Failed to place market order to close position for {symbol}.{RESET}\")\n            return None\n\n    except (InvalidOperation, ValueError, TypeError, KeyError) as e:\n         lg.error(f\"Error parsing position data for closing {symbol}: {e}. Position Data: {position_data}\")\n         return None\n    except Exception as e:\n        lg.error(f\"{NEON_RED}Error attempting to close position for {symbol}: {e}{RESET}\", exc_info\u003dTrue)\n        return None\n\n# --- Main Bot Logic ---\ndef run_bot(exchange: ccxt.Exchange, config: Dict[str, Any], bot_state: Dict[str, Any]):\n    \"\"\"Main bot execution loop.\"\"\"\n    main_logger \u003d get_logger(\u0027main\u0027)\n    main_logger.info(\"Starting Enhanced Trading Bot...\")\n    main_logger.info(f\"Trading Enabled: {config.get(\u0027enable_trading\u0027)}\")\n    main_logger.info(f\"Sandbox Mode: {config.get(\u0027use_sandbox\u0027)}\")\n    main_logger.info(f\"Symbols: {config.get(\u0027symbols\u0027)}\")\n    main_logger.info(f\"Interval: {config.get(\u0027interval\u0027)}\")\n    main_logger.info(f\"Risk Per Trade: {config.get(\u0027risk_per_trade\u0027)*100:.2f}%\")\n    main_logger.info(f\"Leverage: {config.get(\u0027leverage\u0027)}x\")\n    main_logger.info(f\"Max Concurrent Positions: {config.get(\u0027max_concurrent_positions_total\u0027)}\")\n    main_logger.info(f\"Active Weight Set: {config.get(\u0027active_weight_set\u0027)}\")\n\n    global LOOP_DELAY_SECONDS\n    LOOP_DELAY_SECONDS \u003d int(config.get(\"loop_delay\", DEFAULT_LOOP_DELAY_SECONDS))\n\n    symbols_to_trade \u003d config.get(\"symbols\", [])\n    if not symbols_to_trade:\n        main_logger.error(\"No symbols configured in \u0027symbols\u0027 list. Exiting.\")\n        return\n\n    # Initialize state for each symbol if not present\n    for symbol in symbols_to_trade:\n        if symbol not in bot_state:\n            bot_state[symbol] \u003d {\n                \"break_even_triggered\": False,\n                \"last_signal\": \"HOLD\",\n                # Add other state variables as needed (e.g., last order time)\n            }\n\n    while True:\n        start_time \u003d time.time()\n        main_logger.info(f\"--- Starting Bot Cycle ---\")\n\n        # --- Pre-Cycle Checks ---\n        # Fetch balance once per cycle (if trading enabled)\n        current_balance \u003d None\n        if config.get(\"enable_trading\"):\n            try:\n                current_balance \u003d fetch_balance(exchange, QUOTE_CURRENCY, main_logger)\n                if current_balance is None:\n                    main_logger.error(f\"{NEON_RED}Failed to fetch {QUOTE_CURRENCY} balance. Trading actions will be skipped this cycle.{RESET}\")\n            except Exception as e:\n                 main_logger.error(f\"Error fetching balance at start of cycle: {e}\", exc_info\u003dTrue)\n\n        # Count currently open positions across all monitored symbols\n        open_positions_count \u003d 0\n        active_positions \u003d {} # Store fetched active positions for reuse\n        for symbol in symbols_to_trade:\n            symbol_logger \u003d get_logger(symbol, is_symbol_logger\u003dTrue)\n            market_info \u003d get_market_info(exchange, symbol, symbol_logger)\n            if not market_info: continue # Skip symbol if market info fails\n\n            position \u003d fetch_positions_ccxt(exchange, symbol, symbol_logger, market_info)\n            if position:\n                open_positions_count +\u003d 1\n                active_positions[symbol] \u003d position # Store for later use\n\n        main_logger.info(f\"Currently open positions: {open_positions_count} / {config.get(\u0027max_concurrent_positions_total\u0027)}\")\n\n        # --- Symbol Processing Loop ---\n        for symbol in symbols_to_trade:\n            symbol_logger \u003d get_logger(symbol, is_symbol_logger\u003dTrue)\n            symbol_logger.info(f\"--- Processing Symbol: {symbol} ---\")\n            symbol_state \u003d bot_state[symbol] # Get mutable state for this symbol\n\n            try:\n                # 1. Get Market Info\n                market_info \u003d get_market_info(exchange, symbol, symbol_logger)\n                if not market_info:\n                    symbol_logger.error(f\"Failed to get market info for {symbol}. Skipping this cycle.\")\n                    continue\n\n                # 2. Fetch Data (Klines, Price, Orderbook)\n                timeframe \u003d config.get(\"interval\", \"5\")\n                kline_limit \u003d max( # Determine required kline limit based on longest indicator\n                    config.get(\"fibonacci_window\", DEFAULT_FIB_WINDOW),\n                    config.get(\"ema_long_period\", DEFAULT_EMA_LONG_PERIOD),\n                    config.get(\"bollinger_bands_period\", DEFAULT_BOLLINGER_BANDS_PERIOD),\n                    # Add other long periods here...\n                    100 # Minimum limit\n                ) + 50 # Add buffer\n\n                df \u003d fetch_klines_ccxt(exchange, symbol, timeframe, kline_limit, symbol_logger, market_info)\n                if df.empty:\n                    symbol_logger.warning(f\"Kline data unavailable for {symbol}. Skipping analysis.\")\n                    continue\n\n                current_price \u003d fetch_current_price_ccxt(exchange, symbol, symbol_logger, market_info)\n                if current_price is None:\n                    symbol_logger.warning(f\"Current price unavailable for {symbol}. Skipping analysis.\")\n                    continue\n\n                orderbook \u003d None\n                if config.get(\"indicators\", {}).get(\"orderbook\"):\n                    orderbook \u003d fetch_orderbook_ccxt(exchange, symbol, config.get(\"orderbook_limit\", 25), symbol_logger, market_info)\n                    # Don\u0027t skip if orderbook fails, just proceed without it\n\n                # 3. Analyze Data\n                analyzer \u003d TradingAnalyzer(df, symbol_logger, config, market_info, symbol_state)\n\n                # 4. Check Existing Position \u0026 Manage\n                current_position \u003d active_positions.get(symbol) # Use already fetched position\n\n                if current_position:\n                    symbol_logger.info(f\"Managing existing {current_position.get(\u0027side\u0027)} position.\")\n                    # Reset break-even trigger if position side changed (shouldn\u0027t happen in One-Way)\n                    # Implement position management logic here:\n                    manage_existing_position(exchange, config, symbol_logger, analyzer, current_position, current_price)\n\n                # 5. Check for New Entry Signal (if no position or within limits)\n                elif open_positions_count \u003c config.get(\"max_concurrent_positions_total\"):\n                    symbol_logger.info(\"No active position. Checking for entry signals...\")\n                    signal \u003d analyzer.generate_trading_signal(current_price, orderbook)\n                    symbol_state[\"last_signal\"] \u003d signal # Store last signal\n\n                    if signal in [\"BUY\", \"SELL\"] and config.get(\"enable_trading\"):\n                        if current_balance is not None and current_balance \u003e 0:\n                             # Attempt to open a new position\n                             opened_new \u003d attempt_new_entry(exchange, config, symbol_logger, analyzer, signal, current_price, current_balance)\n                             if opened_new:\n                                 open_positions_count +\u003d 1 # Increment count if successful\n                                 # Reset state for the new position\n                                 symbol_state[\"break_even_triggered\"] \u003d False\n                        else:\n                             symbol_logger.warning(f\"Trading enabled but balance is {current_balance}. Cannot enter {signal} trade.\")\n                    elif signal in [\"BUY\", \"SELL\"]:\n                         symbol_logger.info(f\"Entry signal \u0027{signal}\u0027 generated but trading is disabled.\")\n\n                elif current_position is None: # No position, but max positions reached\n                     symbol_logger.info(f\"Max concurrent positions ({open_positions_count}) reached. Skipping new entry check for {symbol}.\")\n\n\n            except Exception as e:\n                symbol_logger.error(f\"{NEON_RED}!!! Unhandled error during cycle for {symbol}: {e} !!!{RESET}\", exc_info\u003dTrue)\n\n            symbol_logger.info(f\"--- Finished Processing Symbol: {symbol} ---\")\n            # Small delay between symbols to avoid hitting rate limits too quickly if many symbols\n            time.sleep(0.5)\n\n        # --- Post-Cycle ---\n        end_time \u003d time.time()\n        cycle_duration \u003d end_time - start_time\n        main_logger.info(f\"--- Bot Cycle Finished (Duration: {cycle_duration:.2f}s) ---\")\n\n        # Save state periodically\n        save_state(STATE_FILE, bot_state, main_logger)\n\n        # Wait for the next cycle\n        wait_time \u003d max(0, LOOP_DELAY_SECONDS - cycle_duration)\n        main_logger.info(f\"Waiting {wait_time:.2f}s for next cycle...\")\n        time.sleep(wait_time)\n\n\ndef manage_existing_position(\n    exchange: ccxt.Exchange,\n    config: Dict[str, Any],\n    logger: logging.Logger,\n    analyzer: TradingAnalyzer,\n    position_data: Dict,\n    current_price: Decimal\n):\n    \"\"\"Handles logic for managing an open position (BE, MA Cross Exit).\"\"\"\n    symbol \u003d position_data.get(\u0027symbol\u0027)\n    position_side \u003d position_data.get(\u0027side\u0027) # \u0027long\u0027 or \u0027short\u0027\n    entry_price_str \u003d position_data.get(\u0027entryPrice\u0027)\n    position_size_str \u003d position_data.get(\u0027contracts\u0027)\n    market_info \u003d analyzer.market_info # Get from analyzer\n    symbol_state \u003d analyzer.symbol_state # Get state dict\n\n    try:\n        entry_price \u003d Decimal(str(entry_price_str))\n        position_size \u003d Decimal(str(position_size_str))\n        if position_size \u003c\u003d 0: return # Should not happen if called correctly\n\n        # --- 1. Check MA Cross Exit ---\n        if config.get(\"enable_ma_cross_exit\"):\n            ema_short \u003d analyzer.indicator_values.get(\"EMA_Short\")\n            ema_long \u003d analyzer.indicator_values.get(\"EMA_Long\")\n            if ema_short is not None and ema_long is not None:\n                is_adverse_cross \u003d False\n                if position_side \u003d\u003d \u0027long\u0027 and ema_short \u003c ema_long:\n                    is_adverse_cross \u003d True\n                    logger.warning(f\"{NEON_YELLOW}MA Cross Exit Triggered (Long): Short EMA ({ema_short:.5f}) crossed below Long EMA ({ema_long:.5f}). Closing position.{RESET}\")\n                elif position_side \u003d\u003d \u0027short\u0027 and ema_short \u003e ema_long:\n                    is_adverse_cross \u003d True\n                    logger.warning(f\"{NEON_YELLOW}MA Cross Exit Triggered (Short): Short EMA ({ema_short:.5f}) crossed above Long EMA ({ema_long:.5f}). Closing position.{RESET}\")\n\n                if is_adverse_cross and config.get(\"enable_trading\"):\n                    close_position_ccxt(exchange, symbol, position_data, logger, market_info)\n                    # Reset state after closing\n                    symbol_state[\"break_even_triggered\"] \u003d False\n                    symbol_state[\"last_signal\"] \u003d \"HOLD\" # Reset signal state\n                    return # Exit management logic as position is being closed\n\n        # --- 2. Check Break-Even Trigger ---\n        if config.get(\"enable_break_even\") and not analyzer.break_even_triggered:\n            atr_float \u003d analyzer.indicator_values.get(\"ATR\")\n            if atr_float is not None and atr_float \u003e 0:\n                atr \u003d Decimal(str(atr_float))\n                trigger_multiple \u003d Decimal(str(config.get(\"break_even_trigger_atr_multiple\", 1.0)))\n                profit_target_points \u003d atr * trigger_multiple\n\n                current_profit_points \u003d Decimal(\u00270\u0027)\n                if position_side \u003d\u003d \u0027long\u0027:\n                    current_profit_points \u003d current_price - entry_price\n                elif position_side \u003d\u003d \u0027short\u0027:\n                    current_profit_points \u003d entry_price - current_price\n\n                if current_profit_points \u003e\u003d profit_target_points:\n                    logger.info(f\"{NEON_GREEN}Break-Even Triggered for {symbol}!{RESET} Profit ({current_profit_points:.5f}) \u003e\u003d Target ({profit_target_points:.5f})\")\n\n                    # Calculate BE price (entry + offset)\n                    min_tick \u003d analyzer.get_min_tick_size()\n                    offset_ticks \u003d int(config.get(\"break_even_offset_ticks\", 2))\n                    if min_tick is not None and min_tick \u003e 0 and offset_ticks \u003e\u003d 0:\n                        offset_value \u003d min_tick * Decimal(offset_ticks)\n                        be_stop_price \u003d None\n                        if position_side \u003d\u003d \u0027long\u0027:\n                            be_stop_price_raw \u003d entry_price + offset_value\n                            # Quantize UP to ensure it\u0027s at least offset_ticks away\n                            be_stop_price \u003d (be_stop_price_raw / min_tick).quantize(Decimal(\u00271\u0027), rounding\u003dROUND_UP) * min_tick\n                        elif position_side \u003d\u003d \u0027short\u0027:\n                            be_stop_price_raw \u003d entry_price - offset_value\n                            # Quantize DOWN to ensure it\u0027s at least offset_ticks away\n                            be_stop_price \u003d (be_stop_price_raw / min_tick).quantize(Decimal(\u00271\u0027), rounding\u003dROUND_DOWN) * min_tick\n\n                        if be_stop_price is not None and be_stop_price \u003e 0:\n                            logger.info(f\"Calculated Break-Even Stop Price: {be_stop_price}\")\n                            # Set the new SL\n                            if config.get(\"enable_trading\"):\n                                # Get current TP/TSL to potentially preserve them if not forcing fixed SL\n                                current_tp \u003d Decimal(str(position_data.get(\u0027takeProfit\u0027, \u00270\u0027))) if position_data.get(\u0027takeProfit\u0027) else None\n                                current_tsl_dist \u003d Decimal(str(position_data.get(\u0027trailingStop\u0027, \u00270\u0027))) if position_data.get(\u0027trailingStop\u0027) else None\n                                current_tsl_act \u003d Decimal(str(position_data.get(\u0027activePrice\u0027, \u00270\u0027))) if position_data.get(\u0027activePrice\u0027) else None\n\n                                # Decide whether to keep TSL or force fixed SL\n                                use_tsl \u003d config.get(\"enable_trailing_stop\") and not config.get(\"break_even_force_fixed_sl\")\n                                tsl_to_set \u003d current_tsl_dist if use_tsl and current_tsl_dist and current_tsl_dist \u003e 0 else None\n                                act_to_set \u003d current_tsl_act if use_tsl and tsl_to_set else None\n\n                                success \u003d set_protection_ccxt(\n                                    exchange\u003dexchange,\n                                    symbol\u003dsymbol,\n                                    stop_loss_price\u003dbe_stop_price,\n                                    take_profit_price\u003dcurrent_tp, # Keep existing TP\n                                    trailing_stop_price\u003dtsl_to_set, # Keep existing TSL only if configured\n                                    trailing_active_price\u003dact_to_set,\n                                    logger\u003dlogger,\n                                    market_info\u003dmarket_info\n                                    # position_idx\u003d... # Add if needed for Hedge Mode\n                                )\n                                if success:\n                                    analyzer.break_even_triggered \u003d True # Update state via property setter\n                                else:\n                                    logger.error(\"Failed to set break-even stop loss via API.\")\n                        else:\n                             logger.error(f\"Calculated invalid break-even stop price ({be_stop_price}). Cannot set BE.\")\n                    else:\n                         logger.error(f\"Cannot calculate break-even offset: Invalid tick size ({min_tick}) or offset ticks ({offset_ticks}).\")\n            else:\n                 logger.warning(f\"Cannot check break-even trigger for {symbol}: Invalid ATR ({atr_float}).\")\n\n        # --- 3. Add other management logic here (e.g., partial closes, TSL adjustments if manual) ---\n        # logger.debug(f\"Finished managing position for {symbol}.\")\n\n    except (InvalidOperation, ValueError, TypeError, KeyError) as e:\n        logger.error(f\"Error parsing position data during management for {symbol}: {e}. Data: {position_data}\", exc_info\u003dTrue)\n    except Exception as e:\n        logger.error(f\"Unexpected error managing position for {symbol}: {e}\", exc_info\u003dTrue)\n\n\ndef attempt_new_entry(\n    exchange: ccxt.Exchange,\n    config: Dict[str, Any],\n    logger: logging.Logger,\n    analyzer: TradingAnalyzer,\n    signal: str, # \"BUY\" or \"SELL\"\n    entry_price_signal: Decimal, # Price at time of signal generation\n    current_balance: Decimal\n) -\u003e bool:\n    \"\"\"Attempts to calculate size, set leverage, place order, and set protection.\"\"\"\n    symbol \u003d analyzer.symbol\n    market_info \u003d analyzer.market_info\n\n    # 1. Calculate TP/SL based on signal price and current ATR\n    # Use signal price for calculation consistency, even if market moved slightly\n    _, take_profit_price, stop_loss_price \u003d analyzer.calculate_entry_tp_sl(entry_price_signal, signal)\n\n    if stop_loss_price is None:\n        logger.error(f\"Cannot enter {signal} trade for {symbol}: Failed to calculate a valid Stop Loss.\")\n        return False\n    # TP is optional, can proceed without it\n\n    # 2. Calculate Position Size\n    risk_per_trade \u003d config.get(\"risk_per_trade\", 0.01)\n    position_size \u003d calculate_position_size(\n        balance\u003dcurrent_balance,\n        risk_per_trade\u003drisk_per_trade,\n        entry_price\u003dentry_price_signal, # Use signal price for sizing consistency\n        stop_loss_price\u003dstop_loss_price,\n        market_info\u003dmarket_info,\n        logger\u003dlogger\n    )\n\n    if position_size is None or position_size \u003c\u003d 0:\n        logger.error(f\"Cannot enter {signal} trade for {symbol}: Failed to calculate a valid position size.\")\n        return False\n\n    # 3. Set Leverage (do this before ordering)\n    leverage \u003d int(config.get(\"leverage\", 10))\n    leverage_set \u003d set_leverage_ccxt(exchange, symbol, leverage, logger, market_info)\n    if not leverage_set:\n        logger.error(f\"Failed to set leverage for {symbol}. Aborting trade entry.\")\n        return False\n    # Add a small delay after setting leverage if needed\n    time.sleep(1)\n\n    # 4. Place Entry Order (Market Order for simplicity)\n    side \u003d \u0027buy\u0027 if signal \u003d\u003d \u0027BUY\u0027 else \u0027sell\u0027\n    entry_order \u003d create_order_ccxt(\n        exchange\u003dexchange,\n        symbol\u003dsymbol,\n        order_type\u003d\u0027market\u0027,\n        side\u003dside,\n        amount\u003dposition_size,\n        logger\u003dlogger,\n        market_info\u003dmarket_info\n    )\n\n    if entry_order is None or not entry_order.get(\u0027id\u0027):\n        logger.error(f\"Failed to place entry market order for {symbol}. Aborting trade.\")\n        return False\n\n    logger.info(f\"Entry order placed successfully for {symbol}. Order ID: {entry_order[\u0027id\u0027]}. Waiting for confirmation...\")\n    time.sleep(POSITION_CONFIRM_DELAY) # Wait for order to likely fill and position to appear\n\n    # 5. Fetch Actual Entry Price (Optional but recommended)\n    # Fetch the actual filled price from the order or position after delay\n    # This is complex, involves fetching order history or position entry price.\n    # For simplicity, we\u0027ll proceed assuming market order filled near signal price.\n    # A more robust implementation would confirm fill and get actual entry.\n    actual_entry_price \u003d entry_price_signal # Approximation\n\n    # 6. Set SL/TP/TSL Protection\n    tsl_distance \u003d None\n    tsl_activation_price \u003d None\n    if config.get(\"enable_trailing_stop\"):\n        callback_rate \u003d Decimal(str(config.get(\"trailing_stop_callback_rate\", 0.005)))\n        activation_perc \u003d Decimal(str(config.get(\"trailing_stop_activation_percentage\", 0.003)))\n        min_tick \u003d analyzer.get_min_tick_size()\n\n        if callback_rate \u003e 0 and min_tick is not None and min_tick \u003e 0:\n            # Calculate absolute distance value for Bybit API\n            tsl_distance_raw \u003d actual_entry_price * callback_rate\n            # Quantize distance UP to nearest tick (safer)\n            tsl_distance \u003d (tsl_distance_raw / min_tick).quantize(Decimal(\u00271\u0027), rounding\u003dROUND_UP) * min_tick\n\n            if tsl_distance \u003c min_tick: # Ensure trail is at least one tick\n                 tsl_distance \u003d min_tick\n                 logger.warning(f\"Calculated TSL distance too small, adjusted to min tick: {tsl_distance}\")\n\n            # Calculate activation price if percentage \u003e 0\n            if activation_perc \u003e 0:\n                activation_offset \u003d actual_entry_price * activation_perc\n                if signal \u003d\u003d \"BUY\":\n                    tsl_activation_price_raw \u003d actual_entry_price + activation_offset\n                    # Quantize UP\n                    tsl_activation_price \u003d (tsl_activation_price_raw / min_tick).quantize(Decimal(\u00271\u0027), rounding\u003dROUND_UP) * min_tick\n                else: # SELL\n                    tsl_activation_price_raw \u003d actual_entry_price - activation_offset\n                    # Quantize DOWN\n                    tsl_activation_price \u003d (tsl_activation_price_raw / min_tick).quantize(Decimal(\u00271\u0027), rounding\u003dROUND_DOWN) * min_tick\n\n                # Ensure activation price is valid (positive and beyond entry)\n                if tsl_activation_price \u003c\u003d 0: tsl_activation_price \u003d None\n                if signal \u003d\u003d \"BUY\" and (tsl_activation_price is None or tsl_activation_price \u003c\u003d actual_entry_price): tsl_activation_price \u003d None\n                if signal \u003d\u003d \"SELL\" and (tsl_activation_price is None or tsl_activation_price \u003e\u003d actual_entry_price): tsl_activation_price \u003d None\n\n            logger.debug(f\"Calculated TSL: Distance\u003d{tsl_distance}, ActivationPrice\u003d{tsl_activation_price}\")\n        else:\n             logger.warning(\"Could not calculate TSL distance due to invalid rate or tick size.\")\n\n\n    protection_set \u003d set_protection_ccxt(\n        exchange\u003dexchange,\n        symbol\u003dsymbol,\n        stop_loss_price\u003dstop_loss_price,\n        take_profit_price\u003dtake_profit_price,\n        trailing_stop_price\u003dtsl_distance,\n        trailing_active_price\u003dtsl_activation_price,\n        logger\u003dlogger,\n        market_info\u003dmarket_info\n        # position_idx\u003d... # Add if needed for Hedge Mode\n    )\n\n    if not protection_set:\n        logger.error(f\"{NEON_RED}Failed to set initial SL/TP/TSL for {symbol} after entry! Position might be unprotected.{RESET}\")\n        # CRITICAL: Consider closing the position immediately if protection fails\n        # close_position_ccxt(...)\n        return False # Indicate failure\n\n    logger.info(f\"{NEON_GREEN}Successfully entered {signal} trade for {symbol} with protection.{RESET}\")\n    return True # Indicate success\n\n\n# --- Main Execution ---\nif __name__ \u003d\u003d \"__main__\":\n    parser \u003d argparse.ArgumentParser(description\u003d\"Enhanced Bybit V5 Trading Bot\")\n    parser.add_argument(\n        \"--config\", type\u003dstr, default\u003dCONFIG_FILE, help\u003df\"Path to configuration file (default: {CONFIG_FILE})\"\n    )\n    parser.add_argument(\n        \"--state\", type\u003dstr, default\u003dSTATE_FILE, help\u003df\"Path to state file (default: {STATE_FILE})\"\n    )\n    parser.add_argument(\n        \"--symbol\", type\u003dstr, help\u003d\"Override symbols in config and trade only this symbol (e.g., BTC/USDT:USDT)\"\n    )\n    parser.add_argument(\n        \"--live\", action\u003d\"store_true\", help\u003d\"Enable live trading (overrides config \u0027enable_trading\u003dfalse\u0027)\"\n    )\n    parser.add_argument(\n        \"--debug\", action\u003d\"store_true\", help\u003d\"Enable DEBUG level logging to console\"\n    )\n    args \u003d parser.parse_args()\n\n    # Set console log level based on args\n    if args.debug:\n        console_log_level \u003d logging.DEBUG\n\n    # Setup main logger first\n    main_logger \u003d get_logger(\u0027main\u0027)\n    main_logger.info(\" --- Bot Starting --- \")\n\n    # Load configuration\n    config \u003d load_config(args.config)\n\n    # Override symbols if specified\n    if args.symbol:\n        main_logger.warning(f\"Overriding config symbols. Trading ONLY: {args.symbol}\")\n        config[\"symbols\"] \u003d [args.symbol]\n\n    # Override trading mode if --live flag is set\n    if args.live:\n        main_logger.warning(f\"{NEON_RED}--- LIVE TRADING ENABLED via command line override! ---{RESET}\")\n        config[\"enable_trading\"] \u003d True\n    elif config.get(\"enable_trading\"):\n         main_logger.warning(f\"{NEON_RED}--- Live trading enabled via config file ---{RESET}\")\n    else:\n         main_logger.info(\"Live trading disabled.\")\n\n\n    # Load state\n    bot_state \u003d load_state(args.state, main_logger)\n\n    # Initialize exchange\n    exchange \u003d initialize_exchange(config, main_logger)\n\n    if exchange:\n        try:\n            run_bot(exchange, config, bot_state)\n        except KeyboardInterrupt:\n            main_logger.info(\"Bot stopped by user (KeyboardInterrupt).\")\n        except Exception as e:\n            main_logger.critical(f\"{NEON_RED}!!! BOT CRASHED due to unhandled exception: {e} !!!{RESET}\", exc_info\u003dTrue)\n        finally:\n            # Save state on exit\n            save_state(args.state, bot_state, main_logger)\n            main_logger.info(\"--- Bot Shutdown ---\")\n    else:\n        main_logger.critical(\"Failed to initialize exchange. Bot cannot start.\")\n\n    logging.shutdown() # Ensure all logs are flushed\n```\n\n**Explanation of Key Enhancements:**\n\n1.  **Structure and Initialization:** Cleaned up imports, constants, and initialization. Added a `STATE_FILE` constant.\n2.  **Logging:** Refined logger setup (`setup_logger`, `get_logger`) to handle symbol-specific logs correctly and use the global `console_log_level`. Added milliseconds and timezone name to console logs.\n3.  **Configuration:** Merged all relevant options from both files into `load_config` defaults. `_ensure_config_keys` handles the combined set.\n4.  **State Management:** Added `load_state` and `save_state` functions to persist information like `break_even_triggered` across bot restarts. The `bot_state` dictionary is passed around.\n5.  **CCXT Initialization:** Combined the best V5 settings (`versions`, timeouts, `brokerId`). Added periodic market reloading logic within `get_market_info`. Uses the robust `fetch_balance`.\n6.  **`safe_ccxt_call`:** Centralized API call logic with retries for network errors and rate limits, including exponential backoff. This simplifies all other CCXT interaction functions.\n7.  **Market Info:** Uses the refined `get_market_info` and its helpers (`get_min_tick_size_from_market`, etc.) for accurate precision and limit data. Added `_determine_category` helper.\n8.  **Data Fetching Wrappers:** `fetch_current_price_ccxt`, `fetch_klines_ccxt`, `fetch_orderbook_ccxt`, `fetch_balance` now use `safe_ccxt_call` and incorporate `market_info` for V5 parameters.\n9.  **`TradingAnalyzer`:**\n    *   Uses `pandas_ta.Strategy` (`_define_ta_strategy`, `_calculate_all_indicators`) for efficiency.\n    *   Manages `symbol_state` via the passed dictionary and property setters/getters (`break_even_triggered`).\n    *   Uses refined market info helpers (`get_min_tick_size`, etc.).\n    *   Indicator check methods (`_check_...`) now fetch values from `self.indicator_values` (populated by the strategy) and return `Optional[float]`.\n    *   `generate_trading_signal` handles `None` scores gracefully and logs detailed score breakdowns.\n    *   `calculate_entry_tp_sl` quantizes entry price first for better accuracy.\n10. **Trading Action Wrappers:** Added robust functions for core trading actions:\n    *   `fetch_positions_ccxt`: Fetches and filters positions for a specific symbol.\n    *   `set_leverage_ccxt`: Sets leverage using V5 parameters.\n    *   `create_order_ccxt`: Places market or limit orders with V5 parameters.\n    *   `set_protection_ccxt`: Sets SL/TP/TSL using the specific V5 `position/trading-stop` endpoint. Handles formatting for distance/activation price.\n    *   `close_position_ccxt`: Closes a position using a `reduceOnly` market order.\n11. **Position Sizing:** Implemented `calculate_position_size` based on risk percentage, balance, and SL distance, including quantization and validation against minimums.\n12. **Main Loop (`run_bot`):**\n    *   Iterates through configured symbols.\n    *   Manages `bot_state` for each symbol.\n    *   Fetches balance once per cycle.\n    *   Counts open positions to respect `max_concurrent_positions_total`.\n    *   Calls `manage_existing_position` or `attempt_new_entry`.\n    *   Includes cycle timing and state saving.\n13. **Position Management (`manage_existing_position`):** Implements MA Cross Exit and Break-Even logic, interacting with `set_protection_ccxt` and `close_position_ccxt`.\n14. **New Entry Logic (`attempt_new_entry`):** Orchestrates the process of calculating TP/SL, sizing, setting leverage, placing the entry order, and setting initial protection. Includes TSL calculation logic based on config percentages.\n15. **Command-Line Arguments:** Added `argparse` for config path, state path, single symbol override, live trading toggle, and debug logging.\n16. **Error Handling:** Improved error logging and handling throughout, especially within `safe_ccxt_call` and the main loop.\n\nThis enhanced version provides a much more robust, feature-complete, and optimized foundation for a multi-symbol trading bot using the Bybit V5 API. Remember to test thoroughly in sandbox mode before enabling live trading.",
      "role": "user",
      "tokenCount": 39443
    }, {
      "text": "Here\u0027s a breakdown of the thought process to generate the enhanced Python trading bot script:\n\n1.  **Understand the Goal:** The primary objective is to merge two existing Python trading bot scripts, combining their strengths, fixing weaknesses, and implementing a more robust, feature-rich, and optimized version specifically targeting Bybit\u0027s V5 API. Key features required are multi-symbol support, `pandas_ta.Strategy` for efficiency, proper V5 API interaction, Trailing Stop Loss (TSL), Break-Even (BE), MA cross exit, state management, Decimal precision, and good logging/error handling.\n\n2.  **Initial Analysis (as provided):** Review the strengths and weaknesses of Script 1 and Script 2. This identifies key components to keep, discard, or improve from each:\n    *   **Keep from Script 1:** Robust `fetch_balance`, detailed V5 param handling (though needing standardization), explicit rate limit parsing (conceptually good, but `safe_ccxt_call` is better), `Decimal` usage, `SensitiveFormatter`.\n    *   **Keep from Script 2:** Multi-symbol structure (`symbols` in config), `pandas_ta.Strategy`, `symbol_state` concept, TSL/BE config options, periodic market reload, market info helpers (`get_..._from_market`), `versions` dict for CCXT V5.\n    *   **Needs Implementation:** Multi-symbol main loop, actual TSL/BE logic in the loop/management functions, position sizing, order placement wrappers, standardized V5 param usage, command-line args.\n    *   **Needs Improvement/Merging:** Configuration handling, CCXT initialization, error handling/retries, logging structure.\n\n3.  **High-Level Plan (as provided):** Outline the steps for merging and enhancement. This acts as a checklist:\n    *   Merge Config\n    *   Adopt `pandas_ta.Strategy`\n    *   Enhance CCXT Interaction (V5, timeouts, reloads, wrappers)\n    *   Refine Market Info\n    *   Implement Multi-Symbol Loop\n    *   Implement Trading Logic (position checks, sizing, order placement, management)\n    *   Implement State Management\n    *   Refine Logging\n    *   Maintain Precision (`Decimal`)\n    *   Add CLI Args\n    *   Improve Code Structure\n\n4.  **Detailed Design \u0026 Implementation Strategy:**\n\n    *   **Structure:** Start with a standard Python script layout: imports, constants, global variables (carefully!), helper functions, classes, main execution block (`if __name__ \u003d\u003d \"__main__\":`). Use type hints and docstrings from the start.\n    *   **Configuration:**\n        *   Define a comprehensive `default_config` dictionary covering all desired features (symbols, interval, risk, leverage, indicator periods, thresholds, TSL/BE settings, indicator enables/weights).\n        *   Implement `load_config` to read JSON, handle missing files (create default), and crucially, use `_ensure_config_keys` to merge defaults into loaded configs, ensuring backward compatibility and providing warnings. Save updates back to the file.\n    *   **Logging:**\n        *   Implement `SensitiveFormatter` to redact API keys.\n        *   Implement `LocalTimeFormatter` for console output using `zoneinfo`.\n        *   Create `setup_logger` to configure both file (UTC) and stream (local time) handlers with appropriate levels and formatters. Use `RotatingFileHandler`.\n        *   Manage loggers in a global `loggers` dictionary to avoid reconfiguration. Use `get_logger` as the access point. Allow per-symbol loggers.\n    *   **State Management:**\n        *   Define `load_state` and `save_state` using JSON. Handle file not found and decoding errors gracefully.\n        *   The main loop will manage the `bot_state` dictionary, passing relevant symbol-specific sub-dictionaries (`symbol_state`) to the `TradingAnalyzer` and management functions.\n    *   **CCXT Setup:**\n        *   `initialize_exchange`: Combine API keys, timeouts, `brokerId`. Critically, include the `versions` dictionary from Script 2 to explicitly target V5 endpoints. Add sandbox mode logic. Implement robust connection testing (market loading, initial balance fetch using the new `fetch_balance` wrapper). Handle `AuthenticationError` specifically with helpful messages.\n        *   `safe_ccxt_call`: This is crucial. Abstract the retry logic for `RateLimitExceeded`, `NetworkError`, `RequestTimeout`, `DDoSProtection`. Use exponential backoff. Parse retry-after times if possible. Re-raise critical errors like `AuthenticationError` and `ExchangeError` (unless specifically handled).\n        *   **API Wrappers:** Create dedicated functions for common CCXT calls (`fetch_...`, `create_...`, `set_...`) that *use* `safe_ccxt_call`. These wrappers should:\n            *   Accept necessary arguments (symbol, side, amount, etc.).\n            *   Accept `market_info` to extract the correct V5 `category` and other necessary parameters.\n            *   Construct the `params` dictionary required by CCXT and Bybit V5.\n            *   Call `safe_ccxt_call`.\n            *   Parse and validate the response (e.g., check `retCode` for Bybit).\n            *   Log actions and results clearly.\n    *   **Market Info:**\n        *   `get_market_info`: Use the logic from Script 2. Add periodic reloading based on `MARKET_RELOAD_INTERVAL_SECONDS`. Ensure it calls the helper functions.\n        *   Helper functions (`get_min_tick_size_from_market`, etc.): Keep these mostly as-is from Script 2, ensuring they handle V5 `info` structures and use `Decimal`. Add `_determine_category`. Enhance logging and fallback values.\n    *   **`TradingAnalyzer` Class:**\n        *   Constructor: Takes `df`, `logger`, `config`, `market_info`, `symbol_state`. Initializes internal state.\n        *   `_define_ta_strategy`: Build the `ta.Strategy` list based on `config[\"indicators\"]` flags and parameters. Store the strategy object. Create `ta_column_map` to map generic names (e.g., \"EMA_Short\") to actual pandas_ta column names (e.g., \"EMA_9\").\n        *   `_calculate_all_indicators`: Apply the strategy using `df.ta.strategy(self.ta_strategy)`. Handle insufficient data warnings.\n        *   `_update_latest_indicator_values`: Populate `self.indicator_values` (dict of `str` to `Optional[float]`) from the *last row* of the calculated DataFrame using the `ta_column_map`.\n        *   **State Property:** Use `@property` for `break_even_triggered` to read/write directly to the passed `symbol_state` dictionary, ensuring state changes are reflected centrally.\n        *   Precision Helpers: Implement `quantize_price`, `quantize_amount` using `Decimal` and market info.\n        *   Fibonacci: Keep the logic using `Decimal` and quantization.\n        *   Indicator Checks (`_check_...`): Rewrite these to use `self.indicator_values.get(\"GenericName\")`. Return `Optional[float]` (-1.0 to 1.0, or None if data missing).\n        *   `generate_trading_signal`: Iterate through enabled indicators, call check methods, apply weights (from config, using `active_weight_set`), sum scores, normalize (optional but good for analysis), compare against threshold, log details, return \"BUY\"/\"SELL\"/\"HOLD\". Handle `None` scores. Pass `orderbook_data` to `_check_orderbook`.\n        *   `calculate_entry_tp_sl`: Take entry price, signal. Fetch ATR from `indicator_values`. Calculate raw TP/SL using multipliers. *Crucially*, quantize the *entry price first*, then calculate offsets, then quantize final TP/SL away from the quantized entry. Return tuple `(quantized_entry, quantized_tp, quantized_sl)`.\n    *   **Position Sizing:**\n        *   `calculate_position_size`: Implement the formula: `size \u003d (balance * risk_pct) / (abs(entry - sl) * value_per_point)`. Use `Decimal`. Get contract size, min amount/cost, amount precision from `market_info`. Quantize the final size `ROUND_DOWN`. Validate against minimums.\n    *   **Main Loop (`run_bot`):**\n        *   Initialize state dict.\n        *   Loop indefinitely (`while True`).\n        *   Fetch balance (once per cycle).\n        *   Fetch all positions (once per cycle) and store them (`active_positions`). Count open positions.\n        *   Iterate through configured `symbols`.\n        *   Get symbol logger and `symbol_state`.\n        *   Inside try/except block for symbol processing:\n            *   Get `market_info`.\n            *   Fetch klines, price, orderbook.\n            *   Instantiate `TradingAnalyzer`.\n            *   Check `active_positions` for the current symbol.\n            *   If position exists: Call `manage_existing_position`.\n            *   If no position AND `open_positions_count \u003c max_concurrent_positions_total`:\n                *   Generate signal using `analyzer.generate_trading_signal`.\n                *   If BUY/SELL signal AND trading enabled AND balance valid: Call `attempt_new_entry`. Update `open_positions_count` if entry successful.\n            *   Log completion/errors for the symbol.\n        *   Save state using `save_state`.\n        *   Calculate cycle duration and sleep.\n    *   **Position Management (`manage_existing_position`):**\n        *   Takes exchange, config, logger, analyzer, position\\_data, current\\_price.\n        *   Implement MA Cross Exit: Check EMAs from `analyzer.indicator_values`. If adverse cross, call `close_position_ccxt`.\n        *   Implement BE: Check if `enable_break_even` and `not analyzer.break_even_triggered`. Calculate profit target (ATR based). Calculate current profit. If target reached:\n            *   Calculate BE stop price (entry + offset ticks, quantized).\n            *   Call `set_protection_ccxt` with the new SL (potentially preserving TP/TSL based on `break_even_force_fixed_sl`).\n            *   Update `analyzer.break_even_triggered \u003d True`.\n    *   **New Entry (`attempt_new_entry`):**\n        *   Takes exchange, config, logger, analyzer, signal, entry\\_price\\_signal, current\\_balance.\n        *   Calculate initial TP/SL using `analyzer.calculate_entry_tp_sl`. Validate SL exists.\n        *   Calculate position size using `calculate_position_size`. Validate size.\n        *   Set leverage using `set_leverage_ccxt`.\n        *   Place market entry order using `create_order_ccxt`. Validate order placed.\n        *   Wait `POSITION_CONFIRM_DELAY`.\n        *   *(Optional enhancement: Fetch actual fill price)*. Use signal price as approximation.\n        *   Calculate TSL parameters (distance, activation price) based on config percentages and actual entry price. Quantize correctly.\n        *   Set initial protection (SL, TP, TSL) using `set_protection_ccxt`. Validate success. Return `True` on full success, `False` otherwise.\n    *   **CLI:** Use `argparse` to handle `--config`, `--state`, `--symbol`, `--live`, `--debug`. Update `console_log_level` and config overrides based on args.\n    *   **Main Block:** Parse args, set up logger, load config, handle overrides, load state, initialize exchange, run `run_bot` in try/except block, save state in `finally`, shutdown logging.\n\n5.  **Refinement and Review:**\n    *   Read through the generated code.\n    *   Check for logical consistency (e.g., state updates, parameter passing).\n    *   Ensure `Decimal` is used for all financial calculations.\n    *   Verify quantization logic (price vs. amount, rounding directions).\n    *   Confirm V5 parameters (`category`, `positionIdx`, TSL fields) are correctly used in wrappers.\n    *   Improve comments and docstrings.\n    *   Check logging levels and messages for clarity.\n    *   Ensure error handling is robust, especially in API calls and critical logic paths. Consider edge cases (e.g., zero balance, invalid market data, API errors).\n\nThis structured approach, moving from high-level requirements to detailed implementation and refinement, helps manage the complexity and ensure all requirements are addressed in the final script. The provided plan and analysis were excellent starting points.",
      "role": "model",
      "tokenCount": 2839,
      "isThought": true
    }, {
      "text": "Okay, this is a comprehensive plan and a solid starting point for the merged and enhanced bot. Let\u0027s proceed with generating the Python code based on this detailed plan.\n\n```python\n# -*- coding: utf-8 -*-\n\"\"\"\nEnhanced Multi-Symbol Trading Bot for Bybit (V5 API)\nMerges features, optimizations, and best practices from previous versions.\nIncludes: pandas_ta.Strategy, Decimal precision, robust CCXT interaction,\n          multi-symbol support, state management, TSL/BE logic, MA cross exit.\n\"\"\"\n\nimport argparse\nimport json\nimport logging\nimport math\nimport os\nimport sys\nimport time\nimport traceback # Added for detailed exception logging\nfrom datetime import datetime, timedelta\nfrom decimal import ROUND_DOWN, ROUND_UP, Decimal, InvalidOperation, getcontext\nfrom logging.handlers import RotatingFileHandler\nfrom typing import Any, Dict, List, Optional, Tuple, Union\n\ntry:\n    from zoneinfo import ZoneInfo # Preferred (Python 3.9+)\nexcept ImportError:\n    from pytz import timezone as ZoneInfo # Fallback for older Python\n\n# Third-party libraries - alphabetized\nimport ccxt\nimport numpy as np # pandas_ta might require numpy\nimport pandas as pd\nimport pandas_ta as ta\nfrom colorama import Fore, Style, init\nfrom dotenv import load_dotenv\n\n# --- Initialization ---\ntry:\n    getcontext().prec \u003d 36 # Increased precision for intermediate calculations\nexcept Exception as e:\n    print(f\"Warning: Could not set Decimal precision: {e}. Using default.\")\ninit(autoreset\u003dTrue)    # Initialize colorama\nload_dotenv()           # Load environment variables from .env file\n\n# --- Neon Color Scheme ---\nNEON_GREEN \u003d Fore.LIGHTGREEN_EX\nNEON_BLUE \u003d Fore.CYAN\nNEON_PURPLE \u003d Fore.MAGENTA\nNEON_YELLOW \u003d Fore.YELLOW\nNEON_RED \u003d Fore.LIGHTRED_EX\nNEON_CYAN \u003d Fore.CYAN\nRESET \u003d Style.RESET_ALL\n\n# --- Environment Variable Loading and Validation ---\nAPI_KEY \u003d os.getenv(\"BYBIT_API_KEY\")\nAPI_SECRET \u003d os.getenv(\"BYBIT_API_SECRET\")\nif not API_KEY or not API_SECRET:\n    print(f\"{NEON_RED}FATAL: BYBIT_API_KEY and BYBIT_API_SECRET must be set in .env file{RESET}\")\n    sys.exit(1) # Exit if keys are missing\n\n# --- Configuration File and Constants ---\nCONFIG_FILE \u003d \"config.json\"\nLOG_DIRECTORY \u003d \"bot_logs\"\nSTATE_FILE \u003d \"bot_state.json\" # File to persist state like break-even triggers\n\n# Ensure log directory exists\nos.makedirs(LOG_DIRECTORY, exist_ok\u003dTrue)\n\n# Timezone for logging and display\ntry:\n    TZ_NAME \u003d os.getenv(\"BOT_TIMEZONE\", \"America/Chicago\") # Default timezone\n    TIMEZONE \u003d ZoneInfo(TZ_NAME)\n    print(f\"Using Timezone: {TZ_NAME}\")\nexcept Exception as tz_err:\n    print(f\"{NEON_YELLOW}Warning: Could not load timezone \u0027{TZ_NAME}\u0027: {tz_err}. Defaulting to UTC.{RESET}\")\n    TIMEZONE \u003d ZoneInfo(\"UTC\")\n\n# --- API Interaction Constants ---\nMAX_API_RETRIES \u003d 4 # Increased max retries slightly\nRETRY_DELAY_SECONDS \u003d 5 # Base delay between retries\nRATE_LIMIT_BUFFER_SECONDS \u003d 0.5 # Add small buffer to rate limit waits\nMARKET_RELOAD_INTERVAL_SECONDS \u003d 3600 # Reload markets every hour\nPOSITION_CONFIRM_DELAY \u003d 10 # Seconds to wait after placing order before checking position status\n\n# Intervals supported by the bot\u0027s internal logic (ensure config matches)\nVALID_INTERVALS \u003d [\"1\", \"3\", \"5\", \"15\", \"30\", \"60\", \"120\", \"240\", \"360\", \"720\", \"D\", \"W\", \"M\"]\n# Map bot intervals to ccxt\u0027s expected timeframe format\nCCXT_INTERVAL_MAP \u003d {\n    \"1\": \"1m\", \"3\": \"3m\", \"5\": \"5m\", \"15\": \"15m\", \"30\": \"30m\",\n    \"60\": \"1h\", \"120\": \"2h\", \"240\": \"4h\", \"360\": \"6h\", \"720\": \"12h\",\n    \"D\": \"1d\", \"W\": \"1w\", \"M\": \"1M\"\n}\n\n# --- Default Indicator/Strategy Parameters (can be overridden by config.json) ---\nDEFAULT_ATR_PERIOD \u003d 14\nDEFAULT_CCI_WINDOW \u003d 20\nDEFAULT_WILLIAMS_R_WINDOW \u003d 14\nDEFAULT_MFI_WINDOW \u003d 14\nDEFAULT_STOCH_RSI_WINDOW \u003d 14 # Window for Stoch RSI calculation itself\nDEFAULT_STOCH_WINDOW \u003d 14     # Window for underlying RSI in StochRSI\nDEFAULT_K_WINDOW \u003d 3          # K period for StochRSI\nDEFAULT_D_WINDOW \u003d 3          # D period for StochRSI\nDEFAULT_RSI_WINDOW \u003d 14\nDEFAULT_BOLLINGER_BANDS_PERIOD \u003d 20\nDEFAULT_BOLLINGER_BANDS_STD_DEV \u003d 2.0 # Ensure float for calculations\nDEFAULT_SMA_10_WINDOW \u003d 10\nDEFAULT_EMA_SHORT_PERIOD \u003d 9\nDEFAULT_EMA_LONG_PERIOD \u003d 21\nDEFAULT_MOMENTUM_PERIOD \u003d 7\nDEFAULT_VOLUME_MA_PERIOD \u003d 15\nDEFAULT_FIB_WINDOW \u003d 50\nDEFAULT_PSAR_AF \u003d 0.02\nDEFAULT_PSAR_MAX_AF \u003d 0.2\nFIB_LEVELS \u003d [0.0, 0.236, 0.382, 0.5, 0.618, 0.786, 1.0] # Standard Fibonacci levels\n\n# --- Bot Timing and Delays ---\nDEFAULT_LOOP_DELAY_SECONDS \u003d 15 # Default time between full cycles\n\n# --- Global Variables ---\nloggers: Dict[str, logging.Logger] \u003d {} # Dictionary to hold logger instances\nconsole_log_level \u003d logging.INFO # Default, can be changed by args\nQUOTE_CURRENCY \u003d \"USDT\" # Default, updated from config\nLOOP_DELAY_SECONDS \u003d DEFAULT_LOOP_DELAY_SECONDS # Default, updated from config\n\n# --- Logger Setup ---\nclass SensitiveFormatter(logging.Formatter):\n    \"\"\"Custom formatter to redact sensitive information (API keys) from logs.\"\"\"\n    REDACTED_STR \u003d \"***REDACTED***\"\n    def format(self, record: logging.LogRecord) -\u003e str:\n        original_message \u003d super().format(record)\n        redacted_message \u003d original_message\n        # More robust redaction - less likely to partially match\n        if API_KEY and len(API_KEY) \u003e 4:\n            redacted_message \u003d redacted_message.replace(API_KEY, self.REDACTED_STR)\n        if API_SECRET and len(API_SECRET) \u003e 4:\n            redacted_message \u003d redacted_message.replace(API_SECRET, self.REDACTED_STR)\n        return redacted_message\n\nclass LocalTimeFormatter(SensitiveFormatter):\n    \"\"\"Formatter that uses the configured local timezone for console output.\"\"\"\n    def converter(self, timestamp):\n        dt \u003d datetime.fromtimestamp(timestamp, tz\u003dTIMEZONE)\n        return dt.timetuple()\n\n    def formatTime(self, record, datefmt\u003dNone):\n        dt \u003d datetime.fromtimestamp(record.created, tz\u003dTIMEZONE)\n        if datefmt:\n            s \u003d dt.strftime(datefmt)\n        else:\n            s \u003d dt.strftime(\"%Y-%m-%d %H:%M:%S\")\n            s \u003d f\"{s},{int(record.msecs):03d}\"\n        return s\n\ndef setup_logger(name: str, is_symbol_logger: bool \u003d False) -\u003e logging.Logger:\n    \"\"\"Sets up a logger with rotating file and timezone-aware console handlers.\"\"\"\n    global console_log_level # Access global console level setting\n\n    logger_instance_name \u003d f\"livebot_{name.replace(\u0027/\u0027, \u0027_\u0027).replace(\u0027:\u0027, \u0027-\u0027)}\" if is_symbol_logger else f\"livebot_{name}\"\n\n    if logger_instance_name in loggers:\n        logger \u003d loggers[logger_instance_name]\n        # Update existing console handler level if needed\n        for handler in logger.handlers:\n            if isinstance(handler, logging.StreamHandler):\n                handler.setLevel(console_log_level)\n        # No need to log reconfiguration unless debugging logger setup itself\n        # logger.debug(f\"Logger \u0027{logger_instance_name}\u0027 already configured. Console level set to {logging.getLevelName(console_log_level)}.\")\n        return logger\n\n    log_filename \u003d os.path.join(LOG_DIRECTORY, f\"{logger_instance_name}.log\")\n    logger \u003d logging.getLogger(logger_instance_name)\n\n    # Prevent setting level lower than WARNING for root/ccxt loggers if desired\n    effective_level \u003d logging.DEBUG # Default: Capture everything at logger level\n    logger.setLevel(effective_level)\n\n    # --- File Handler (UTC Timestamps) ---\n    try:\n        file_handler \u003d RotatingFileHandler(\n            log_filename, maxBytes\u003d10 * 1024 * 1024, backupCount\u003d5, encoding\u003d\u0027utf-8\u0027\n        )\n        # Use UTC for file logs\n        file_formatter \u003d SensitiveFormatter(\n            \"%(asctime)s.%(msecs)03d UTC - %(levelname)-8s - [%(name)s:%(lineno)d] - %(message)s\",\n            datefmt\u003d\u0027%Y-%m-%d %H:%M:%S\u0027\n        )\n        # Ensure UTC conversion for file handler\n        file_formatter.converter \u003d time.gmtime\n        file_handler.setFormatter(file_formatter)\n        file_handler.setLevel(logging.DEBUG) # Log everything to the file\n        logger.addHandler(file_handler)\n    except Exception as e:\n        print(f\"{NEON_RED}Error setting up file logger for {log_filename}: {e}{RESET}\")\n\n    # --- Stream Handler (Local Time Timestamps) ---\n    stream_handler \u003d logging.StreamHandler(sys.stdout) # Explicitly use stdout\n    stream_formatter \u003d LocalTimeFormatter(\n        f\"{NEON_BLUE}%(asctime)s{RESET} {TIMEZONE.tzname(datetime.now(TIMEZONE))} - {NEON_YELLOW}%(levelname)-8s{RESET} - {NEON_PURPLE}[%(name)s]{RESET} - %(message)s\",\n        datefmt\u003d\u0027%Y-%m-%d %H:%M:%S,%f\u0027 # Include microseconds if needed\n    )\n    stream_handler.setFormatter(stream_formatter)\n    stream_handler.setLevel(console_log_level) # Set level from global variable\n    logger.addHandler(stream_handler)\n\n    logger.propagate \u003d False # Prevent duplicate logs in parent/root logger\n    loggers[logger_instance_name] \u003d logger\n    # Initial info log goes through the handlers configured above\n    logger.info(f\"Logger \u0027{logger_instance_name}\u0027 initialized. File: \u0027{os.path.basename(log_filename)}\u0027, Console Level: {logging.getLevelName(console_log_level)}\")\n    return logger\n\ndef get_logger(name: str, is_symbol_logger: bool \u003d False) -\u003e logging.Logger:\n    \"\"\"Retrieves or creates a logger instance.\"\"\"\n    return setup_logger(name, is_symbol_logger)\n\n# --- Configuration Management ---\ndef _ensure_config_keys(config: Dict[str, Any], default_config: Dict[str, Any]) -\u003e Tuple[Dict[str, Any], bool]:\n    \"\"\"Recursively ensures all keys from the default config are present in the loaded config.\"\"\"\n    updated_config \u003d config.copy()\n    keys_added_or_type_mismatch \u003d False\n    for key, default_value in default_config.items():\n        if key not in updated_config:\n            updated_config[key] \u003d default_value\n            keys_added_or_type_mismatch \u003d True\n            print(f\"{NEON_YELLOW}Config Warning: Missing key \u0027{key}\u0027. Added default value: {repr(default_value)}{RESET}\")\n        elif isinstance(default_value, dict) and isinstance(updated_config.get(key), dict):\n            # Recursively check nested dictionaries\n            nested_updated_config, nested_keys_added \u003d _ensure_config_keys(updated_config[key], default_value)\n            if nested_keys_added:\n                updated_config[key] \u003d nested_updated_config\n                keys_added_or_type_mismatch \u003d True\n        elif updated_config.get(key) is not None and type(default_value) !\u003d type(updated_config.get(key)):\n            # Check type mismatch, allowing Int -\u003e Float/Decimal promotion silently\n            is_promoting_num \u003d (isinstance(default_value, (float, Decimal)) and isinstance(updated_config.get(key), int))\n            if not is_promoting_num:\n                # Warn about other type mismatches but keep the loaded value\n                print(f\"{NEON_YELLOW}Config Warning: Type mismatch for key \u0027{key}\u0027. Expected {type(default_value)}, got {type(updated_config.get(key))}. Using loaded value: {repr(updated_config.get(key))}.{RESET}\")\n                # No need to set keys_added_or_type_mismatch \u003d True here, as we are using the loaded value\n\n    return updated_config, keys_added_or_type_mismatch\n\ndef load_config(filepath: str) -\u003e Dict[str, Any]:\n    \"\"\"Load config, create default if missing, ensure keys exist, save updates.\"\"\"\n    default_config \u003d {\n        \"symbols\": [\"BTC/USDT:USDT\"], # List of CCXT symbols (e.g., BASE/QUOTE:SETTLE)\n        \"interval\": \"5\", # Default interval (string, ensure it\u0027s in VALID_INTERVALS)\n        \"loop_delay\": DEFAULT_LOOP_DELAY_SECONDS,\n        \"quote_currency\": \"USDT\",\n        \"enable_trading\": False, # SAFETY FIRST: Default to False\n        \"use_sandbox\": True,     # SAFETY FIRST: Default to True (testnet)\n        \"risk_per_trade\": 0.01, # Risk 1% (as float)\n        \"leverage\": 20,          # Desired leverage (check exchange limits!)\n        \"max_concurrent_positions_total\": 1, # Global limit across all symbols\n        \"position_mode\": \"One-Way\", # \"One-Way\" or \"Hedge\" - MUST MATCH EXCHANGE SETTING\n        # --- Indicator Periods \u0026 Settings ---\n        \"atr_period\": DEFAULT_ATR_PERIOD,\n        \"ema_short_period\": DEFAULT_EMA_SHORT_PERIOD,\n        \"ema_long_period\": DEFAULT_EMA_LONG_PERIOD,\n        \"rsi_period\": DEFAULT_RSI_WINDOW,\n        \"bollinger_bands_period\": DEFAULT_BOLLINGER_BANDS_PERIOD,\n        \"bollinger_bands_std_dev\": DEFAULT_BOLLINGER_BANDS_STD_DEV,\n        \"cci_window\": DEFAULT_CCI_WINDOW,\n        \"williams_r_window\": DEFAULT_WILLIAMS_R_WINDOW,\n        \"mfi_window\": DEFAULT_MFI_WINDOW,\n        \"stoch_rsi_window\": DEFAULT_STOCH_RSI_WINDOW,\n        \"stoch_rsi_rsi_window\": DEFAULT_STOCH_WINDOW,\n        \"stoch_rsi_k\": DEFAULT_K_WINDOW,\n        \"stoch_rsi_d\": DEFAULT_D_WINDOW,\n        \"psar_af\": DEFAULT_PSAR_AF,\n        \"psar_max_af\": DEFAULT_PSAR_MAX_AF,\n        \"sma_10_window\": DEFAULT_SMA_10_WINDOW,\n        \"momentum_period\": DEFAULT_MOMENTUM_PERIOD,\n        \"volume_ma_period\": DEFAULT_VOLUME_MA_PERIOD,\n        \"fibonacci_window\": DEFAULT_FIB_WINDOW,\n        # --- Signal Generation \u0026 Thresholds ---\n        \"orderbook_limit\": 25,\n        \"signal_score_threshold\": 1.5, # Use float\n        \"stoch_rsi_oversold_threshold\": 25.0, # Use float\n        \"stoch_rsi_overbought_threshold\": 75.0, # Use float\n        \"volume_confirmation_multiplier\": 1.5, # Use float\n        \"scalping_signal_threshold\": 2.5, # Use float (for \u0027scalping\u0027 weight set)\n        # --- Risk Management Multipliers (based on ATR) ---\n        \"stop_loss_multiple\": 1.8, # Use float (for initial SL sizing)\n        \"take_profit_multiple\": 0.7, # Use float\n        # --- Exit Strategies ---\n        \"enable_ma_cross_exit\": True,\n        # --- Trailing Stop Loss Config (Exchange-based TSL) ---\n        \"enable_trailing_stop\": True,\n        # Trail distance as a percentage of entry price (e.g., 0.005 for 0.5%)\n        # This percentage is used to calculate the absolute \u0027trailingStop\u0027 value for Bybit API\n        \"trailing_stop_callback_rate\": 0.005, # Use float\n        # Activate TSL when price moves this percentage in profit (e.g., 0.003 for 0.3%)\n        # Set to 0 for immediate activation (API value \u00270\u0027). Calculated into \u0027activePrice\u0027 for Bybit API.\n        \"trailing_stop_activation_percentage\": 0.003, # Use float\n        # --- Break-Even Stop Config ---\n        \"enable_break_even\": True,\n        \"break_even_trigger_atr_multiple\": 1.0, # Use float (Trigger BE when profit \u003d X * ATR)\n        \"break_even_offset_ticks\": 2, # Use integer (Place BE SL N ticks beyond entry)\n        \"break_even_force_fixed_sl\": True, # Cancel TSL and set fixed SL at BE price? (Safer for Bybit V5)\n        # --- Indicator Enable/Disable Flags ---\n        \"indicators\": {\n            \"ema_alignment\": True, \"momentum\": True, \"volume_confirmation\": True,\n            \"stoch_rsi\": True, \"rsi\": True, \"bollinger_bands\": True, \"vwap\": True,\n            \"cci\": True, \"wr\": True, \"psar\": True, \"sma_10\": True, \"mfi\": True,\n            \"orderbook\": True,\n        },\n        # --- Indicator Weighting Sets ---\n        \"weight_sets\": {\n            \"scalping\": {\n                \"ema_alignment\": 0.2, \"momentum\": 0.3, \"volume_confirmation\": 0.2,\n                \"stoch_rsi\": 0.6, \"rsi\": 0.2, \"bollinger_bands\": 0.3, \"vwap\": 0.4,\n                \"cci\": 0.3, \"wr\": 0.3, \"psar\": 0.2, \"sma_10\": 0.1, \"mfi\": 0.2, \"orderbook\": 0.15,\n            },\n            \"default\": {\n                \"ema_alignment\": 0.3, \"momentum\": 0.2, \"volume_confirmation\": 0.1,\n                \"stoch_rsi\": 0.4, \"rsi\": 0.3, \"bollinger_bands\": 0.2, \"vwap\": 0.3,\n                \"cci\": 0.2, \"wr\": 0.2, \"psar\": 0.3, \"sma_10\": 0.1, \"mfi\": 0.2, \"orderbook\": 0.1,\n            }\n        },\n        \"active_weight_set\": \"default\" # Which weight set to use\n    }\n\n    # --- File Handling ---\n    config_to_use \u003d default_config\n    keys_updated_in_file \u003d False\n    if not os.path.exists(filepath):\n        print(f\"{NEON_YELLOW}Config file not found at \u0027{filepath}\u0027. Creating default config...{RESET}\")\n        try:\n            with open(filepath, \"w\", encoding\u003d\"utf-8\") as f:\n                json.dump(default_config, f, indent\u003d4, sort_keys\u003dTrue)\n            print(f\"{NEON_GREEN}Created default config file: {filepath}{RESET}\")\n            # Use the default config we just wrote\n        except IOError as e:\n            print(f\"{NEON_RED}Error creating default config file {filepath}: {e}. Using in-memory defaults.{RESET}\")\n            # config_to_use remains default_config\n    else:\n        # --- Load Existing Config and Merge Defaults ---\n        try:\n            with open(filepath, \"r\", encoding\u003d\"utf-8\") as f:\n                config_from_file \u003d json.load(f)\n            # Ensure all default keys exist in the loaded config\n            updated_config_from_file, keys_added \u003d _ensure_config_keys(config_from_file, default_config)\n            config_to_use \u003d updated_config_from_file # Use the potentially updated loaded config\n            if keys_added:\n                keys_updated_in_file \u003d True # Flag that the file needs saving\n                print(f\"{NEON_YELLOW}Updating config file \u0027{filepath}\u0027 with missing/changed default keys...{RESET}\")\n                # Save the updated config back to the file\n                try:\n                    with open(filepath, \"w\", encoding\u003d\"utf-8\") as f_write:\n                        json.dump(config_to_use, f_write, indent\u003d4, sort_keys\u003dTrue)\n                    print(f\"{NEON_GREEN}Config file updated successfully.{RESET}\")\n                except IOError as e:\n                    print(f\"{NEON_RED}Error writing updated config file {filepath}: {e}{RESET}\")\n                    keys_updated_in_file \u003d False # Failed to save, clear the flag\n        except (FileNotFoundError, json.JSONDecodeError) as e:\n            print(f\"{NEON_RED}Error loading config file {filepath}: {e}. Using default config.{RESET}\")\n            config_to_use \u003d default_config # Revert to default\n            try: # Attempt to recreate default if loading failed\n                with open(filepath, \"w\", encoding\u003d\"utf-8\") as f_recreate:\n                    json.dump(default_config, f_recreate, indent\u003d4, sort_keys\u003dTrue)\n                print(f\"{NEON_GREEN}Recreated default config file: {filepath}{RESET}\")\n            except IOError as e_create:\n                print(f\"{NEON_RED}Error recreating default config file after load error: {e_create}{RESET}\")\n        except Exception as e:\n            print(f\"{NEON_RED}Unexpected error loading configuration: {e}. Using defaults.{RESET}\")\n            config_to_use \u003d default_config # Revert to default\n\n    # Ensure numeric types are correct (e.g., convert floats/ints loaded from JSON to Decimal where needed)\n    # This is better handled when accessing the config values, using Decimal(str(config.get(...)))\n    # but we can do a basic pass here if necessary for critical values.\n\n    return config_to_use\n\n# --- State Management ---\ndef load_state(filepath: str, logger: logging.Logger) -\u003e Dict[str, Any]:\n    \"\"\"Loads the bot\u0027s state from a JSON file.\"\"\"\n    if os.path.exists(filepath):\n        try:\n            with open(filepath, \u0027r\u0027, encoding\u003d\u0027utf-8\u0027) as f:\n                state \u003d json.load(f)\n                logger.info(f\"Loaded previous state from {filepath}\")\n                return state\n        except (json.JSONDecodeError, IOError) as e:\n            logger.error(f\"Error loading state file {filepath}: {e}. Starting with empty state.\")\n            return {}\n        except Exception as e:\n            logger.error(f\"Unexpected error loading state: {e}. Starting with empty state.\", exc_info\u003dTrue)\n            return {}\n    else:\n        logger.info(\"No previous state file found. Starting with empty state.\")\n        return {}\n\ndef save_state(filepath: str, state: Dict[str, Any], logger: logging.Logger):\n    \"\"\"Saves the bot\u0027s state to a JSON file.\"\"\"\n    try:\n        # Create a copy to avoid modifying the original during serialization\n        state_to_save \u003d state.copy()\n        with open(filepath, \u0027w\u0027, encoding\u003d\u0027utf-8\u0027) as f:\n            json.dump(state_to_save, f, indent\u003d4)\n        logger.debug(f\"Saved current state to {filepath}\")\n    except (IOError, TypeError) as e:\n        logger.error(f\"Error saving state file {filepath}: {e}\")\n    except Exception as e:\n        logger.error(f\"Unexpected error saving state: {e}\", exc_info\u003dTrue)\n\n# --- CCXT Exchange Setup ---\ndef initialize_exchange(config: Dict[str, Any], logger: logging.Logger) -\u003e Optional[ccxt.Exchange]:\n    \"\"\"Initializes the CCXT Bybit exchange object with V5 settings, error handling, and tests.\"\"\"\n    lg \u003d logger\n    global QUOTE_CURRENCY # Allow updating global quote currency\n\n    try:\n        # Update global quote currency from config\n        QUOTE_CURRENCY \u003d config.get(\"quote_currency\", \"USDT\")\n        lg.info(f\"Using Quote Currency: {QUOTE_CURRENCY}\")\n\n        exchange_options \u003d {\n            \u0027apiKey\u0027: API_KEY,\n            \u0027secret\u0027: API_SECRET,\n            \u0027enableRateLimit\u0027: True, # Let ccxt handle basic rate limiting\n            \u0027rateLimit\u0027: 120, # Bybit V5 has complex limits, set a base ms delay (adjust as needed)\n            \u0027options\u0027: {\n                \u0027defaultType\u0027: \u0027linear\u0027, # Assume linear contracts (USDT margined)\n                \u0027adjustForTimeDifference\u0027: True, # Auto-sync time with server\n                # Connection timeouts (milliseconds) - Use generous timeouts\n                \u0027recvWindow\u0027: 10000,         # Bybit default 5000, increased safety\n                \u0027fetchTickerTimeout\u0027: 15000, # 15 seconds\n                \u0027fetchBalanceTimeout\u0027: 20000, # 20 seconds\n                \u0027createOrderTimeout\u0027: 25000, # 25 seconds\n                \u0027fetchOrderTimeout\u0027: 20000,\n                \u0027fetchPositionsTimeout\u0027: 20000,\n                \u0027cancelOrderTimeout\u0027: 20000,\n                \u0027fetchOHLCVTimeout\u0027: 20000,\n                \u0027setLeverageTimeout\u0027: 20000,\n                \u0027fetchMarketsTimeout\u0027: 30000, # Longer timeout for market loading\n\n                \u0027brokerId\u0027: \u0027EnhancedWhale71\u0027, # Add a broker ID for Bybit tracking\n                # Explicitly request V5 API for relevant endpoints using \u0027versions\u0027\n                \u0027versions\u0027: {\n                    \u0027public\u0027: {\n                        \u0027GET\u0027: {\n                            \u0027market/tickers\u0027: \u0027v5\u0027,\n                            \u0027market/kline\u0027: \u0027v5\u0027,\n                            \u0027market/orderbook\u0027: \u0027v5\u0027,\n                        },\n                    },\n                    \u0027private\u0027: {\n                        \u0027GET\u0027: {\n                            \u0027position/list\u0027: \u0027v5\u0027,\n                            \u0027account/wallet-balance\u0027: \u0027v5\u0027,\n                            \u0027order/realtime\u0027: \u0027v5\u0027, # For fetching open orders\n                            \u0027order/history\u0027: \u0027v5\u0027, # For fetching historical orders\n                        },\n                        \u0027POST\u0027: {\n                            \u0027order/create\u0027: \u0027v5\u0027,\n                            \u0027order/cancel\u0027: \u0027v5\u0027,\n                            \u0027position/set-leverage\u0027: \u0027v5\u0027,\n                            \u0027position/trading-stop\u0027: \u0027v5\u0027, # For SL/TP/TSL\n                        },\n                    },\n                },\n                 # Fallback default options (can help if \u0027versions\u0027 mapping is incomplete in CCXT)\n                 \u0027default_options\u0027: {\n                    \u0027fetchPositions\u0027: \u0027v5\u0027,\n                    \u0027fetchBalance\u0027: \u0027v5\u0027,\n                    \u0027createOrder\u0027: \u0027v5\u0027,\n                    \u0027fetchOrder\u0027: \u0027v5\u0027,\n                    \u0027fetchTicker\u0027: \u0027v5\u0027,\n                    \u0027fetchOHLCV\u0027: \u0027v5\u0027,\n                    \u0027fetchOrderBook\u0027: \u0027v5\u0027,\n                    \u0027setLeverage\u0027: \u0027v5\u0027,\n                    \u0027private_post_v5_position_trading_stop\u0027: \u0027v5\u0027, # More explicit target\n                },\n                # Map standard types to Bybit V5 account types\n                \u0027accountsByType\u0027: {\n                    \u0027spot\u0027: \u0027SPOT\u0027,\n                    \u0027future\u0027: \u0027CONTRACT\u0027, # Covers linear/inverse implicitly via symbol\n                    \u0027swap\u0027: \u0027CONTRACT\u0027,   # Covers linear/inverse implicitly via symbol\n                    \u0027margin\u0027: \u0027UNIFIED\u0027, # Unified handles margin\n                    \u0027option\u0027: \u0027OPTION\u0027,\n                    \u0027unified\u0027: \u0027UNIFIED\u0027,\n                    \u0027contract\u0027: \u0027CONTRACT\u0027,\n                },\n                 # Map Bybit V5 account types back if needed (less common use)\n                \u0027accountsById\u0027: {\n                    \u0027SPOT\u0027: \u0027spot\u0027,\n                    \u0027CONTRACT\u0027: \u0027future\u0027, # Map back to a common type\n                    \u0027UNIFIED\u0027: \u0027unified\u0027,\n                    \u0027OPTION\u0027: \u0027option\u0027,\n                },\n                \u0027bybit\u0027: { # Bybit specific options\n                     \u0027defaultSettleCoin\u0027: QUOTE_CURRENCY,\n                }\n            }\n        }\n\n        exchange_id \u003d \u0027bybit\u0027\n        exchange_class \u003d getattr(ccxt, exchange_id)\n        exchange \u003d exchange_class(exchange_options)\n\n        if config.get(\u0027use_sandbox\u0027, True):\n            lg.warning(f\"{NEON_YELLOW}USING SANDBOX MODE (Testnet){RESET}\")\n            exchange.set_sandbox_mode(True)\n        else:\n            lg.warning(f\"{NEON_RED}--- USING LIVE TRADING MODE (Real Money) ---{RESET}\")\n\n        # --- Test Connection \u0026 Load Markets ---\n        lg.info(f\"Connecting to {exchange.id} (Sandbox: {config.get(\u0027use_sandbox\u0027, True)})...\")\n        lg.info(f\"Loading markets for {exchange.id}... (CCXT Version: {ccxt.__version__})\")\n        try:\n            # Let CCXT handle initial market loading, but ensure it happens\n            exchange.load_markets()\n            exchange.last_load_markets_timestamp \u003d time.time()\n            lg.info(f\"Markets loaded successfully for {exchange.id}. Found {len(exchange.markets)} markets.\")\n        except (ccxt.NetworkError, ccxt.ExchangeError, Exception) as e:\n            lg.error(f\"{NEON_RED}Error loading markets: {e}. Check connection/API settings.{RESET}\", exc_info\u003dTrue)\n            # traceback.print_exc() # Print full traceback for market load errors\n            return None\n\n        # --- Test API Credentials \u0026 Permissions (Fetch Balance) ---\n        lg.info(f\"Attempting initial balance fetch for {QUOTE_CURRENCY}...\")\n        try:\n            balance_decimal \u003d fetch_balance(exchange, QUOTE_CURRENCY, lg) # Uses the robust version\n\n            if balance_decimal is not None:\n                 lg.info(f\"{NEON_GREEN}Successfully connected and fetched initial balance.{RESET} ({QUOTE_CURRENCY} available: {balance_decimal:.4f})\")\n            else:\n                 # fetch_balance already logs errors/warnings\n                 lg.warning(f\"{NEON_YELLOW}Initial balance fetch returned None or failed. Check logs. Ensure API keys have \u0027Read\u0027 permissions and correct account type (CONTRACT/UNIFIED/SPOT) is accessible for {QUOTE_CURRENCY}.{RESET}\")\n                 if config.get(\"enable_trading\"):\n                     lg.error(f\"{NEON_RED}Cannot verify balance. Trading is enabled, aborting initialization for safety.{RESET}\")\n                     return None\n                 else:\n                     lg.warning(\"Continuing in non-trading mode despite balance fetch issue.\")\n\n        except ccxt.AuthenticationError as auth_err:\n            lg.error(f\"{NEON_RED}CCXT Authentication Error during initial balance fetch: {auth_err}{RESET}\")\n            lg.error(f\"{NEON_RED}\u003e\u003e Ensure API keys are correct, have necessary permissions (Read, Trade), match the account type (Real/Testnet), and IP whitelist is correctly set if enabled on Bybit.{RESET}\")\n            return None\n        except Exception as balance_err:\n            lg.warning(f\"{NEON_YELLOW}Warning during initial balance fetch: {balance_err}. Continuing, but check API permissions/account type if trading fails.{RESET}\")\n            # traceback.print_exc()\n            if config.get(\"enable_trading\"):\n                 lg.error(f\"{NEON_RED}Aborting initialization due to balance fetch error in trading mode.{RESET}\")\n                 return None\n\n        return exchange\n\n    except (ccxt.AuthenticationError, ccxt.ExchangeError, ccxt.NetworkError, Exception) as e:\n        lg.error(f\"{NEON_RED}Failed to initialize CCXT exchange: {e}{RESET}\", exc_info\u003dTrue)\n        # traceback.print_exc()\n        return None\n\n# --- CCXT API Call Helper with Retries ---\ndef safe_ccxt_call(\n    exchange: ccxt.Exchange,\n    method_name: str,\n    logger: logging.Logger,\n    max_retries: int \u003d MAX_API_RETRIES,\n    retry_delay: int \u003d RETRY_DELAY_SECONDS,\n    *args, **kwargs\n) -\u003e Any:\n    \"\"\"Safely calls a CCXT method with retry logic for network errors and rate limits.\"\"\"\n    lg \u003d logger\n    last_exception \u003d None\n    for attempt in range(max_retries + 1):\n        try:\n            method \u003d getattr(exchange, method_name)\n            # lg.debug(f\"Calling {method_name} (Attempt {attempt + 1}/{max_retries + 1}) Args: {args}, Kwargs: {kwargs}\")\n            result \u003d method(*args, **kwargs)\n            # lg.debug(f\"{method_name} call successful.\")\n            return result\n        except ccxt.RateLimitExceeded as e:\n            last_exception \u003d e\n            wait_time \u003d retry_delay * (2 ** attempt) # Default exponential backoff\n            suggested_wait \u003d None\n            try: # Try parsing suggested wait time from Bybit error message\n                import re\n                # Example Bybit msg: \"Rate limit exceeded, please try again in 153 ms.\" or \"Too many visits!\"\n                error_msg \u003d str(e).lower()\n                match_ms \u003d re.search(r\u0027(?:try again in|retry after)\\s*(\\d+)\\s*ms\u0027, error_msg)\n                match_s \u003d re.search(r\u0027(?:try again in|retry after)\\s*(\\d+)\\s*s\u0027, error_msg)\n                if match_ms: suggested_wait \u003d max(1, math.ceil(int(match_ms.group(1)) / 1000) + RATE_LIMIT_BUFFER_SECONDS)\n                elif match_s: suggested_wait \u003d max(1, int(match_s.group(1)) + RATE_LIMIT_BUFFER_SECONDS)\n                elif \"too many visits\" in error_msg or \"limit\" in error_msg :\n                    # Generic rate limit message, use exponential backoff but maybe slightly longer\n                    suggested_wait \u003d wait_time + 1.0\n            except Exception: pass # Ignore parsing errors, use default backoff\n\n            final_wait \u003d suggested_wait if suggested_wait is not None else wait_time\n            lg.warning(f\"Rate limit hit calling {method_name}. Retrying in {final_wait:.2f}s... (Attempt {attempt + 1}) Error: {e}\")\n            time.sleep(final_wait)\n        except (ccxt.NetworkError, ccxt.RequestTimeout, ccxt.DDoSProtection) as e:\n            last_exception \u003d e\n            wait_time \u003d retry_delay * (2 ** attempt) # Exponential backoff\n            lg.warning(f\"Network/DDoS/Timeout error calling {method_name}: {e}. Retrying in {wait_time}s... (Attempt {attempt + 1})\")\n            time.sleep(wait_time)\n        except ccxt.AuthenticationError as e:\n            lg.error(f\"{NEON_RED}Authentication Error calling {method_name}: {e}. Check API keys/permissions. Not retrying.{RESET}\")\n            raise e # Re-raise critical auth errors\n        except ccxt.ExchangeError as e:\n            # Check for specific non-retryable exchange errors\n            # Bybit V5 Error Codes: https://bybit-exchange.github.io/docs/v5/error_code\n            bybit_code \u003d getattr(e, \u0027code\u0027, None) # CCXT sometimes puts code here\n            if bybit_code is None and hasattr(e, \u0027args\u0027) and len(e.args) \u003e 0:\n                 # Sometimes the code is in the message, e.g., \"bybit {\"retCode\":110007,...}\"\n                 try:\n                     error_details \u003d str(e.args[0])\n                     if \"retCode\" in error_details:\n                         # Basic parsing, might need refinement\n                         details_dict \u003d json.loads(error_details[error_details.find(\u0027{\u0027):error_details.rfind(\u0027}\u0027)+1])\n                         bybit_code \u003d details_dict.get(\u0027retCode\u0027)\n                 except Exception: pass # Ignore parsing errors\n\n            # List of potentially non-retryable Bybit errors (add more as needed)\n            # 110007: Insufficient margin / balance\n            # 110013: Leverage exceeds risk limit tier\n            # 110017: Order qty exceeds max limit\n            # 110020: Position size would exceed risk limit\n            # 110025: Invalid order price (too far from mark price, etc.)\n            # 110043: Set leverage failed (same leverage, etc) - Can sometimes be ignored?\n            # 110045: Position status is not normal (e.g., during liquidation)\n            # 170007: Invalid symbol / instrument not found\n            # 170131: Quantity too low / less than min order qty\n            # 170132: Price precision invalid\n            # 170133: Qty precision invalid\n            # 170140: Order cost too low / less than min order value\n            non_retryable_codes \u003d [110007, 110013, 110017, 110020, 110025, 110045, 170007, 170131, 170132, 170133, 170140]\n\n            if bybit_code in non_retryable_codes:\n                lg.error(f\"{NEON_RED}Non-retryable Exchange Error calling {method_name}: {e} (Code: {bybit_code}). Not retrying.{RESET}\")\n                raise e # Re-raise immediately\n            else:\n                 lg.warning(f\"{NEON_YELLOW}Retryable Exchange Error calling {method_name}: {e} (Code: {bybit_code}). Retrying... (Attempt {attempt + 1}){RESET}\")\n                 last_exception \u003d e\n                 wait_time \u003d retry_delay * (2 ** attempt)\n                 time.sleep(wait_time) # Wait and retry for other exchange errors\n        except Exception as e:\n            lg.error(f\"{NEON_RED}Unexpected Error calling {method_name}: {e}. Not retrying.{RESET}\", exc_info\u003dTrue)\n            # traceback.print_exc()\n            raise e # Re-raise unexpected errors\n\n    lg.error(f\"{NEON_RED}Max retries ({max_retries}) reached for {method_name}. Last error: {last_exception}{RESET}\")\n    raise last_exception # Re-raise the last exception after exhausting retries\n\n# --- Market Info Helper Functions ---\ndef _determine_category(market_info: Dict, logger: logging.Logger) -\u003e Optional[str]:\n    \"\"\"Helper to determine Bybit V5 category from market info.\"\"\"\n    if not market_info: return None\n    market_type \u003d market_info.get(\u0027type\u0027) # spot, swap, future, option\n    is_linear \u003d market_info.get(\u0027linear\u0027, False)\n    is_inverse \u003d market_info.get(\u0027inverse\u0027, False)\n    is_contract \u003d market_info.get(\u0027contract\u0027, False)\n    is_spot \u003d market_info.get(\u0027spot\u0027, False)\n    is_option \u003d market_info.get(\u0027option\u0027, False)\n    symbol \u003d market_info.get(\u0027symbol\u0027, \u0027N/A\u0027)\n\n    # Prioritize standard CCXT types\n    if market_type \u003d\u003d \u0027spot\u0027: return \u0027spot\u0027\n    if market_type \u003d\u003d \u0027option\u0027: return \u0027option\u0027\n    # For futures/swaps, determine linear/inverse\n    if market_type \u003d\u003d \u0027swap\u0027 or market_type \u003d\u003d \u0027future\u0027 or is_contract:\n        if is_linear: return \u0027linear\u0027\n        if is_inverse: return \u0027inverse\u0027\n        # Fallback guess for contracts based on settle currency if flags missing\n        settle \u003d market_info.get(\u0027settle\u0027, \u0027\u0027).upper()\n        quote \u003d market_info.get(\u0027quote\u0027, \u0027\u0027).upper()\n        if settle \u003d\u003d \u0027USDT\u0027 or settle \u003d\u003d \u0027USDC\u0027 or settle \u003d\u003d quote:\n            # logger.debug(f\"Assuming \u0027linear\u0027 for {symbol} based on settle/quote ({settle}/{quote}).\")\n            return \u0027linear\u0027\n        elif settle \u003d\u003d market_info.get(\u0027base\u0027, \u0027\u0027).upper():\n            # logger.debug(f\"Assuming \u0027inverse\u0027 for {symbol} based on settle/base ({settle}).\")\n            return \u0027inverse\u0027\n        else:\n            logger.warning(f\"Could not determine linear/inverse for contract {symbol} (Settle: {settle}). Defaulting to linear.\")\n            return \u0027linear\u0027 # Default guess\n\n    # Fallback based on flags if type is missing/unknown\n    elif is_linear: return \u0027linear\u0027\n    elif is_inverse: return \u0027inverse\u0027\n    elif is_spot: return \u0027spot\u0027\n    elif is_option: return \u0027option\u0027\n    else:\n        logger.warning(f\"Could not determine category for market {symbol}. Market Type: {market_type}, Flags: L\u003d{is_linear},I\u003d{is_inverse},C\u003d{is_contract},S\u003d{is_spot},O\u003d{is_option}. Defaulting to None.\")\n        return None # Cannot determine\n\ndef get_market_info(exchange: ccxt.Exchange, symbol: str, logger: logging.Logger) -\u003e Optional[Dict]:\n    \"\"\"Fetches and returns enhanced market information for a symbol, handling reloads.\"\"\"\n    lg \u003d logger\n    try:\n        # Check if reload is needed\n        reload_needed \u003d False\n        now \u003d time.time()\n        last_load_time \u003d getattr(exchange, \u0027last_load_markets_timestamp\u0027, 0)\n\n        if now - last_load_time \u003e MARKET_RELOAD_INTERVAL_SECONDS:\n            reload_needed \u003d True\n            lg.info(f\"Market info older than {MARKET_RELOAD_INTERVAL_SECONDS}s ({now - last_load_time:.0f}s). Reloading...\")\n        elif symbol not in exchange.markets:\n             reload_needed \u003d True\n             lg.warning(f\"Symbol {symbol} not found in cached markets. Reloading...\")\n\n        if reload_needed:\n            try:\n                lg.info(\"Attempting to reload markets...\")\n                # Use safe call for loading markets\n                markets \u003d safe_ccxt_call(exchange, \u0027load_markets\u0027, lg, reload\u003dTrue)\n                if markets:\n                    exchange.last_load_markets_timestamp \u003d time.time()\n                    lg.info(f\"Markets reloaded successfully. Found {len(markets)} markets.\")\n                else:\n                    lg.error(f\"{NEON_RED}Market reload call returned None/empty. Check API/connection.{RESET}\")\n                    # Attempt to use potentially stale data if available\n                    if symbol not in exchange.markets:\n                         return None # Cannot proceed without market info\n            except Exception as load_err:\n                 lg.error(f\"{NEON_RED}Failed to reload markets: {load_err}{RESET}\")\n                 # traceback.print_exc()\n                 if symbol not in exchange.markets:\n                     return None\n\n        # Get market data using ccxt\u0027s safe method\n        market \u003d exchange.market(symbol)\n        if not market:\n             lg.error(f\"{NEON_RED}Market data for {symbol} could not be retrieved even after load attempt.{RESET}\")\n             # Maybe the symbol format is wrong (e.g., missing :SETTLE)?\n             if \u0027:\u0027 not in symbol and QUOTE_CURRENCY:\n                 test_symbol \u003d f\"{symbol}:{QUOTE_CURRENCY}\"\n                 lg.warning(f\"Attempting fetch with settlement currency: {test_symbol}\")\n                 market \u003d exchange.market(test_symbol)\n                 if market:\n                      lg.info(f\"Successfully found market using {test_symbol}\")\n                      symbol \u003d test_symbol # Update symbol if found this way\n                 else:\n                      lg.error(f\"Still failed to find market for {symbol} or {test_symbol}\")\n                      return None\n             else:\n                 return None\n\n        # --- Enhance market dict with standardized/derived info ---\n        # Use a copy to avoid modifying the global exchange.markets dict directly\n        enhanced_market \u003d market.copy()\n\n        enhanced_market[\u0027category\u0027] \u003d _determine_category(enhanced_market, lg)\n        enhanced_market[\u0027min_tick_size\u0027] \u003d get_min_tick_size_from_market(enhanced_market, lg)\n        enhanced_market[\u0027price_precision_digits\u0027] \u003d get_price_precision_digits_from_market(enhanced_market, lg)\n        enhanced_market[\u0027amount_precision_digits\u0027] \u003d get_amount_precision_digits_from_market(enhanced_market, lg)\n        enhanced_market[\u0027min_order_amount\u0027] \u003d get_min_order_amount_from_market(enhanced_market, lg)\n        enhanced_market[\u0027min_order_cost\u0027] \u003d get_min_order_cost_from_market(enhanced_market, lg)\n        enhanced_market[\u0027contract_size\u0027] \u003d get_contract_size_from_market(enhanced_market, lg)\n        enhanced_market[\u0027is_contract\u0027] \u003d enhanced_market.get(\u0027contract\u0027, False) or enhanced_market.get(\u0027type\u0027) in [\u0027swap\u0027, \u0027future\u0027]\n\n        # Log key derived values if debugging\n        # lg.debug(f\"Enhanced Market Info ({symbol}): Category\u003d{enhanced_market[\u0027category\u0027]}, Tick\u003d{enhanced_market[\u0027min_tick_size\u0027]}, \"\n        #          f\"PricePrec\u003d{enhanced_market[\u0027price_precision_digits\u0027]}, AmtPrec\u003d{enhanced_market[\u0027amount_precision_digits\u0027]}, \"\n        #          f\"MinAmt\u003d{enhanced_market[\u0027min_order_amount\u0027]}, MinCost\u003d{enhanced_market[\u0027min_order_cost\u0027]}, \"\n        #          f\"ContractSize\u003d{enhanced_market[\u0027contract_size\u0027]}, IsContract\u003d{enhanced_market[\u0027is_contract\u0027]}\")\n\n        return enhanced_market\n\n    except ccxt.BadSymbol as e:\n        lg.error(f\"{NEON_RED}Symbol Error: {e}. Is \u0027{symbol}\u0027 correctly formatted and supported by {exchange.id}?{RESET}\")\n    except (ccxt.NetworkError, ccxt.ExchangeError) as e:\n        lg.error(f\"{NEON_RED}API error fetching/processing market info for {symbol}: {e}{RESET}\")\n    except Exception as e:\n        lg.error(f\"{NEON_RED}Unexpected error fetching market info for {symbol}: {e}{RESET}\", exc_info\u003dTrue)\n        # traceback.print_exc()\n    return None\n\ndef get_min_tick_size_from_market(market: Dict, logger: logging.Logger) -\u003e Optional[Decimal]:\n    \"\"\"Extracts minimum price increment (tick size) from CCXT market structure as Decimal.\"\"\"\n    symbol \u003d market.get(\u0027symbol\u0027, \u0027N/A\u0027)\n    tick_size \u003d None\n    try:\n        # 1. Standard CCXT precision structure\n        precision_price \u003d market.get(\u0027precision\u0027, {}).get(\u0027price\u0027)\n        if precision_price is not None:\n            tick_size \u003d Decimal(str(precision_price))\n            # logger.debug(f\"Tick size from precision.price for {symbol}: {tick_size}\")\n            if tick_size \u003e 0: return tick_size\n\n        # 2. Bybit V5 info structure (more reliable)\n        info \u003d market.get(\u0027info\u0027, {})\n        tick_size_str \u003d info.get(\u0027priceFilter\u0027, {}).get(\u0027tickSize\u0027)\n        if tick_size_str is not None:\n            tick_size \u003d Decimal(str(tick_size_str))\n            # logger.debug(f\"Tick size from info.priceFilter.tickSize for {symbol}: {tick_size}\")\n            if tick_size \u003e 0: return tick_size\n\n        # 3. Fallback: Infer from price precision digits (less accurate)\n        digits \u003d get_price_precision_digits_from_market(market, logger) # Call helper, handles its own fallbacks\n        if digits is not None:\n            inferred_tick \u003d Decimal(\u00271\u0027) / (Decimal(\u002710\u0027) ** digits)\n            # logger.debug(f\"Tick size inferred from price digits ({digits}) for {symbol}: {inferred_tick}\")\n            return inferred_tick\n\n        logger.warning(f\"Could not determine price tick size for {symbol}. Checked precision.price, info.priceFilter.tickSize, inferred from digits.\")\n        return None\n    except (InvalidOperation, ValueError, TypeError, KeyError) as e:\n        logger.error(f\"Error determining min tick size for {symbol}: {e}\")\n        return None\n\ndef get_price_precision_digits_from_market(market: Dict, logger: logging.Logger) -\u003e Optional[int]:\n    \"\"\"Extracts number of decimal places for price from CCXT market structure.\"\"\"\n    symbol \u003d market.get(\u0027symbol\u0027, \u0027N/A\u0027)\n    digits \u003d None\n    try:\n        # 1. Standard CCXT precision.price (if it represents digits directly)\n        precision_price \u003d market.get(\u0027precision\u0027, {}).get(\u0027price\u0027)\n        if precision_price is not None:\n            try:\n                price_prec_dec \u003d Decimal(str(precision_price))\n                # If it looks like integer digits (\u003e\u003d 0)\n                if price_prec_dec \u003e\u003d 0 and price_prec_dec \u003d\u003d price_prec_dec.to_integral_value():\n                    digits \u003d int(price_prec_dec)\n                    # logger.debug(f\"Price digits from precision.price for {symbol}: {digits}\")\n                    if digits is not None: return digits\n            except (InvalidOperation, ValueError, TypeError):\n                 pass # If conversion fails or it\u0027s not integer-like, proceed\n\n        # 2. Infer from tick size (most reliable if tick size is found)\n        min_tick \u003d get_min_tick_size_from_market(market, logger) # Use helper, handles its own logic\n        if min_tick is not None and min_tick \u003e 0:\n            # Use Decimal\u0027s exponent after normalization\n            digits \u003d abs(min_tick.normalize().as_tuple().exponent)\n            # logger.debug(f\"Price digits inferred from tick size ({min_tick}) for {symbol}: {digits}\")\n            if digits is not None: return digits\n\n        # 3. Fallback: Bybit \u0027priceScale\u0027 (often represents digits)\n        info \u003d market.get(\u0027info\u0027, {})\n        price_scale_str \u003d info.get(\u0027priceScale\u0027)\n        if price_scale_str is not None:\n            try:\n                 digits \u003d int(price_scale_str)\n                 # logger.debug(f\"Price digits from info.priceScale for {symbol}: {digits}\")\n                 if digits is not None and digits \u003e\u003d0: return digits\n            except (ValueError, TypeError): pass\n\n\n        logger.warning(f\"Could not determine price precision digits for {symbol}. Checked precision.price, inferred from tick, info.priceScale. Defaulting to 8.\")\n        return 8 # Fallback default\n    except Exception as e:\n        logger.error(f\"Error determining price precision digits for {symbol}: {e}\")\n        return 8 # Fallback default\n\ndef get_amount_precision_digits_from_market(market: Dict, logger: logging.Logger) -\u003e Optional[int]:\n    \"\"\"Extracts number of decimal places for amount/quantity from CCXT market structure.\"\"\"\n    symbol \u003d market.get(\u0027symbol\u0027, \u0027N/A\u0027)\n    digits \u003d None\n    try:\n        # 1. Infer from amount step size (most reliable: lotSizeFilter.qtyStep)\n        info \u003d market.get(\u0027info\u0027, {})\n        step_size_str \u003d info.get(\u0027lotSizeFilter\u0027, {}).get(\u0027qtyStep\u0027)\n        if step_size_str is not None:\n            try:\n                step_size \u003d Decimal(str(step_size_str))\n                if step_size \u003e 0:\n                    if step_size \u003d\u003d 1: digits \u003d 0 # Handle step size of 1\n                    else: digits \u003d abs(step_size.normalize().as_tuple().exponent)\n                    # logger.debug(f\"Amount digits from info.lotSizeFilter.qtyStep ({step_size}) for {symbol}: {digits}\")\n                    if digits is not None: return digits\n            except (InvalidOperation, ValueError, TypeError): pass\n\n        # 2. Standard CCXT precision.amount (often digits, sometimes step size)\n        precision_amount \u003d market.get(\u0027precision\u0027, {}).get(\u0027amount\u0027)\n        if precision_amount is not None:\n            try:\n                amount_prec_dec \u003d Decimal(str(precision_amount))\n                if amount_prec_dec \u003e 0 and amount_prec_dec \u003c\u003d 1: # Looks like step size\n                     if amount_prec_dec \u003d\u003d 1: digits \u003d 0\n                     else: digits \u003d abs(amount_prec_dec.normalize().as_tuple().exponent)\n                     # logger.debug(f\"Amount digits inferred from precision.amount step ({amount_prec_dec}) for {symbol}: {digits}\")\n                elif amount_prec_dec \u003e\u003d 0 and amount_prec_dec \u003d\u003d amount_prec_dec.to_integral_value(): # Looks like digits\n                     digits \u003d int(amount_prec_dec)\n                     # logger.debug(f\"Amount digits directly from precision.amount ({digits}) for {symbol}: {digits}\")\n\n                if digits is not None: return digits\n            except (InvalidOperation, ValueError, TypeError): pass\n\n        # 3. Fallback: Infer from min order quantity (if step size missing)\n        min_qty \u003d get_min_order_amount_from_market(market, logger) # Uses helper\n        if min_qty is not None and min_qty \u003e 0:\n             if min_qty \u003d\u003d 1: digits \u003d 0\n             else: digits \u003d abs(min_qty.normalize().as_tuple().exponent)\n             # logger.debug(f\"Amount digits inferred from min qty ({min_qty}) for {symbol}: {digits}\")\n             if digits is not None: return digits\n\n        logger.warning(f\"Could not determine amount precision digits for {symbol}. Checked qtyStep, precision.amount, inferred from minQty. Defaulting to 8.\")\n        return 8 # Fallback default\n    except Exception as e:\n        logger.error(f\"Error determining amount precision digits for {symbol}: {e}\")\n        return 8 # Fallback default\n\ndef get_min_order_amount_from_market(market: Dict, logger: logging.Logger) -\u003e Optional[Decimal]:\n    \"\"\"Extracts minimum order amount/quantity from CCXT market structure as Decimal.\"\"\"\n    symbol \u003d market.get(\u0027symbol\u0027, \u0027N/A\u0027)\n    min_amount \u003d None\n    try:\n        # 1. Bybit V5 info structure (most reliable)\n        info \u003d market.get(\u0027info\u0027, {})\n        min_amount_str \u003d info.get(\u0027lotSizeFilter\u0027, {}).get(\u0027minOrderQty\u0027)\n        if min_amount_str is not None:\n            min_amount \u003d Decimal(str(min_amount_str))\n            # logger.debug(f\"Min amount from info.lotSizeFilter.minOrderQty for {symbol}: {min_amount}\")\n            if min_amount \u003e 0: return min_amount\n\n        # 2. Standard CCXT limits structure\n        limits_amount \u003d market.get(\u0027limits\u0027, {}).get(\u0027amount\u0027, {})\n        min_amount_lim \u003d limits_amount.get(\u0027min\u0027)\n        if min_amount_lim is not None:\n            min_amount \u003d Decimal(str(min_amount_lim))\n            # logger.debug(f\"Min amount from limits.amount.min for {symbol}: {min_amount}\")\n            if min_amount \u003e 0: return min_amount\n\n        logger.warning(f\"Could not find minimum order amount for {symbol}. Checked info.lotSizeFilter.minOrderQty, limits.amount.min.\")\n        return None\n    except (InvalidOperation, ValueError, TypeError, KeyError) as e:\n        logger.error(f\"Error determining min order amount for {symbol}: {e}\")\n        return None\n\ndef get_min_order_cost_from_market(market: Dict, logger: logging.Logger) -\u003e Optional[Decimal]:\n    \"\"\"Extracts minimum order cost (value) from CCXT market structure as Decimal.\"\"\"\n    symbol \u003d market.get(\u0027symbol\u0027, \u0027N/A\u0027)\n    min_cost \u003d None\n    try:\n        # 1. Bybit V5 info structure (Spot often has minOrderAmt)\n        info \u003d market.get(\u0027info\u0027, {})\n        min_cost_str \u003d info.get(\u0027lotSizeFilter\u0027, {}).get(\u0027minOrderAmt\u0027) # Note: Often for Spot only\n        if min_cost_str is not None:\n            min_cost \u003d Decimal(str(min_cost_str))\n            # logger.debug(f\"Min cost from info.lotSizeFilter.minOrderAmt for {symbol}: {min_cost}\")\n            if min_cost \u003e 0: return min_cost\n\n        # 2. Standard CCXT limits structure\n        limits_cost \u003d market.get(\u0027limits\u0027, {}).get(\u0027cost\u0027, {})\n        min_cost_lim \u003d limits_cost.get(\u0027min\u0027)\n        if min_cost_lim is not None:\n            min_cost \u003d Decimal(str(min_cost_lim))\n            # logger.debug(f\"Min cost from limits.cost.min for {symbol}: {min_cost}\")\n            if min_cost \u003e 0: return min_cost\n\n        # logger.debug(f\"Minimum order cost not explicitly specified for {symbol}. Checked info.lotSizeFilter.minOrderAmt, limits.cost.min. May need calculation.\")\n        return None # Indicate not directly available\n    except (InvalidOperation, ValueError, TypeError, KeyError) as e:\n        logger.error(f\"Error determining min order cost for {symbol}: {e}\")\n        return None\n\ndef get_contract_size_from_market(market: Dict, logger: logging.Logger) -\u003e Decimal:\n    \"\"\"Extracts contract size from market info as Decimal, defaulting to 1.\"\"\"\n    symbol \u003d market.get(\u0027symbol\u0027, \u0027N/A\u0027)\n    contract_size \u003d Decimal(\u00271\u0027) # Default\n    try:\n        # 1. Standard CCXT field\n        cs_raw_ccxt \u003d market.get(\u0027contractSize\u0027)\n        if cs_raw_ccxt is not None:\n            cs_dec \u003d Decimal(str(cs_raw_ccxt))\n            if cs_dec \u003e 0:\n                # logger.debug(f\"Contract size from market.contractSize for {symbol}: {cs_dec}\")\n                contract_size \u003d cs_dec; return contract_size # Return immediately if found valid\n\n        # 2. Bybit specific field in \u0027info\u0027\n        cs_raw_info \u003d market.get(\u0027info\u0027, {}).get(\u0027contractSize\u0027)\n        if cs_raw_info is not None:\n            cs_dec \u003d Decimal(str(cs_raw_info))\n            if cs_dec \u003e 0:\n                # logger.debug(f\"Contract size from info.contractSize for {symbol}: {cs_dec}\")\n                contract_size \u003d cs_dec; return contract_size # Return immediately\n\n        # If neither field yields a positive value, the default \u00271\u0027 remains\n        # logger.debug(f\"Contract size not specified or invalid for {symbol}. Defaulting to {contract_size}.\")\n\n    except (InvalidOperation, ValueError, TypeError, KeyError) as e:\n        logger.error(f\"Error determining contract size for {symbol}: {e}. Defaulting to 1.\")\n        contract_size \u003d Decimal(\u00271\u0027) # Ensure default on error\n\n    return contract_size\n\n# --- Data Fetching Wrappers ---\ndef fetch_current_price_ccxt(exchange: ccxt.Exchange, symbol: str, logger: logging.Logger, market_info: Dict) -\u003e Optional[Decimal]:\n    \"\"\"Fetch current price using safe_ccxt_call and market info.\"\"\"\n    lg \u003d logger\n    try:\n        params \u003d {}\n        category \u003d market_info.get(\u0027category\u0027)\n        if category and exchange.id \u003d\u003d \u0027bybit\u0027: # Only add category for Bybit\n            params[\u0027category\u0027] \u003d category\n            # lg.debug(f\"Using params for fetch_ticker ({symbol}): {params}\")\n\n        ticker \u003d safe_ccxt_call(exchange, \u0027fetch_ticker\u0027, lg, symbol\u003dsymbol, params\u003dparams)\n        if not ticker:\n            lg.warning(f\"fetch_ticker returned None for {symbol}.\")\n            return None\n\n        # Helper to safely convert to Decimal and check positivity\n        def safe_decimal(key: str) -\u003e Optional[Decimal]:\n            value \u003d ticker.get(key)\n            if value is None: return None\n            try:\n                d_val \u003d Decimal(str(value))\n                return d_val if d_val \u003e 0 else None\n            except (InvalidOperation, ValueError, TypeError):\n                # lg.warning(f\"Invalid numeric value for \u0027{key}\u0027 in ticker: {value}\")\n                return None\n\n        # Prioritize: last \u003e mark (if available) \u003e midpoint(bid/ask) \u003e ask \u003e bid\n        price \u003d safe_decimal(\u0027last\u0027)\n        if price: lg.debug(f\"Using \u0027last\u0027 price: {price}\"); return price\n\n        mark \u003d safe_decimal(\u0027mark\u0027) # Bybit often provides mark price for derivatives\n        if mark: lg.debug(f\"Using \u0027mark\u0027 price: {mark}\"); return mark\n\n        bid \u003d safe_decimal(\u0027bid\u0027)\n        ask \u003d safe_decimal(\u0027ask\u0027)\n        if bid and ask and bid \u003c ask: # Ensure bid \u003c ask\n            price \u003d (bid + ask) / Decimal(\u00272\u0027)\n            lg.debug(f\"Using bid/ask midpoint: {price} (Bid: {bid}, Ask: {ask})\")\n            return price\n\n        # Use ask/bid as last resort if only one is valid\n        if ask: lg.warning(f\"Using \u0027ask\u0027 price as fallback: {ask}\"); return ask\n        if bid: lg.warning(f\"Using \u0027bid\u0027 price as last resort: {bid}\"); return bid\n\n        lg.error(f\"{NEON_RED}Failed to extract a valid positive price from ticker for {symbol}. Ticker: {ticker}{RESET}\")\n        return None\n\n    except Exception as e:\n        lg.error(f\"{NEON_RED}Error in fetch_current_price_ccxt for {symbol}: {e}{RESET}\", exc_info\u003dTrue)\n        # traceback.print_exc()\n        return None\n\ndef fetch_klines_ccxt(exchange: ccxt.Exchange, symbol: str, timeframe: str, limit: int, logger: logging.Logger, market_info: Dict) -\u003e pd.DataFrame:\n    \"\"\"Fetch OHLCV klines using safe_ccxt_call and market info, returns processed DataFrame.\"\"\"\n    lg \u003d logger\n    ccxt_timeframe \u003d CCXT_INTERVAL_MAP.get(timeframe)\n    if not ccxt_timeframe:\n        lg.error(f\"Invalid timeframe \u0027{timeframe}\u0027 provided for {symbol}. Valid: {list(CCXT_INTERVAL_MAP.keys())}\")\n        return pd.DataFrame()\n\n    try:\n        params \u003d {}\n        category \u003d market_info.get(\u0027category\u0027)\n        # Kline endpoint often requires category for Bybit V5\n        if category and exchange.id \u003d\u003d \u0027bybit\u0027:\n            params[\u0027category\u0027] \u003d category\n            # lg.debug(f\"Using params for fetch_ohlcv ({symbol}): {params}\")\n\n        # Use safe_ccxt_call for the API request\n        ohlcv \u003d safe_ccxt_call(exchange, \u0027fetch_ohlcv\u0027, lg, symbol\u003dsymbol, timeframe\u003dccxt_timeframe, limit\u003dlimit, params\u003dparams)\n\n        if ohlcv is None or len(ohlcv) \u003d\u003d 0:\n            lg.warning(f\"{NEON_YELLOW}No kline data returned for {symbol} {timeframe} after retries.{RESET}\")\n            return pd.DataFrame()\n\n        # --- Data Processing ---\n        df \u003d pd.DataFrame(ohlcv, columns\u003d[\u0027timestamp\u0027, \u0027open\u0027, \u0027high\u0027, \u0027low\u0027, \u0027close\u0027, \u0027volume\u0027])\n        if df.empty:\n            lg.warning(f\"{NEON_YELLOW}Kline DataFrame empty for {symbol} {timeframe} after creation.{RESET}\")\n            return df\n\n        # Convert timestamp to datetime, set as index (UTC by default from CCXT)\n        df[\u0027timestamp\u0027] \u003d pd.to_datetime(df[\u0027timestamp\u0027], unit\u003d\u0027ms\u0027, utc\u003dTrue, errors\u003d\u0027coerce\u0027)\n        df.dropna(subset\u003d[\u0027timestamp\u0027], inplace\u003dTrue)\n        if df.empty:\n            lg.warning(f\"{NEON_YELLOW}Kline DataFrame empty after timestamp conversion for {symbol}.{RESET}\")\n            return df\n        df.set_index(\u0027timestamp\u0027, inplace\u003dTrue)\n\n        # Convert OHLCV columns to numeric (Decimal for precision)\n        for col in [\u0027open\u0027, \u0027high\u0027, \u0027low\u0027, \u0027close\u0027, \u0027volume\u0027]:\n            # df[col] \u003d pd.to_numeric(df[col], errors\u003d\u0027coerce\u0027)\n            # Convert directly to Decimal for consistency\n            df[col] \u003d df[col].apply(lambda x: Decimal(str(x)) if pd.notna(x) else Decimal(\u0027NaN\u0027))\n\n\n        initial_len \u003d len(df)\n        # Drop rows with NaN in critical OHLC columns or non-positive close\n        df.dropna(subset\u003d[\u0027open\u0027, \u0027high\u0027, \u0027low\u0027, \u0027close\u0027], inplace\u003dTrue)\n        df \u003d df[df[\u0027close\u0027] \u003e Decimal(\u00270\u0027)]\n        # Optional: Fill NaN volume with 0 if needed by indicators (MFI might need volume)\n        df[\u0027volume\u0027] \u003d df[\u0027volume\u0027].apply(lambda x: x if x.is_finite() else Decimal(\u00270\u0027))\n\n\n        rows_dropped \u003d initial_len - len(df)\n        if rows_dropped \u003e 0:\n            lg.debug(f\"Dropped {rows_dropped} rows with NaN/invalid OHLC data for {symbol}.\")\n\n        if df.empty:\n            lg.warning(f\"{NEON_YELLOW}Kline data empty after cleaning for {symbol}.{RESET}\")\n            return pd.DataFrame()\n\n        df.sort_index(inplace\u003dTrue) # Ensure chronological order\n        lg.info(f\"Successfully fetched and processed {len(df)} klines for {symbol} {timeframe} (Limit: {limit})\")\n        return df\n\n    except Exception as e:\n        lg.error(f\"{NEON_RED}Error in fetch_klines_ccxt for {symbol} {timeframe}: {e}{RESET}\", exc_info\u003dTrue)\n        # traceback.print_exc()\n        return pd.DataFrame()\n\ndef fetch_orderbook_ccxt(exchange: ccxt.Exchange, symbol: str, limit: int, logger: logging.Logger, market_info: Dict) -\u003e Optional[Dict]:\n    \"\"\"Fetch orderbook using safe_ccxt_call and market info.\"\"\"\n    lg \u003d logger\n    try:\n        params \u003d {}\n        category \u003d market_info.get(\u0027category\u0027)\n        # Orderbook endpoint often requires category for Bybit V5\n        if category and exchange.id \u003d\u003d \u0027bybit\u0027:\n            params[\u0027category\u0027] \u003d category\n            # lg.debug(f\"Using params for fetch_order_book ({symbol}): {params}\")\n\n        # Use safe_ccxt_call for the API request\n        orderbook \u003d safe_ccxt_call(exchange, \u0027fetch_order_book\u0027, lg, symbol\u003dsymbol, limit\u003dlimit, params\u003dparams)\n\n        # Basic validation\n        if not orderbook:\n            lg.warning(f\"fetch_order_book returned None/empty for {symbol}.\")\n            return None\n        if not isinstance(orderbook.get(\u0027bids\u0027), list) or not isinstance(orderbook.get(\u0027asks\u0027), list):\n            lg.warning(f\"{NEON_YELLOW}Invalid orderbook structure for {symbol}. Missing bids/asks lists. Response: {orderbook}{RESET}\")\n            return None\n        if not orderbook[\u0027bids\u0027] and not orderbook[\u0027asks\u0027]:\n             lg.warning(f\"{NEON_YELLOW}Orderbook received but bids/asks lists are empty for {symbol}.{RESET}\")\n             # Return empty book, might be valid state\n\n        # lg.debug(f\"Successfully fetched orderbook for {symbol} with {len(orderbook[\u0027bids\u0027])} bids, {len(orderbook[\u0027asks\u0027])} asks.\")\n        return orderbook\n\n    except Exception as e:\n        lg.error(f\"{NEON_RED}Error in fetch_orderbook_ccxt for {symbol}: {e}{RESET}\", exc_info\u003dTrue)\n        # traceback.print_exc()\n        return None\n\ndef fetch_balance(exchange: ccxt.Exchange, currency: str, logger: logging.Logger) -\u003e Optional[Decimal]:\n    \"\"\"Fetches available balance for a currency, handling Bybit V5 structures/retries.\"\"\"\n    lg \u003d logger\n    last_exception \u003d None\n    # Relevant account types for Bybit V5 (CONTRACT covers swap/future, UNIFIED for UTA)\n    account_types_to_try \u003d [\u0027CONTRACT\u0027, \u0027UNIFIED\u0027, \u0027SPOT\u0027]\n\n    for attempt in range(MAX_API_RETRIES + 1):\n        balance_info \u003d None\n        successful_acc_type \u003d None\n\n        # Try fetching for specific account types\n        for acc_type in account_types_to_try:\n            try:\n                params \u003d {}\n                # Bybit V5 fetch_balance often needs accountType and optionally coin\n                if exchange.id \u003d\u003d \u0027bybit\u0027:\n                    params[\u0027accountType\u0027] \u003d acc_type\n                    params[\u0027coin\u0027] \u003d currency # Specify the coin to get detailed balance\n\n                lg.debug(f\"Fetching balance using params\u003d{params} for {currency} (Attempt {attempt + 1}, Type: {acc_type})\")\n\n                # Use safe_ccxt_call - disable inner retries to let outer loop control retries across types\n                balance_info \u003d safe_ccxt_call(exchange, \u0027fetch_balance\u0027, lg, max_retries\u003d0, params\u003dparams)\n\n                # Check if the response seems valid for this account type/currency\n                # Need to parse the specific structure returned by Bybit V5\n                if balance_info and \u0027info\u0027 in balance_info and balance_info[\u0027info\u0027].get(\u0027retCode\u0027) \u003d\u003d 0:\n                    # Check within info -\u003e result -\u003e list\n                    if \u0027result\u0027 in balance_info[\u0027info\u0027] and \u0027list\u0027 in balance_info[\u0027info\u0027][\u0027result\u0027]:\n                        bal_list \u003d balance_info[\u0027info\u0027][\u0027result\u0027][\u0027list\u0027]\n                        if isinstance(bal_list, list) and len(bal_list) \u003e 0:\n                             # Check if the returned list contains our currency or account info\n                             # V5 structure: list[{accountType, coin:[{coin, availableBalance,...}]}]\n                             found_currency_in_list \u003d False\n                             for account_data in bal_list:\n                                 if isinstance(account_data.get(\u0027coin\u0027), list):\n                                     for coin_data in account_data[\u0027coin\u0027]:\n                                         if coin_data.get(\u0027coin\u0027) \u003d\u003d currency:\n                                             found_currency_in_list \u003d True; break\n                                 if found_currency_in_list: break\n\n                             if found_currency_in_list:\n                                 lg.debug(f\"Received valid balance structure for accountType \u0027{acc_type}\u0027.\")\n                                 successful_acc_type \u003d acc_type\n                                 break # Found valid data for this type, proceed to parse\n                             else:\n                                 lg.debug(f\"Balance list received for \u0027{acc_type}\u0027, but currency \u0027{currency}\u0027 not found within.\")\n                                 balance_info \u003d None # Reset to try next type\n                        else:\n                             lg.debug(f\"Balance list empty for accountType \u0027{acc_type}\u0027. Trying next.\")\n                             balance_info \u003d None\n                    else:\n                        lg.debug(f\"Balance structure for accountType \u0027{acc_type}\u0027 missing \u0027result\u0027 or \u0027list\u0027. Trying next. Info: {balance_info.get(\u0027info\u0027)}\")\n                        balance_info \u003d None\n                else:\n                    ret_code \u003d balance_info.get(\u0027info\u0027, {}).get(\u0027retCode\u0027, \u0027N/A\u0027) if balance_info else \u0027N/A\u0027\n                    ret_msg \u003d balance_info.get(\u0027info\u0027, {}).get(\u0027retMsg\u0027, \u0027N/A\u0027) if balance_info else \u0027N/A\u0027\n                    lg.debug(f\"Balance structure for accountType \u0027{acc_type}\u0027 seems empty or indicates error (Code: {ret_code}, Msg: {ret_msg}). Trying next.\")\n                    balance_info \u003d None # Reset to try next type\n\n            except ccxt.ExchangeError as e:\n                # Ignore \"account type not support\" errors and try the next type\n                ignore_msgs \u003d [\"account type not support\", \"invalid account type\", \"accounttype invalid\"]\n                # Bybit specific codes for account issues\n                bybit_code \u003d None\n                if hasattr(e, \u0027args\u0027) and len(e.args) \u003e 0:\n                    try:\n                        error_details \u003d str(e.args[0])\n                        if \"retCode\" in error_details:\n                            details_dict \u003d json.loads(error_details[error_details.find(\u0027{\u0027):error_details.rfind(\u0027}\u0027)+1])\n                            bybit_code \u003d details_dict.get(\u0027retCode\u0027)\n                    except Exception: pass\n                # 10001: Parameter error (could be invalid accountType)\n                # 30086: Unified trade Account Type Error / Not supported operation\n                if any(msg in str(e).lower() for msg in ignore_msgs) or bybit_code in [10001, 30086]:\n                    lg.debug(f\"Account type \u0027{acc_type}\u0027 not supported or parameter error fetching balance: {e}. Trying next.\")\n                    last_exception \u003d e\n                    continue\n                else:\n                    lg.warning(f\"Non-ignorable ExchangeError fetching balance with type {acc_type}: {e}\")\n                    last_exception \u003d e\n                    # Don\u0027t break inner loop, let outer loop handle retries if applicable\n            except (ccxt.NetworkError, ccxt.RequestTimeout, ccxt.DDoSProtection, ccxt.RateLimitExceeded) as e:\n                 # Let the outer retry loop handle these - break inner loop\n                 lg.warning(f\"Network/RateLimit error during balance fetch attempt with type {acc_type}: {e}\")\n                 last_exception \u003d e\n                 break # Break inner loop, let outer loop retry\n            except Exception as e:\n                 lg.error(f\"Unexpected error during balance fetch attempt with type {acc_type}: {e}\", exc_info\u003dTrue)\n                 # traceback.print_exc()\n                 last_exception \u003d e\n                 break # Break inner loop, let outer loop retry\n\n        # If a valid structure was found or network error occurred, break the outer retry loop\n        if balance_info or isinstance(last_exception, (ccxt.NetworkError, ccxt.RequestTimeout, ccxt.DDoSProtection, ccxt.RateLimitExceeded)):\n             break\n\n        # If specific types failed without network errors, wait and retry outer loop\n        if attempt \u003c MAX_API_RETRIES:\n             wait_time \u003d retry_delay * (2 ** attempt)\n             lg.warning(f\"Balance fetch attempt {attempt + 1} failed for all types. Retrying in {wait_time}s...\")\n             time.sleep(wait_time)\n        else:\n             lg.error(f\"{NEON_RED}Max retries reached fetching balance for {currency}. Last error: {last_exception}{RESET}\")\n             return None # Exhausted retries\n\n    # --- Parse the balance_info (if successful) ---\n    if not balance_info:\n         lg.error(f\"{NEON_RED}Failed to fetch any valid balance information for {currency} after all attempts. Last error: {last_exception}{RESET}\")\n         return None\n\n    available_balance_str \u003d None\n    try:\n        # Parse Bybit V5 structure: info -\u003e result -\u003e list -\u003e coin[]\n        if \u0027info\u0027 in balance_info and balance_info[\u0027info\u0027].get(\u0027retCode\u0027) \u003d\u003d 0 and \u0027result\u0027 in balance_info[\u0027info\u0027] and \u0027list\u0027 in balance_info[\u0027info\u0027][\u0027result\u0027]:\n            balance_list \u003d balance_info[\u0027info\u0027][\u0027result\u0027][\u0027list\u0027]\n            for account in balance_list:\n                # V5 often returns only the requested account type, but check just in case\n                # if account.get(\u0027accountType\u0027) \u003d\u003d successful_acc_type: # Match the type that worked\n                coin_list \u003d account.get(\u0027coin\u0027)\n                if isinstance(coin_list, list):\n                    for coin_data in coin_list:\n                        if coin_data.get(\u0027coin\u0027) \u003d\u003d currency:\n                            # Prefer \u0027availableToWithdraw\u0027 or \u0027availableBalance\u0027 (more accurate for trading)\n                            # Bybit V5 names: availableBalance, walletBalance\n                            free \u003d coin_data.get(\u0027availableBalance\u0027) # This seems most relevant for placing new trades\n                            if free is None: free \u003d coin_data.get(\u0027availableToWithdraw\u0027) # Fallback\n                            if free is None: free \u003d coin_data.get(\u0027walletBalance\u0027) # Last resort total balance\n\n                            if free is not None and str(free).strip() !\u003d \"\":\n                                available_balance_str \u003d str(free)\n                                lg.debug(f\"Found balance via Bybit V5 structure: {available_balance_str} {currency} (Account: {account.get(\u0027accountType\u0027, \u0027Unknown\u0027)}, Field: {\u0027availableBalance\u0027 if coin_data.get(\u0027availableBalance\u0027) is not None else (\u0027availableToWithdraw\u0027 if coin_data.get(\u0027availableToWithdraw\u0027) is not None else \u0027walletBalance\u0027)})\")\n                                break # Found the currency\n                    if available_balance_str is not None: break # Found the currency in this account type\n            if available_balance_str is None:\n                lg.warning(f\"{currency} not found within Bybit V5 \u0027info.result.list[].coin[]\u0027 for account type \u0027{successful_acc_type}\u0027. Structure: {balance_info.get(\u0027info\u0027)}\")\n\n        # Fallback: Standard CCXT structure (less likely for Bybit V5 specific fetch)\n        elif currency in balance_info and isinstance(balance_info.get(currency), dict) and balance_info[currency].get(\u0027free\u0027) is not None:\n            available_balance_str \u003d str(balance_info[currency][\u0027free\u0027])\n            lg.debug(f\"Found balance via standard ccxt structure [\u0027{currency}\u0027][\u0027free\u0027]: {available_balance_str}\")\n\n        elif \u0027free\u0027 in balance_info and isinstance(balance_info.get(\u0027free\u0027), dict) and currency in balance_info[\u0027free\u0027]:\n            available_balance_str \u003d str(balance_info[\u0027free\u0027][currency])\n            lg.debug(f\"Found balance via top-level \u0027free\u0027 dictionary: {available_balance_str} {currency}\")\n\n\n        # If still not found, log error\n        if available_balance_str is None:\n            lg.error(f\"{NEON_RED}Could not extract balance for {currency} from structure. Response Info: {balance_info.get(\u0027info\u0027)}{RESET}\")\n            # lg.debug(f\"Full balance response: {balance_info}\")\n            return None\n\n        # --- Convert to Decimal ---\n        final_balance \u003d Decimal(available_balance_str)\n        if final_balance.is_finite() and final_balance \u003e\u003d 0:\n            lg.info(f\"Available {currency} balance: {final_balance:.4f}\")\n            return final_balance\n        else:\n            lg.error(f\"Parsed balance for {currency} is invalid (Negative or NaN/Inf): {final_balance}\"); return None\n\n    except (InvalidOperation, ValueError, TypeError) as e:\n        lg.error(f\"Failed to convert balance \u0027{available_balance_str}\u0027 to Decimal for {currency}: {e}.\"); return None\n    except Exception as e:\n        lg.error(f\"Unexpected error parsing balance structure for {currency}: {e}\", exc_info\u003dTrue)\n        # traceback.print_exc()\n        return None\n\n\n# --- Trading Analyzer Class ---\nclass TradingAnalyzer:\n    \"\"\"\n    Analyzes trading data using pandas_ta.Strategy, generates weighted signals,\n    and provides risk management helpers. Uses Decimal for precision.\n    Manages state like break-even trigger status via a passed-in dictionary.\n    \"\"\"\n    def __init__(\n        self,\n        df: pd.DataFrame,\n        logger: logging.Logger,\n        config: Dict[str, Any],\n        market_info: Dict[str, Any],\n        symbol_state: Dict[str, Any], # Mutable state dict for this symbol\n    ) -\u003e None:\n        if df is None or not isinstance(df, pd.DataFrame) or df.empty:\n             raise ValueError(\"TradingAnalyzer requires a non-empty pandas DataFrame.\")\n        if not market_info or not isinstance(market_info, dict):\n            raise ValueError(\"TradingAnalyzer requires a valid market_info dictionary.\")\n        if symbol_state is None or not isinstance(symbol_state, dict):\n             raise ValueError(\"TradingAnalyzer requires a valid symbol_state dictionary.\")\n\n        self.df \u003d df.copy() # Work on a copy to avoid modifying the original DataFrame passed in\n        self.logger \u003d logger\n        self.config \u003d config\n        self.market_info \u003d market_info # Keep reference\n        self.symbol \u003d market_info.get(\u0027symbol\u0027, \u0027UNKNOWN_SYMBOL\u0027)\n        self.interval \u003d config.get(\"interval\", \"UNKNOWN_INTERVAL\")\n        self.symbol_state \u003d symbol_state # Store reference to the mutable state dict\n\n        # Use Decimal for internal indicator storage where precision matters (e.g., price levels)\n        self.indicator_values: Dict[str, Optional[Decimal]] \u003d {} # Stores latest indicator Decimal/float values\n        self.signals: Dict[str, int] \u003d {\"BUY\": 0, \"SELL\": 0, \"HOLD\": 1} # Simple signal state\n        self.active_weight_set_name \u003d config.get(\"active_weight_set\", \"default\")\n        self.weights \u003d config.get(\"weight_sets\",{}).get(self.active_weight_set_name, {})\n        self.fib_levels_data: Dict[str, Decimal] \u003d {} # Stores calculated fib levels (Decimal)\n        self.ta_strategy: Optional[ta.Strategy] \u003d None # Store the TA strategy object\n        self.ta_column_map: Dict[str, str] \u003d {} # Map generic name (e.g., \"EMA_short\") to actual column name\n\n        if not self.weights:\n            logger.warning(f\"{NEON_YELLOW}Active weight set \u0027{self.active_weight_set_name}\u0027 not found or empty in config for {self.symbol}. Signal scores might be zero.{RESET}\")\n\n        # --- Convert DataFrame OHLCV to float for pandas_ta ---\n        # pandas_ta generally works best with float64\n        try:\n            for col in [\u0027open\u0027, \u0027high\u0027, \u0027low\u0027, \u0027close\u0027, \u0027volume\u0027]:\n                 if col in self.df.columns and pd.api.types.is_decimal_dtype(self.df[col]):\n                      self.df[col] \u003d self.df[col].apply(lambda x: float(x) if x.is_finite() else np.nan)\n                 elif col in self.df.columns: # Ensure numeric otherwise\n                      self.df[col] \u003d pd.to_numeric(self.df[col], errors\u003d\u0027coerce\u0027)\n\n            # Verify conversion\n            # self.logger.debug(f\"DataFrame dtypes after float conversion: {self.df.dtypes}\")\n\n        except Exception as e:\n             logger.error(f\"Error converting DataFrame columns to float for {self.symbol}: {e}\", exc_info\u003dTrue)\n             # Decide how to handle: raise error, or try to continue? For now, continue.\n\n        # --- Initialize and Calculate ---\n        self._define_ta_strategy()\n        self._calculate_all_indicators()\n        self._update_latest_indicator_values() # Populates self.indicator_values with Decimals\n        self.calculate_fibonacci_levels() # Populates self.fib_levels_data with Decimals\n\n    @property\n    def break_even_triggered(self) -\u003e bool:\n        \"\"\"Gets the break-even status from the shared symbol state.\"\"\"\n        return self.symbol_state.get(\u0027break_even_triggered\u0027, False)\n\n    @break_even_triggered.setter\n    def break_even_triggered(self, value: bool):\n        \"\"\"Sets the break-even status in the shared symbol state.\"\"\"\n        if self.symbol_state.get(\u0027break_even_triggered\u0027) !\u003d value:\n            self.symbol_state[\u0027break_even_triggered\u0027] \u003d value\n            self.logger.info(f\"Break-even status for {self.symbol} set to: {value}\")\n\n    def _define_ta_strategy(self) -\u003e None:\n        \"\"\"Defines the pandas_ta Strategy based on config.\"\"\"\n        cfg \u003d self.config\n        indi_cfg \u003d cfg.get(\"indicators\", {})\n\n        # Helper to safely get numeric config values or use defaults\n        def get_num_param(key: str, default: Union[int, float]) -\u003e Union[int, float]:\n            val \u003d cfg.get(key, default)\n            try:\n                if isinstance(default, int): return int(val)\n                if isinstance(default, float): return float(val)\n                return val # Should not happen with int/float defaults\n            except (ValueError, TypeError): return default\n\n        # Get periods/windows/settings\n        atr_p \u003d get_num_param(\"atr_period\", DEFAULT_ATR_PERIOD)\n        ema_s \u003d get_num_param(\"ema_short_period\", DEFAULT_EMA_SHORT_PERIOD)\n        ema_l \u003d get_num_param(\"ema_long_period\", DEFAULT_EMA_LONG_PERIOD)\n        rsi_p \u003d get_num_param(\"rsi_period\", DEFAULT_RSI_WINDOW)\n        bb_p \u003d get_num_param(\"bollinger_bands_period\", DEFAULT_BOLLINGER_BANDS_PERIOD)\n        bb_std \u003d get_num_param(\"bollinger_bands_std_dev\", DEFAULT_BOLLINGER_BANDS_STD_DEV)\n        cci_w \u003d get_num_param(\"cci_window\", DEFAULT_CCI_WINDOW)\n        wr_w \u003d get_num_param(\"williams_r_window\", DEFAULT_WILLIAMS_R_WINDOW)\n        mfi_w \u003d get_num_param(\"mfi_window\", DEFAULT_MFI_WINDOW)\n        stochrsi_w \u003d get_num_param(\"stoch_rsi_window\", DEFAULT_STOCH_RSI_WINDOW)\n        stochrsi_rsi_w \u003d get_num_param(\"stoch_rsi_rsi_window\", DEFAULT_STOCH_WINDOW)\n        stochrsi_k \u003d get_num_param(\"stoch_rsi_k\", DEFAULT_K_WINDOW)\n        stochrsi_d \u003d get_num_param(\"stoch_rsi_d\", DEFAULT_D_WINDOW)\n        psar_af \u003d get_num_param(\"psar_af\", DEFAULT_PSAR_AF)\n        psar_max \u003d get_num_param(\"psar_max_af\", DEFAULT_PSAR_MAX_AF)\n        sma10_w \u003d get_num_param(\"sma_10_window\", DEFAULT_SMA_10_WINDOW)\n        mom_p \u003d get_num_param(\"momentum_period\", DEFAULT_MOMENTUM_PERIOD)\n        vol_ma_p \u003d get_num_param(\"volume_ma_period\", DEFAULT_VOLUME_MA_PERIOD)\n\n        ta_list \u003d []\n        self.ta_column_map \u003d {} # Reset map\n\n        # Always add ATR (needed for risk management)\n        ta_list.append({\"kind\": \"atr\", \"length\": atr_p})\n        self.ta_column_map[\"ATR\"] \u003d f\"ATRr_{atr_p}\" # pandas_ta uses \u0027r\u0027 suffix for RMA smoothed ATR\n\n        # Add indicators based on config flags\n        if indi_cfg.get(\"ema_alignment\") or cfg.get(\"enable_ma_cross_exit\"):\n            if ema_s \u003e 0:\n                 ta_list.append({\"kind\": \"ema\", \"length\": ema_s, \"col_names\": (f\"EMA_{ema_s}\",)})\n                 self.ta_column_map[\"EMA_Short\"] \u003d f\"EMA_{ema_s}\"\n            if ema_l \u003e 0:\n                 ta_list.append({\"kind\": \"ema\", \"length\": ema_l, \"col_names\": (f\"EMA_{ema_l}\",)})\n                 self.ta_column_map[\"EMA_Long\"] \u003d f\"EMA_{ema_l}\"\n        if indi_cfg.get(\"momentum\") and mom_p \u003e 0:\n            ta_list.append({\"kind\": \"mom\", \"length\": mom_p, \"col_names\": (f\"MOM_{mom_p}\",)})\n            self.ta_column_map[\"Momentum\"] \u003d f\"MOM_{mom_p}\"\n        if indi_cfg.get(\"volume_confirmation\") and vol_ma_p \u003e 0:\n            # Calculate SMA of volume, use specific column name via col_names\n            ta_list.append({\"kind\": \"sma\", \"close\": \"volume\", \"length\": vol_ma_p, \"col_names\": (f\"VOL_SMA_{vol_ma_p}\",)})\n            self.ta_column_map[\"Volume_MA\"] \u003d f\"VOL_SMA_{vol_ma_p}\"\n        if indi_cfg.get(\"stoch_rsi\") and stochrsi_w \u003e 0 and stochrsi_rsi_w \u003e 0 and stochrsi_k \u003e 0 and stochrsi_d \u003e 0:\n            k_col \u003d f\"STOCHRSIk_{stochrsi_w}_{stochrsi_rsi_w}_{stochrsi_k}_{stochrsi_d}\"\n            d_col \u003d f\"STOCHRSId_{stochrsi_w}_{stochrsi_rsi_w}_{stochrsi_k}_{stochrsi_d}\"\n            ta_list.append({\"kind\": \"stochrsi\", \"length\": stochrsi_w, \"rsi_length\": stochrsi_rsi_w, \"k\": stochrsi_k, \"d\": stochrsi_d, \"col_names\": (k_col, d_col)})\n            self.ta_column_map[\"StochRSI_K\"] \u003d k_col\n            self.ta_column_map[\"StochRSI_D\"] \u003d d_col\n        if indi_cfg.get(\"rsi\") and rsi_p \u003e 0:\n            ta_list.append({\"kind\": \"rsi\", \"length\": rsi_p, \"col_names\": (f\"RSI_{rsi_p}\",)})\n            self.ta_column_map[\"RSI\"] \u003d f\"RSI_{rsi_p}\"\n        if indi_cfg.get(\"bollinger_bands\") and bb_p \u003e 0:\n            # Define column names explicitly\n            bbl_col \u003d f\"BBL_{bb_p}_{bb_std:.1f}\"\n            bbm_col \u003d f\"BBM_{bb_p}_{bb_std:.1f}\"\n            bbu_col \u003d f\"BBU_{bb_p}_{bb_std:.1f}\"\n            # bba_col \u003d f\"BBA_{bb_p}_{bb_std:.1f}\" # Bandwidth\n            # bbp_col \u003d f\"BBP_{bb_p}_{bb_std:.1f}\" # Percent\n            ta_list.append({\"kind\": \"bbands\", \"length\": bb_p, \"std\": bb_std, \"col_names\": (bbl_col, bbm_col, bbu_col, f\"BBB_{bb_p}_{bb_std:.1f}\", f\"BBP_{bb_p}_{bb_std:.1f}\")}) # Include Bandwidth and Percent cols returned by bbands\n            self.ta_column_map[\"BB_Lower\"] \u003d bbl_col\n            self.ta_column_map[\"BB_Middle\"] \u003d bbm_col\n            self.ta_column_map[\"BB_Upper\"] \u003d bbu_col\n        if indi_cfg.get(\"vwap\"):\n             # VWAP calculation might need typ price (HLC/3), check ta docs\n             # Add typical price column if needed by vwap implementation\n             if \u0027typical\u0027 not in self.df.columns:\n                 self.df[\u0027typical\u0027] \u003d (self.df[\u0027high\u0027] + self.df[\u0027low\u0027] + self.df[\u0027close\u0027]) / 3.0\n             # Use \u0027typical\u0027 as the close price for VWAP? Or let ta handle HLC input?\n             # Default ta.vwap uses HLC/3 implicitly if volume present.\n             vwap_col \u003d \"VWAP_D\" # Default column name, may vary\n             ta_list.append({\"kind\": \"vwap\", \"col_names\": (vwap_col,)}) # Assuming daily reset, adjust anchor if needed\n             self.ta_column_map[\"VWAP\"] \u003d vwap_col\n        if indi_cfg.get(\"cci\") and cci_w \u003e 0:\n            cci_col \u003d f\"CCI_{cci_w}_0.015\" # Default suffix added by ta\n            ta_list.append({\"kind\": \"cci\", \"length\": cci_w, \"col_names\": (cci_col,)})\n            self.ta_column_map[\"CCI\"] \u003d cci_col\n        if indi_cfg.get(\"wr\") and wr_w \u003e 0:\n            wr_col \u003d f\"WILLR_{wr_w}\"\n            ta_list.append({\"kind\": \"willr\", \"length\": wr_w, \"col_names\": (wr_col,)})\n            self.ta_column_map[\"WR\"] \u003d wr_col\n        if indi_cfg.get(\"psar\"):\n            # Format AF/MAX consistently for column names\n            psar_af_str \u003d f\"{psar_af}\".rstrip(\u00270\u0027).rstrip(\u0027.\u0027) if \u0027.\u0027 in f\"{psar_af}\" else f\"{psar_af}\"\n            psar_max_str \u003d f\"{psar_max}\".rstrip(\u00270\u0027).rstrip(\u0027.\u0027) if \u0027.\u0027 in f\"{psar_max}\" else f\"{psar_max}\"\n            l_col \u003d f\"PSARl_{psar_af_str}_{psar_max_str}\"\n            s_col \u003d f\"PSARs_{psar_af_str}_{psar_max_str}\"\n            af_col \u003d f\"PSARaf_{psar_af_str}_{psar_max_str}\"\n            r_col \u003d f\"PSARr_{psar_af_str}_{psar_max_str}\"\n            ta_list.append({\"kind\": \"psar\", \"af\": psar_af, \"max_af\": psar_max, \"col_names\": (l_col, s_col, af_col, r_col)})\n            self.ta_column_map[\"PSAR_Long\"] \u003d l_col\n            self.ta_column_map[\"PSAR_Short\"] \u003d s_col\n            self.ta_column_map[\"PSAR_AF\"] \u003d af_col\n            self.ta_column_map[\"PSAR_Reversal\"] \u003d r_col\n        if indi_cfg.get(\"sma_10\") and sma10_w \u003e 0:\n            ta_list.append({\"kind\": \"sma\", \"length\": sma10_w, \"col_names\": (f\"SMA_{sma10_w}\",)})\n            self.ta_column_map[\"SMA10\"] \u003d f\"SMA_{sma10_w}\"\n        if indi_cfg.get(\"mfi\") and mfi_w \u003e 0:\n            # MFI needs typical price and volume\n            if \u0027typical\u0027 not in self.df.columns:\n                self.df[\u0027typical\u0027] \u003d (self.df[\u0027high\u0027] + self.df[\u0027low\u0027] + self.df[\u0027close\u0027]) / 3.0\n            ta_list.append({\"kind\": \"mfi\", \"length\": mfi_w, \"col_names\": (f\"MFI_{mfi_w}\",)})\n            self.ta_column_map[\"MFI\"] \u003d f\"MFI_{mfi_w}\"\n\n        if not ta_list:\n            self.logger.warning(f\"No indicators enabled or configured correctly for {self.symbol}. Analysis will be limited.\")\n            return # No strategy to define\n\n        self.ta_strategy \u003d ta.Strategy(\n            name\u003d\"EnhancedMultiIndicator\",\n            description\u003d\"Calculates multiple TA indicators based on config\",\n            ta\u003dta_list\n        )\n        self.logger.debug(f\"Defined TA Strategy for {self.symbol} with {len(ta_list)} indicators.\")\n        # self.logger.debug(f\"TA Column Map: {self.ta_column_map}\")\n        # self.logger.debug(f\"Strategy TA List: {self.ta_strategy.ta}\")\n\n\n    def _calculate_all_indicators(self):\n        \"\"\"Calculates all enabled indicators using the defined pandas_ta strategy.\"\"\"\n        if self.df.empty:\n            self.logger.warning(f\"DataFrame empty, cannot calculate indicators for {self.symbol}.\")\n            return\n        if not self.ta_strategy:\n            self.logger.warning(f\"TA Strategy not defined or empty for {self.symbol}. Skipping indicator calculation.\")\n            return\n\n        # Check for sufficient data length based on strategy\u0027s requirements\n        min_required_data \u003d self.ta_strategy.required if hasattr(self.ta_strategy, \u0027required\u0027) else 50 # Estimate if required not available\n        buffer \u003d 20 # Add buffer for stability\n        if len(self.df) \u003c min_required_data + buffer:\n            self.logger.warning(f\"{NEON_YELLOW}Insufficient data ({len(self.df)} points) for {self.symbol} to calculate all indicators reliably (min recommended: {min_required_data + buffer}). Results may be inaccurate.{RESET}\")\n\n        try:\n            # Apply the strategy to the DataFrame (modifies it in place)\n            self.logger.debug(f\"Running pandas_ta strategy calculation for {self.symbol}...\")\n            self.df.ta.strategy(self.ta_strategy, timed\u003dFalse) # Set timed\u003dTrue for performance debugging\n            self.logger.debug(f\"Finished indicator calculations for {self.symbol}.\")\n            # Log columns added by the strategy for verification\n            # new_cols \u003d [col for col in self.df.columns if col not in [\u0027open\u0027, \u0027high\u0027, \u0027low\u0027, \u0027close\u0027, \u0027volume\u0027, \u0027typical\u0027]]\n            # self.logger.debug(f\"Columns after TA calculation: {self.df.columns.tolist()}\")\n\n        except AttributeError as ae:\n             if \"\u0027Decimal\u0027 object has no attribute\" in str(ae):\n                 self.logger.error(f\"{NEON_RED}Pandas TA Error for {self.symbol}: Calculation failed, likely due to Decimal type input. Ensure DataFrame uses float64. Error: {ae}{RESET}\", exc_info\u003dFalse)\n             else:\n                 self.logger.error(f\"{NEON_RED}Pandas TA attribute error for {self.symbol}: {ae}. Is pandas_ta installed correctly?{RESET}\", exc_info\u003dTrue)\n                 # traceback.print_exc()\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Error calculating indicators with pandas_ta strategy for {self.symbol}: {e}{RESET}\", exc_info\u003dTrue)\n            # traceback.print_exc()\n            # Invalidate column map if calculation fails? Or just let _update_latest handle missing cols.\n\n    def _update_latest_indicator_values(self):\n        \"\"\"Updates the indicator_values dict with the latest Decimal values from self.df.\"\"\"\n        self.indicator_values \u003d {} # Reset values\n        if self.df.empty or len(self.df) \u003d\u003d 0:\n            self.logger.warning(f\"Cannot update latest values: DataFrame empty/short for {self.symbol}.\")\n            return\n\n        try:\n            # Use .iloc[-1] to get the last row (Series)\n            latest_series \u003d self.df.iloc[-1]\n\n            if latest_series.isnull().all():\n                self.logger.warning(f\"Cannot update latest values: Last row is all NaNs for {self.symbol}.\")\n                return\n\n            # Helper to convert to Decimal, handling NaN/None/Inf\n            def to_decimal(value: Any) -\u003e Optional[Decimal]:\n                if pd.isna(value) or value is None: return None\n                try:\n                     dec_val \u003d Decimal(str(value))\n                     return dec_val if dec_val.is_finite() else None # Return None for Inf/-Inf\n                except (InvalidOperation, ValueError, TypeError): return None\n\n            # Populate from calculated indicators using the map\n            for generic_name, actual_col_name in self.ta_column_map.items():\n                if actual_col_name and actual_col_name in latest_series.index:\n                    value \u003d latest_series[actual_col_name]\n                    self.indicator_values[generic_name] \u003d to_decimal(value)\n                else:\n                    # self.logger.debug(f\"Column \u0027{actual_col_name}\u0027 for indicator \u0027{generic_name}\u0027 not found in DataFrame.\")\n                    self.indicator_values[generic_name] \u003d None # Store None if column missing\n\n            # Add essential price/volume data as Decimal (use capitalized keys for consistency)\n            for base_col in [\u0027open\u0027, \u0027high\u0027, \u0027low\u0027, \u0027close\u0027, \u0027volume\u0027]:\n                if base_col in latest_series.index:\n                     value \u003d latest_series[base_col]\n                     self.indicator_values[base_col.capitalize()] \u003d to_decimal(value)\n                else:\n                     self.indicator_values[base_col.capitalize()] \u003d None\n\n            # Log non-None values for debugging\n            valid_values_str \u003d {}\n            for k, v in self.indicator_values.items():\n                 if v is not None:\n                     try: valid_values_str[k] \u003d f\"{v:.5f}\" # Format Decimal for logging\n                     except: valid_values_str[k] \u003d str(v) # Fallback\n\n            self.logger.debug(f\"Latest indicator Decimal values updated for {self.symbol}: {valid_values_str}\")\n\n        except IndexError:\n             self.logger.error(f\"Error updating latest indicator values: DataFrame index out of bounds (empty?) for {self.symbol}.\")\n        except KeyError as ke:\n            self.logger.error(f\"Error updating latest indicator values: Column key error \u0027{ke}\u0027 for {self.symbol}. TA calculation might have failed.\", exc_info\u003dTrue)\n        except Exception as e:\n            self.logger.error(f\"Unexpected error updating latest indicator values for {self.symbol}: {e}\", exc_info\u003dTrue)\n            # traceback.print_exc()\n            self.indicator_values \u003d {} # Reset on error\n\n    # --- Precision and Market Info Helpers (using market_info) ---\n    def get_min_tick_size(self) -\u003e Optional[Decimal]:\n        \"\"\"Gets the minimum price increment (tick size) from market info as Decimal.\"\"\"\n        tick \u003d self.market_info.get(\u0027min_tick_size\u0027)\n        if tick is None or tick \u003c\u003d 0:\n             self.logger.warning(f\"Invalid min_tick_size ({tick}) retrieved for {self.symbol}\")\n             return None\n        return tick\n\n    def get_price_precision_digits(self) -\u003e int:\n        \"\"\"Gets price precision (number of decimal places) from market info.\"\"\"\n        digits \u003d self.market_info.get(\u0027price_precision_digits\u0027)\n        return digits if digits is not None and digits \u003e\u003d0 else 8 # Default fallback 8\n\n    def get_amount_precision_digits(self) -\u003e int:\n        \"\"\"Gets amount precision (number of decimal places) from market info.\"\"\"\n        digits \u003d self.market_info.get(\u0027amount_precision_digits\u0027)\n        return digits if digits is not None and digits \u003e\u003d0 else 8 # Default fallback 8\n\n    def quantize_price(self, price: Union[Decimal, float, str], rounding\u003dROUND_DOWN) -\u003e Optional[Decimal]:\n        \"\"\"Quantizes a price DOWN to the market\u0027s tick size.\"\"\"\n        min_tick \u003d self.get_min_tick_size()\n        if min_tick is None:\n            self.logger.error(f\"Cannot quantize price for {self.symbol}: Missing min_tick_size.\")\n            return None\n        try:\n            price_decimal \u003d Decimal(str(price))\n            if not price_decimal.is_finite(): return None # Handle NaN/Inf input\n\n            # Quantize to the nearest tick using the specified rounding mode\n            quantized \u003d (price_decimal / min_tick).quantize(Decimal(\u00270\u0027), rounding\u003drounding) * min_tick\n            # Optional: Format to ensure correct number of decimal places as per tick size\n            # digits \u003d abs(min_tick.normalize().as_tuple().exponent)\n            # return Decimal(f\"{quantized:.{digits}f}\")\n            return quantized\n        except (InvalidOperation, ValueError, TypeError) as e:\n            self.logger.error(f\"Error quantizing price \u0027{price}\u0027 for {self.symbol}: {e}\")\n            return None\n\n    def quantize_amount(self, amount: Union[Decimal, float, str], rounding\u003dROUND_DOWN) -\u003e Optional[Decimal]:\n        \"\"\"Quantizes an amount to the market\u0027s amount precision (step size) using specified rounding.\"\"\"\n        amount_digits \u003d self.get_amount_precision_digits()\n        if amount_digits is None: # Should use the fallback 8 from the getter\n            self.logger.error(f\"Cannot quantize amount for {self.symbol}: Invalid amount_precision_digits.\")\n            return None\n        try:\n            amount_decimal \u003d Decimal(str(amount))\n            if not amount_decimal.is_finite(): return None # Handle NaN/Inf input\n\n            # Amount step size is 10^(-digits)\n            step_size \u003d Decimal(\u00271\u0027) / (Decimal(\u002710\u0027) ** amount_digits)\n            quantized \u003d (amount_decimal / step_size).quantize(Decimal(\u00270\u0027), rounding\u003drounding) * step_size\n            # Format to the correct number of decimal places to avoid issues with trailing zeros beyond precision\n            # This ensures the string representation matches the required precision\n            return Decimal(f\"{quantized:.{amount_digits}f}\")\n        except (InvalidOperation, ValueError, TypeError) as e:\n            self.logger.error(f\"Error quantizing amount \u0027{amount}\u0027 for {self.symbol}: {e}\")\n            return None\n\n    # --- Fibonacci Calculation ---\n    def calculate_fibonacci_levels(self, window: Optional[int] \u003d None) -\u003e Dict[str, Decimal]:\n        \"\"\"Calculates Fibonacci retracement levels over a window using Decimal and quantization.\"\"\"\n        self.fib_levels_data \u003d {} # Reset\n        window \u003d window or int(self.config.get(\"fibonacci_window\", DEFAULT_FIB_WINDOW))\n        if len(self.df) \u003c window:\n            self.logger.debug(f\"Not enough data ({len(self.df)}) for Fib window ({window}) on {self.symbol}.\")\n            return {}\n\n        df_slice \u003d self.df.tail(window)\n        try:\n            # Use Decimal directly if df columns are already Decimal, otherwise convert from float\n            if pd.api.types.is_decimal_dtype(df_slice[\"high\"]):\n                high_raw \u003d df_slice[\"high\"].dropna().max(); low_raw \u003d df_slice[\"low\"].dropna().min()\n            else: # Assume float if not Decimal\n                 high_raw \u003d Decimal(str(df_slice[\"high\"].dropna().max()))\n                 low_raw \u003d Decimal(str(df_slice[\"low\"].dropna().min()))\n\n            if not high_raw.is_finite() or not low_raw.is_finite():\n                self.logger.warning(f\"No valid high/low in last {window} periods for Fib on {self.symbol}. High\u003d{high_raw}, Low\u003d{low_raw}\"); return {}\n\n            high \u003d high_raw; low \u003d low_raw; diff \u003d high - low\n            levels \u003d {}; min_tick \u003d self.get_min_tick_size()\n\n            if diff \u003e\u003d Decimal(\u00270\u0027) and min_tick is not None:\n                for level_pct_float in FIB_LEVELS:\n                    level_pct \u003d Decimal(str(level_pct_float))\n                    level_price_raw \u003d high - (diff * level_pct)\n                    # Quantize DOWN to nearest tick\n                    level_price \u003d self.quantize_price(level_price_raw, rounding\u003dROUND_DOWN) # Quantize Fib levels down\n                    if level_price is not None:\n                         levels[f\"Fib_{level_pct * 100:.1f}%\"] \u003d level_price\n                    else:\n                         self.logger.warning(f\"Failed to quantize Fib level {level_pct*100:.1f}% ({level_price_raw}) for {self.symbol}\")\n            elif min_tick is None:\n                 self.logger.warning(f\"Invalid min_tick_size for Fib quantization on {self.symbol}. Using raw values.\")\n                 for level_pct_float in FIB_LEVELS:\n                     level_pct \u003d Decimal(str(level_pct_float))\n                     level_price_raw \u003d high - (diff * level_pct)\n                     levels[f\"Fib_{level_pct * 100:.1f}%\"] \u003d level_price_raw # Store raw Decimal\n            else: # Should not happen if diff \u003c 0, but handle defensively\n                 self.logger.warning(f\"Invalid range (high \u003c low?) for Fib on {self.symbol}. High\u003d{high}, Low\u003d{low}\")\n                 return {}\n\n            self.fib_levels_data \u003d levels\n            price_prec \u003d self.get_price_precision_digits()\n            log_levels \u003d {k: f\"{v:.{price_prec}f}\" for k, v in levels.items()}\n            # self.logger.debug(f\"Calculated Fibonacci levels for {self.symbol}: {log_levels}\")\n            return levels\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Fibonacci calculation error for {self.symbol}: {e}{RESET}\", exc_info\u003dTrue)\n            # traceback.print_exc()\n            self.fib_levels_data \u003d {}; return {}\n\n    # --- Indicator Check Methods (Return float score -1.0 to 1.0, or None if value missing) ---\n    # These methods now use self.indicator_values[GENERIC_NAME] which should contain Decimals\n    def _get_indicator_float(self, name: str) -\u003e Optional[float]:\n        \"\"\"Safely gets indicator value as float.\"\"\"\n        val \u003d self.indicator_values.get(name)\n        if val is None or not val.is_finite(): return None\n        try: return float(val)\n        except: return None\n\n    def _check_ema_alignment(self) -\u003e Optional[float]:\n        ema_short \u003d self._get_indicator_float(\"EMA_Short\")\n        ema_long \u003d self._get_indicator_float(\"EMA_Long\")\n        if ema_short is None or ema_long is None: return None\n        if ema_short \u003e ema_long: return 1.0\n        if ema_short \u003c ema_long: return -1.0\n        return 0.0\n\n    def _check_momentum(self) -\u003e Optional[float]:\n        mom \u003d self._get_indicator_float(\"Momentum\")\n        if mom is None: return None\n        # Simple scaling (adjust scale_factor based on typical range for asset/TF)\n        # Example: if typical MOM is +/- 5, scale_factor \u003d 0.2. If +/- 0.5, scale_factor \u003d 2.0\n        scale_factor \u003d 0.1 # Example scale factor - NEEDS TUNING\n        return max(-1.0, min(1.0, mom * scale_factor))\n\n    def _check_volume_confirmation(self) -\u003e Optional[float]:\n        vol \u003d self._get_indicator_float(\"Volume\")\n        vol_ma \u003d self._get_indicator_float(\"Volume_MA\")\n        if vol is None or vol_ma is None or vol_ma \u003c\u003d 0: return None\n        try: mult \u003d float(self.config.get(\"volume_confirmation_multiplier\", 1.5))\n        except: mult \u003d 1.5\n        if vol \u003e vol_ma * mult: return 0.7 # High volume confirmation (positive signal only)\n        # Optionally add negative signal for low volume:\n        # if vol \u003c vol_ma / mult: return -0.4 # Low volume lack of confirmation\n        return 0.0 # Neutral\n\n    def _check_stoch_rsi(self) -\u003e Optional[float]:\n        k \u003d self._get_indicator_float(\"StochRSI_K\"); d \u003d self._get_indicator_float(\"StochRSI_D\")\n        if k is None or d is None: return None\n        try:\n            oversold \u003d float(self.config.get(\"stoch_rsi_oversold_threshold\", 25.0))\n            overbought \u003d float(self.config.get(\"stoch_rsi_overbought_threshold\", 75.0))\n        except: oversold, overbought \u003d 25.0, 75.0\n        score \u003d 0.0\n        # Prioritize crossing signals\n        # Check previous values if available (more robust crossing check) - requires storing previous state or looking at df[-2]\n        # Simple check based on current values:\n        if k \u003c oversold and d \u003c oversold: # Both oversold\n             score \u003d 0.8 if k \u003e d else 0.6 # Stronger signal if K crossed D upwards recently\n        elif k \u003e overbought and d \u003e overbought: # Both overbought\n             score \u003d -0.8 if k \u003c d else -0.6 # Stronger signal if K crossed D downwards recently\n        # Zone signals\n        elif k \u003c oversold: score \u003d 0.5 # In oversold zone\n        elif k \u003e overbought: score \u003d -0.5 # In overbought zone\n        # Trend bias based on K vs D\n        elif k \u003e d: score \u003d 0.2 # K over D bullish bias\n        elif k \u003c d: score \u003d -0.2 # K under D bearish bias\n        return max(-1.0, min(1.0, score))\n\n    def _check_rsi(self) -\u003e Optional[float]:\n        rsi \u003d self._get_indicator_float(\"RSI\")\n        if rsi is None: return None\n        # Using more granular scoring based on zones\n        if rsi \u003c\u003d 20: return 1.0   # Very oversold\n        if rsi \u003c\u003d 30: return 0.7   # Oversold\n        if rsi \u003e\u003d 80: return -1.0  # Very overbought\n        if rsi \u003e\u003d 70: return -0.7  # Overbought\n        # Linear scale between 30 and 70\n        if 30 \u003c rsi \u003c 70: return 1.0 - (rsi - 30.0) * (2.0 / 40.0)\n        return 0.0 # Between 30-70 but exactly on boundary (shouldn\u0027t happen often)\n\n    def _check_cci(self) -\u003e Optional[float]:\n        cci \u003d self._get_indicator_float(\"CCI\")\n        if cci is None: return None\n        # Using standard CCI levels\n        if cci \u003c\u003d -200: return 1.0 # Extreme oversold\n        if cci \u003c\u003d -100: return 0.7 # Oversold entry/confirmation\n        if cci \u003e\u003d 200: return -1.0 # Extreme overbought\n        if cci \u003e\u003d 100: return -0.7 # Overbought entry/confirmation\n        # Scale between -100 and 100 (less signal strength)\n        if -100 \u003c cci \u003c 100: return -(cci / 100.0) * 0.3 # Weaker signal towards zero crossing\n        return 0.0\n\n    def _check_wr(self) -\u003e Optional[float]: # Williams %R\n        wr \u003d self._get_indicator_float(\"WR\") # Note: WR is typically negative, ranging -100 to 0\n        if wr is None: return None\n        if wr \u003c\u003d -90: return 1.0   # Very oversold\n        if wr \u003c\u003d -80: return 0.7   # Oversold\n        if wr \u003e\u003d -10: return -1.0  # Very overbought\n        if wr \u003e\u003d -20: return -0.7  # Overbought\n        # Linear scale between -80 and -20\n        if -80 \u003c wr \u003c -20: return 1.0 - (wr - (-80.0)) * (2.0 / 60.0)\n        return 0.0\n\n    def _check_psar(self) -\u003e Optional[float]:\n        psar_l_val \u003d self.indicator_values.get(\"PSAR_Long\") # Decimal or None\n        psar_s_val \u003d self.indicator_values.get(\"PSAR_Short\") # Decimal or None\n        # Check if PSAR value exists (is not None and is finite)\n        is_long_active \u003d psar_l_val is not None and psar_l_val.is_finite()\n        is_short_active \u003d psar_s_val is not None and psar_s_val.is_finite()\n\n        # PSAR Long is active when PSAR dot is below price (uptrend)\n        if is_long_active and not is_short_active: return 1.0\n        # PSAR Short is active when PSAR dot is above price (downtrend)\n        if not is_long_active and is_short_active: return -1.0\n\n        # Check for reversal signal (PSARr column)\n        # reversal \u003d self._get_indicator_float(\"PSAR_Reversal\")\n        # if reversal is not None and reversal !\u003d 0:\n        #     # logger.debug(f\"PSAR reversal detected: {reversal}\")\n        #     return 1.0 if reversal \u003e 0 else -1.0 # Use reversal signal directly\n\n        return 0.0 # Neutral/Ambiguous (e.g., first few bars, or if both L/S somehow appear)\n\n    def _check_sma10(self) -\u003e Optional[float]:\n        sma \u003d self._get_indicator_float(\"SMA10\")\n        close \u003d self._get_indicator_float(\"Close\")\n        if sma is None or close is None: return None\n        if close \u003e sma: return 0.5 # Price above SMA10 -\u003e Weak Buy\n        if close \u003c sma: return -0.5 # Price below SMA10 -\u003e Weak Sell\n        return 0.0\n\n    def _check_vwap(self) -\u003e Optional[float]:\n        vwap \u003d self._get_indicator_float(\"VWAP\")\n        close \u003d self._get_indicator_float(\"Close\")\n        if vwap is None or close is None: return None\n        if close \u003e vwap: return 0.6 # Price above VWAP -\u003e Moderate Buy\n        if close \u003c vwap: return -0.6 # Price below VWAP -\u003e Moderate Sell\n        return 0.0\n\n    def _check_mfi(self) -\u003e Optional[float]:\n        mfi \u003d self._get_indicator_float(\"MFI\")\n        if mfi is None: return None\n        # Similar zones to RSI\n        if mfi \u003c\u003d 15: return 1.0   # Very oversold\n        if mfi \u003c\u003d 25: return 0.7   # Oversold\n        if mfi \u003e\u003d 85: return -1.0  # Very overbought\n        if mfi \u003e\u003d 75: return -0.7  # Overbought\n        # Linear scale between 25 and 75\n        if 25 \u003c mfi \u003c 75: return 1.0 - (mfi - 25.0) * (2.0 / 50.0)\n        return 0.0\n\n    def _check_bollinger_bands(self) -\u003e Optional[float]:\n        bbl \u003d self._get_indicator_float(\"BB_Lower\")\n        bbu \u003d self._get_indicator_float(\"BB_Upper\")\n        close \u003d self._get_indicator_float(\"Close\")\n        if bbl is None or bbu is None or close is None: return None\n\n        band_range \u003d bbu - bbl\n        if band_range \u003c\u003d 0: return 0.0 # Avoid division by zero if bands invalid\n\n        # Score based on proximity to bands (normalized)\n        # Value close to 1 means close to lower band, close to -1 means close to upper band\n        # Value around 0 means near middle band\n        position_in_band \u003d (close - bbl) / band_range # Range 0 to 1 usually\n        score \u003d 1.0 - 2.0 * position_in_band # Rescale to -1 to 1\n\n        # Add stronger signal if price touches or crosses bands\n        if close \u003c\u003d bbl: score \u003d 1.0 # Strong buy signal (touch/cross lower)\n        if close \u003e\u003d bbu: score \u003d -1.0 # Strong sell signal (touch/cross upper)\n\n        return max(-1.0, min(1.0, score)) # Clamp score\n\n    def _check_orderbook(self, orderbook_data: Optional[Dict]) -\u003e Optional[float]:\n        \"\"\"Analyzes Order Book Imbalance (OBI).\"\"\"\n        if not orderbook_data: return None\n        try:\n            bids \u003d orderbook_data.get(\u0027bids\u0027, []); asks \u003d orderbook_data.get(\u0027asks\u0027, [])\n            if not bids or not asks: return 0.0 # Neutral if one side is empty\n\n            # Consider top N levels or volume within X% of mid-price\n            levels_to_check \u003d min(len(bids), len(asks), int(self.config.get(\"orderbook_limit\", 10)))\n            if levels_to_check \u003c\u003d 0: return 0.0\n\n            # Calculate Weighted Mid Price\n            # best_bid_price \u003d Decimal(str(bids[0][0])); best_ask_price \u003d Decimal(str(asks[0][0]))\n            # best_bid_vol \u003d Decimal(str(bids[0][1])); best_ask_vol \u003d Decimal(str(asks[0][1]))\n            # mid_price \u003d (best_bid_price * best_ask_vol + best_ask_price * best_bid_vol) / (best_bid_vol + best_ask_vol) if (best_bid_vol + best_ask_vol) \u003e 0 else (best_bid_price + best_ask_price) / 2\n\n            # Sum volume within N levels\n            bid_vol \u003d sum(Decimal(str(b[1])) for b in bids[:levels_to_check])\n            ask_vol \u003d sum(Decimal(str(a[1])) for a in asks[:levels_to_check])\n            total_vol \u003d bid_vol + ask_vol\n\n            if total_vol \u003c\u003d 0: return 0.0 # Neutral if no volume in checked levels\n\n            obi \u003d (bid_vol - ask_vol) / total_vol # OBI range: -1 to +1\n            # self.logger.debug(f\"OBI ({levels_to_check} levels): BidVol\u003d{bid_vol:.4f}, AskVol\u003d{ask_vol:.4f}, OBI\u003d{obi:.4f}\")\n\n            # Return OBI directly as score, clamped between -1 and 1\n            return float(max(Decimal(\"-1.0\"), min(Decimal(\"1.0\"), obi)))\n\n        except (InvalidOperation, ValueError, TypeError, IndexError) as e:\n            self.logger.warning(f\"Error calculating OBI for {self.symbol}: {e}\"); return None\n        except Exception as e: self.logger.error(f\"Unexpected OBI error: {e}\"); return None\n\n    # --- Signal Generation \u0026 Scoring ---\n    def generate_trading_signal(self, current_price_dec: Decimal, orderbook_data: Optional[Dict]) -\u003e str:\n        \"\"\"Generates a trading signal (BUY/SELL/HOLD) based on weighted indicator scores.\"\"\"\n        self.signals \u003d {\"BUY\": 0, \"SELL\": 0, \"HOLD\": 1} # Reset signals, default HOLD\n        final_signal_score \u003d Decimal(\"0.0\")\n        total_weight_applied \u003d Decimal(\"0.0\")\n        active_indicator_count \u003d 0; nan_indicator_count \u003d 0\n        debug_scores \u003d {}\n\n        if not self.indicator_values or current_price_dec is None or not current_price_dec.is_finite() or current_price_dec \u003c\u003d 0:\n            self.logger.warning(f\"Cannot generate signal for {self.symbol}: Invalid inputs (indicators empty or price invalid: {current_price_dec}).\")\n            return \"HOLD\"\n\n        active_weights \u003d self.config.get(\"weight_sets\", {}).get(self.active_weight_set_name)\n        if not active_weights:\n            self.logger.error(f\"Weight set \u0027{self.active_weight_set_name}\u0027 missing/empty for {self.symbol}. HOLDING.\")\n            return \"HOLD\"\n\n        # Map indicator keys from config to their check methods\n        indicator_check_methods \u003d {\n            \"ema_alignment\": self._check_ema_alignment,\n            \"momentum\": self._check_momentum,\n            \"volume_confirmation\": self._check_volume_confirmation,\n            \"stoch_rsi\": self._check_stoch_rsi,\n            \"rsi\": self._check_rsi,\n            \"bollinger_bands\": self._check_bollinger_bands,\n            \"vwap\": self._check_vwap,\n            \"cci\": self._check_cci,\n            \"wr\": self._check_wr,\n            \"psar\": self._check_psar,\n            \"sma_10\": self._check_sma10,\n            \"mfi\": self._check_mfi,\n            \"orderbook\": lambda: self._check_orderbook(orderbook_data), # Lambda for extra arg\n        }\n\n        # --- Calculate Weighted Score ---\n        for indicator_key, enabled in self.config.get(\"indicators\", {}).items():\n            if not enabled:\n                debug_scores[indicator_key] \u003d \"Disabled\"\n                continue\n\n            weight_str \u003d active_weights.get(indicator_key)\n            if weight_str is None:\n                debug_scores[indicator_key] \u003d \"No Weight\"\n                continue # Skip if no weight defined for this enabled indicator\n\n            try:\n                weight \u003d Decimal(str(weight_str))\n                if weight \u003d\u003d 0:\n                     debug_scores[indicator_key] \u003d \"Weight\u003d0\"\n                     continue # Skip zero weights silently\n            except (InvalidOperation, ValueError, TypeError):\n                self.logger.warning(f\"Invalid weight \u0027{weight_str}\u0027 for indicator \u0027{indicator_key}\u0027 in set \u0027{self.active_weight_set_name}\u0027. Skipping.\")\n                debug_scores[indicator_key] \u003d f\"Invalid Wt({weight_str})\"\n                continue\n\n            check_method \u003d indicator_check_methods.get(indicator_key)\n            if check_method and callable(check_method):\n                indicator_score_float \u003d None # Use None to indicate missing value\n                try:\n                    indicator_score_float \u003d check_method()\n                except Exception as e:\n                    self.logger.error(f\"Error in check method for {indicator_key} on {self.symbol}: {e}\", exc_info\u003dTrue)\n                    # traceback.print_exc()\n\n                if indicator_score_float is not None and math.isfinite(indicator_score_float):\n                    try:\n                        # Clamp score between -1.0 and 1.0 before applying weight\n                        clamped_score \u003d max(-1.0, min(1.0, indicator_score_float))\n                        indicator_score_decimal \u003d Decimal(str(clamped_score))\n                        weighted_score \u003d indicator_score_decimal * weight\n                        final_signal_score +\u003d weighted_score\n                        total_weight_applied +\u003d abs(weight) # Use absolute weight for normalization denominator\n                        active_indicator_count +\u003d 1\n                        debug_scores[indicator_key] \u003d f\"{indicator_score_float:.2f}(x{weight:.2f})\u003d{weighted_score:.3f}\"\n                    except (InvalidOperation, ValueError, TypeError) as calc_err:\n                        self.logger.error(f\"Error processing score for {indicator_key}: {calc_err}\")\n                        debug_scores[indicator_key] \u003d \"Calc Err\"\n                        nan_indicator_count +\u003d 1\n                else:\n                    debug_scores[indicator_key] \u003d \"NaN/None\"\n                    nan_indicator_count +\u003d 1\n            elif indicator_key in active_weights: # Only warn if weight exists but method doesn\u0027t\n                self.logger.warning(f\"Check method not found or implemented for enabled indicator with weight: {indicator_key}\")\n                debug_scores[indicator_key] \u003d \"No Method\"\n\n        # --- Determine Final Signal ---\n        final_signal \u003d \"HOLD\"\n        normalized_score \u003d Decimal(\"0.0\") # Score normalized by sum of absolute weights\n\n        if total_weight_applied \u003e 0:\n            normalized_score \u003d (final_signal_score / total_weight_applied).quantize(Decimal(\"0.0001\"))\n        elif active_indicator_count \u003e 0:\n             self.logger.warning(f\"No non-zero weights applied for {active_indicator_count} active indicators on {self.symbol}. Final score is 0. HOLDING.\")\n        # else: # No active indicators case is handled by score being 0\n\n        # Use the appropriate threshold based on the active weight set\n        threshold_key \u003d \"scalping_signal_threshold\" if self.active_weight_set_name \u003d\u003d \"scalping\" else \"signal_score_threshold\"\n        default_threshold \u003d 2.5 if self.active_weight_set_name \u003d\u003d \"scalping\" else 1.5\n        try:\n            # Threshold applies to the *non-normalized* score (sum of weighted scores)\n            threshold \u003d Decimal(str(self.config.get(threshold_key, default_threshold)))\n        except (InvalidOperation, ValueError, TypeError):\n            threshold \u003d Decimal(str(default_threshold))\n            self.logger.warning(f\"Invalid threshold value for {threshold_key}. Using default: {threshold}\")\n\n        # Determine signal based on threshold\n        if final_signal_score \u003e\u003d threshold:\n            final_signal \u003d \"BUY\"\n        elif final_signal_score \u003c\u003d -threshold:\n            final_signal \u003d \"SELL\"\n\n        # --- Log Summary ---\n        price_prec \u003d self.get_price_precision_digits()\n        score_details_str \u003d \", \".join([f\"{k}: {v}\" for k, v in debug_scores.items() if v not in [\"Disabled\", \"No Weight\", \"Weight\u003d0\"]]) # Show only relevant scores\n        log_msg \u003d ( f\"Signal Calc ({self.symbol} @ {current_price_dec:.{price_prec}f}): \"\n                    f\"Set\u003d\u0027{self.active_weight_set_name}\u0027, \"\n                    f\"Indis(Actv/NaN): {active_indicator_count}/{nan_indicator_count}, \"\n                    f\"TotalAbsWt: {total_weight_applied:.3f}, \"\n                    f\"RawScore: {final_signal_score:.4f}, NormScore: {normalized_score:.4f}, \"\n                    f\"Threshold: +/-{threshold:.3f} -\u003e \"\n                    f\"Signal: {NEON_GREEN if final_signal \u003d\u003d \u0027BUY\u0027 else NEON_RED if final_signal \u003d\u003d \u0027SELL\u0027 else NEON_YELLOW}{final_signal}{RESET}\")\n        self.logger.info(log_msg)\n        if nan_indicator_count \u003e 0 or active_indicator_count \u003d\u003d 0:\n             self.logger.debug(f\"  Detailed Scores: {debug_scores}\") # Log all scores if issues\n\n        # Update internal signal state\n        if final_signal in self.signals:\n            self.signals[final_signal] \u003d 1\n            if final_signal !\u003d \"HOLD\": self.signals[\"HOLD\"] \u003d 0\n\n        return final_signal\n\n    # --- Risk Management Calculations ---\n    def calculate_entry_tp_sl(\n        self, entry_price: Decimal, signal: str\n    ) -\u003e Tuple[Optional[Decimal], Optional[Decimal], Optional[Decimal]]:\n        \"\"\"\n        Calculates potential TP and initial SL based on entry, ATR, config, quantized to tick size.\n        Returns (quantized_entry, quantized_tp, quantized_sl). Entry price is also quantized.\n        \"\"\"\n        quantized_entry, take_profit, stop_loss \u003d None, None, None\n        if signal not in [\"BUY\", \"SELL\"] or entry_price is None or not entry_price.is_finite() or entry_price \u003c\u003d 0:\n            self.logger.error(f\"Invalid input for TP/SL calc: Signal\u003d{signal}, Entry\u003d{entry_price}\")\n            return None, None, None\n\n        # Quantize entry price first (use rounding appropriate for side?) - Use default rounding for entry itself\n        quantized_entry \u003d self.quantize_price(entry_price, rounding\u003dROUND_DOWN) # Quantize entry down generally\n        if quantized_entry is None:\n             self.logger.error(f\"Failed to quantize entry price {entry_price} for TP/SL calc.\")\n             return None, None, None\n\n        atr_val \u003d self.indicator_values.get(\"ATR\")\n        if atr_val is None or not atr_val.is_finite() or atr_val \u003c\u003d 0:\n            self.logger.warning(f\"Cannot calculate TP/SL for {self.symbol}: Invalid ATR ({atr_val}).\")\n            return quantized_entry, None, None # Return quantized entry, but no SL/TP\n\n        try:\n            atr \u003d atr_val # Already Decimal\n            tp_mult \u003d Decimal(str(self.config.get(\"take_profit_multiple\", 1.0)))\n            sl_mult \u003d Decimal(str(self.config.get(\"stop_loss_multiple\", 1.5)))\n            min_tick \u003d self.get_min_tick_size() # Already checked in quantize_price, but check again\n\n            if min_tick is None: # Should not happen if entry quantization worked\n                self.logger.error(f\"Cannot calculate TP/SL for {self.symbol}: Min tick size missing after entry quantization.\")\n                return quantized_entry, None, None\n\n            tp_offset \u003d atr * tp_mult; sl_offset \u003d atr * sl_mult\n\n            # Calculate raw TP/SL based on *quantized* entry\n            if signal \u003d\u003d \"BUY\":\n                tp_raw \u003d quantized_entry + tp_offset; sl_raw \u003d quantized_entry - sl_offset\n                # Quantize TP UP (away from entry), SL DOWN (away from entry)\n                take_profit \u003d self.quantize_price(tp_raw, rounding\u003dROUND_UP)\n                stop_loss \u003d self.quantize_price(sl_raw, rounding\u003dROUND_DOWN)\n            elif signal \u003d\u003d \"SELL\":\n                tp_raw \u003d quantized_entry - tp_offset; sl_raw \u003d quantized_entry + sl_offset\n                # Quantize TP DOWN (away from entry), SL UP (away from entry)\n                take_profit \u003d self.quantize_price(tp_raw, rounding\u003dROUND_DOWN)\n                stop_loss \u003d self.quantize_price(sl_raw, rounding\u003dROUND_UP)\n\n            # --- Validation ---\n            if stop_loss is not None:\n                 # Ensure SL is strictly beyond entry by \u003e\u003d 1 tick\n                 if signal \u003d\u003d \"BUY\" and stop_loss \u003e\u003d quantized_entry:\n                     stop_loss \u003d self.quantize_price(quantized_entry - min_tick, rounding\u003dROUND_DOWN)\n                     self.logger.debug(f\"Adjusted BUY SL below entry: {stop_loss}\")\n                 elif signal \u003d\u003d \"SELL\" and stop_loss \u003c\u003d quantized_entry:\n                     stop_loss \u003d self.quantize_price(quantized_entry + min_tick, rounding\u003dROUND_UP)\n                     self.logger.debug(f\"Adjusted SELL SL above entry: {stop_loss}\")\n                 # Ensure SL is positive\n                 if stop_loss \u003c\u003d 0:\n                     self.logger.error(f\"Calculated SL is zero/negative ({stop_loss}). Setting SL to None.\"); stop_loss \u003d None\n\n            if take_profit is not None:\n                 # Ensure TP is strictly beyond entry by \u003e\u003d 1 tick\n                 if signal \u003d\u003d \"BUY\" and take_profit \u003c\u003d quantized_entry:\n                     take_profit \u003d self.quantize_price(quantized_entry + min_tick, rounding\u003dROUND_UP)\n                     self.logger.debug(f\"Adjusted BUY TP above entry: {take_profit}\")\n                 elif signal \u003d\u003d \"SELL\" and take_profit \u003e\u003d quantized_entry:\n                     take_profit \u003d self.quantize_price(quantized_entry - min_tick, rounding\u003dROUND_DOWN)\n                     self.logger.debug(f\"Adjusted SELL TP below entry: {take_profit}\")\n                 # Ensure TP is positive\n                 if take_profit \u003c\u003d 0:\n                     self.logger.error(f\"Calculated TP is zero/negative ({take_profit}). Setting TP to None.\"); take_profit \u003d None\n\n\n            # --- Log Results ---\n            prec \u003d self.get_price_precision_digits()\n            tp_log \u003d f\"{take_profit:.{prec}f}\" if take_profit else \u0027N/A\u0027\n            sl_log \u003d f\"{stop_loss:.{prec}f}\" if stop_loss else \u0027N/A\u0027\n            entry_log \u003d f\"{quantized_entry:.{prec}f}\"\n            atr_log \u003d f\"{atr:.{prec+1}f}\" # Show ATR with slightly more precision\n\n            self.logger.info(f\"Calculated TP/SL for {self.symbol} {signal}: Entry\u003d{entry_log}, TP\u003d{tp_log}, SL\u003d{sl_log} (ATR\u003d{atr_log})\")\n            return quantized_entry, take_profit, stop_loss\n\n        except (InvalidOperation, ValueError, TypeError, Exception) as e:\n            self.logger.error(f\"{NEON_RED}Error calculating TP/SL for {self.symbol}: {e}{RESET}\", exc_info\u003dTrue)\n            # traceback.print_exc()\n            return quantized_entry, None, None # Return quantized entry on error, but no TP/SL\n\n# --- Position Sizing ---\ndef calculate_position_size(\n    balance: Decimal,\n    risk_per_trade: float, # Expect float 0.01 for 1%\n    entry_price: Decimal,\n    stop_loss_price: Decimal,\n    market_info: Dict,\n    leverage: int, # Pass configured leverage\n    logger: logging.Logger\n) -\u003e Optional[Decimal]:\n    \"\"\"Calculates position size based on balance, risk %, SL distance, market limits, and leverage.\"\"\"\n    lg \u003d logger\n    symbol \u003d market_info.get(\u0027symbol\u0027, \u0027N/A\u0027)\n    contract_size \u003d market_info.get(\u0027contract_size\u0027, Decimal(\u00271\u0027))\n    min_order_amount \u003d market_info.get(\u0027min_order_amount\u0027) # Decimal or None\n    min_order_cost \u003d market_info.get(\u0027min_order_cost\u0027) # Decimal or None\n    amount_digits \u003d market_info.get(\u0027amount_precision_digits\u0027) # Int or None\n    is_contract \u003d market_info.get(\u0027is_contract\u0027, False)\n    is_inverse \u003d market_info.get(\u0027inverse\u0027, False)\n\n    # Validate inputs\n    if balance \u003c\u003d 0:\n        lg.error(f\"Cannot calculate position size for {symbol}: Balance is zero or negative ({balance}).\")\n        return None\n    if entry_price \u003c\u003d 0 or stop_loss_price \u003c\u003d 0:\n        lg.error(f\"Cannot calculate position size for {symbol}: Entry ({entry_price}) or SL ({stop_loss_price}) is invalid.\")\n        return None\n    if entry_price \u003d\u003d stop_loss_price:\n        lg.error(f\"Cannot calculate position size for {symbol}: Entry and SL prices are identical.\")\n        return None\n    if amount_digits is None:\n         lg.error(f\"Cannot calculate position size for {symbol}: Amount precision digits not found.\")\n         return None\n    if risk_per_trade \u003c\u003d 0 or risk_per_trade \u003e\u003d 1:\n        lg.error(f\"Cannot calculate position size: Invalid risk_per_trade ({risk_per_trade}). Must be between 0 and 1.\")\n        return None\n    if leverage \u003c\u003d 0 and is_contract:\n         lg.error(f\"Cannot calculate position size for contract {symbol}: Leverage must be positive ({leverage}).\")\n         return None\n\n    try:\n        risk_amount_quote \u003d balance * Decimal(str(risk_per_trade)) # Risk amount in Quote currency (e.g., USDT)\n        sl_distance_points \u003d abs(entry_price - stop_loss_price)\n\n        # Calculate value per point in Quote currency\n        # For linear contracts (BASE/USDT): value per point \u003d contract_size (points are USDT)\n        # For inverse contracts (BASE/USD settled in BASE): value per point \u003d contract_size / entry_price (approx value of 1 point in BASE, need to convert to QUOTE)\n        # For spot: Not applicable directly, size is calculated differently (Amount \u003d RiskAmtQuote / SL_Distance_Quote)\n\n        if is_contract:\n            if is_inverse:\n                # Risk per contract in BASE currency \u003d sl_distance_points * contract_size / entry_price (approx)\n                # More accurately: Risk \u003d contract_size * abs(1/entry - 1/sl)\n                risk_per_contract_base \u003d contract_size * abs(Decimal(\u00271\u0027) / entry_price - Decimal(\u00271\u0027) / stop_loss_price)\n                # Convert risk per contract to QUOTE currency\n                risk_per_contract_quote \u003d risk_per_contract_base * entry_price # Approx conversion using entry price\n            else: # Linear contract\n                # Risk per contract in QUOTE currency \u003d sl_distance_points * contract_size\n                risk_per_contract_quote \u003d sl_distance_points * contract_size\n\n            if risk_per_contract_quote \u003c\u003d 0:\n                 lg.error(f\"Cannot calculate position size for {symbol}: Risk per contract is zero or negative ({risk_per_contract_quote}).\")\n                 return None\n\n            # Ideal size in contracts \u003d Total risk amount (Quote) / Risk per contract (Quote)\n            size_unquantized \u003d risk_amount_quote / risk_per_contract_quote\n        else: # Spot\n             # Ideal size in BASE currency \u003d Risk amount (Quote) / SL distance (Quote)\n             if sl_distance_points \u003c\u003d 0:\n                 lg.error(f\"Cannot calculate position size for spot {symbol}: SL distance is zero or negative.\")\n                 return None\n             size_unquantized \u003d risk_amount_quote / sl_distance_points\n\n\n        lg.debug(f\"Position Size Calc ({symbol}): Balance\u003d{balance:.2f}, RiskAmt\u003d{risk_amount_quote:.4f}, \"\n                 f\"SLDist\u003d{sl_distance_points}, Entry\u003d{entry_price}, SL\u003d{stop_loss_price}, \"\n                 f\"{\u0027RiskPerContrQuote\u003d\u0027+str(risk_per_contract_quote) if is_contract else \u0027\u0027}, \"\n                 f\"UnquantizedSize\u003d{size_unquantized:.8f}\")\n\n        # Quantize the size according to market rules (amount precision) - ROUND DOWN\n        step_size \u003d Decimal(\u00271\u0027) / (Decimal(\u002710\u0027) ** amount_digits)\n        quantized_size \u003d (size_unquantized / step_size).quantize(Decimal(\u00270\u0027), rounding\u003dROUND_DOWN) * step_size\n        # Format to correct digits just in case quantization resulted in tiny residual\n        quantized_size \u003d Decimal(f\"{quantized_size:.{amount_digits}f}\")\n\n        lg.debug(f\"Quantized Size ({symbol}): {quantized_size} (Step: {step_size})\")\n\n        # --- Validation against market limits and margin ---\n        if quantized_size \u003c\u003d 0:\n            lg.warning(f\"{NEON_YELLOW}Calculated position size ({quantized_size}) is zero after quantization for {symbol}. Cannot place trade.{RESET}\")\n            return None\n\n        # Check against minimum order amount\n        if min_order_amount is not None and quantized_size \u003c min_order_amount:\n            lg.warning(f\"{NEON_YELLOW}Calculated size {quantized_size} is below minimum order amount {min_order_amount} for {symbol}. Adjust risk or balance.{RESET}\")\n            return None\n\n        # Estimate order cost/margin required\n        order_value \u003d quantized_size * entry_price * (contract_size if is_inverse else Decimal(\u00271\u0027)) # Value in quote currency (approx for inverse)\n        margin_required \u003d order_value / Decimal(leverage) if is_contract else order_value # Margin for contracts, full value for spot\n\n        # Check against minimum order cost (if specified)\n        if min_order_cost is not None and order_value \u003c min_order_cost:\n            lg.warning(f\"{NEON_YELLOW}Estimated order value {order_value:.4f} is below minimum cost {min_order_cost} for {symbol}. Cannot place trade.{RESET}\")\n            return None\n\n        # Check if required margin exceeds available balance (basic check)\n        # Note: This doesn\u0027t account for existing positions or maintenance margin. Exchange check is final.\n        if margin_required \u003e balance:\n             lg.warning(f\"{NEON_YELLOW}Estimated margin required ({margin_required:.4f}) exceeds available balance ({balance:.4f}) for {symbol} at {leverage}x leverage. Cannot place trade.{RESET}\")\n             # Optionally, calculate max possible size based on balance and retry? For now, just fail.\n             # max_size_based_on_margin \u003d (balance * Decimal(leverage)) / (entry_price * (contract_size if is_inverse else Decimal(\u00271\u0027)))\n             # quantized_max_size \u003d ... quantize max_size_based_on_margin ...\n             # if quantized_max_size \u003e\u003d min_order_amount: lg.warning(\"Consider reducing risk % or leverage.\"); return quantized_max_size\n             return None\n\n\n        lg.info(f\"Calculated position size for {symbol}: {quantized_size}\")\n        return quantized_size\n\n    except (InvalidOperation, ValueError, TypeError, Exception) as e:\n        lg.error(f\"{NEON_RED}Error calculating position size for {symbol}: {e}{RESET}\", exc_info\u003dTrue)\n        # traceback.print_exc()\n        return None\n\n# --- CCXT Trading Action Wrappers ---\n\ndef fetch_positions_ccxt(exchange: ccxt.Exchange, symbol: str, logger: logging.Logger, market_info: Dict) -\u003e Optional[Dict]:\n    \"\"\"Fetches open position for a specific symbol using V5 API.\"\"\"\n    lg \u003d logger\n    category \u003d market_info.get(\u0027category\u0027)\n    market_id \u003d market_info.get(\u0027id\u0027, symbol) # Use the exchange\u0027s specific ID\n\n    if not category or category not in [\u0027linear\u0027, \u0027inverse\u0027]: # Positions only for derivatives\n        lg.debug(f\"Skipping position check for non-derivative symbol {symbol} (Category: {category})\")\n        return None\n    if not exchange.has.get(\u0027fetchPositions\u0027):\n         lg.error(f\"Exchange {exchange.id} does not support fetchPositions(). Cannot check position.\")\n         return None\n\n    try:\n        # Bybit V5 fetch_positions requires category and optionally symbol or settleCoin\n        params \u003d {\u0027category\u0027: category, \u0027symbol\u0027: market_id}\n        lg.debug(f\"Fetching positions for {symbol} (MarketID: {market_id}) with params: {params}\")\n\n        # Use safe_ccxt_call\n        all_positions \u003d safe_ccxt_call(exchange, \u0027fetch_positions\u0027, lg, symbols\u003d[symbol], params\u003dparams) # Request specific symbol if possible\n\n        if all_positions is None: # Error handled by safe_ccxt_call\n            lg.warning(f\"fetch_positions call returned None for {symbol}.\")\n            return None\n\n        # fetch_positions should return a list, potentially empty\n        if not isinstance(all_positions, list):\n            lg.error(f\"fetch_positions did not return a list for {symbol}. Response: {all_positions}\")\n            return None\n\n        # Filter for the specific symbol (double check, as API might return others)\n        # And ensure the position size is non-zero\n        for pos in all_positions:\n            if pos.get(\u0027symbol\u0027) \u003d\u003d symbol:\n                try:\n                     # Check \u0027contracts\u0027 (standard ccxt) or \u0027size\u0027 (Bybit V5 info)\n                     pos_size_str \u003d pos.get(\u0027contracts\u0027, pos.get(\u0027info\u0027, {}).get(\u0027size\u0027))\n                     if pos_size_str is None:\n                         lg.warning(f\"Position data for {symbol} missing size/contracts. Data: {pos}\")\n                         continue # Check next entry in list if any\n\n                     pos_size \u003d Decimal(str(pos_size_str))\n                     if pos_size !\u003d 0: # Check for non-zero size (can be negative for short)\n                          # Get side (\u0027long\u0027/\u0027short\u0027)\n                          pos_side \u003d pos.get(\u0027side\u0027)\n                          if pos_side is None: # Infer side from size if missing\n                              pos_side \u003d \u0027long\u0027 if pos_size \u003e 0 else \u0027short\u0027 if pos_size \u003c 0 else None\n\n                          if pos_side:\n                               pos[\u0027side\u0027] \u003d pos_side # Ensure side is set\n                               pos[\u0027contracts\u0027] \u003d abs(pos_size) # Ensure contracts is positive size\n                               lg.info(f\"Found active {pos_side} position for {symbol}: Size\u003d{abs(pos_size)}, Entry\u003d{pos.get(\u0027entryPrice\u0027)}\")\n                               # Add market info to position dict for convenience\n                               pos[\u0027market_info\u0027] \u003d market_info\n                               return pos\n                          else:\n                               lg.warning(f\"Position found for {symbol} but could not determine side (Size: {pos_size}).\")\n                               continue\n\n                     else:\n                          # Position exists but size is 0 (recently closed or error)\n                          lg.debug(f\"Position found for {symbol} but size is 0. Treating as no active position.\")\n                          # return None # Should continue checking list in case of hedge mode oddities\n\n                except (InvalidOperation, ValueError, TypeError, KeyError) as e:\n                     lg.error(f\"Could not parse position data for {symbol}: {e}. Data: {pos}\")\n                     # return None # Treat as error / no position\n\n        lg.debug(f\"No active non-zero position found for {symbol} after checking {len(all_positions)} results.\")\n        return None # No active position found for this specific symbol\n\n    except Exception as e:\n        lg.error(f\"{NEON_RED}Error fetching or processing positions for {symbol}: {e}{RESET}\", exc_info\u003dTrue)\n        # traceback.print_exc()\n        return None\n\ndef set_leverage_ccxt(exchange: ccxt.Exchange, symbol: str, leverage: int, logger: logging.Logger, market_info: Dict):\n    \"\"\"Sets leverage for a symbol using V5 API.\"\"\"\n    lg \u003d logger\n    category \u003d market_info.get(\u0027category\u0027)\n    market_id \u003d market_info.get(\u0027id\u0027, symbol)\n\n    if not category or category not in [\u0027linear\u0027, \u0027inverse\u0027]:\n        lg.debug(f\"Skipping leverage setting for non-derivative symbol {symbol} (Category: {category})\")\n        return True # Not applicable, treat as success\n    if not exchange.has.get(\u0027setLeverage\u0027):\n         lg.error(f\"Exchange {exchange.id} does not support setLeverage().\")\n         return False\n\n    # Check current leverage first (requires fetch_position) - Optional optimization\n    # current_pos \u003d fetch_positions_ccxt(exchange, symbol, logger, market_info)\n    # current_leverage \u003d int(current_pos.get(\u0027leverage\u0027, 0)) if current_pos else 0\n    # if current_leverage \u003d\u003d leverage:\n    #     lg.debug(f\"Leverage already set to {leverage}x for {symbol}.\")\n    #     return True\n\n    try:\n        # Bybit V5 requires buyLeverage and sellLeverage, set both to the same value\n        params \u003d {\n            \u0027category\u0027: category,\n            \u0027symbol\u0027: market_id, # Pass symbol in params for V5\n            \u0027buyLeverage\u0027: str(leverage),\n            \u0027sellLeverage\u0027: str(leverage)\n        }\n        lg.info(f\"Setting leverage for {symbol} (MarketID: {market_id}) to {leverage}x...\")\n        lg.debug(f\"Leverage Params: {params}\")\n        # CCXT\u0027s set_leverage should handle mapping to the correct V5 endpoint and params\n        result \u003d safe_ccxt_call(exchange, \u0027set_leverage\u0027, lg, leverage\u003dleverage, symbol\u003dsymbol, params\u003dparams)\n\n        # Check result if possible (CCXT might not return detailed info)\n        # Bybit V5 POST /v5/position/set-leverage returns {} on success (retCode 0)\n        # We rely on safe_ccxt_call not raising an exception\n        lg.info(f\"{NEON_GREEN}Leverage set successfully for {symbol} to {leverage}x (Result: {result}).{RESET}\")\n        return True\n    except ccxt.ExchangeError as e:\n         # Handle specific error code 110043: \"Set leverage not modified\"\n         bybit_code \u003d None\n         if hasattr(e, \u0027args\u0027) and len(e.args) \u003e 0:\n              try:\n                  error_details \u003d str(e.args[0])\n                  if \"retCode\" in error_details:\n                       details_dict \u003d json.loads(error_details[error_details.find(\u0027{\u0027):error_details.rfind(\u0027}\u0027)+1])\n                       bybit_code \u003d details_dict.get(\u0027retCode\u0027)\n              except Exception: pass\n         if bybit_code \u003d\u003d 110043:\n              lg.info(f\"Leverage already set to {leverage}x for {symbol} (Exchange code 110043).\")\n              return True\n         else:\n              lg.error(f\"{NEON_RED}Failed to set leverage for {symbol} to {leverage}x: {e} (Code: {bybit_code}){RESET}\", exc_info\u003dTrue)\n              # traceback.print_exc()\n              return False\n    except Exception as e:\n        lg.error(f\"{NEON_RED}Unexpected error setting leverage for {symbol} to {leverage}x: {e}{RESET}\", exc_info\u003dTrue)\n        # traceback.print_exc()\n        return False\n\ndef create_order_ccxt(\n    exchange: ccxt.Exchange,\n    symbol: str,\n    order_type: str, # \u0027market\u0027, \u0027limit\u0027\n    side: str,       # \u0027buy\u0027, \u0027sell\u0027\n    amount: Decimal,\n    price: Optional[Decimal] \u003d None, # Required for limit orders\n    params: Optional[Dict] \u003d None, # For extra params like reduceOnly, positionIdx, tpsl\n    logger: Optional[logging.Logger] \u003d None,\n    market_info: Optional[Dict] \u003d None\n) -\u003e Optional[Dict]:\n    \"\"\"Creates an order using safe_ccxt_call with V5 parameters and Decimal inputs.\"\"\"\n    lg \u003d logger or get_logger(\u0027main\u0027) # Use main logger if none provided\n    if not market_info:\n         lg.error(f\"Market info required for create_order_ccxt ({symbol})\")\n         return None\n\n    category \u003d market_info.get(\u0027category\u0027)\n    market_id \u003d market_info.get(\u0027id\u0027, symbol)\n    if not category:\n         lg.error(f\"Cannot determine category for {symbol}. Cannot place order.\")\n         return None\n\n    # Validate amount \u0026 price\n    if amount \u003c\u003d 0:\n         lg.error(f\"Order amount must be positive for {symbol}. Amount: {amount}\")\n         return None\n    if order_type.lower() \u003d\u003d \u0027limit\u0027:\n        if price is None or price \u003c\u003d 0:\n            lg.error(f\"Valid positive price parameter is required for limit orders ({symbol}). Price: {price}\")\n            return None\n        # Format price to string with correct precision (use quantize without rounding?)\n        price_digits \u003d market_info.get(\u0027price_precision_digits\u0027, 8)\n        price_str \u003d f\"{price:.{price_digits}f}\"\n    else:\n        price_str \u003d None # No price for market orders\n\n    # Format amount to string with correct precision\n    amount_digits \u003d market_info.get(\u0027amount_precision_digits\u0027, 8)\n    amount_str \u003d f\"{amount:.{amount_digits}f}\"\n\n\n    # Prepare base parameters for Bybit V5\n    # CCXT handles symbol mapping, but \u0027category\u0027 is often needed in params\n    order_params \u003d {\u0027category\u0027: category}\n\n    # Add position mode if needed (usually set account-wide, but can be specified)\n    # position_mode \u003d config.get(\"position_mode\", \"One-Way\") # Assume loaded elsewhere\n    # if position_mode \u003d\u003d \"Hedge\":\n    #     order_params[\u0027positionIdx\u0027] \u003d 1 if side \u003d\u003d \u0027buy\u0027 else 2\n    # else: # One-Way\n    #     order_params[\u0027positionIdx\u0027] \u003d 0\n\n    # Add user-provided params, potentially overriding base ones\n    if params:\n        order_params.update(params)\n        lg.debug(f\"Using additional order params: {params}\")\n\n    try:\n        lg.info(f\"Attempting to create {side.upper()} {order_type.upper()} order: {amount_str} {symbol} \"\n                f\"{\u0027@ \u0027+price_str if price_str else \u0027at Market\u0027}\")\n        lg.debug(f\"Final Order Params: {order_params}\")\n\n        # Convert Decimal amount/price to float for CCXT, as it often expects floats\n        amount_float \u003d float(amount_str)\n        price_float \u003d float(price_str) if price_str else None\n\n        order_result \u003d safe_ccxt_call(\n            exchange,\n            \u0027create_order\u0027,\n            lg,\n            symbol\u003dsymbol, # Use the standard symbol format CCXT expects\n            type\u003dorder_type,\n            side\u003dside,\n            amount\u003damount_float,\n            price\u003dprice_float,\n            params\u003dorder_params\n        )\n\n        if order_result and order_result.get(\u0027id\u0027):\n            # Bybit V5 create order response is nested in \u0027info\u0027\n            ret_code \u003d order_result.get(\u0027info\u0027, {}).get(\u0027retCode\u0027, -1)\n            ret_msg \u003d order_result.get(\u0027info\u0027, {}).get(\u0027retMsg\u0027, \u0027Unknown\u0027)\n            order_id \u003d order_result.get(\u0027id\u0027) # CCXT usually extracts the ID\n\n            if ret_code \u003d\u003d 0:\n                 lg.info(f\"{NEON_GREEN}Successfully created {side} {order_type} order for {symbol}. Order ID: {order_id}{RESET}\")\n                 # lg.debug(f\"Order Result: {order_result}\")\n                 return order_result # Return the parsed CCXT order structure\n            else:\n                 # Order was likely rejected by exchange despite API call success\n                 lg.error(f\"{NEON_RED}Order placement rejected by exchange for {symbol}. Code\u003d{ret_code}, Msg\u003d\u0027{ret_msg}\u0027. Order ID (if assigned): {order_id}{RESET}\")\n                 lg.debug(f\"Rejected Order Result: {order_result}\")\n                 return None # Indicate failure\n        elif order_result:\n             # Call succeeded but no order ID returned - unusual\n             lg.error(f\"Order placement call for {symbol} returned a result but no Order ID. Response: {order_result}\")\n             return None\n        else:\n            # safe_ccxt_call would have raised error if it failed after retries\n            lg.error(f\"Order placement call for {symbol} returned None unexpectedly (after retries).\")\n            return None\n\n    except Exception as e:\n        # Errors raised by safe_ccxt_call or validation steps\n        lg.error(f\"{NEON_RED}Failed to create order for {symbol}: {e}{RESET}\", exc_info\u003dTrue)\n        # traceback.print_exc()\n        return None\n\ndef set_protection_ccxt(\n    exchange: ccxt.Exchange,\n    symbol: str,\n    stop_loss_price: Optional[Decimal] \u003d None,\n    take_profit_price: Optional[Decimal] \u003d None,\n    trailing_stop_price: Optional[Decimal] \u003d None, # Bybit V5: Absolute distance value (price ticks)\n    trailing_active_price: Optional[Decimal] \u003d None, # Bybit V5: Activation price trigger\n    position_idx: int \u003d 0, # 0 for One-Way, 1 for Buy Hedge, 2 for Sell Hedge\n    logger: Optional[logging.Logger] \u003d None,\n    market_info: Optional[Dict] \u003d None\n) -\u003e bool:\n    \"\"\"Sets Stop Loss, Take Profit, and/or Trailing Stop using Bybit V5 position/trading-stop.\"\"\"\n    lg \u003d logger or get_logger(\u0027main\u0027)\n    if not market_info:\n         lg.error(f\"Market info required for set_protection_ccxt ({symbol})\")\n         return False\n\n    category \u003d market_info.get(\u0027category\u0027)\n    market_id \u003d market_info.get(\u0027id\u0027, symbol)\n    price_digits \u003d market_info.get(\u0027price_precision_digits\u0027, 8)\n\n    if not category or category not in [\u0027linear\u0027, \u0027inverse\u0027]:\n        lg.warning(f\"Cannot set SL/TP/TSL for non-derivative symbol {symbol} (Category: {category})\")\n        return False # Not applicable for Spot\n\n    # Check if the exchange explicitly supports this method via V5 endpoint\n    # This check might be complex. Assume \u0027private_post_position_trading_stop\u0027 is the target.\n    # We will call it directly using safe_ccxt_call.\n\n    params \u003d {\n        \u0027category\u0027: category,\n        \u0027symbol\u0027: market_id,\n        # \u0027positionIdx\u0027: position_idx, # Required for Hedge mode, optional for One-Way (defaults to 0)\n        # V5 requires tpslMode or specific order types. \u0027Full\u0027 targets the whole position.\n        \u0027tpslMode\u0027: \u0027Full\u0027,\n        # stopLoss, takeProfit, trailingStop, activePrice are the key V5 params\n    }\n    # Add positionIdx based on config/mode if necessary\n    # position_mode \u003d config.get(\"position_mode\", \"One-Way\")\n    # if position_mode \u003d\u003d \"Hedge\": params[\u0027positionIdx\u0027] \u003d position_idx # Use passed idx\n\n    log_parts \u003d []\n    # Format prices to strings with correct precision if provided\n    def format_price(price: Optional[Decimal]) -\u003e str:\n        if price is not None and price.is_finite() and price \u003e 0:\n            return f\"{price:.{price_digits}f}\"\n        return \"0\" # Send \"0\" or empty string to cancel/not set\n\n    sl_str \u003d format_price(stop_loss_price)\n    tp_str \u003d format_price(take_profit_price)\n    tsl_dist_str \u003d format_price(trailing_stop_price) # Trail distance treated as price value\n    tsl_act_str \u003d format_price(trailing_active_price)\n\n    params[\u0027stopLoss\u0027] \u003d sl_str\n    params[\u0027takeProfit\u0027] \u003d tp_str\n    params[\u0027trailingStop\u0027] \u003d tsl_dist_str\n    if tsl_dist_str !\u003d \"0\": # Only include activePrice if TSL is being set\n        params[\u0027activePrice\u0027] \u003d tsl_act_str\n\n    # Log the intended actions\n    if sl_str !\u003d \"0\": log_parts.append(f\"SL\u003d{sl_str}\")\n    if tp_str !\u003d \"0\": log_parts.append(f\"TP\u003d{tp_str}\")\n    if tsl_dist_str !\u003d \"0\": log_parts.append(f\"TSL_Dist\u003d{tsl_dist_str}\" + (f\", Act\u003d{tsl_act_str}\" if tsl_act_str !\u003d \"0\" else \", Act\u003dImmediate\"))\n\n    if not log_parts:\n        lg.warning(f\"No valid protection levels provided for set_protection_ccxt ({symbol}). Nothing to set.\")\n        # Return True as technically no setting failed, but nothing was done.\n        # Or False if expectation is that *something* should be set. Let\u0027s return True.\n        return True\n\n    try:\n        lg.info(f\"Setting protection for {symbol} (MarketID: {market_id}): {\u0027, \u0027.join(log_parts)}\")\n        lg.debug(f\"Protection Params: {params}\")\n\n        # Call the specific V5 endpoint directly via safe_ccxt_call\n        # Method name format might vary slightly in different ccxt versions, check exchange.has\n        # Assume \u0027privatePostPositionTradingStop\u0027 or similar is available internally in ccxt\n        method_to_call \u003d \u0027private_post_position_trading_stop\u0027 # Check ccxt source or exchange.has if unsure\n        result \u003d safe_ccxt_call(exchange, method_to_call, lg, params\u003dparams)\n\n        # Bybit V5 returns {\"retCode\": 0, \"retMsg\": \"OK\", ...} on success\n        if result and result.get(\u0027retCode\u0027) \u003d\u003d 0:\n            lg.info(f\"{NEON_GREEN}Successfully set protection for {symbol}.{RESET}\")\n            # lg.debug(f\"Protection Result: {result}\")\n            return True\n        elif result:\n            ret_code \u003d result.get(\u0027retCode\u0027, -1)\n            ret_msg \u003d result.get(\u0027retMsg\u0027, \u0027Unknown\u0027)\n            lg.error(f\"{NEON_RED}Failed to set protection for {symbol}. Exchange Response: Code\u003d{ret_code}, Msg\u003d\u0027{ret_msg}\u0027{RESET}\")\n            lg.debug(f\"Full protection result: {result}\")\n            return False\n        else:\n            # safe_ccxt_call failed after retries\n            lg.error(f\"Set protection call ({method_to_call}) for {symbol} failed or returned None after retries.\")\n            return False\n\n    except Exception as e:\n        lg.error(f\"{NEON_RED}Failed to set protection for {symbol}: {e}{RESET}\", exc_info\u003dTrue)\n        # traceback.print_exc()\n        return False\n\ndef close_position_ccxt(\n    exchange: ccxt.Exchange,\n    symbol: str,\n    position_data: Dict, # Pass the fetched position data\n    logger: Optional[logging.Logger] \u003d None,\n    market_info: Optional[Dict] \u003d None\n) -\u003e Optional[Dict]:\n    \"\"\"Closes an existing position by placing a market order in the opposite direction with reduceOnly.\"\"\"\n    lg \u003d logger or get_logger(\u0027main\u0027)\n    if not market_info:\n         lg.error(f\"Market info required for close_position_ccxt ({symbol})\")\n         return None\n    if not position_data:\n         lg.error(f\"Position data required for close_position_ccxt ({symbol})\")\n         return None\n\n    try:\n        # Use Decimal for size\n        pos_size_str \u003d position_data.get(\u0027contracts\u0027, position_data.get(\u0027info\u0027, {}).get(\u0027size\u0027)) # Prefer \u0027contracts\u0027 if available\n        position_side \u003d position_data.get(\u0027side\u0027) # \u0027long\u0027 or \u0027short\u0027\n\n        if pos_size_str is None or position_side is None:\n             lg.error(f\"Missing size or side in position data for closing {symbol}. Data: {position_data}\")\n             return None\n\n        position_size \u003d Decimal(str(pos_size_str))\n        # Ensure size is positive absolute value for order placement\n        amount_to_close \u003d abs(position_size)\n\n        if amount_to_close \u003c\u003d 0:\n            lg.warning(f\"Attempted to close position for {symbol}, but parsed size is {position_size}. No action needed.\")\n            return None # No position to close\n\n        close_side \u003d \u0027sell\u0027 if position_side \u003d\u003d \u0027long\u0027 else \u0027buy\u0027\n\n        lg.info(f\"Attempting to close {position_side} position for {symbol} (Size: {amount_to_close}) by placing a {close_side} MARKET order...\")\n\n        # Add reduceOnly flag to ensure it only closes the position\n        # Bybit V5 uses \u0027reduceOnly\u0027: True\n        params \u003d {\n            \u0027reduceOnly\u0027: True,\n            # Add positionIdx if using Hedge Mode based on the position being closed\n            # \u0027positionIdx\u0027: position_data.get(\u0027info\u0027, {}).get(\u0027positionIdx\u0027, 0) # Get from position info if possible\n        }\n        # position_mode \u003d config.get(\"position_mode\", \"One-Way\")\n        # if position_mode \u003d\u003d \"Hedge\":\n        #      idx \u003d position_data.get(\u0027info\u0027,{}).get(\u0027positionIdx\u0027)\n        #      if idx is not None: params[\u0027positionIdx\u0027] \u003d idx\n\n\n        close_order \u003d create_order_ccxt(\n            exchange\u003dexchange,\n            symbol\u003dsymbol,\n            order_type\u003d\u0027market\u0027,\n            side\u003dclose_side,\n            amount\u003damount_to_close, # Pass the positive Decimal amount\n            params\u003dparams,\n            logger\u003dlg,\n            market_info\u003dmarket_info\n        )\n\n        if close_order and close_order.get(\u0027id\u0027):\n            lg.info(f\"{NEON_GREEN}Successfully placed MARKET order to close position for {symbol}. Close Order ID: {close_order.get(\u0027id\u0027)}{RESET}\")\n            # Note: Market order execution isn\u0027t guaranteed instantly.\n            # Further checks might be needed to confirm closure (e.g., re-fetch position).\n            return close_order # Return the order info dict\n        else:\n            lg.error(f\"{NEON_RED}Failed to place market order to close position for {symbol}. Check logs above.{RESET}\")\n            return None\n\n    except (InvalidOperation, ValueError, TypeError, KeyError) as e:\n         lg.error(f\"Error parsing position data for closing {symbol}: {e}. Position Data: {position_data}\", exc_info\u003dTrue)\n         return None\n    except Exception as e:\n        lg.error(f\"{NEON_RED}Error attempting to close position for {symbol}: {e}{RESET}\", exc_info\u003dTrue)\n        # traceback.print_exc()\n        return None\n\n# --- Main Bot Logic ---\ndef run_bot(exchange: ccxt.Exchange, config: Dict[str, Any], bot_state: Dict[str, Any]):\n    \"\"\"Main bot execution loop.\"\"\"\n    main_logger \u003d get_logger(\u0027main\u0027)\n    main_logger.info(f\"{NEON_CYAN}\u003d\u003d\u003d Starting Enhanced Trading Bot \u003d\u003d\u003d{RESET}\")\n    main_logger.info(f\"Trading Enabled: {config.get(\u0027enable_trading\u0027)}\")\n    main_logger.info(f\"Sandbox Mode: {config.get(\u0027use_sandbox\u0027)}\")\n    main_logger.info(f\"Symbols: {config.get(\u0027symbols\u0027)}\")\n    main_logger.info(f\"Interval: {config.get(\u0027interval\u0027)}\")\n    main_logger.info(f\"Risk Per Trade: {config.get(\u0027risk_per_trade\u0027)*100:.2f}%\")\n    main_logger.info(f\"Leverage: {config.get(\u0027leverage\u0027)}x\")\n    main_logger.info(f\"Max Concurrent Positions: {config.get(\u0027max_concurrent_positions_total\u0027)}\")\n    main_logger.info(f\"Position Mode: {config.get(\u0027position_mode\u0027)}\")\n    main_logger.info(f\"Active Weight Set: {config.get(\u0027active_weight_set\u0027)}\")\n    main_logger.info(f\"Quote Currency: {QUOTE_CURRENCY}\")\n\n    global LOOP_DELAY_SECONDS\n    try:\n        LOOP_DELAY_SECONDS \u003d int(config.get(\"loop_delay\", DEFAULT_LOOP_DELAY_SECONDS))\n        if LOOP_DELAY_SECONDS \u003c 5: # Add minimum delay sanity check\n             main_logger.warning(f\"Loop delay {LOOP_DELAY_SECONDS}s is very short. Increasing to 5s.\")\n             LOOP_DELAY_SECONDS \u003d 5\n    except (ValueError, TypeError):\n        main_logger.error(f\"Invalid loop_delay value in config. Using default: {DEFAULT_LOOP_DELAY_SECONDS}s\")\n        LOOP_DELAY_SECONDS \u003d DEFAULT_LOOP_DELAY_SECONDS\n\n\n    symbols_to_trade \u003d config.get(\"symbols\", [])\n    if not symbols_to_trade or not isinstance(symbols_to_trade, list):\n        main_logger.error(\"No valid \u0027symbols\u0027 list configured in config.json. Exiting.\")\n        return\n\n    # Initialize state for each symbol if not present\n    for symbol in symbols_to_trade:\n        if symbol not in bot_state:\n            bot_state[symbol] \u003d {\n                \"break_even_triggered\": False,\n                \"last_signal\": \"HOLD\",\n                \"last_entry_price\": None, # Store entry price for BE reference if needed\n                # Add other state variables as needed (e.g., last order time, consecutive losses)\n            }\n        # Ensure necessary keys exist even if state was loaded\n        if \"break_even_triggered\" not in bot_state[symbol]: bot_state[symbol][\"break_even_triggered\"] \u003d False\n        if \"last_signal\" not in bot_state[symbol]: bot_state[symbol][\"last_signal\"] \u003d \"HOLD\"\n        if \"last_entry_price\" not in bot_state[symbol]: bot_state[symbol][\"last_entry_price\"] \u003d None\n\n\n    cycle_count \u003d 0\n    while True:\n        cycle_count +\u003d 1\n        start_time \u003d time.time()\n        main_logger.info(f\"{NEON_BLUE}--- Starting Bot Cycle {cycle_count} ---{RESET}\")\n\n        # --- Pre-Cycle Checks ---\n        # Fetch balance once per cycle (if trading enabled)\n        current_balance: Optional[Decimal] \u003d None\n        if config.get(\"enable_trading\"):\n            try:\n                current_balance \u003d fetch_balance(exchange, QUOTE_CURRENCY, main_logger)\n                if current_balance is None:\n                    main_logger.error(f\"{NEON_RED}Failed to fetch {QUOTE_CURRENCY} balance. Trading actions will be skipped this cycle.{RESET}\")\n                    # Continue loop, but trading actions will fail safe later\n                # else: # Balance logged by fetch_balance on success\n            except Exception as e:\n                 main_logger.error(f\"Error fetching balance at start of cycle: {e}\", exc_info\u003dTrue)\n                 # traceback.print_exc()\n\n        # Fetch currently open positions across all monitored symbols\n        open_positions_count \u003d 0\n        active_positions: Dict[str, Dict] \u003d {} # Store fetched active positions {symbol: position_data}\n        main_logger.debug(\"Fetching positions for all configured symbols...\")\n        for symbol in symbols_to_trade:\n            # Need market info to fetch positions correctly\n            temp_logger \u003d get_logger(symbol, is_symbol_logger\u003dTrue) # Use symbol logger\n            market_info \u003d get_market_info(exchange, symbol, temp_logger)\n            if not market_info:\n                 temp_logger.error(f\"Cannot fetch position for {symbol}: Failed to get market info.\")\n                 continue # Skip symbol if market info fails\n\n            # Only fetch if it\u0027s a contract market\n            if market_info.get(\u0027is_contract\u0027):\n                position \u003d fetch_positions_ccxt(exchange, symbol, temp_logger, market_info)\n                if position and position.get(\u0027contracts\u0027, Decimal(\u00270\u0027)) !\u003d Decimal(\u00270\u0027):\n                    # Position size check already done in fetch_positions_ccxt\n                    open_positions_count +\u003d 1\n                    active_positions[symbol] \u003d position # Store for later use\n                    # Update state with entry price if position exists and state doesn\u0027t have it\n                    if bot_state[symbol].get(\"last_entry_price\") is None:\n                         entry_p_str \u003d position.get(\u0027entryPrice\u0027)\n                         if entry_p_str is not None:\n                              try: bot_state[symbol][\"last_entry_price\"] \u003d str(Decimal(entry_p_str)) # Store as string\n                              except: pass\n            else:\n                 temp_logger.debug(f\"Skipping position fetch for non-contract symbol: {symbol}\")\n\n\n        max_allowed_positions \u003d int(config.get(\"max_concurrent_positions_total\", 1))\n        main_logger.info(f\"Currently open positions: {open_positions_count} / {max_allowed_positions}\")\n\n        # --- Symbol Processing Loop ---\n        for symbol in symbols_to_trade:\n            symbol_logger \u003d get_logger(symbol, is_symbol_logger\u003dTrue)\n            symbol_logger.info(f\"--- Processing Symbol: {symbol} ---\")\n            symbol_state \u003d bot_state[symbol] # Get mutable state for this symbol\n\n            try:\n                # 1. Get Market Info (already fetched for position check, but get again for consistency?)\n                # Let\u0027s re-fetch to ensure freshness within the symbol loop\n                market_info \u003d get_market_info(exchange, symbol, symbol_logger)\n                if not market_info:\n                    symbol_logger.error(f\"Failed to get market info for {symbol}. Skipping this cycle.\")\n                    continue\n\n                # 2. Fetch Data (Klines, Price, Orderbook)\n                timeframe \u003d config.get(\"interval\", \"5\")\n                if timeframe not in CCXT_INTERVAL_MAP:\n                    symbol_logger.error(f\"Invalid interval \u0027{timeframe}\u0027 in config for {symbol}. Skipping.\")\n                    continue\n\n                # Determine required kline limit based on longest indicator + buffer\n                periods \u003d [ # Collect all periods used\n                    int(config.get(p, d)) for p, d in [\n                        (\"atr_period\", DEFAULT_ATR_PERIOD),\n                        (\"ema_long_period\", DEFAULT_EMA_LONG_PERIOD),\n                        (\"rsi_period\", DEFAULT_RSI_WINDOW),\n                        (\"bollinger_bands_period\", DEFAULT_BOLLINGER_BANDS_PERIOD),\n                        (\"cci_window\", DEFAULT_CCI_WINDOW),\n                        (\"williams_r_window\", DEFAULT_WILLIAMS_R_WINDOW),\n                        (\"mfi_window\", DEFAULT_MFI_WINDOW),\n                        (\"stoch_rsi_window\", DEFAULT_STOCH_RSI_WINDOW),\n                        (\"stoch_rsi_rsi_window\", DEFAULT_STOCH_WINDOW),\n                        (\"sma_10_window\", DEFAULT_SMA_10_WINDOW),\n                        (\"momentum_period\", DEFAULT_MOMENTUM_PERIOD),\n                        (\"volume_ma_period\", DEFAULT_VOLUME_MA_PERIOD),\n                        (\"fibonacci_window\", DEFAULT_FIB_WINDOW),\n                    ] if int(config.get(p, d)) \u003e 0 # Only consider positive periods\n                ]\n                kline_limit \u003d max(periods) + 50 if periods else 150 # Longest period + buffer, or default 150\n\n                df \u003d fetch_klines_ccxt(exchange, symbol, timeframe, kline_limit, symbol_logger, market_info)\n                if df.empty or len(df) \u003c kline_limit / 2: # Check if we got significantly less than requested\n                    symbol_logger.warning(f\"Kline data unavailable or insufficient ({len(df)} rows) for {symbol}. Skipping analysis.\")\n                    continue\n\n                current_price_dec \u003d fetch_current_price_ccxt(exchange, symbol, symbol_logger, market_info)\n                if current_price_dec is None:\n                    symbol_logger.warning(f\"Current price unavailable for {symbol}. Skipping analysis.\")\n                    continue\n\n                orderbook \u003d None\n                if config.get(\"indicators\", {}).get(\"orderbook\"):\n                    try:\n                        orderbook \u003d fetch_orderbook_ccxt(exchange, symbol, int(config.get(\"orderbook_limit\", 25)), symbol_logger, market_info)\n                    except Exception as ob_err:\n                        symbol_logger.warning(f\"Failed to fetch orderbook for {symbol}: {ob_err}\")\n                    # Don\u0027t skip if orderbook fails, just proceed without it\n\n                # 3. Analyze Data\n                analyzer \u003d TradingAnalyzer(df, symbol_logger, config, market_info, symbol_state)\n\n                # 4. Check Existing Position \u0026 Manage\n                current_position \u003d active_positions.get(symbol) # Use position fetched at start of cycle\n\n                if current_position:\n                    pos_side \u003d current_position.get(\u0027side\u0027)\n                    pos_size_str \u003d current_position.get(\u0027contracts\u0027, current_position.get(\u0027info\u0027, {}).get(\u0027size\u0027))\n                    symbol_logger.info(f\"Managing existing {pos_side} position (Size: {pos_size_str}).\")\n                    # Pass necessary data to management function\n                    manage_existing_position(exchange, config, symbol_logger, analyzer, current_position, current_price_dec)\n                    # Note: manage_existing_position might close the position. We don\u0027t check for new entries immediately after.\n\n                # 5. Check for New Entry Signal (if no position OR if within limits - contract markets only)\n                elif market_info.get(\u0027is_contract\u0027) and open_positions_count \u003c max_allowed_positions:\n                    symbol_logger.info(\"No active position. Checking for entry signals...\")\n                    # Reset BE trigger state if no position exists\n                    if analyzer.break_even_triggered:\n                         symbol_logger.info(\"Resetting break-even triggered state as position no longer exists.\")\n                         analyzer.break_even_triggered \u003d False # Update via property setter\n                    if symbol_state.get(\"last_entry_price\") is not None:\n                         symbol_state[\"last_entry_price\"] \u003d None # Clear last entry price\n\n                    # Generate signal\n                    signal \u003d analyzer.generate_trading_signal(current_price_dec, orderbook)\n                    symbol_state[\"last_signal\"] \u003d signal # Store last signal\n\n                    if signal in [\"BUY\", \"SELL\"]:\n                        if config.get(\"enable_trading\"):\n                            if current_balance is not None and current_balance \u003e 0:\n                                 # Attempt to open a new position\n                                 opened_new \u003d attempt_new_entry(exchange, config, symbol_logger, analyzer, signal, current_price_dec, current_balance)\n                                 if opened_new:\n                                     open_positions_count +\u003d 1 # Increment count immediately\n                                     # State (like BE triggered) is reset inside attempt_new_entry or manage\n                                     # Store entry price in state\n                                     # TODO: Get actual entry price from order result if possible\n                                     approx_entry \u003d analyzer.quantize_price(current_price_dec) # Approximate entry\n                                     symbol_state[\"last_entry_price\"] \u003d str(approx_entry) if approx_entry else str(current_price_dec)\n                                     # Break inner loop to re-evaluate counts/balance? Maybe not needed if count updated.\n                            else:\n                                 symbol_logger.warning(f\"Trading enabled but balance is {current_balance}. Cannot enter {signal} trade.\")\n                        else: # Trading disabled\n                             symbol_logger.info(f\"Entry signal \u0027{signal}\u0027 generated but trading is disabled.\")\n                    # No else needed for HOLD signal\n\n                elif current_position is None and market_info.get(\u0027is_contract\u0027): # No position, but max positions reached\n                     symbol_logger.info(f\"Max concurrent positions ({open_positions_count}) reached. Skipping new entry check for {symbol}.\")\n                elif not market_info.get(\u0027is_contract\u0027): # Spot market\n                     symbol_logger.debug(f\"Spot market {symbol}. Entry logic currently focused on contracts. Skipping entry check.\")\n                     # TODO: Add specific spot entry logic if needed\n\n\n            except Exception as e:\n                symbol_logger.error(f\"{NEON_RED}!!! Unhandled error during cycle for {symbol}: {e} !!!{RESET}\", exc_info\u003dTrue)\n                # traceback.print_exc()\n\n            symbol_logger.info(f\"--- Finished Processing Symbol: {symbol} ---\")\n            # Small delay between symbols to potentially ease API load\n            time.sleep(0.2) # Reduced delay\n\n        # --- Post-Cycle ---\n        end_time \u003d time.time()\n        cycle_duration \u003d end_time - start_time\n        main_logger.info(f\"{NEON_BLUE}--- Bot Cycle {cycle_count} Finished (Duration: {cycle_duration:.2f}s) ---{RESET}\")\n\n        # Save state periodically (e.g., every cycle or less frequently)\n        save_state(STATE_FILE, bot_state, main_logger)\n\n        # Wait for the next cycle\n        wait_time \u003d max(0, LOOP_DELAY_SECONDS - cycle_duration)\n        if wait_time \u003e 0:\n            main_logger.info(f\"Waiting {wait_time:.2f}s for next cycle (Loop Delay: {LOOP_DELAY_SECONDS}s)...\")\n            time.sleep(wait_time)\n        else:\n            main_logger.warning(f\"Cycle duration ({cycle_duration:.2f}s) exceeded loop delay ({LOOP_DELAY_SECONDS}s). Starting next cycle immediately.\")\n\n\ndef manage_existing_position(\n    exchange: ccxt.Exchange,\n    config: Dict[str, Any],\n    logger: logging.Logger,\n    analyzer: TradingAnalyzer, # Provides access to indicators, market_info, state\n    position_data: Dict,\n    current_price_dec: Decimal\n):\n    \"\"\"Handles logic for managing an open position (BE, MA Cross Exit).\"\"\"\n    symbol \u003d position_data.get(\u0027symbol\u0027)\n    position_side \u003d position_data.get(\u0027side\u0027) # \u0027long\u0027 or \u0027short\u0027\n    entry_price_str \u003d position_data.get(\u0027entryPrice\u0027)\n    # Use absolute size from position_data if available\n    pos_size_str \u003d position_data.get(\u0027contracts\u0027, position_data.get(\u0027info\u0027, {}).get(\u0027size\u0027))\n    market_info \u003d analyzer.market_info # Get from analyzer\n    symbol_state \u003d analyzer.symbol_state # Get state dict\n\n    if not all([symbol, position_side, entry_price_str, pos_size_str]):\n        logger.error(f\"Incomplete position data for management: {position_data}\")\n        return\n\n    try:\n        entry_price \u003d Decimal(str(entry_price_str))\n        position_size \u003d Decimal(str(pos_size_str)) # This is absolute size\n        if position_size \u003c\u003d 0:\n             logger.warning(f\"Position size is {position_size} for {symbol} in management. Skipping.\")\n             return # Should not happen if called correctly\n\n        # --- 1. Check MA Cross Exit ---\n        if config.get(\"enable_ma_cross_exit\"):\n            ema_short_f \u003d analyzer._get_indicator_float(\"EMA_Short\")\n            ema_long_f \u003d analyzer._get_indicator_float(\"EMA_Long\")\n\n            if ema_short_f is not None and ema_long_f is not None:\n                is_adverse_cross \u003d False\n                # Check cross condition (using a small tolerance/hysteresis might be better)\n                tolerance \u003d 0.0001 # Example tolerance (adjust based on price scale)\n                if position_side \u003d\u003d \u0027long\u0027 and ema_short_f \u003c ema_long_f * (1 - tolerance):\n                    is_adverse_cross \u003d True\n                    logger.warning(f\"{NEON_YELLOW}MA Cross Exit Triggered (Long): Short EMA ({ema_short_f:.5f}) crossed below Long EMA ({ema_long_f:.5f}). Closing position.{RESET}\")\n                elif position_side \u003d\u003d \u0027short\u0027 and ema_short_f \u003e ema_long_f * (1 + tolerance):\n                    is_adverse_cross \u003d True\n                    logger.warning(f\"{NEON_YELLOW}MA Cross Exit Triggered (Short): Short EMA ({ema_short_f:.5f}) crossed above Long EMA ({ema_long_f:.5f}). Closing position.{RESET}\")\n\n                if is_adverse_cross and config.get(\"enable_trading\"):\n                    logger.info(\"Attempting to close position due to MA cross...\")\n                    close_result \u003d close_position_ccxt(exchange, symbol, position_data, logger, market_info)\n                    if close_result:\n                        # Reset state after closing attempt (assuming market order will fill)\n                        symbol_state[\"break_even_triggered\"] \u003d False\n                        symbol_state[\"last_signal\"] \u003d \"HOLD\" # Reset signal state\n                        symbol_state[\"last_entry_price\"] \u003d None\n                        logger.info(f\"Position close order placed for {symbol} due to MA Cross.\")\n                        return # Exit management logic as position is being closed\n                    else:\n                         logger.error(f\"Failed to place position close order for {symbol} after MA Cross trigger.\")\n                         # Continue with other checks? Or retry close? For now, continue.\n\n        # --- 2. Check Break-Even Trigger (Only if not already triggered) ---\n        if config.get(\"enable_break_even\") and not analyzer.break_even_triggered:\n            atr_val \u003d analyzer.indicator_values.get(\"ATR\") # Decimal\n            if atr_val is not None and atr_val.is_finite() and atr_val \u003e 0:\n                try:\n                    trigger_multiple \u003d Decimal(str(config.get(\"break_even_trigger_atr_multiple\", 1.0)))\n                    profit_target_points \u003d atr_val * trigger_multiple\n\n                    # Calculate current profit in price points\n                    current_profit_points \u003d Decimal(\u00270\u0027)\n                    if position_side \u003d\u003d \u0027long\u0027:\n                        current_profit_points \u003d current_price_dec - entry_price\n                    elif position_side \u003d\u003d \u0027short\u0027:\n                        current_profit_points \u003d entry_price - current_price_dec\n\n                    # Check if profit target is reached\n                    if current_profit_points \u003e\u003d profit_target_points:\n                        logger.info(f\"{NEON_GREEN}Break-Even Triggered for {symbol}!{RESET} Profit ({current_profit_points:.5f}) \u003e\u003d Target ({profit_target_points:.5f})\")\n\n                        # Calculate BE price (entry + offset)\n                        min_tick \u003d analyzer.get_min_tick_size()\n                        offset_ticks \u003d int(config.get(\"break_even_offset_ticks\", 2))\n\n                        if min_tick is not None and min_tick \u003e 0 and offset_ticks \u003e\u003d 0:\n                            offset_value \u003d min_tick * Decimal(offset_ticks)\n                            be_stop_price \u003d None\n                            if position_side \u003d\u003d \u0027long\u0027:\n                                be_stop_price_raw \u003d entry_price + offset_value\n                                # Quantize UP to ensure it\u0027s at least offset_ticks away / above entry\n                                be_stop_price \u003d analyzer.quantize_price(be_stop_price_raw, rounding\u003dROUND_UP)\n                                # Final check: ensure BE stop is strictly \u003e entry\n                                if be_stop_price is not None and be_stop_price \u003c\u003d entry_price:\n                                     be_stop_price \u003d analyzer.quantize_price(entry_price + min_tick, rounding\u003dROUND_UP)\n\n                            elif position_side \u003d\u003d \u0027short\u0027:\n                                be_stop_price_raw \u003d entry_price - offset_value\n                                # Quantize DOWN to ensure it\u0027s at least offset_ticks away / below entry\n                                be_stop_price \u003d analyzer.quantize_price(be_stop_price_raw, rounding\u003dROUND_DOWN)\n                                # Final check: ensure BE stop is strictly \u003c entry\n                                if be_stop_price is not None and be_stop_price \u003e\u003d entry_price:\n                                     be_stop_price \u003d analyzer.quantize_price(entry_price - min_tick, rounding\u003dROUND_DOWN)\n\n                            if be_stop_price is not None and be_stop_price \u003e 0:\n                                logger.info(f\"Calculated Break-Even Stop Price: {be_stop_price}\")\n                                # Set the new SL\n                                if config.get(\"enable_trading\"):\n                                    # Get current TP/TSL from position info to potentially preserve them\n                                    # Note: CCXT parsing might place these in \u0027info\u0027\n                                    pos_info \u003d position_data.get(\u0027info\u0027, {})\n                                    current_tp_str \u003d pos_info.get(\u0027takeProfit\u0027) # Check info dict first\n                                    if not current_tp_str: current_tp_str \u003d position_data.get(\u0027takeProfit\u0027) # Check top level\n                                    current_tsl_dist_str \u003d pos_info.get(\u0027trailingStop\u0027)\n                                    current_tsl_act_str \u003d pos_info.get(\u0027activePrice\u0027)\n\n                                    current_tp \u003d Decimal(current_tp_str) if current_tp_str and current_tp_str !\u003d \"0\" else None\n                                    current_tsl_dist \u003d Decimal(current_tsl_dist_str) if current_tsl_dist_str and current_tsl_dist_str !\u003d \"0\" else None\n                                    current_tsl_act \u003d Decimal(current_tsl_act_str) if current_tsl_act_str and current_tsl_act_str !\u003d \"0\" else None\n\n                                    # Decide whether to keep TSL or force fixed SL at BE\n                                    use_tsl \u003d config.get(\"enable_trailing_stop\") and not config.get(\"break_even_force_fixed_sl\")\n                                    tsl_to_set \u003d current_tsl_dist if use_tsl and current_tsl_dist else None\n                                    act_to_set \u003d current_tsl_act if use_tsl and tsl_to_set else None\n                                    tp_to_set \u003d current_tp # Always keep existing TP unless explicitly changed\n\n                                    logger.info(f\"Attempting to set BE SL\u003d{be_stop_price}\" + (f\", preserving TP\u003d{tp_to_set}\" if tp_to_set else \"\") + (f\", preserving TSL\u003d{tsl_to_set}\" if tsl_to_set else \"\") + (f\", removing TSL\" if not tsl_to_set and current_tsl_dist else \"\") )\n\n                                    # Get positionIdx if needed\n                                    pos_idx \u003d pos_info.get(\u0027positionIdx\u0027, 0)\n\n                                    success \u003d set_protection_ccxt(\n                                        exchange\u003dexchange,\n                                        symbol\u003dsymbol,\n                                        stop_loss_price\u003dbe_stop_price,\n                                        take_profit_price\u003dtp_to_set,\n                                        trailing_stop_price\u003dtsl_to_set,\n                                        trailing_active_price\u003dact_to_set,\n                                        position_idx\u003dpos_idx,\n                                        logger\u003dlogger,\n                                        market_info\u003dmarket_info\n                                    )\n                                    if success:\n                                        logger.info(f\"{NEON_GREEN}Successfully set break-even stop loss for {symbol}.{RESET}\")\n                                        analyzer.break_even_triggered \u003d True # Update state via property setter\n                                    else:\n                                        logger.error(f\"{NEON_RED}Failed to set break-even stop loss via API for {symbol}. State not updated.{RESET}\")\n                            else:\n                                 logger.error(f\"Calculated invalid break-even stop price ({be_stop_price}). Cannot set BE.\")\n                        else:\n                             logger.error(f\"Cannot calculate break-even offset for {symbol}: Invalid tick size ({min_tick}) or offset ticks ({offset_ticks}).\")\n                except (InvalidOperation, ValueError, TypeError) as e:\n                    logger.error(f\"Error during break-even calculation for {symbol}: {e}\")\n            else:\n                 logger.warning(f\"Cannot check break-even trigger for {symbol}: Invalid ATR ({atr_val}).\")\n\n\n        # --- 3. Add other management logic here ---\n        # (e.g., partial closes based on Fib levels, TSL adjustments if done manually)\n        # logger.debug(f\"Finished managing position for {symbol}.\")\n\n    except (InvalidOperation, ValueError, TypeError, KeyError) as e:\n        logger.error(f\"Error parsing position data during management for {symbol}: {e}. Data: {position_data}\", exc_info\u003dTrue)\n        # traceback.print_exc()\n    except Exception as e:\n        logger.error(f\"Unexpected error managing position for {symbol}: {e}\", exc_info\u003dTrue)\n        # traceback.print_exc()\n\n\ndef attempt_new_entry(\n    exchange: ccxt.Exchange,\n    config: Dict[str, Any],\n    logger: logging.Logger,\n    analyzer: TradingAnalyzer, # Provides access to indicators, market_info, state, quantization\n    signal: str, # \"BUY\" or \"SELL\"\n    entry_price_signal: Decimal, # Price at time of signal generation\n    current_balance: Decimal\n) -\u003e bool:\n    \"\"\"Attempts to calculate size, set leverage, place order, and set protection.\"\"\"\n    symbol \u003d analyzer.symbol\n    market_info \u003d analyzer.market_info\n    symbol_state \u003d analyzer.symbol_state\n\n    logger.info(f\"Attempting {signal} entry for {symbol} based on signal price {entry_price_signal:.{analyzer.get_price_precision_digits()}f}\")\n\n    # 1. Calculate Quantized Entry, TP, SL based on signal price and current ATR\n    quantized_entry, take_profit_price, stop_loss_price \u003d analyzer.calculate_entry_tp_sl(entry_price_signal, signal)\n\n    if quantized_entry is None:\n        logger.error(f\"Cannot enter {signal} trade for {symbol}: Failed to quantize entry price.\")\n        return False\n    if stop_loss_price is None:\n        logger.error(f\"Cannot enter {signal} trade for {symbol}: Failed to calculate a valid Stop Loss.\")\n        return False\n    # TP is optional, can proceed without it if None\n\n    # 2. Calculate Position Size\n    risk_per_trade \u003d float(config.get(\"risk_per_trade\", 0.01)) # Ensure float\n    leverage \u003d int(config.get(\"leverage\", 10)) # Ensure int\n    position_size \u003d calculate_position_size(\n        balance\u003dcurrent_balance,\n        risk_per_trade\u003drisk_per_trade,\n        entry_price\u003dquantized_entry, # Use quantized entry for sizing\n        stop_loss_price\u003dstop_loss_price,\n        market_info\u003dmarket_info,\n        leverage\u003dleverage,\n        logger\u003dlogger\n    )\n\n    if position_size is None or position_size \u003c\u003d 0:\n        logger.error(f\"Cannot enter {signal} trade for {symbol}: Failed to calculate a valid position size (Result: {position_size}).\")\n        return False\n\n    # 3. Set Leverage (do this before ordering, only for contracts)\n    if market_info.get(\u0027is_contract\u0027):\n        leverage_set \u003d set_leverage_ccxt(exchange, symbol, leverage, logger, market_info)\n        if not leverage_set:\n            logger.error(f\"Failed to set leverage for {symbol}. Aborting trade entry.\")\n            return False\n        # Add a small delay after setting leverage if needed by exchange\n        # time.sleep(0.5) # Optional short delay\n\n    # 4. Place Entry Order (Market Order for simplicity)\n    side \u003d \u0027buy\u0027 if signal \u003d\u003d \u0027BUY\u0027 else \u0027sell\u0027\n    # Use positionIdx\u003d0 for One-Way mode (default)\n    # For Hedge mode, would need logic here to determine 1 (buy) or 2 (sell)\n    entry_order_params \u003d {\n         # \u0027positionIdx\u0027: 0 # Default for One-Way\n    }\n    # position_mode \u003d config.get(\"position_mode\", \"One-Way\")\n    # if position_mode \u003d\u003d \"Hedge\": entry_order_params[\u0027positionIdx\u0027] \u003d 1 if side \u003d\u003d \u0027buy\u0027 else 2\n\n    entry_order \u003d create_order_ccxt(\n        exchange\u003dexchange,\n        symbol\u003dsymbol,\n        order_type\u003d\u0027market\u0027, # Consider using Limit orders slightly adjusted for better entry\n        side\u003dside,\n        amount\u003dposition_size, # Pass Decimal size\n        params\u003dentry_order_params,\n        logger\u003dlogger,\n        market_info\u003dmarket_info\n    )\n\n    if entry_order is None or not entry_order.get(\u0027id\u0027):\n        logger.error(f\"Failed to place entry market order for {symbol}. Aborting trade.\")\n        return False\n\n    # --- Entry Order Placed ---\n    order_id \u003d entry_order[\u0027id\u0027]\n    logger.info(f\"Entry order ({order_id}) placed successfully for {symbol}. Waiting {POSITION_CONFIRM_DELAY}s for confirmation/fill...\")\n    time.sleep(POSITION_CONFIRM_DELAY) # Wait for order to likely fill and position to appear\n\n    # 5. Fetch Actual Entry Price (More Robust) - Optional but Recommended\n    # Attempt to fetch the filled order or the updated position info\n    actual_entry_price \u003d quantized_entry # Default to calculated entry\n    filled_size \u003d position_size # Assume full fill for now\n    try:\n        # Option A: Fetch Order\n        # fetched_order \u003d safe_ccxt_call(exchange, \u0027fetch_order\u0027, logger, id\u003dorder_id, symbol\u003dsymbol, params\u003d{\u0027category\u0027: market_info.get(\u0027category\u0027)})\n        # if fetched_order and fetched_order.get(\u0027status\u0027) \u003d\u003d \u0027closed\u0027 and fetched_order.get(\u0027average\u0027):\n        #     actual_entry_price \u003d Decimal(str(fetched_order[\u0027average\u0027]))\n        #     filled_size \u003d Decimal(str(fetched_order.get(\u0027filled\u0027, position_size)))\n        #     logger.info(f\"Confirmed entry order filled. Actual Entry: {actual_entry_price}, Filled Size: {filled_size}\")\n        # else:\n        #     logger.warning(f\"Could not confirm entry order fill details via fetch_order. Using calculated entry price. Order status: {fetched_order.get(\u0027status\u0027) if fetched_order else \u0027N/A\u0027}\")\n\n        # Option B: Re-fetch Position (might be more reliable)\n        logger.debug(f\"Re-fetching position for {symbol} to confirm entry and get details...\")\n        time.sleep(1) # Extra short delay before fetching position\n        updated_position \u003d fetch_positions_ccxt(exchange, symbol, logger, market_info)\n        if updated_position and updated_position.get(\u0027entryPrice\u0027):\n             entry_p_str \u003d updated_position.get(\u0027entryPrice\u0027)\n             actual_entry_price \u003d Decimal(str(entry_p_str))\n             # Verify size matches expected (or is close)\n             current_size_str \u003d updated_position.get(\u0027contracts\u0027, updated_position.get(\u0027info\u0027,{}).get(\u0027size\u0027))\n             current_size \u003d Decimal(str(current_size_str)) if current_size_str else Decimal(\u00270\u0027)\n             filled_size \u003d abs(current_size) # Update filled size\n             logger.info(f\"Confirmed position update. Actual Entry: {actual_entry_price}, Current Size: {filled_size} (Expected: {position_size})\")\n             if abs(filled_size - position_size) / position_size \u003e Decimal(\u00270.01\u0027): # Check if fill size deviates significantly\n                   logger.warning(f\"Filled size {filled_size} differs significantly from ordered size {position_size}.\")\n                   # Adjust SL/TP based on actual filled size? Complex. For now, proceed with original plan.\n        else:\n             logger.warning(f\"Could not confirm entry details by re-fetching position. Using calculated entry price {actual_entry_price}.\")\n\n    except Exception as confirm_err:\n         logger.error(f\"Error confirming entry order/position details: {confirm_err}. Using calculated entry price {actual_entry_price}.\")\n         # traceback.print_exc()\n\n\n    # 6. Set SL/TP/TSL Protection using the *actual* or best-known entry price\n    tsl_distance \u003d None\n    tsl_activation_price \u003d None\n    if config.get(\"enable_trailing_stop\"):\n        try:\n            callback_rate \u003d Decimal(str(config.get(\"trailing_stop_callback_rate\", 0.005)))\n            activation_perc \u003d Decimal(str(config.get(\"trailing_stop_activation_percentage\", 0.003)))\n            min_tick \u003d analyzer.get_min_tick_size()\n\n            if callback_rate \u003e 0 and min_tick is not None and min_tick \u003e 0:\n                # Calculate absolute distance value based on actual entry price\n                tsl_distance_raw \u003d actual_entry_price * callback_rate\n                # Quantize distance UP to nearest tick (safer trail)\n                tsl_distance \u003d (tsl_distance_raw / min_tick).quantize(Decimal(\u00271\u0027), rounding\u003dROUND_UP) * min_tick\n\n                if tsl_distance \u003c min_tick: # Ensure trail is at least one tick\n                     tsl_distance \u003d min_tick\n                     logger.warning(f\"Calculated TSL distance {tsl_distance_raw} too small, adjusted to min tick: {tsl_distance}\")\n\n                # Calculate activation price if percentage \u003e 0\n                if activation_perc \u003e 0:\n                    activation_offset \u003d actual_entry_price * activation_perc\n                    tsl_activation_price_raw \u003d None\n                    if signal \u003d\u003d \"BUY\":\n                        tsl_activation_price_raw \u003d actual_entry_price + activation_offset\n                        # Quantize UP, away from entry\n                        tsl_activation_price \u003d analyzer.quantize_price(tsl_activation_price_raw, rounding\u003dROUND_UP)\n                        # Ensure activation is \u003e entry\n                        if tsl_activation_price is not None and tsl_activation_price \u003c\u003d actual_entry_price:\n                            tsl_activation_price \u003d analyzer.quantize_price(actual_entry_price + min_tick, rounding\u003dROUND_UP)\n                    else: # SELL\n                        tsl_activation_price_raw \u003d actual_entry_price - activation_offset\n                        # Quantize DOWN, away from entry\n                        tsl_activation_price \u003d analyzer.quantize_price(tsl_activation_price_raw, rounding\u003dROUND_DOWN)\n                         # Ensure activation is \u003c entry\n                        if tsl_activation_price is not None and tsl_activation_price \u003e\u003d actual_entry_price:\n                            tsl_activation_price \u003d analyzer.quantize_price(actual_entry_price - min_tick, rounding\u003dROUND_DOWN)\n\n                    # Ensure activation price is valid (positive)\n                    if tsl_activation_price is not None and tsl_activation_price \u003c\u003d 0: tsl_activation_price \u003d None\n\n                logger.debug(f\"Calculated TSL: Distance\u003d{tsl_distance}, ActivationPrice\u003d{tsl_activation_price} (based on entry {actual_entry_price})\")\n            else:\n                 logger.warning(\"Could not calculate TSL distance for {symbol} due to invalid rate ({callback_rate}) or tick size ({min_tick}).\")\n        except Exception as tsl_calc_err:\n            logger.error(f\"Error calculating TSL parameters for {symbol}: {tsl_calc_err}\", exc_info\u003dTrue)\n            # traceback.print_exc()\n\n\n    # Get positionIdx if needed\n    pos_idx \u003d 0\n    # if position_mode \u003d\u003d \"Hedge\": pos_idx \u003d 1 if side \u003d\u003d \u0027buy\u0027 else 2\n\n\n    protection_set \u003d set_protection_ccxt(\n        exchange\u003dexchange,\n        symbol\u003dsymbol,\n        stop_loss_price\u003dstop_loss_price, # Use originally calculated SL price\n        take_profit_price\u003dtake_profit_price, # Use originally calculated TP price\n        trailing_stop_price\u003dtsl_distance, # Use calculated TSL distance\n        trailing_active_price\u003dtsl_activation_price, # Use calculated TSL activation\n        position_idx\u003dpos_idx,\n        logger\u003dlogger,\n        market_info\u003dmarket_info\n    )\n\n    if not protection_set:\n        logger.error(f\"{NEON_RED}Failed to set initial SL/TP/TSL for {symbol} after entry! Position might be unprotected.{RESET}\")\n        # CRITICAL: Consider closing the position immediately if protection fails and trading is enabled\n        if config.get(\"enable_trading\"):\n            logger.warning(f\"Attempting emergency close of unprotected position {symbol}...\")\n            # Need position data again - re-fetch?\n            pos_to_close \u003d fetch_positions_ccxt(exchange, symbol, logger, market_info)\n            if pos_to_close:\n                 close_position_ccxt(exchange, symbol, pos_to_close, logger, market_info)\n            else:\n                 logger.error(f\"Could not fetch position data to perform emergency close for {symbol}.\")\n        return False # Indicate overall entry failure\n\n    logger.info(f\"{NEON_GREEN}Successfully entered {signal} trade for {symbol} with protection.{RESET}\")\n    # Reset BE state for the new trade\n    symbol_state[\"break_even_triggered\"] \u003d False\n    symbol_state[\"last_entry_price\"] \u003d str(actual_entry_price) # Store actual entry price string\n    return True # Indicate success\n\n\n# --- Main Execution ---\nif __name__ \u003d\u003d \"__main__\":\n    parser \u003d argparse.ArgumentParser(description\u003d\"Enhanced Bybit V5 Multi-Symbol Trading Bot\")\n    parser.add_argument(\n        \"--config\", type\u003dstr, default\u003dCONFIG_FILE, help\u003df\"Path to configuration file (default: {CONFIG_FILE})\"\n    )\n    parser.add_argument(\n        \"--state\", type\u003dstr, default\u003dSTATE_FILE, help\u003df\"Path to state file (default: {STATE_FILE})\"\n    )\n    parser.add_argument(\n        \"--symbol\", \"--symbols\", dest\u003d\"symbols\", type\u003dstr, help\u003d\"Override symbols in config: trade only specified symbol(s), comma-separated (e.g., BTC/USDT:USDT,ETH/USDT:USDT)\"\n    )\n    parser.add_argument(\n        \"--live\", action\u003d\"store_true\", help\u003d\"Enable live trading (overrides config \u0027enable_trading\u003dfalse\u0027 and \u0027use_sandbox\u003dtrue\u0027)\"\n    )\n    parser.add_argument(\n        \"--debug\", action\u003d\"store_true\", help\u003d\"Enable DEBUG level logging to console\"\n    )\n    args \u003d parser.parse_args()\n\n    # Set console log level based on args BEFORE setting up loggers\n    if args.debug:\n        console_log_level \u003d logging.DEBUG\n        print(\"DEBUG logging enabled for console.\")\n    else:\n        console_log_level \u003d logging.INFO\n\n    # Setup main logger first using the determined level\n    main_logger \u003d get_logger(\u0027main\u0027)\n    main_logger.info(\" --- Bot Starting --- \")\n\n    # Load configuration\n    config \u003d load_config(args.config)\n\n    # Override symbols if specified via command line\n    if args.symbols:\n        override_symbols \u003d [s.strip() for s in args.symbols.split(\u0027,\u0027) if s.strip()]\n        if override_symbols:\n             main_logger.warning(f\"{NEON_YELLOW}Overriding config symbols via command line. Trading ONLY: {override_symbols}{RESET}\")\n             config[\"symbols\"] \u003d override_symbols\n        else:\n             main_logger.error(\"Empty symbol list provided via command line override. Check --symbols argument.\")\n             sys.exit(1)\n\n\n    # Override trading mode and sandbox if --live flag is set\n    if args.live:\n        main_logger.warning(f\"{NEON_RED}--- LIVE TRADING ENABLED via command line override! ---{RESET}\")\n        if config.get(\"enable_trading\", False) is False:\n             main_logger.warning(\"Overriding config \u0027enable_trading\u003dfalse\u0027.\")\n             config[\"enable_trading\"] \u003d True\n        if config.get(\"use_sandbox\", True) is True:\n             main_logger.warning(\"Overriding config \u0027use_sandbox\u003dtrue\u0027.\")\n             config[\"use_sandbox\"] \u003d False\n    # Log final effective trading/sandbox mode\n    elif config.get(\"enable_trading\"):\n         main_logger.warning(f\"{NEON_RED}--- Live trading enabled via config file ---{RESET}\")\n    else:\n         main_logger.info(\"Live trading disabled.\")\n    if config.get(\"use_sandbox\"):\n         main_logger.warning(f\"{NEON_YELLOW}Sandbox mode (testnet) is ACTIVE.{RESET}\")\n    else:\n         main_logger.warning(f\"{NEON_RED}Sandbox mode is INACTIVE (using real exchange).{RESET}\")\n\n\n    # Load state\n    bot_state \u003d load_state(args.state, main_logger)\n\n    # Initialize exchange\n    exchange \u003d initialize_exchange(config, main_logger)\n\n    # --- Run Bot ---\n    if exchange:\n        main_logger.info(f\"{NEON_GREEN}Exchange initialized successfully. Starting main loop...{RESET}\")\n        try:\n            run_bot(exchange, config, bot_state)\n        except KeyboardInterrupt:\n            main_logger.info(\"Bot stopped by user (KeyboardInterrupt).\")\n        except Exception as e:\n            main_logger.critical(f\"{NEON_RED}!!! BOT CRASHED due to unhandled exception in main loop: {e} !!!{RESET}\", exc_info\u003dTrue)\n            # traceback.print_exc() # Ensure traceback is printed\n        finally:\n            # Save state on exit, regardless of reason\n            main_logger.info(\"Attempting to save final state...\")\n            save_state(args.state, bot_state, main_logger)\n            main_logger.info(\"--- Bot Shutdown ---\")\n    else:\n        main_logger.critical(\"Failed to initialize exchange. Bot cannot start.\")\n\n    logging.shutdown() # Ensure all logs are flushed before exit\n    print(\"Bot execution finished.\")\n    sys.exit(0 if exchange else 1) # Exit with error code if exchange failed init\n\n```",
      "role": "model",
      "finishReason": "STOP",
      "tokenCount": 50141
    }, {
      "text": "does this use correct endpoints",
      "role": "user",
      "tokenCount": 6
    }, {
      "text": "Here\u0027s a thinking process to analyze the endpoint usage in the generated Python bot code:\n\n1.  **Understand the Goal:** The user wants to know if the provided Python script uses the *correct* CCXT methods and parameters, specifically targeting the Bybit V5 API endpoints as intended by the design plan.\n\n2.  **Identify Key Interaction Points:** Where does the script interact with the CCXT library to communicate with the Bybit API?\n    *   `initialize_exchange`: Sets up the connection, loads markets, fetches initial balance.\n    *   `safe_ccxt_call`: The wrapper function used for most API calls. Need to check *what* methods it\u0027s asked to call.\n    *   `get_market_info`: Loads/reloads markets.\n    *   `fetch_current_price_ccxt`: Fetches ticker data.\n    *   `fetch_klines_ccxt`: Fetches OHLCV data.\n    *   `fetch_orderbook_ccxt`: Fetches order book data.\n    *   `fetch_balance`: Fetches wallet balance.\n    *   `fetch_positions_ccxt`: Fetches open positions.\n    *   `set_leverage_ccxt`: Sets leverage.\n    *   `create_order_ccxt`: Creates new orders.\n    *   `set_protection_ccxt`: Sets SL/TP/TSL.\n    *   `close_position_ccxt`: Creates a closing order.\n    *   `attempt_new_entry`: Calls `set_leverage`, `create_order`, `set_protection`.\n    *   `manage_existing_position`: Calls `set_protection`, `close_position`.\n\n3.  **Analyze `initialize_exchange`:**\n    *   `options[\u0027versions\u0027]`: This is the *explicit* mechanism to tell CCXT which API version to use for specific *implicit* method calls (like `fetchTicker`, `fetchPositions`). It maps standard CCXT function names (like `market/tickers` which corresponds to `fetch_ticker`) to the desired API version (\u0027v5\u0027). This looks *correct* and is the preferred modern way.\n    *   `options[\u0027default_options\u0027]`: This provides *fallback* hints to CCXT, like `\u0027fetchPositions\u0027: \u0027v5\u0027`. While somewhat redundant with `versions`, it acts as a safeguard if the `versions` mapping isn\u0027t complete or perfectly understood by CCXT for *all* derived calls. It\u0027s good practice to include it.\n    *   `options[\u0027accountsByType\u0027]`: Maps standard CCXT account types (\u0027spot\u0027, \u0027future\u0027) to Bybit V5 names (\u0027SPOT\u0027, \u0027CONTRACT\u0027). This is *crucial* for functions like `fetch_balance` when passing `accountType` in parameters. Looks *correct*.\n    *   `load_markets()`: Called initially. By default, CCXT tries to load relevant markets. The V5 hints should guide it.\n    *   `fetch_balance()`: Called for initial check. The V5 hints and `accountsByType` should ensure it hits the V5 endpoint. The implementation of `fetch_balance` itself tries specific `accountType` parameters (\u0027CONTRACT\u0027, \u0027UNIFIED\u0027, \u0027SPOT\u0027), which are V5-specific. This looks *correct*.\n\n4.  **Analyze Parameter Usage in Wrapper Functions:** Do the functions prepare the *correct parameters* expected by Bybit V5 when calling CCXT methods?\n    *   `fetch_...` functions (ticker, klines, orderbook, balance, positions): They correctly extract the `category` (\u0027linear\u0027, \u0027inverse\u0027, \u0027spot\u0027) from `market_info` and add it to the `params` dictionary *only if the exchange is Bybit*. This is *correct* as Bybit V5 often requires the category parameter for these endpoints.\n    *   `set_leverage_ccxt`: Passes `category`, `symbol`, `buyLeverage`, `sellLeverage` in `params`. This matches the Bybit V5 `/v5/position/set-leverage` requirements. *Correct*.\n    *   `create_order_ccxt`: Passes `category` in `params`. It also handles user-provided `params` like `reduceOnly` and potentially `positionIdx`. This allows for V5-specific order features. *Correct*.\n    *   `set_protection_ccxt`: This is critical. It *directly* calls `private_post_position_trading_stop` via `safe_ccxt_call`. It constructs the `params` dictionary with `category`, `symbol`, `tpslMode\u003d\u0027Full\u0027`, and correctly formatted strings for `stopLoss`, `takeProfit`, `trailingStop`, `activePrice`. This directly targets the intended V5 endpoint and uses the correct V5 field names. *Correct*.\n    *   `close_position_ccxt`: Calls `create_order_ccxt` with `reduceOnly\u003dTrue` in the `params`. This is the standard V5 mechanism for closing positions without accidentally increasing them. *Correct*.\n\n5.  **Analyze `safe_ccxt_call`:**\n    *   It correctly uses `getattr(exchange, method_name)` to call the specified CCXT method (e.g., `fetch_ticker`, `create_order`, `private_post_position_trading_stop`).\n    *   It passes `*args` and `**kwargs` (which include the `params` dictionary) to the underlying CCXT method.\n    *   The retry logic handles common issues but doesn\u0027t fundamentally change *which* endpoint is called.\n\n6.  **Synthesize Findings:**\n    *   The use of `options[\u0027versions\u0027]` and `options[\u0027default_options\u0027]` in `initialize_exchange` correctly instructs CCXT to prefer V5 endpoints for standard calls.\n    *   Functions that wrap CCXT calls correctly prepare the `params` dictionary with the `category` where Bybit V5 requires it.\n    *   Crucially, `set_protection_ccxt` *directly targets* the specific V5 endpoint (`/v5/position/trading-stop`) using the correct parameter names (`stopLoss`, `takeProfit`, `trailingStop`, `activePrice`, `tpslMode`). This bypasses potential ambiguities in CCXT\u0027s implicit method mapping for this specific, newer V5 feature.\n    *   Leverage setting also uses the correct V5 parameters (`buyLeverage`, `sellLeverage`).\n    *   Order creation uses `category` and supports V5 parameters like `reduceOnly`.\n\n7.  **Conclusion:** Yes, based on the analysis:\n    *   The script leverages CCXT\u0027s mechanisms (`versions`, `default_options`) to target V5 endpoints for standard operations.\n    *   It correctly identifies and includes the necessary `category` parameter in API calls where Bybit V5 requires it.\n    *   For the critical SL/TP/TSL function (`set_protection_ccxt`), it explicitly calls the V5 endpoint (`private_post_position_trading_stop`) with the correct V5-specific parameters, ensuring the intended endpoint is used.\n    *   Other trading actions like leverage setting and order creation also use parameters consistent with V5 requirements.\n\n8.  **Refine Answer:** Structure the answer clearly, stating the conclusion first and then providing supporting points referencing specific parts of the code (initialization, parameter preparation, explicit calls). Mention the importance of the `category` parameter and the direct call for `set_protection_ccxt`.",
      "role": "model",
      "tokenCount": 1627,
      "isThought": true
    }, {
      "text": "Yes, based on the analysis of the generated code, it appears to **correctly target and utilize Bybit V5 API endpoints** where intended and feasible through CCXT.\n\nHere\u0027s a breakdown of why:\n\n1.  **CCXT Initialization (`initialize_exchange`):**\n    *   **`options[\u0027versions\u0027]`:** This dictionary explicitly tells CCXT to use the \u0027v5\u0027 API version for specific underlying REST endpoints when you make standard CCXT calls (like `fetch_ticker`, `fetch_positions`, `create_order`, etc.). This is the primary mechanism ensuring V5 is targeted for mapped functions.\n    *   **`options[\u0027default_options\u0027]`:** This acts as a fallback or further hint to CCXT, specifying \u0027v5\u0027 for common operations. While potentially redundant with `versions`, it reinforces the intent.\n    *   **`options[\u0027accountsByType\u0027]`:** This correctly maps standard CCXT account types (`spot`, `future`, `swap`) to the Bybit V5 names (`SPOT`, `CONTRACT`), which is crucial for functions like `fetch_balance` that take `accountType` as a parameter.\n\n2.  **V5-Specific Parameters (`category`):**\n    *   Many Bybit V5 endpoints (especially for fetching market data, positions, balances) require the `category` parameter (`linear`, `inverse`, `spot`, `option`).\n    *   The helper functions (`fetch_current_price_ccxt`, `fetch_klines_ccxt`, `fetch_orderbook_ccxt`, `fetch_balance`, `fetch_positions_ccxt`, `set_leverage_ccxt`, `create_order_ccxt`, `set_protection_ccxt`) correctly extract the `category` from the `market_info` dictionary and include it in the `params` dictionary passed to the underlying `safe_ccxt_call` when the exchange is Bybit. This ensures the V5 endpoints receive this required parameter.\n\n3.  **Direct Endpoint Call (`set_protection_ccxt`):**\n    *   Setting SL/TP/TSL uses the V5 endpoint `/v5/position/trading-stop`. Instead of relying solely on CCXT potentially mapping a generic function to this, the code explicitly calls `private_post_position_trading_stop` via `safe_ccxt_call`.\n    *   It correctly formats the V5-specific parameters required by this endpoint: `category`, `symbol`, `tpslMode\u003d\u0027Full\u0027`, `stopLoss`, `takeProfit`, `trailingStop`, and `activePrice`. This direct targeting ensures the correct V5 functionality is used.\n\n4.  **Leverage Setting (`set_leverage_ccxt`):**\n    *   This function passes the `category`, `symbol`, `buyLeverage`, and `sellLeverage` parameters, which correspond to the fields required by the Bybit V5 `/v5/position/set-leverage` endpoint.\n\n5.  **Order Creation (`create_order_ccxt`, `close_position_ccxt`):**\n    *   These functions pass the `category` parameter.\n    *   `close_position_ccxt` specifically uses the `reduceOnly: True` parameter, which is the correct V5 mechanism for ensuring an order only reduces or closes an existing position.\n\n**In summary:** The combination of CCXT\u0027s V5 configuration hints (`versions`, `default_options`), the consistent injection of the `category` parameter where needed, and the direct, correctly parameterized call to the V5 trading-stop endpoint strongly indicates that the script is using the correct Bybit V5 endpoints as designed.",
      "role": "model",
      "finishReason": "STOP",
      "tokenCount": 786
    }],
    "pendingInputs": [{
      "text": "",
      "role": "user"
    }]
  }
}