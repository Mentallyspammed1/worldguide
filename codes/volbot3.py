
2025-04-24 16:26:48 - INFO     - [volbot_10000000AIDOGE_USDT_USDT] - Calculating Volbot strategy indicators...
2025-04-24 16:26:48 - INFO     - [volbot_10000000AIDOGE_USDT_USDT] - Calculating Volumatic Trend Levels...
2025-04-24 16:26:57 - ERROR    - [volbot_10000000AIDOGE_USDT_USDT] - Error calculating indicators for 10000000AIDOGE/USDT:USDT: 'numpy.ndarray' object has no attribute 'fillna'
Traceback (most recent call last):
  File "/data/data/com.termux/files/home/worldguide/codes/volbot2.py", line 1074, in _calculate_strategy_indicators
    df_calc = calculate_volatility_levels(df_calc, self.config, self.logger)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/data/data/com.termux/files/home/worldguide/codes/volbot2.py", line 688, in calculate_volatility_levels
    ).fillna(0)
      ^^^^^^
AttributeError: 'numpy.ndarray' object has no attribute 'fillna'. Did you mean: 'fill'?
2025-04-24 16:26:57 - WARNING  - [volbot_10000000AIDOGE_USDT_USDT] - Cannot update latest state: Processed DataFrame is empty for 10000000AIDOGE/USDT:USDT.
2025-04-24 16:26:57 - ERROR    - [volbot_10000000AIDOGE_USDT_USDT] - Failed to calculate indicators or update state for 10000000AIDOGE/USDT:USDT. Skipping further analysis.
2025-04-24 16:26:57 - INFO     - [volbot_1000000BABYDOGE_USDT_USDT] - --- Starting analysis cycle for 1000000BABYDOGE/USDT:USDT ---
2025-04-24 16:26:58 - INFO     - [volbot_1000000BABYDOGE_USDT_USDT] - Successfully fetched and processed 1000 klines for 1000000BABYDOGE/USDT:USDT 3m
2025-04-24 16:26:58 - WARNING  - [volbot_1000000BABYDOGE_USDT_USDT] - Insufficient data (1000 points) for 1000000BABYDOGE/USDT:USDT to calculate all indicators reliably (recommend min: ~1050). Results may be inaccurate or contain NaNs.
2025-04-24 16:26:58 - INFO     - [volbot_1000000BABYDOGE_USDT_USDT] - Calculating Volbot strategy indicators...
2025-04-24 16:26:58 - INFO     - [volbot_1000000BABYDOGE_USDT_USDT] - Calculating Volumatic Trend Levels...
2025-04-24 16:27:08 - ERROR    - [volbot_1000000BABYDOGE_USDT_USDT] - Error calculating indicators for 1000000BABYDOGE/USDT:USDT: 'numpy.ndarray' object has no attribute 'fillna'
Traceback (most recent call last):
  File "/data/data/com.termux/files/home/worldguide/codes/volbot2.py", line 1074, in _calculate_strategy_indicators
    df_calc = calculate_volatility_levels(df_calc, self.config, self.logger)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/data/data/com.termux/files/home/worldguide/codes/volbot2.py", line 688, in calculate_volatility_levels
    ).fillna(0)
      ^^^^^^
AttributeError: 'numpy.ndarray' object has no attribute 'fillna'. Did you mean: 'fill'?
2025-04-24 16:27:09 - WARNING  - [volbot_1000000BABYDOGE_USDT_USDT] - Cannot update latest state: Processed DataFrame is empty for 1000000BABYDOGE/USDT:USDT.
2025-04-24 16:27:09 - ERROR    - [volbot_1000000BABYDOGE_USDT_USDT] - Failed to calculate indicators or update state for 1000000BABYDOGE/USDT:USDT. Skipping further analysis.
2025-04-24 16:27:09 - INFO     - [volbot_1000000CHEEMS_USDT_USDT] - --- Starting analysis cycle for 1000000CHEEMS/USDT:USDT ---
2025-04-24 16:27:09 - INFO     - [volbot_1000000CHEEMS_USDT_USDT] - Successfully fetched and processed 1000 klines for 1000000CHEEMS/USDT:USDT 3m
2025-04-24 16:27:09 - WARNING  - [volbot_1000000CHEEMS_USDT_USDT] - Insufficient data (1000 points) for 1000000CHEEMS/USDT:USDT to calculate all indicators reliably (recommend min: ~1050). Results may be inaccurate or contain NaNs.
2025-04-24 16:27:09 - INFO     - [volbot_1000000CHEEMS_USDT_USDT] - Calculating Volbot strategy indicators...
2025-04-24 16:27:09 - INFO     - [volbot_1000000CHEEMS_USDT_USDT] - Calculating Volumatic Trend Levels...
2025-04-24 16:27:21 - ERROR    - [volbot_1000000CHEEMS_USDT_USDT] - Error calculating indicators for 1000000CHEEMS/USDT:USDT: 'numpy.ndarray' object has no attribute 'fillna'
Traceback (most recent call last):
  File "/data/data/com.termux/files/home/worldguide/codes/volbot2.py", line 1074, in _calculate_strategy_indicators
    df_calc = calculate_volatility_levels(df_calc, self.config, self.logger)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/data/data/com.termux/files/home/worldguide/codes/volbot2.py", line 688, in calculate_volatility_levels
    ).fillna(0)
      ^^^^^^
AttributeError: 'numpy.ndarray' object has no attribute 'fillna'. Did you mean: 'fill'?
2025-04-24 16:27:21 - WARNING  - [volbot_1000000CHEEMS_USDT_USDT] - Cannot update latest state: Processed DataFrame is empty for 1000000CHEEMS/USDT:USDT.
2025-04-24 16:27:21 - ERROR    - [volbot_1000000CHEEMS_USDT_USDT] - Failed to calculate indicators or update state for 1000000CHEEMS/USDT:USDT. Skipping further analysis.
2025-04-24 16:27:21 - INFO     - [volbot_1000000MOG_USDT_USDT] - --- Starting analysis cycle for 1000000MOG/USDT:USDT ---
2025-04-24 16:27:21 - INFO     - [volbot_1000000MOG_USDT_USDT] - Successfully fetched and processed 1000 klines for 1000000MOG/USDT:USDT 3m
2025-04-24 16:27:21 - WARNING  - [volbot_1000000MOG_USDT_USDT] - Insufficient data (1000 points) for 1000000MOG/USDT:USDT to calculate all indicators reliably (recommend min: ~1050). Results may be inaccurate or contain NaNs.
2025-04-24 16:27:21 - INFO     - [volbot_1000000MOG_USDT_USDT] - Calculating Volbot strategy indicators...
2025-04-24 16:27:21 - INFO     - [volbot_1000000MOG_USDT_USDT] - Calculating Volumatic Trend Levels...

# volbot.py
# Incorporates Volumatic Trend + Order Block strategy into a trading framework using ccxt.
# Enhanced version with improved structure, error handling, logging, and clarity.

import hashlib
import hmac
import json
import logging
import math
import os
import re
import time
from datetime import datetime
from decimal import Decimal, ROUND_DOWN, ROUND_UP, getcontext, InvalidOperation
from logging.handlers import RotatingFileHandler
from typing import Any, Dict, List, Optional, Tuple, Union

import ccxt
import numpy as np
import pandas as pd
import pandas_ta as ta
import requests
from colorama import Fore, Style, init
from dotenv import load_dotenv
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
from zoneinfo import ZoneInfo

# Initialize colorama and set Decimal precision
init(autoreset=True)
getcontext().prec = 28  # Increased precision for complex financial calculations
load_dotenv()

# --- Constants ---
# Color Scheme
NEON_GREEN = Fore.LIGHTGREEN_EX
NEON_BLUE = Fore.CYAN
NEON_PURPLE = Fore.MAGENTA
NEON_YELLOW = Fore.YELLOW
NEON_RED = Fore.LIGHTRED_EX
NEON_CYAN = Fore.CYAN
RESET = Style.RESET_ALL

# Strategy-Specific Colors
COLOR_UP = Fore.CYAN + Style.BRIGHT
COLOR_DN = Fore.YELLOW + Style.BRIGHT
COLOR_BULL_BOX = Fore.GREEN
COLOR_BEAR_BOX = Fore.RED
COLOR_CLOSED_BOX = Fore.LIGHTBLACK_EX
COLOR_INFO = Fore.MAGENTA
COLOR_HEADER = Fore.BLUE + Style.BRIGHT
COLOR_WARNING = NEON_YELLOW
COLOR_ERROR = NEON_RED
COLOR_SUCCESS = NEON_GREEN

# API Credentials (Loaded from .env)
API_KEY = os.getenv("BYBIT_API_KEY")
API_SECRET = os.getenv("BYBIT_API_SECRET")
if not API_KEY or not API_SECRET:
    raise ValueError("BYBIT_API_KEY and BYBIT_API_SECRET must be set in .env")

# File/Directory Configuration
CONFIG_FILE = "config.json"
LOG_DIRECTORY = "bot_logs"
os.makedirs(LOG_DIRECTORY, exist_ok=True)

# Time & Retry Configuration
try:
    # Allow overriding timezone in config, fallback to Chicago
    # Note: Ensure the specified timezone is available in the system's tz database
    CONFIG_TIMEZONE = json.load(open(CONFIG_FILE, 'r', encoding='utf-8')).get("timezone", "America/Chicago")
    TIMEZONE = ZoneInfo(CONFIG_TIMEZONE)
except (FileNotFoundError, json.JSONDecodeError, Exception):
     # Use default if config loading fails during constant definition
    print(f"{COLOR_WARNING}Could not load timezone from config, using default 'America/Chicago'.{RESET}")
    TIMEZONE = ZoneInfo("America/Chicago")

MAX_API_RETRIES = 3  # Max retries for recoverable API errors
RETRY_DELAY_SECONDS = 5  # Delay between retries
LOOP_DELAY_SECONDS = 15  # Min time between the end of one cycle and the start of the next

# Interval Configuration
VALID_INTERVALS = ["1", "3", "5", "15", "30", "60", "120", "240", "D", "W", "M"]  # Intervals supported by the bot's logic
CCXT_INTERVAL_MAP = {  # Map our intervals to ccxt's expected format
    "1": "1m", "3": "3m", "5": "5m", "15": "15m", "30": "30m",
    "60": "1h", "120": "2h", "240": "4h", "D": "1d", "W": "1w", "M": "1M"
}

# API Error Codes for Retry Logic (HTTP status codes)
RETRY_ERROR_CODES = [429, 500, 502, 503, 504]

# --- Default Volbot Strategy Parameters (overridden by config.json) ---
DEFAULT_VOLBOT_LENGTH = 40
DEFAULT_VOLBOT_ATR_LENGTH = 200
DEFAULT_VOLBOT_VOLUME_PERCENTILE_LOOKBACK = 1000
DEFAULT_VOLBOT_VOLUME_NORMALIZATION_PERCENTILE = 100 # Use max volume in lookback
DEFAULT_VOLBOT_OB_SOURCE = "Wicks" # "Wicks" or "Bodys"
DEFAULT_VOLBOT_PIVOT_LEFT_LEN_H = 25
DEFAULT_VOLBOT_PIVOT_RIGHT_LEN_H = 25
DEFAULT_VOLBOT_PIVOT_LEFT_LEN_L = 25
DEFAULT_VOLBOT_PIVOT_RIGHT_LEN_L = 25
DEFAULT_VOLBOT_MAX_BOXES = 50

# Default Risk Management Parameters (overridden by config.json)
DEFAULT_ATR_PERIOD = 14 # Risk Management ATR (for SL/TP/BE)

# Global QUOTE_CURRENCY placeholder, dynamically loaded from config
QUOTE_CURRENCY = "USDT" # Default fallback

# Default console log level
console_log_level = logging.INFO

# --- Logger Setup ---
class SensitiveFormatter(logging.Formatter):
    """Formatter that redacts sensitive information like API keys from log messages."""
    def format(self, record: logging.LogRecord) -> str:
        """Formats the log record, redacting sensitive info."""
        msg = super().format(record)
        if API_KEY:
            msg = msg.replace(API_KEY, "***API_KEY***")
        if API_SECRET:
            msg = msg.replace(API_SECRET, "***SECRET***") # Redact secret too
        return msg

def setup_logger(name_suffix: str) -> logging.Logger:
    """
    Sets up a logger instance with specified suffix, file rotation, and console output.

    Args:
        name_suffix: A string suffix for the logger name and filename (e.g., symbol or 'init').

    Returns:
        The configured logging.Logger instance.
    """
    safe_suffix = re.sub(r'[^\w\-]+', '_', name_suffix) # Make suffix filesystem-safe
    logger_name = f"volbot_{safe_suffix}"
    log_filename = os.path.join(LOG_DIRECTORY, f"{logger_name}.log")
    logger = logging.getLogger(logger_name)

    # Prevent adding handlers multiple times if logger already exists
    if logger.hasHandlers():
        # Ensure existing console handler level is correct
        for handler in logger.handlers:
            if isinstance(handler, logging.StreamHandler):
                handler.setLevel(console_log_level)
        return logger

    logger.setLevel(logging.DEBUG) # Set root level to DEBUG to allow handlers to filter

    # File Handler (DEBUG level)
    try:
        file_handler = RotatingFileHandler(
            log_filename, maxBytes=10 * 1024 * 1024, backupCount=5, encoding='utf-8'
        )
        file_formatter = SensitiveFormatter(
            "%(asctime)s - %(levelname)s - [%(name)s:%(lineno)d] - %(message)s",
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        file_handler.setFormatter(file_formatter)
        file_handler.setLevel(logging.DEBUG)
        logger.addHandler(file_handler)
    except Exception as e:
        # Use print as logger might not be fully functional yet
        print(f"{COLOR_ERROR}Error setting up file logger for {log_filename}: {e}{RESET}")

    # Console Handler (configurable level)
    stream_handler = logging.StreamHandler()
    # Define colors for different log levels
    level_colors = {
        logging.DEBUG: NEON_BLUE,
        logging.INFO: NEON_GREEN,
        logging.WARNING: NEON_YELLOW,
        logging.ERROR: NEON_RED,
        logging.CRITICAL: Fore.RED + Style.BRIGHT,
    }

    class ColorFormatter(SensitiveFormatter):
        def format(self, record):
            log_color = level_colors.get(record.levelno, RESET)
            record.levelname = f"{log_color}{record.levelname:<8}{RESET}" # Pad level name
            # Format timestamp and name parts
            record.asctime = f"{NEON_BLUE}{self.formatTime(record, self.datefmt)}{RESET}"
            record.name_part = f"{NEON_PURPLE}[{record.name}]{RESET}"
            # Format the final message using the parent's method after modifications
            formatted_message = super().format(record)
            # Ensure final message has color reset
            return f"{formatted_message}{RESET}"

    stream_formatter = ColorFormatter(
        "%(asctime)s - %(levelname)s - %(name_part)s - %(message)s",
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    stream_handler.setFormatter(stream_formatter)
    stream_handler.setLevel(console_log_level)
    logger.addHandler(stream_handler)

    logger.propagate = False # Prevent messages from reaching the root logger
    return logger

# --- Configuration Loading ---
def load_config(filepath: str) -> Dict[str, Any]:
    """
    Loads configuration from a JSON file. Creates a default config if the file
    doesn't exist. Ensures all default keys are present, adding missing ones
    with default values and updating the file if necessary.

    Args:
        filepath: The path to the configuration JSON file.

    Returns:
        A dictionary containing the configuration settings.
    """
    global QUOTE_CURRENCY # Allow updating the global variable
    default_config = {
        # --- General Bot Settings ---
        "timezone": "America/Chicago",# Timezone for logging and potentially scheduling (e.g., "Europe/London")
        "interval": "5",              # Default trading interval (string format)
        "retry_delay": RETRY_DELAY_SECONDS, # API retry delay in seconds
        "enable_trading": False,      # MASTER SWITCH: Set to true to allow placing real orders. Default: False.
        "use_sandbox": True,          # Use exchange's testnet/sandbox environment. Default: True.
        "risk_per_trade": 0.01,       # Max percentage of account balance to risk per trade (0.01 = 1%)
        "leverage": 10,               # Desired leverage for contract trading (applied if possible)
        "max_concurrent_positions": 1,# Max open positions allowed per symbol by this bot instance
        "quote_currency": "USDT",     # Currency for balance checks and position sizing (MUST match exchange pairs, e.g., USDT for BTC/USDT)
        "console_log_level": "INFO",  # Console logging verbosity (DEBUG, INFO, WARNING, ERROR, CRITICAL)

        # --- Volbot Strategy Settings ---
        "volbot_enabled": True,         # Enable/disable Volbot strategy calculations and signals
        "volbot_length": DEFAULT_VOLBOT_LENGTH, # Main period for Volbot EMAs
        "volbot_atr_length": DEFAULT_VOLBOT_ATR_LENGTH, # ATR period for Volbot dynamic levels
        "volbot_volume_percentile_lookback": DEFAULT_VOLBOT_VOLUME_PERCENTILE_LOOKBACK, # Lookback for volume normalization
        "volbot_volume_normalization_percentile": DEFAULT_VOLBOT_VOLUME_NORMALIZATION_PERCENTILE, # Percentile (usually 100=max)
        "volbot_ob_source": DEFAULT_VOLBOT_OB_SOURCE, # "Wicks" or "Bodys" for Order Block detection
        "volbot_pivot_left_len_h": DEFAULT_VOLBOT_PIVOT_LEFT_LEN_H, # Left bars for Pivot High
        "volbot_pivot_right_len_h": DEFAULT_VOLBOT_PIVOT_RIGHT_LEN_H,# Right bars for Pivot High
        "volbot_pivot_left_len_l": DEFAULT_VOLBOT_PIVOT_LEFT_LEN_L, # Left bars for Pivot Low
        "volbot_pivot_right_len_l": DEFAULT_VOLBOT_PIVOT_RIGHT_LEN_L,# Right bars for Pivot Low
        "volbot_max_boxes": DEFAULT_VOLBOT_MAX_BOXES, # Max number of active Order Blocks to track
        "volbot_signal_on_trend_flip": True, # Generate BUY/SELL on Volbot trend direction change
        "volbot_signal_on_ob_entry": True,   # Generate BUY/SELL on price entering an Order Block matching trend

        # --- Risk Management Settings ---
        "atr_period": DEFAULT_ATR_PERIOD, # ATR period for SL/TP/BE calculations (Risk Management ATR)
        "stop_loss_multiple": 1.8, # Risk ATR multiple for initial Stop Loss distance
        "take_profit_multiple": 0.7, # Risk ATR multiple for initial Take Profit distance

        # --- Trailing Stop Loss Config (Exchange-based TSL) ---
        "enable_trailing_stop": True, # Attempt to set an exchange-based Trailing Stop Loss on entry
        "trailing_stop_callback_rate": 0.005, # Trail distance as percentage (0.005=0.5%) or price distance (e.g., 50 for $50). Check exchange API docs.
        "trailing_stop_activation_percentage": 0.003, # Profit percentage to activate TSL (0.003=0.3%). 0 for immediate activation if supported.

        # --- Break-Even Stop Config ---
        "enable_break_even": True,              # Enable moving SL to break-even + offset
        "break_even_trigger_atr_multiple": 1.0, # Profit needed (in multiples of Risk ATR) to trigger BE
        "break_even_offset_ticks": 2,           # Number of minimum price ticks to offset BE SL from entry (for fees/slippage)
    }

    config_updated = False
    if not os.path.exists(filepath):
        try:
            with open(filepath, "w", encoding="utf-8") as f:
                json.dump(default_config, f, indent=4, sort_keys=True)
            print(f"{COLOR_WARNING}Created default config file: {filepath}{RESET}")
            loaded_config = default_config
            config_updated = True # Technically created, not updated, but flag useful
        except IOError as e:
            print(f"{COLOR_ERROR}Error creating default config file {filepath}: {e}. Using default values.{RESET}")
            return default_config # Return defaults if creation fails
    else:
        try:
            with open(filepath, 'r', encoding="utf-8") as f:
                loaded_config = json.load(f)
            # Ensure all default keys exist, add missing ones
            loaded_config, config_updated = _ensure_config_keys(loaded_config, default_config)
            if config_updated:
                try:
                    with open(filepath, "w", encoding="utf-8") as f_write:
                        json.dump(loaded_config, f_write, indent=4, sort_keys=True)
                    print(f"{COLOR_WARNING}Updated config file '{filepath}' with missing default keys.{RESET}")
                except IOError as e:
                    print(f"{COLOR_ERROR}Error writing updated config file {filepath}: {e}{RESET}")
        except (FileNotFoundError, json.JSONDecodeError) as e:
            print(f"{COLOR_ERROR}Error loading config file {filepath}: {e}. Using default config.{RESET}")
            # Attempt to recreate default config if loading failed
            try:
                with open(filepath, "w", encoding="utf-8") as f:
                    json.dump(default_config, f, indent=4, sort_keys=True)
                print(f"{COLOR_WARNING}Recreated default config file: {filepath}{RESET}")
            except IOError as e_create:
                print(f"{COLOR_ERROR}Error creating default config file after load error: {e_create}{RESET}")
            return default_config

    # Update global QUOTE_CURRENCY
    QUOTE_CURRENCY = loaded_config.get("quote_currency", default_config["quote_currency"])

    # Update global console log level
    global console_log_level
    level_name = loaded_config.get("console_log_level", "INFO").upper()
    console_log_level = getattr(logging, level_name, logging.INFO)

    return loaded_config

def _ensure_config_keys(loaded_config: Dict[str, Any], default_config: Dict[str, Any]) -> Tuple[Dict[str, Any], bool]:
    """
    Recursively ensures default keys exist in loaded config. Returns updated config and a flag indicating if changes were made.
    """
    updated = False
    for key, default_value in default_config.items():
        if key not in loaded_config:
            loaded_config[key] = default_value
            updated = True
        elif isinstance(default_value, dict) and isinstance(loaded_config.get(key), dict):
            # Recurse for nested dictionaries
            loaded_config[key], nested_updated = _ensure_config_keys(loaded_config[key], default_value)
            if nested_updated:
                updated = True
    return loaded_config, updated

# Load configuration globally AFTER functions are defined
CONFIG = load_config(CONFIG_FILE)

# --- CCXT Exchange Setup ---
def initialize_exchange(logger: logging.Logger) -> Optional[ccxt.Exchange]:
    """
    Initializes the CCXT Bybit exchange object with configuration settings.

    Args:
        logger: The logger instance.

    Returns:
        An initialized ccxt.Exchange object, or None if initialization fails.
    """
    lg = logger
    try:
        exchange_id = 'bybit' # Hardcoded to Bybit for this script
        exchange_class = getattr(ccxt, exchange_id)

        exchange_options = {
            'apiKey': API_KEY,
            'secret': API_SECRET,
            'enableRateLimit': True,
            'options': {
                'defaultType': 'linear', # Prefer linear contracts
                'adjustForTimeDifference': True,
                # Increased timeouts (milliseconds)
                'recvWindow': 10000, # Bybit recommended recv_window
                'fetchTickerTimeout': 15000,
                'fetchBalanceTimeout': 20000,
                'createOrderTimeout': 25000,
                'cancelOrderTimeout': 15000,
                'fetchOHLCVTimeout': 20000,
            }
        }

        exchange = exchange_class(exchange_options)

        # Set Sandbox Mode
        use_sandbox = CONFIG.get('use_sandbox', True)
        exchange.set_sandbox_mode(use_sandbox)
        sandbox_status = f"{COLOR_WARNING}SANDBOX MODE{RESET}" if use_sandbox else f"{COLOR_ERROR}LIVE TRADING MODE{RESET}"
        lg.warning(f"Exchange {exchange.id} initialized. Status: {sandbox_status}")

        # Load Markets
        lg.info(f"Loading markets for {exchange.id}...")
        try:
            exchange.load_markets()
            lg.info(f"Markets loaded successfully ({len(exchange.markets)} symbols).")
        except (ccxt.NetworkError, ccxt.ExchangeError) as e:
            lg.error(f"{COLOR_ERROR}Failed to load markets: {e}. Check connection and API status.{RESET}")
            return None

        # Test API Connection with Balance Fetch
        lg.info("Attempting initial balance fetch to test API keys and connection...")
        test_balance = fetch_balance(exchange, QUOTE_CURRENCY, lg) # Use the robust fetch_balance
        if test_balance is not None:
             lg.info(f"{COLOR_SUCCESS}API keys and connection successful. Initial {QUOTE_CURRENCY} balance: {test_balance:.4f}{RESET}")
        else:
            # fetch_balance logs detailed errors, add a summary here
            lg.error(f"{COLOR_ERROR}Initial balance fetch failed. Possible issues:{RESET}")
            lg.error(f"{COLOR_ERROR}- Invalid API Key/Secret.{RESET}")
            lg.error(f"{COLOR_ERROR}- Incorrect API permissions (Read/Trade needed).{RESET}")
            lg.error(f"{COLOR_ERROR}- IP Whitelist mismatch on Bybit.{RESET}")
            lg.error(f"{COLOR_ERROR}- Using Live keys on Testnet or vice-versa.{RESET}")
            lg.error(f"{COLOR_ERROR}- Network/Exchange connectivity issues.{RESET}")
            return None # Critical failure

        return exchange

    except ccxt.AuthenticationError as e:
        lg.critical(f"{COLOR_ERROR}CCXT Authentication Error during initialization: {e}{RESET}")
    except ccxt.ExchangeError as e:
        lg.critical(f"{COLOR_ERROR}CCXT Exchange Error initializing: {e}{RESET}")
    except ccxt.NetworkError as e:
        lg.critical(f"{COLOR_ERROR}CCXT Network Error initializing: {e}{RESET}")
    except Exception as e:
        lg.critical(f"{COLOR_ERROR}Failed to initialize CCXT exchange: {e}{RESET}", exc_info=True)
    return None

# --- CCXT Data Fetching ---
def safe_decimal(value: Any, default: Optional[Decimal] = None) -> Optional[Decimal]:
    """Safely convert a value to Decimal, handling None, strings, floats. Returns default if conversion fails."""
    if value is None:
        return default
    try:
        # Handle potential scientific notation in strings
        str_value = str(value).strip()
        if 'e' in str_value.lower():
             # Let Decimal handle scientific notation directly
             d = Decimal(str_value)
        else:
             d = Decimal(str_value)
        return d
    except (InvalidOperation, ValueError, TypeError):
        return default

def fetch_current_price_ccxt(exchange: ccxt.Exchange, symbol: str, logger: logging.Logger) -> Optional[Decimal]:
    """
    Fetches the current market price for a symbol using the exchange's ticker,
    with robust fallbacks and validation.

    Args:
        exchange: Initialized ccxt.Exchange object.
        symbol: Trading symbol (e.g., 'BTC/USDT:USDT').
        logger: Logger instance.

    Returns:
        The current price as a Decimal, or None if fetching fails or price is invalid.
    """
    lg = logger
    price: Optional[Decimal] = None
    try:
        lg.debug(f"Fetching ticker for {symbol}...")
        # Use appropriate params for Bybit V5 ticker fetching if needed
        params = {}
        if 'bybit' in exchange.id.lower():
            market = exchange.market(symbol) # Assume market loaded
            category = 'linear' if market.get('linear', True) else 'inverse'
            params['category'] = category

        ticker = exchange.fetch_ticker(symbol, params=params)
        lg.debug(f"Ticker data received for {symbol}: {ticker}")

        # 1. Try 'last' price
        last_price = safe_decimal(ticker.get('last'))
        if last_price is not None and last_price > 0:
            price = last_price
            lg.debug(f"Using 'last' price: {price}")
        else:
            # 2. Try Bid/Ask Midpoint
            bid = safe_decimal(ticker.get('bid'))
            ask = safe_decimal(ticker.get('ask'))
            if bid is not None and ask is not None and bid > 0 and ask > 0 and bid <= ask:
                price = (bid + ask) / Decimal('2')
                lg.debug(f"Using bid/ask midpoint: {price}")
            else:
                # 3. Try 'ask' price
                if ask is not None and ask > 0:
                    price = ask
                    lg.debug(f"Using 'ask' price (fallback): {price}")
                # 4. Try 'bid' price (last resort)
                elif bid is not None and bid > 0:
                    price = bid
                    lg.debug(f"Using 'bid' price (last resort): {price}")

        # Final validation
        if price is not None and price > 0:
            return price
        else:
            lg.error(f"{COLOR_ERROR}Failed to fetch a valid positive current price for {symbol} from ticker.{RESET}")
            lg.debug(f"Invalid ticker data: {ticker}")
            return None

    except (ccxt.NetworkError, ccxt.RequestTimeout, requests.exceptions.ConnectionError, requests.exceptions.Timeout) as e:
        lg.error(f"{COLOR_ERROR}Network error fetching price for {symbol}: {e}{RESET}")
    except ccxt.ExchangeError as e:
        # Check for specific "symbol not found" errors
        if "symbol not found" in str(e).lower() or "instrument not found" in str(e).lower():
             lg.error(f"{COLOR_ERROR}Symbol {symbol} not found on exchange ticker endpoint: {e}{RESET}")
        else:
             lg.error(f"{COLOR_ERROR}Exchange error fetching price for {symbol}: {e}{RESET}")
    except Exception as e:
        lg.error(f"{COLOR_ERROR}Unexpected error fetching price for {symbol}: {e}{RESET}", exc_info=True)
    return None

def fetch_klines_ccxt(exchange: ccxt.Exchange, symbol: str, timeframe: str, limit: int = 1060, logger: Optional[logging.Logger] = None) -> pd.DataFrame:
    """
    Fetches OHLCV kline data using CCXT with retries, validation, and DataFrame conversion.

    Args:
        exchange: Initialized ccxt.Exchange object.
        symbol: Trading symbol.
        timeframe: CCXT timeframe string (e.g., '5m', '1h').
        limit: Maximum number of klines to fetch.
        logger: Logger instance.

    Returns:
        A pandas DataFrame with OHLCV data indexed by timestamp, or an empty DataFrame on failure.
    """
    lg = logger or logging.getLogger(__name__)
    empty_df = pd.DataFrame()
    try:
        if not exchange.has['fetchOHLCV']:
            lg.error(f"Exchange {exchange.id} does not support fetchOHLCV.")
            return empty_df

        ohlcv: Optional[List[List[Any]]] = None
        for attempt in range(MAX_API_RETRIES + 1):
            try:
                lg.debug(f"Fetching klines for {symbol}, {timeframe}, limit={limit} (Attempt {attempt+1}/{MAX_API_RETRIES + 1})")
                # Add category param for Bybit V5 klines
                params = {}
                if 'bybit' in exchange.id.lower():
                    market = exchange.market(symbol) # Assume market loaded
                    category = 'linear' if market.get('linear', True) else 'inverse'
                    params['category'] = category

                ohlcv = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit, params=params)

                if ohlcv and len(ohlcv) > 0:
                    lg.debug(f"Received {len(ohlcv)} klines from API.")
                    break # Success
                else:
                    lg.warning(f"fetch_ohlcv returned empty list for {symbol} (Attempt {attempt+1}). Retrying...")
                    if attempt < MAX_API_RETRIES: time.sleep(RETRY_DELAY_SECONDS)

            except (ccxt.NetworkError, ccxt.RequestTimeout, requests.exceptions.ConnectionError, requests.exceptions.Timeout) as e:
                if attempt < MAX_API_RETRIES:
                    lg.warning(f"Network error fetching klines for {symbol} (Attempt {attempt + 1}): {e}. Retrying in {RETRY_DELAY_SECONDS}s...")
                    time.sleep(RETRY_DELAY_SECONDS)
                else:
                    lg.error(f"Max retries exceeded for network error fetching klines: {e}")
                    raise e # Raise after max retries
            except ccxt.RateLimitExceeded as e:
                wait_time_match = re.search(r'(\d+)\s*seconds', str(e))
                wait_time = int(wait_time_match.group(1)) if wait_time_match else RETRY_DELAY_SECONDS * (attempt + 2) # Exponential backoff suggestion
                lg.warning(f"Rate limit exceeded fetching klines for {symbol}. Retrying in {wait_time}s... (Attempt {attempt+1})")
                if attempt < MAX_API_RETRIES: time.sleep(wait_time)
                else: raise e
            except ccxt.ExchangeError as e:
                 # Check for "symbol not found" errors specifically
                 if "symbol not found" in str(e).lower() or "instrument invalid" in str(e).lower():
                      lg.error(f"{COLOR_ERROR}Symbol {symbol} not found on exchange kline endpoint: {e}{RESET}")
                      return empty_df # Cannot recover from invalid symbol
                 lg.error(f"Exchange error during fetch_ohlcv for {symbol}: {e}")
                 if attempt < MAX_API_RETRIES: time.sleep(RETRY_DELAY_SECONDS) # Retry generic exchange errors once or twice
                 else: raise e

        if not ohlcv:
            lg.warning(f"{COLOR_WARNING}No kline data returned for {symbol} {timeframe} after all retries.{RESET}")
            return empty_df

        # Convert to DataFrame
        df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        if df.empty:
            lg.warning(f"DataFrame conversion resulted in empty DF for {symbol}.")
            return empty_df

        # --- Data Cleaning and Processing ---
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms', errors='coerce')
        df.dropna(subset=['timestamp'], inplace=True)
        df.set_index('timestamp', inplace=True)

        numeric_cols = ['open', 'high', 'low', 'close', 'volume']
        for col in numeric_cols:
            # Convert using safe_decimal for better handling of various inputs
            df[col] = df[col].apply(lambda x: safe_decimal(x, default=np.nan))
            # Ensure dtype is suitable for numeric operations (e.g., float64)
            df[col] = pd.to_numeric(df[col], errors='coerce')

        initial_len = len(df)
        df.dropna(subset=['open', 'high', 'low', 'close'], inplace=True) # Need valid price data
        df.fillna({'volume': 0}, inplace=True) # Fill NaN volume with 0
        df = df[df['close'] > 0] # Ensure close price is positive

        rows_dropped = initial_len - len(df)
        if rows_dropped > 0:
            lg.debug(f"Dropped {rows_dropped} rows with NaN/invalid price data for {symbol}.")

        if df.empty:
            lg.warning(f"{COLOR_WARNING}Kline data for {symbol} {timeframe} was empty after processing/cleaning.{RESET}")
            return empty_df

        df.sort_index(inplace=True) # Ensure chronological order

        lg.info(f"Successfully fetched and processed {len(df)} klines for {symbol} {timeframe}")
        return df

    except ccxt.BadSymbol as e:
         lg.error(f"{COLOR_ERROR}Invalid symbol {symbol} for klines: {e}{RESET}")
    except ccxt.NetworkError as e:
        lg.error(f"{COLOR_ERROR}Network error fetching klines for {symbol} after retries: {e}{RESET}")
    except ccxt.ExchangeError as e:
        lg.error(f"{COLOR_ERROR}Exchange error processing klines for {symbol}: {e}{RESET}")
    except Exception as e:
        lg.error(f"{COLOR_ERROR}Unexpected error processing klines for {symbol}: {e}{RESET}", exc_info=True)
    return empty_df

# --- Volbot Strategy Calculation Functions ---

def ema_swma(series: pd.Series, length: int, logger: logging.Logger) -> pd.Series:
    """
    Calculates a Smoothed Weighted Moving Average (SWMA), an EMA applied
    to a weighted average of the last 4 values (weights: 1/6, 2/6, 2/6, 1/6).
    Uses pandas_ta.ema with adjust=False for TV-like calculation.

    Args:
        series: Input pandas Series (e.g., 'close' prices).
        length: EMA length parameter.
        logger: Logger instance.

    Returns:
        A pandas Series with SWMA values.
    """
    lg = logger
    lg.debug(f"Calculating SWMA with length: {length}...")
    required_periods = 4 # Need 4 periods for the weighting
    if len(series) < required_periods:
        lg.warning(f"Series length ({len(series)}) < {required_periods}. SWMA requires {required_periods} periods. Returning standard EMA.")
        # Fallback to standard EMA, use adjust=False for consistency
        return ta.ema(series, length=length, adjust=False)

    # Calculate the weighted average: (1/6)*P[t] + (2/6)*P[t-1] + (2/6)*P[t-2] + (1/6)*P[t-3]
    # Ensure correct alignment using shift
    weighted_series = (series / 6 +
                       series.shift(1) * 2 / 6 +
                       series.shift(2) * 2 / 6 +
                       series.shift(3) / 6)

    # Calculate EMA on the weighted series, drop initial NaNs caused by weighting shifts
    # Use adjust=False for behavior closer to TradingView's EMA calculation
    smoothed_ema = ta.ema(weighted_series.dropna(), length=length, adjust=False)

    # Reindex to match the original series index, forward-filling initial NaNs if needed
    return smoothed_ema.reindex(series.index).ffill() # ffill to handle NaNs at the very beginning


def calculate_volatility_levels(df: pd.DataFrame, config: Dict[str, Any], logger: logging.Logger) -> pd.DataFrame:
    """
    Calculates core Volumatic Trend indicators: EMAs, ATR, dynamic levels,
    normalized volume, and cumulative volume metrics.

    Args:
        df: DataFrame with OHLCV data.
        config: Configuration dictionary.
        logger: Logger instance.

    Returns:
        DataFrame with added Volbot strategy columns. Returns input df if insufficient data.
    """
    lg = logger
    lg.info("Calculating Volumatic Trend Levels...")
    length = config.get("volbot_length", DEFAULT_VOLBOT_LENGTH)
    atr_length = config.get("volbot_atr_length", DEFAULT_VOLBOT_ATR_LENGTH)
    volume_lookback = config.get("volbot_volume_percentile_lookback", DEFAULT_VOLBOT_VOLUME_PERCENTILE_LOOKBACK)

    # Check for sufficient data length
    min_len = max(length, atr_length, volume_lookback) + 10 # Add buffer
    if len(df) < min_len:
        lg.warning(f"{COLOR_WARNING}Insufficient data ({len(df)} rows) for Volumatic Trend calculation (min ~{min_len}). Skipping.{RESET}")
        return df # Return original df without calculations

    df_calc = df.copy() # Work on a copy

    try:
        # Calculate Strategy EMAs and ATR
        df_calc['ema1_strat'] = ema_swma(df_calc['close'], length, lg)
        df_calc['ema2_strat'] = ta.ema(df_calc['close'], length=length, adjust=False)
        df_calc['atr_strat'] = ta.atr(df_calc['high'], df_calc['low'], df_calc['close'], length=atr_length)

        # Determine Trend Direction (UP if smoothed EMA > standard EMA)
        df_calc['trend_up_strat'] = df_calc['ema1_strat'] > df_calc['ema2_strat']
        # Identify exact points where trend changes (True on the first bar of the new trend)
        df_calc['trend_changed_strat'] = df_calc['trend_up_strat'].diff().fillna(False) # True where trend flips

        # Initialize level columns
        level_cols = ['upper_strat', 'lower_strat', 'lower_vol_strat', 'upper_vol_strat',
                      'step_up_strat', 'step_dn_strat']
        for col in level_cols:
            df_calc[col] = np.nan

        # --- Calculate Dynamic Levels Based on Trend Changes ---
        # Levels are reset/recalculated ONLY on the bar where the trend flip occurs.
        # They remain constant until the next flip.
        last_ema1 = np.nan
        last_atr = np.nan
        for i in range(len(df_calc)):
            current_index = df_calc.index[i]

            # Use values from the PREVIOUS bar to calculate levels for the CURRENT bar if trend flipped
            if i > 0:
                 prev_index = df_calc.index[i-1]
                 if df_calc.loc[current_index, 'trend_changed_strat']:
                    # Trend flipped *between* previous and current bar. Calculate levels based on previous bar's data.
                    ema1_val = df_calc.loc[prev_index, 'ema1_strat']
                    atr_val = df_calc.loc[prev_index, 'atr_strat']

                    if pd.notna(ema1_val) and pd.notna(atr_val) and atr_val > 0:
                        # Calculate levels based on EMA1 +/- 3*ATR
                        upper = ema1_val + atr_val * 3
                        lower = ema1_val - atr_val * 3
                        # Intermediate volatility levels (adjust width by 4*ATR)
                        lower_vol = lower + atr_val * 4 # Top of lower vol zone
                        upper_vol = upper - atr_val * 4 # Bottom of upper vol zone

                        # Step sizes (per 1% of normalized volume)
                        step_up = (lower_vol - lower) / 100 if lower_vol > lower else 0
                        step_dn = (upper - upper_vol) / 100 if upper > upper_vol else 0

                        # Assign the newly calculated levels to the current bar
                        df_calc.loc[current_index, 'upper_strat'] = upper
                        df_calc.loc[current_index, 'lower_strat'] = lower
                        df_calc.loc[current_index, 'lower_vol_strat'] = lower_vol
                        df_calc.loc[current_index, 'upper_vol_strat'] = upper_vol
                        df_calc.loc[current_index, 'step_up_strat'] = step_up
                        df_calc.loc[current_index, 'step_dn_strat'] = step_dn
                        last_ema1, last_atr = ema1_val, atr_val # Store for propagation
                    else:
                        # If EMA/ATR is NaN at trend change, propagate previous levels
                        lg.debug(f"NaN EMA/ATR at trend change index {i}. Propagating previous valid levels.")
                        df_calc.loc[current_index, level_cols] = df_calc.loc[prev_index, level_cols]
                 else:
                     # Trend did not change, propagate levels from the previous bar
                     df_calc.loc[current_index, level_cols] = df_calc.loc[prev_index, level_cols]
            else:
                # For the very first bar, levels are NaN (or handle initialization if needed)
                pass # Levels remain NaN initially

        # --- Calculate Volume Metrics ---
        # Normalized Volume (0-100 based on max volume in lookback)
        max_vol_lookback = df_calc['volume'].rolling(window=volume_lookback, min_periods=1).max()
        df_calc['vol_norm_strat'] = np.where(
            max_vol_lookback > 0,
            (df_calc['volume'] / max_vol_lookback * 100),
            0
        ).fillna(0)

        # Volume-adjusted step amount
        df_calc['vol_up_step_strat'] = df_calc['step_up_strat'] * df_calc['vol_norm_strat']
        df_calc['vol_dn_step_strat'] = df_calc['step_dn_strat'] * df_calc['vol_norm_strat']

        # Final Volume-Adjusted Trend Levels
        df_calc['vol_trend_up_level_strat'] = df_calc['lower_strat'] + df_calc['vol_up_step_strat']
        df_calc['vol_trend_dn_level_strat'] = df_calc['upper_strat'] - df_calc['vol_dn_step_strat']

        # --- Cumulative Volume Since Last Trend Change ---
        df_calc['volume_delta_strat'] = np.where(df_calc['close'] > df_calc['open'], df_calc['volume'],
                                           np.where(df_calc['close'] < df_calc['open'], -df_calc['volume'], 0))
        df_calc['volume_total_strat'] = df_calc['volume']

        # Group by trend blocks (identified by cumulative sum of trend changes)
        trend_block_group = df_calc['trend_changed_strat'].cumsum()
        df_calc['cum_vol_delta_since_change_strat'] = df_calc.groupby(trend_block_group)['volume_delta_strat'].cumsum()
        df_calc['cum_vol_total_since_change_strat'] = df_calc.groupby(trend_block_group)['volume_total_strat'].cumsum()

        # Track index of last trend change for reference
        df_calc['last_trend_change_idx'] = df_calc.index[df_calc['trend_changed_strat']].to_series().reindex(df_calc.index).ffill()


        lg.info("Volumatic Trend Levels calculation complete.")
        return df_calc

    except Exception as e:
        lg.error(f"{COLOR_ERROR}Error during Volumatic Trend calculation: {e}{RESET}", exc_info=True)
        return df # Return original DataFrame on error


def calculate_pivot_order_blocks(df: pd.DataFrame, config: Dict[str, Any], logger: logging.Logger) -> pd.DataFrame:
    """
    Identifies Pivot High (PH) and Pivot Low (PL) points, used for Order Block detection.

    Args:
        df: DataFrame with OHLCV data.
        config: Configuration dictionary.
        logger: Logger instance.

    Returns:
        DataFrame with added 'ph_strat' (Pivot High price) and 'pl_strat' (Pivot Low price).
        Returns input df if insufficient data.
    """
    lg = logger
    source = config.get("volbot_ob_source", DEFAULT_VOLBOT_OB_SOURCE)
    left_h = config.get("volbot_pivot_left_len_h", DEFAULT_VOLBOT_PIVOT_LEFT_LEN_H)
    right_h = config.get("volbot_pivot_right_len_h", DEFAULT_VOLBOT_PIVOT_RIGHT_LEN_H)
    left_l = config.get("volbot_pivot_left_len_l", DEFAULT_VOLBOT_PIVOT_LEFT_LEN_L)
    right_l = config.get("volbot_pivot_right_len_l", DEFAULT_VOLBOT_PIVOT_RIGHT_LEN_L)
    lg.info(f"Calculating Pivot Points (Source: {source}, Left/Right H: {left_h}/{right_h}, L: {left_l}/{right_l})...")

    # Check for sufficient data length
    min_len_h = left_h + right_h + 1
    min_len_l = left_l + right_l + 1
    if len(df) < max(min_len_h, min_len_l):
        lg.warning(f"{COLOR_WARNING}Insufficient data ({len(df)} rows) for Pivot calculation (min H ~{min_len_h}, L ~{min_len_l}). Skipping.{RESET}")
        return df

    df_calc = df.copy()
    try:
        # Select price series based on source config
        high_col = df_calc['high'] if source == "Wicks" else df_calc['close'] # Pivot High uses High (Wicks) or Close (Bodys)
        low_col = df_calc['low'] if source == "Wicks" else df_calc['open']   # Pivot Low uses Low (Wicks) or Open (Bodys)

        df_calc['ph_strat'] = np.nan
        df_calc['pl_strat'] = np.nan

        # --- Calculate Pivot Highs (PH) ---
        # A bar `i` is PH if high_col[i] is strictly greater than highs in `left_h` bars before
        # AND strictly greater than highs in `right_h` bars after.
        for i in range(left_h, len(df_calc) - right_h):
            is_pivot_high = True
            pivot_val = high_col.iloc[i]
            # Check left: pivot_val > all left values
            for j in range(1, left_h + 1):
                if high_col.iloc[i-j] >= pivot_val:
                    is_pivot_high = False; break
            if not is_pivot_high: continue
            # Check right: pivot_val > all right values
            for j in range(1, right_h + 1):
                if high_col.iloc[i+j] >= pivot_val:
                    is_pivot_high = False; break

            if is_pivot_high:
                df_calc.loc[df_calc.index[i], 'ph_strat'] = pivot_val # Store the high price at the pivot bar

        # --- Calculate Pivot Lows (PL) ---
        # A bar `i` is PL if low_col[i] is strictly lower than lows in `left_l` bars before
        # AND strictly lower than lows in `right_l` bars after.
        for i in range(left_l, len(df_calc) - right_l):
            is_pivot_low = True
            pivot_val = low_col.iloc[i]
            # Check left: pivot_val < all left values
            for j in range(1, left_l + 1):
                if low_col.iloc[i-j] <= pivot_val:
                    is_pivot_low = False; break
            if not is_pivot_low: continue
            # Check right: pivot_val < all right values
            for j in range(1, right_l + 1):
                if low_col.iloc[i+j] <= pivot_val:
                    is_pivot_low = False; break

            if is_pivot_low:
                 df_calc.loc[df_calc.index[i], 'pl_strat'] = pivot_val # Store the low price at the pivot bar

        lg.info("Pivot Point calculation complete.")
        return df_calc

    except Exception as e:
        lg.error(f"{COLOR_ERROR}Error during Pivot calculation: {e}{RESET}", exc_info=True)
        return df # Return original DataFrame on error

def manage_order_blocks(df: pd.DataFrame, config: Dict[str, Any], logger: logging.Logger) -> Tuple[pd.DataFrame, List[Dict], List[Dict]]:
    """
    Identifies, creates, and manages the state (active/closed) of Order Blocks (OBs)
    based on pivot points and subsequent price action.

    Args:
        df: DataFrame with OHLCV and pivot columns ('ph_strat', 'pl_strat').
        config: Configuration dictionary.
        logger: Logger instance.

    Returns:
        Tuple: (DataFrame with active OB references, list of all bull OBs, list of all bear OBs).
               Returns input df and empty lists if insufficient data or error.
    """
    lg = logger
    lg.info("Managing Order Block Boxes...")
    source = config.get("volbot_ob_source", DEFAULT_VOLBOT_OB_SOURCE)
    right_h = config.get("volbot_pivot_right_len_h", DEFAULT_VOLBOT_PIVOT_RIGHT_LEN_H) # Bars from PH back to OB candle
    right_l = config.get("volbot_pivot_right_len_l", DEFAULT_VOLBOT_PIVOT_RIGHT_LEN_L) # Bars from PL back to OB candle
    max_boxes = config.get("volbot_max_boxes", DEFAULT_VOLBOT_MAX_BOXES)

    df_calc = df.copy()
    bull_boxes: List[Dict] = []
    bear_boxes: List[Dict] = []
    box_counter = 0

    # Check if pivot columns exist
    if 'ph_strat' not in df_calc.columns or 'pl_strat' not in df_calc.columns:
        lg.warning(f"{COLOR_WARNING}Pivot columns ('ph_strat', 'pl_strat') not found. Skipping OB management.{RESET}")
        df_calc['active_bull_ob_strat'] = None
        df_calc['active_bear_ob_strat'] = None
        return df_calc, bull_boxes, bear_boxes

    df_calc['active_bull_ob_strat'] = pd.Series(dtype='object')
    df_calc['active_bear_ob_strat'] = pd.Series(dtype='object')

    try:
        # Iterate through each bar to potentially create and manage OBs
        for i in range(len(df_calc)):
            current_idx = df_calc.index[i]
            current_close = df_calc.loc[current_idx, 'close']

            # --- Create New Bearish OB (Based on Pivot Highs) ---
            # PH confirmed at index 'i'. OB candle is 'right_h' bars *before* 'i'.
            if pd.notna(df_calc.loc[current_idx, 'ph_strat']):
                ob_candle_iloc = i - right_h
                if ob_candle_iloc >= 0:
                    ob_candle_idx = df_calc.index[ob_candle_iloc]
                    top_p, bottom_p = np.nan, np.nan

                    if source == "Bodys": # Bearish Body OB: Close to Open
                        top_p = df_calc.loc[ob_candle_idx, 'close']
                        bottom_p = df_calc.loc[ob_candle_idx, 'open']
                    else: # Wicks (Default): High to Close
                        top_p = df_calc.loc[ob_candle_idx, 'high']
                        bottom_p = df_calc.loc[ob_candle_idx, 'close']

                    if pd.notna(top_p) and pd.notna(bottom_p):
                        # Ensure top > bottom
                        top_price = max(top_p, bottom_p)
                        bottom_price = min(top_p, bottom_p)
                        box_counter += 1
                        new_box = {
                            'id': f'BearOB_{box_counter}', 'type': 'bear',
                            'start_idx': ob_candle_idx, 'pivot_idx': current_idx,
                            'end_idx': current_idx, # Tracks mitigation bar
                            'top': top_price, 'bottom': bottom_price, 'state': 'active'
                        }
                        bear_boxes.append(new_box)
                        lg.debug(f"Created Bearish OB: {new_box['id']} (Pivot: {current_idx}, Candle: {ob_candle_idx}, Range: [{bottom_price:.5f}, {top_price:.5f}])")

            # --- Create New Bullish OB (Based on Pivot Lows) ---
            # PL confirmed at index 'i'. OB candle is 'right_l' bars *before* 'i'.
            if pd.notna(df_calc.loc[current_idx, 'pl_strat']):
                ob_candle_iloc = i - right_l
                if ob_candle_iloc >= 0:
                    ob_candle_idx = df_calc.index[ob_candle_iloc]
                    top_p, bottom_p = np.nan, np.nan

                    if source == "Bodys": # Bullish Body OB: Close to Open
                        top_p = df_calc.loc[ob_candle_idx, 'close']
                        bottom_p = df_calc.loc[ob_candle_idx, 'open']
                    else: # Wicks (Default): Open to Low
                        top_p = df_calc.loc[ob_candle_idx, 'open']
                        bottom_p = df_calc.loc[ob_candle_idx, 'low']

                    if pd.notna(top_p) and pd.notna(bottom_p):
                        # Ensure top > bottom
                        top_price = max(top_p, bottom_p)
                        bottom_price = min(top_p, bottom_p)
                        box_counter += 1
                        new_box = {
                            'id': f'BullOB_{box_counter}', 'type': 'bull',
                            'start_idx': ob_candle_idx, 'pivot_idx': current_idx,
                            'end_idx': current_idx, # Tracks mitigation bar
                            'top': top_price, 'bottom': bottom_price, 'state': 'active'
                        }
                        bull_boxes.append(new_box)
                        lg.debug(f"Created Bullish OB: {new_box['id']} (Pivot: {current_idx}, Candle: {ob_candle_idx}, Range: [{bottom_price:.5f}, {top_price:.5f}])")

            # --- Manage Existing Boxes State & Identify Active OB for Current Bar ---
            active_bull_ref = None
            for box in bull_boxes:
                if box['state'] == 'active':
                    # Check for mitigation (close below Bull OB bottom)
                    if current_close < box['bottom']:
                        box['state'] = 'closed'
                        box['end_idx'] = current_idx
                        lg.debug(f"Closed Bullish OB: {box['id']} (Close {current_close:.5f} < Bottom {box['bottom']:.5f})")
                    else:
                        # Still active, check if price is currently inside
                        if box['bottom'] <= current_close <= box['top']:
                            active_bull_ref = box # Store reference to the active box dict

            active_bear_ref = None
            for box in bear_boxes:
                if box['state'] == 'active':
                    # Check for mitigation (close above Bear OB top)
                    if current_close > box['top']:
                        box['state'] = 'closed'
                        box['end_idx'] = current_idx
                        lg.debug(f"Closed Bearish OB: {box['id']} (Close {current_close:.5f} > Top {box['top']:.5f})")
                    else:
                        # Still active, check if price is currently inside
                        if box['bottom'] <= current_close <= box['top']:
                            active_bear_ref = box # Store reference to the active box dict

            # Store the active OB reference (or None) in the DataFrame for this bar
            df_calc.at[current_idx, 'active_bull_ob_strat'] = active_bull_ref
            df_calc.at[current_idx, 'active_bear_ob_strat'] = active_bear_ref

        # --- Clean Up Old Active Boxes (Limit Memory/Complexity) ---
        # Only keep the 'max_boxes' most recent *active* boxes of each type
        active_bull_boxes = sorted([b for b in bull_boxes if b['state'] == 'active'], key=lambda x: x['pivot_idx'], reverse=True)
        active_bear_boxes = sorted([b for b in bear_boxes if b['state'] == 'active'], key=lambda x: x['pivot_idx'], reverse=True)

        # Combine closed boxes with the N most recent active boxes
        bull_boxes = [b for b in bull_boxes if b['state'] == 'closed'] + active_bull_boxes[:max_boxes]
        bear_boxes = [b for b in bear_boxes if b['state'] == 'closed'] + active_bear_boxes[:max_boxes]

        num_active_bull = len(active_bull_boxes)
        num_active_bear = len(active_bear_boxes)
        if num_active_bull > max_boxes: lg.debug(f"Trimmed active Bull OBs from {num_active_bull} to {max_boxes}")
        if num_active_bear > max_boxes: lg.debug(f"Trimmed active Bear OBs from {num_active_bear} to {max_boxes}")

        lg.info(f"Order Block management complete. Total Bull OBs tracked: {len(bull_boxes)}, Bear OBs: {len(bear_boxes)}")
        return df_calc, bull_boxes, bear_boxes

    except Exception as e:
        lg.error(f"{COLOR_ERROR}Error during Order Block management: {e}{RESET}", exc_info=True)
        # Return original df state if error occurs during management
        df['active_bull_ob_strat'] = None
        df['active_bear_ob_strat'] = None
        return df, [], []


# --- Trading Analyzer Class ---
class TradingAnalyzer:
    """
    Analyzes trading data using Volbot strategy, generates signals, and calculates risk metrics.
    """
    def __init__(
        self,
        df: pd.DataFrame,
        logger: logging.Logger,
        config: Dict[str, Any],
        market_info: Dict[str, Any],
    ) -> None:
        self.df_raw = df
        self.df_processed = pd.DataFrame()
        self.logger = logger
        self.config = config
        self.market_info = market_info
        self.symbol = market_info.get('symbol', 'UNKNOWN_SYMBOL')
        self.interval = config.get("interval", "UNKNOWN")
        self.ccxt_interval = CCXT_INTERVAL_MAP.get(self.interval, "UNKNOWN")
        self.price_precision = self._determine_price_precision()
        self.amount_precision = self._determine_amount_precision()
        self.min_tick_size = self._determine_min_tick_size()

        self.strategy_state: Dict[str, Any] = {}
        self.latest_active_bull_ob: Optional[Dict] = None
        self.latest_active_bear_ob: Optional[Dict] = None
        self.all_bull_boxes: List[Dict] = []
        self.all_bear_boxes: List[Dict] = []

        self._calculate_indicators()
        self._update_latest_strategy_state()

    def _determine_price_precision(self) -> int:
        """Determine decimal places for price formatting."""
        try:
            tick_size = self.min_tick_size # Use the already determined tick size
            if tick_size > 0:
                return abs(tick_size.normalize().as_tuple().exponent)
        except Exception as e:
            self.logger.warning(f"Could not determine price precision from tick size for {self.symbol}: {e}. Using default.")
        # Default fallback
        return 4

    def _determine_amount_precision(self) -> int:
         """Determine decimal places for amount/size formatting."""
         try:
            precision_info = self.market_info.get('precision', {})
            amount_precision_val = precision_info.get('amount')
            if isinstance(amount_precision_val, int):
                return amount_precision_val # Direct decimal places
            elif isinstance(amount_precision_val, (float, str)):
                # Assume it's step size, calculate decimals
                step_size = Decimal(str(amount_precision_val))
                if step_size > 0:
                    return abs(step_size.normalize().as_tuple().exponent)
         except Exception as e:
             self.logger.warning(f"Could not determine amount precision for {self.symbol}: {e}. Using default.")
         # Default fallback
         return 8 # Common default for crypto amounts

    def _determine_min_tick_size(self) -> Decimal:
        """Determine minimum price increment (tick size)."""
        try:
            # Prefer precision info
            precision_info = self.market_info.get('precision', {})
            price_prec = precision_info.get('price') # Often the tick size
            if price_prec is not None:
                 tick = safe_decimal(price_prec)
                 if tick and tick > 0: return tick

            # Fallback to limits info
            limits_info = self.market_info.get('limits', {})
            price_limits = limits_info.get('price', {})
            min_price = price_limits.get('min')
            if min_price is not None:
                tick = safe_decimal(min_price)
                if tick and tick > 0: return tick

        except Exception as e:
            self.logger.warning(f"Could not reliably determine tick size for {self.symbol}: {e}. Using fallback.")

        # Fallback: estimate from price precision (less reliable)
        try:
            precision_info = self.market_info.get('precision', {})
            price_prec_places = precision_info.get('price') # Might be decimal places integer
            if isinstance(price_prec_places, int) and price_prec_places >= 0:
                fallback_tick = Decimal('1e-' + str(price_prec_places))
                self.logger.debug(f"Using fallback tick size based on precision places for {self.symbol}: {fallback_tick}")
                return fallback_tick
        except Exception: pass

        # Absolute fallback
        default_tick = Decimal('0.0001')
        self.logger.warning(f"Using default tick size {default_tick} for {self.symbol}.")
        return default_tick

    def _calculate_indicators(self) -> None:
        """Calculates Risk Management ATR and Volbot strategy indicators."""
        if self.df_raw.empty:
            self.logger.warning(f"{COLOR_WARNING}Raw DataFrame empty, cannot calculate indicators for {self.symbol}.{RESET}")
            return

        # Check min data length
        min_len_volbot = max(
            self.config.get("volbot_length", DEFAULT_VOLBOT_LENGTH),
            self.config.get("volbot_atr_length", DEFAULT_VOLBOT_ATR_LENGTH),
            self.config.get("volbot_volume_percentile_lookback", DEFAULT_VOLBOT_VOLUME_PERCENTILE_LOOKBACK),
            self.config.get("volbot_pivot_left_len_h", DEFAULT_VOLBOT_PIVOT_LEFT_LEN_H) + self.config.get("volbot_pivot_right_len_h", DEFAULT_VOLBOT_PIVOT_RIGHT_LEN_H) + 1,
            self.config.get("volbot_pivot_left_len_l", DEFAULT_VOLBOT_PIVOT_LEFT_LEN_L) + self.config.get("volbot_pivot_right_len_l", DEFAULT_VOLBOT_PIVOT_RIGHT_LEN_L) + 1
        )
        min_len_risk = self.config.get("atr_period", DEFAULT_ATR_PERIOD)
        min_required_data = max(min_len_volbot, min_len_risk) + 50 # Add buffer

        if len(self.df_raw) < min_required_data:
            self.logger.warning(
                f"{COLOR_WARNING}Insufficient data ({len(self.df_raw)} points) for {self.symbol}. "
                f"Need ~{min_required_data} for reliable calculations. Results may be inaccurate.{RESET}"
            )
            # Proceed, but be aware of potential NaNs or inaccuracies

        try:
            df_calc = self.df_raw.copy()

            # 1. Calculate Risk Management ATR (for SL/TP/BE)
            atr_period_risk = self.config.get("atr_period", DEFAULT_ATR_PERIOD)
            df_calc['atr_risk'] = ta.atr(df_calc['high'], df_calc['low'], df_calc['close'], length=atr_period_risk)
            self.logger.debug(f"Calculated Risk Management ATR (Length: {atr_period_risk})")

            # 2. Calculate Volbot Strategy Indicators (if enabled)
            if self.config.get("volbot_enabled", True):
                df_calc = calculate_volatility_levels(df_calc, self.config, self.logger)
                df_calc = calculate_pivot_order_blocks(df_calc, self.config, self.logger)
                df_calc, self.all_bull_boxes, self.all_bear_boxes = manage_order_blocks(df_calc, self.config, self.logger)
            else:
                 self.logger.info("Volbot strategy calculation skipped (disabled in config).")

            self.df_processed = df_calc
            self.logger.debug(f"Indicator calculations complete for {self.symbol}. Processed DF has {len(self.df_processed)} rows.")

        except Exception as e:
            self.logger.error(f"{COLOR_ERROR}Error calculating indicators for {self.symbol}: {e}{RESET}", exc_info=True)
            self.df_processed = pd.DataFrame() # Ensure empty on error

    def _update_latest_strategy_state(self) -> None:
        """Updates `strategy_state` with the latest values from `df_processed`."""
        self.strategy_state = {} # Reset state
        self.latest_active_bull_ob = None
        self.latest_active_bear_ob = None

        if self.df_processed.empty or len(self.df_processed) == 0:
            self.logger.warning(f"Cannot update state: Processed DataFrame is empty for {self.symbol}.")
            return

        try:
            latest = self.df_processed.iloc[-1]

            if latest.isnull().all():
                self.logger.warning(f"{COLOR_WARNING}Last row of processed DataFrame contains all NaNs for {self.symbol}. Insufficient history?{RESET}")
                return

            # Extract core data + Risk ATR
            core_cols = ['open', 'high', 'low', 'close', 'volume', 'atr_risk']
            for col in core_cols:
                 self.strategy_state[col] = latest.get(col) # Use .get() for safety

            # Extract Volbot state if calculated
            if self.config.get("volbot_enabled", True) and 'trend_up_strat' in latest: # Check if volbot cols exist
                volbot_cols = [
                    'trend_up_strat', 'trend_changed_strat',
                    'vol_trend_up_level_strat', 'vol_trend_dn_level_strat',
                    'lower_strat', 'upper_strat', 'lower_vol_strat', 'upper_vol_strat',
                    'cum_vol_delta_since_change_strat', 'cum_vol_total_since_change_strat',
                    'last_trend_change_idx',
                    'ema1_strat', 'ema2_strat', 'atr_strat'
                ]
                for col in volbot_cols:
                    self.strategy_state[col] = latest.get(col)

                # Get latest active OB references (these are dicts or None)
                self.latest_active_bull_ob = latest.get('active_bull_ob_strat')
                self.latest_active_bear_ob = latest.get('active_bear_ob_strat')
                self.strategy_state['is_in_active_bull_ob'] = self.latest_active_bull_ob is not None
                self.strategy_state['is_in_active_bear_ob'] = self.latest_active_bear_ob is not None

            # Convert Decimal types for consistency if needed (Pandas often uses float)
            for key, value in self.strategy_state.items():
                if isinstance(value, (float, np.float64)):
                    self.strategy_state[key] = safe_decimal(value)

            # Log the updated state compactly
            log_state = {k: f"{v:.{self.price_precision}f}" if isinstance(v, Decimal) and k != 'volume' else v
                         for k, v in self.strategy_state.items() if pd.notna(v)}
            self.logger.debug(f"Latest strategy state updated for {self.symbol}: {log_state}")
            if self.latest_active_bull_ob: self.logger.debug(f"  Latest Active Bull OB: ID={self.latest_active_bull_ob.get('id')}, Range=[{self.latest_active_bull_ob.get('bottom'):.5f}, {self.latest_active_bull_ob.get('top'):.5f}]")
            if self.latest_active_bear_ob: self.logger.debug(f"  Latest Active Bear OB: ID={self.latest_active_bear_ob.get('id')}, Range=[{self.latest_active_bear_ob.get('bottom'):.5f}, {self.latest_active_bear_ob.get('top'):.5f}]")

        except IndexError:
            self.logger.error(f"Error accessing latest row for {self.symbol}. Processed DataFrame might be empty or too short.")
        except Exception as e:
            self.logger.error(f"Unexpected error updating latest strategy state for {self.symbol}: {e}", exc_info=True)

    # --- Utility Functions ---
    def get_price_precision(self) -> int: return self.price_precision
    def get_amount_precision(self) -> int: return self.amount_precision
    def get_min_tick_size(self) -> Decimal: return self.min_tick_size

    # --- Signal Generation ---
    def generate_trading_signal(self) -> str:
        """
        Generates "BUY", "SELL", or "HOLD" signal based on Volbot rules and config.
        """
        signal = "HOLD"
        if not self.strategy_state or not self.config.get("volbot_enabled", True):
            self.logger.debug("Cannot generate Volbot signal: State empty or strategy disabled.")
            return signal

        try:
            is_trend_up = self.strategy_state.get('trend_up_strat') # Boolean or None
            trend_changed = self.strategy_state.get('trend_changed_strat', False)
            is_in_bull_ob = self.strategy_state.get('is_in_active_bull_ob', False)
            is_in_bear_ob = self.strategy_state.get('is_in_active_bear_ob', False)

            signal_on_flip = self.config.get("volbot_signal_on_trend_flip", True)
            signal_on_ob = self.config.get("volbot_signal_on_ob_entry", True)

            if is_trend_up is None: # Trend couldn't be determined
                self.logger.debug("Volbot signal: HOLD (Trend state undetermined)")
                return "HOLD"

            # Rule 1: Trend Flip Signal (Highest Priority)
            if signal_on_flip and trend_changed:
                signal = "BUY" if is_trend_up else "SELL"
                reason = f"Trend flipped to {'UP' if is_trend_up else 'DOWN'}"
                color = COLOR_UP if is_trend_up else COLOR_DN
                self.logger.info(f"{color}Volbot Signal: {signal} (Reason: {reason}){RESET}")
                return signal

            # Rule 2: Order Block Entry Signal (If no flip)
            if signal_on_ob:
                if is_trend_up and is_in_bull_ob:
                    signal = "BUY"
                    ob_id = self.latest_active_bull_ob.get('id', 'N/A') if self.latest_active_bull_ob else 'N/A'
                    reason = f"Price in Bull OB '{ob_id}' during Uptrend"
                    self.logger.info(f"{COLOR_BULL_BOX}Volbot Signal: {signal} (Reason: {reason}){RESET}")
                    return signal
                elif not is_trend_up and is_in_bear_ob:
                    signal = "SELL"
                    ob_id = self.latest_active_bear_ob.get('id', 'N/A') if self.latest_active_bear_ob else 'N/A'
                    reason = f"Price in Bear OB '{ob_id}' during Downtrend"
                    self.logger.info(f"{COLOR_BEAR_BOX}Volbot Signal: {signal} (Reason: {reason}){RESET}")
                    return signal

            # Rule 3: Default to HOLD
            if signal == "HOLD":
                trend_str = "UP" if is_trend_up else "DOWN"
                ob_status = f"InBullOB={is_in_bull_ob}, InBearOB={is_in_bear_ob}"
                self.logger.info(f"Volbot Signal: HOLD (Conditions: Trend={trend_str}, {ob_status})")

        except Exception as e:
             self.logger.error(f"{COLOR_ERROR}Error generating signal: {e}{RESET}", exc_info=True)
             return "HOLD" # Default to HOLD on error

        return signal

    # --- Risk Management Calculations ---
    def calculate_entry_tp_sl(
        self, entry_price: Decimal, signal: str
    ) -> Tuple[Optional[Decimal], Optional[Decimal], Optional[Decimal]]:
        """
        Calculates potential TP and initial SL based on entry, signal, Risk ATR, and config.
        Rounds results to the market's minimum tick size.

        Args:
            entry_price: Potential entry price (Decimal).
            signal: "BUY" or "SELL".

        Returns:
            Tuple (entry_price, take_profit, stop_loss), Decimals or None.
        """
        if signal not in ["BUY", "SELL"]:
            self.logger.debug(f"Cannot calculate TP/SL: Signal is '{signal}'.")
            return entry_price, None, None

        atr_val = self.strategy_state.get("atr_risk") # Use Risk Management ATR
        tp_multiple = safe_decimal(self.config.get("take_profit_multiple", 1.0))
        sl_multiple = safe_decimal(self.config.get("stop_loss_multiple", 1.5))
        min_tick = self.min_tick_size

        if not all([isinstance(v, Decimal) and v > 0 for v in [entry_price, tp_multiple, sl_multiple, min_tick]]) or \
           not (isinstance(atr_val, Decimal) and atr_val > 0):
            self.logger.warning(f"{COLOR_WARNING}Cannot calculate TP/SL for {self.symbol}: Invalid inputs "
                                f"(Entry={entry_price}, ATR={atr_val}, TP mult={tp_multiple}, SL mult={sl_multiple}, Tick={min_tick}).{RESET}")
            return entry_price, None, None

        try:
            tp_offset = atr_val * tp_multiple
            sl_offset = atr_val * sl_multiple
            take_profit, stop_loss = None, None

            if signal == "BUY":
                tp_raw = entry_price + tp_offset
                sl_raw = entry_price - sl_offset
                # Round TP UP, SL DOWN to nearest tick
                take_profit = (tp_raw / min_tick).quantize(Decimal('1'), rounding=ROUND_UP) * min_tick
                stop_loss = (sl_raw / min_tick).quantize(Decimal('1'), rounding=ROUND_DOWN) * min_tick
            elif signal == "SELL":
                tp_raw = entry_price - tp_offset
                sl_raw = entry_price + sl_offset
                # Round TP DOWN, SL UP to nearest tick
                take_profit = (tp_raw / min_tick).quantize(Decimal('1'), rounding=ROUND_DOWN) * min_tick
                stop_loss = (sl_raw / min_tick).quantize(Decimal('1'), rounding=ROUND_UP) * min_tick

            # --- Validate Calculated SL/TP ---
            # Ensure SL is at least one tick away from entry in the loss direction
            if signal == "BUY" and stop_loss >= entry_price:
                adjusted_sl = (entry_price - min_tick).quantize(min_tick, rounding=ROUND_DOWN)
                self.logger.warning(f"{COLOR_WARNING}BUY SL ({stop_loss}) >= entry ({entry_price}). Adjusting SL to {adjusted_sl}.{RESET}")
                stop_loss = adjusted_sl
            elif signal == "SELL" and stop_loss <= entry_price:
                adjusted_sl = (entry_price + min_tick).quantize(min_tick, rounding=ROUND_UP)
                self.logger.warning(f"{COLOR_WARNING}SELL SL ({stop_loss}) <= entry ({entry_price}). Adjusting SL to {adjusted_sl}.{RESET}")
                stop_loss = adjusted_sl

            # Ensure TP is at least one tick away from entry in the profit direction
            if signal == "BUY" and take_profit <= entry_price:
                adjusted_tp = (entry_price + min_tick).quantize(min_tick, rounding=ROUND_UP)
                self.logger.warning(f"{COLOR_WARNING}BUY TP ({take_profit}) <= entry ({entry_price}). Adjusting TP to {adjusted_tp}.{RESET}")
                take_profit = adjusted_tp
            elif signal == "SELL" and take_profit >= entry_price:
                adjusted_tp = (entry_price - min_tick).quantize(min_tick, rounding=ROUND_DOWN)
                self.logger.warning(f"{COLOR_WARNING}SELL TP ({take_profit}) >= entry ({entry_price}). Adjusting TP to {adjusted_tp}.{RESET}")
                take_profit = adjusted_tp

            # Ensure SL/TP are positive prices
            if stop_loss is not None and stop_loss <= 0:
                self.logger.error(f"{COLOR_ERROR}SL calculation resulted in zero/negative price ({stop_loss}). Setting SL to None.{RESET}")
                stop_loss = None
            if take_profit is not None and take_profit <= 0:
                self.logger.error(f"{COLOR_ERROR}TP calculation resulted in zero/negative price ({take_profit}). Setting TP to None.{RESET}")
                take_profit = None

            price_fmt = f".{self.price_precision}f"
            tp_str = f"{take_profit:{price_fmt}}" if take_profit else "N/A"
            sl_str = f"{stop_loss:{price_fmt}}" if stop_loss else "N/A"
            self.logger.info(f"Calculated TP/SL for {self.symbol} {signal} (Risk ATR={atr_val:{price_fmt}}): "
                             f"Entry={entry_price:{price_fmt}}, TP={tp_str}, SL={sl_str}")
            return entry_price, take_profit, stop_loss

        except Exception as e:
            self.logger.error(f"{COLOR_ERROR}Error calculating TP/SL for {self.symbol}: {e}{RESET}", exc_info=True)
            return entry_price, None, None

# --- Trading Logic Helper Functions ---

def fetch_balance(exchange: ccxt.Exchange, currency: str, logger: logging.Logger) -> Optional[Decimal]:
    """
    Fetches the available balance for a specific currency, handling various account types and structures.

    Args:
        exchange: Initialized ccxt.Exchange object.
        currency: Currency code (e.g., "USDT").
        logger: Logger instance.

    Returns:
        Available balance as Decimal, or None on failure.
    """
    lg = logger
    balance_info: Optional[Dict] = None
    balance_found = False

    # Prioritize specific account types relevant for derivatives (Bybit V5)
    account_types_to_try = ['CONTRACT', 'UNIFIED']
    if 'bybit' not in exchange.id.lower():
        account_types_to_try = ['future', 'swap', 'margin', 'spot'] # Generic attempt order

    for acc_type in account_types_to_try:
        try:
            lg.debug(f"Fetching balance with params={{'type': '{acc_type}'}} for {currency}...")
            balance_info = exchange.fetch_balance(params={'type': acc_type})
            # Store the attempted type for later parsing logic
            balance_info['params'] = {'type': acc_type}

            # Check if parsing finds the balance (logic moved below)
            parsed_balance = _parse_balance_from_response(balance_info, currency, lg)
            if parsed_balance is not None:
                balance_found = True
                break # Found balance, exit loop
            else:
                 lg.debug(f"Balance for {currency} not found in '{acc_type}' account type structure.")
                 balance_info = None # Reset to try next type

        except (ccxt.ExchangeError, ccxt.NetworkError) as e:
            # Ignore errors like "account type not supported" and try next
            if "account type not support" in str(e).lower() or "invalid account type" in str(e).lower():
                lg.debug(f"Account type '{acc_type}' not supported/invalid. Trying next.")
                continue
            else:
                lg.warning(f"Exchange/Network error fetching balance (type {acc_type}): {e}. Trying next.")
                if acc_type == account_types_to_try[-1]: # If last attempt failed
                     lg.error(f"Failed to fetch balance for all attempted account types.")
                     return None # Give up if all specific types failed with errors
                continue
        except Exception as e:
            lg.warning(f"Unexpected error fetching balance (type {acc_type}): {e}. Trying next.")
            continue

    # If not found with specific types, try default fetch_balance
    if not balance_found:
        lg.debug(f"Fetching balance using default parameters for {currency}...")
        try:
            balance_info = exchange.fetch_balance()
            balance_info['params'] = {'type': 'default'} # Mark as default fetch
        except Exception as e:
            lg.error(f"{COLOR_ERROR}Failed to fetch balance using default parameters: {e}{RESET}")
            return None # Cannot proceed

    # --- Parse the final balance_info structure ---
    final_balance = _parse_balance_from_response(balance_info, currency, lg)

    if final_balance is not None:
        lg.info(f"Available {currency} balance: {final_balance:.4f}")
        return final_balance
    else:
        lg.error(f"{COLOR_ERROR}Could not determine available balance for {currency} after all attempts.{RESET}")
        lg.debug(f"Final balance_info structure checked: {balance_info}")
        return None

def _parse_balance_from_response(balance_info: Dict, currency: str, logger: logging.Logger) -> Optional[Decimal]:
    """Helper to parse balance from various potential structures in ccxt response."""
    lg = logger
    if not balance_info: return None

    attempted_type = balance_info.get('params',{}).get('type', 'unknown')
    available_balance_str: Optional[str] = None
    parse_source = "N/A"

    try:
        # 1. Standard ccxt 'free' balance (top-level)
        if currency in balance_info and 'free' in balance_info[currency] and balance_info[currency]['free'] is not None:
            available_balance_str = str(balance_info[currency]['free'])
            parse_source = f"standard ['{currency}']['free'] (type: {attempted_type})"

        # 2. Bybit V5 nested structure ('info.result.list')
        # Check only if standard parse failed or returned zero/empty
        if not available_balance_str or safe_decimal(available_balance_str, Decimal('0')) == 0:
            info_dict = balance_info.get('info', {})
            result_dict = info_dict.get('result', {})
            balance_list = result_dict.get('list')
            if isinstance(balance_list, list):
                parsed_v5_acc_type = 'N/A'
                for account in balance_list:
                    current_account_type = account.get('accountType') # e.g., CONTRACT, UNIFIED, SPOT
                    # Match if specific type was requested OR if it was a default fetch (check all)
                    if attempted_type == 'default' or current_account_type == attempted_type:
                        coin_list = account.get('coin')
                        if isinstance(coin_list, list):
                            for coin_data in coin_list:
                                if coin_data.get('coin') == currency:
                                    # Prioritize keys for available balance
                                    free = coin_data.get('availableToWithdraw',
                                                   coin_data.get('availableBalance',
                                                                 coin_data.get('equity'))) # Use equity as another fallback
                                    if free is not None:
                                        available_balance_str = str(free)
                                        parsed_v5_acc_type = current_account_type or 'Unknown'
                                        parse_source = f"Bybit V5 nested list (Account: {parsed_v5_acc_type})"
                                        break # Found currency balance
                            if available_balance_str is not None: break # Exit account loop
                if available_balance_str is None:
                    lg.debug(f"{currency} not found within Bybit V5 'info.result.list[].coin[]' for type {attempted_type}.")


        # 3. Alternative top-level 'free' dictionary structure
        if not available_balance_str or safe_decimal(available_balance_str, Decimal('0')) == 0:
             if 'free' in balance_info and isinstance(balance_info['free'], dict) and currency in balance_info['free']:
                 free_val = balance_info['free'][currency]
                 if free_val is not None:
                    available_balance_str = str(free_val)
                    parse_source = f"top-level 'free' dict (type: {attempted_type})"

        # --- Final Conversion and Fallback ---
        if available_balance_str is not None:
            final_balance = safe_decimal(available_balance_str)
            if final_balance is not None:
                if final_balance > 0:
                    lg.debug(f"Parsed balance via {parse_source}: {final_balance} {currency}")
                    return final_balance
                elif final_balance == 0:
                     lg.debug(f"Parsed balance via {parse_source} is zero: {final_balance} {currency}")
                     # Continue checking other sources or fallbacks if balance is zero
                else: # Negative balance?
                     lg.warning(f"{COLOR_WARNING}Parsed balance via {parse_source} is negative ({final_balance}). Treating as zero.{RESET}")
                     # Treat negative balance as zero for safety/simplicity
                     available_balance_str = None # Reset to trigger potential fallback
            else:
                lg.debug(f"Failed to convert parsed balance string '{available_balance_str}' from {parse_source} to Decimal.")
                available_balance_str = None # Reset to trigger fallback

        # 4. Fallback to 'total' balance if 'free'/'available' is zero or missing
        if available_balance_str is None or (final_balance is not None and final_balance == 0):
            total_balance_str = None
            total_source = "N/A"
            # Check standard 'total'
            if currency in balance_info and 'total' in balance_info[currency] and balance_info[currency]['total'] is not None:
                 total_balance_str = str(balance_info[currency]['total'])
                 total_source = f"standard ['{currency}']['total']"
            # Check V5 'walletBalance' or 'equity' as total proxy
            elif 'info' in balance_info and isinstance(balance_info['info'].get('result', {}).get('list'), list):
                 balance_list = balance_info['info']['result']['list']
                 for account in balance_list:
                     current_account_type = account.get('accountType')
                     if attempted_type == 'default' or current_account_type == attempted_type:
                         coin_list = account.get('coin')
                         if isinstance(coin_list, list):
                             for coin_data in coin_list:
                                 if coin_data.get('coin') == currency:
                                     # Use walletBalance or equity as total proxy
                                     total = coin_data.get('walletBalance', coin_data.get('equity'))
                                     if total is not None:
                                         total_balance_str = str(total)
                                         total_source = f"Bybit V5 nested '{'walletBalance' if coin_data.get('walletBalance') else 'equity'}'"
                                         break
                             if total_balance_str is not None: break
                 if total_balance_str is None: lg.debug("V5 'walletBalance'/'equity' not found.")

            if total_balance_str is not None:
                 total_balance = safe_decimal(total_balance_str)
                 if total_balance is not None and total_balance > 0:
                      lg.warning(f"{COLOR_WARNING}Could not find positive 'free'/'available' balance for {currency}. "
                                 f"Using 'total' balance ({total_balance}) from {total_source} as fallback. This may include collateral/unrealized PnL.{RESET}")
                      return total_balance
                 else:
                      lg.debug(f"'Total' balance from {total_source} is zero or invalid ({total_balance_str}).")

        # If all parsing and fallbacks fail
        return None

    except Exception as e:
        lg.error(f"Error parsing balance response: {e}", exc_info=True)
        lg.debug(f"Balance info structure during parse error: {balance_info}")
        return None


def get_market_info(exchange: ccxt.Exchange, symbol: str, logger: logging.Logger) -> Optional[Dict]:
    """
    Retrieves and validates market information for a symbol from ccxt.

    Args:
        exchange: Initialized ccxt.Exchange object.
        symbol: Trading symbol (e.g., 'BTC/USDT:USDT').
        logger: Logger instance.

    Returns:
        Market info dictionary, or None if not found or error occurs. Adds 'is_contract'.
    """
    lg = logger
    try:
        if not exchange.markets:
            lg.info("Markets not loaded, loading now...")
            exchange.load_markets()

        if symbol not in exchange.markets:
            lg.warning(f"Symbol '{symbol}' not found in initially loaded markets. Reloading markets...")
            try:
                exchange.load_markets(reload=True)
            except Exception as reload_err:
                 lg.error(f"Failed to reload markets: {reload_err}")
                 return None # Cannot proceed if reload fails

            # Check again after reload
            if symbol not in exchange.markets:
                lg.error(f"{COLOR_ERROR}Market '{symbol}' not found after reloading. "
                         f"Check symbol format and availability on {exchange.id}.{RESET}")
                return None

        market = exchange.market(symbol)
        if not market:
            lg.error(f"{COLOR_ERROR}ccxt returned None for market('{symbol}') despite symbol being listed.{RESET}")
            return None

        # --- Add derived info ---
        market['is_contract'] = market.get('contract', False) or market.get('type') in ['swap', 'future']
        market_type = market.get('type', 'unknown')
        contract_type = "Linear" if market.get('linear', False) else "Inverse" if market.get('inverse', False) else "N/A"

        # --- Log key details ---
        price_prec = market.get('precision', {}).get('price', 'N/A')
        amount_prec = market.get('precision', {}).get('amount', 'N/A')
        min_amount = market.get('limits', {}).get('amount', {}).get('min', 'N/A')
        min_cost = market.get('limits', {}).get('cost', {}).get('min', 'N/A')
        contract_size = market.get('contractSize', 'N/A')

        lg.debug(f"Market Info {symbol}: Type={market_type}, Contract={contract_type}, IsContract={market['is_contract']}, "
                 f"PricePrec={price_prec}, AmtPrec={amount_prec}, MinAmt={min_amount}, MinCost={min_cost}, ContractSize={contract_size}")

        # --- Validate essential info ---
        if 'precision' not in market or 'limits' not in market:
             lg.error(f"{COLOR_ERROR}Market {symbol} lacks essential 'precision' or 'limits' information.{RESET}")
             return None
        if market.get('precision', {}).get('price') is None or market.get('precision', {}).get('amount') is None:
             lg.error(f"{COLOR_ERROR}Market {symbol} lacks price or amount precision.{RESET}")
             return None

        return market

    except ccxt.BadSymbol as e:
        lg.error(f"{COLOR_ERROR}Symbol '{symbol}' is invalid on {exchange.id}: {e}{RESET}")
        return None
    except (ccxt.NetworkError, ccxt.ExchangeError) as e:
        lg.error(f"{COLOR_ERROR}API Error getting market info for {symbol}: {e}{RESET}")
        return None
    except Exception as e:
        lg.error(f"{COLOR_ERROR}Unexpected error getting market info for {symbol}: {e}{RESET}", exc_info=True)
        return None

def calculate_position_size(
    balance: Decimal,
    risk_per_trade: float,
    initial_stop_loss_price: Decimal,
    entry_price: Decimal,
    market_info: Dict,
    exchange: ccxt.Exchange, # Pass exchange for formatting
    logger: Optional[logging.Logger] = None
) -> Optional[Decimal]:
    """
    Calculates position size considering balance, risk, SL, entry, and market constraints.

    Args:
        balance: Available quote currency balance (Decimal).
        risk_per_trade: Risk percentage (e.g., 0.01).
        initial_stop_loss_price: Initial SL price (Decimal).
        entry_price: Potential entry price (Decimal).
        market_info: Market info dictionary.
        exchange: Initialized ccxt.Exchange object.
        logger: Logger instance.

    Returns:
        Calculated and adjusted position size (Decimal), or None on failure.
    """
    lg = logger or logging.getLogger(__name__)
    symbol = market_info.get('symbol', 'UNKNOWN')
    quote_currency = market_info.get('quote', 'QUOTE')
    base_currency = market_info.get('base', 'BASE')
    is_contract = market_info.get('is_contract', False)
    is_linear = market_info.get('linear', True) # Default to linear if unsure
    is_inverse = market_info.get('inverse', False)
    size_unit = base_currency if not is_contract else ("Contracts" if is_inverse else base_currency) # Unit for logging

    # --- Input Validation ---
    if not isinstance(balance, Decimal) or balance <= 0:
        lg.error(f"Pos Sizing Fail ({symbol}): Invalid balance ({balance}).")
        return None
    if not (0 < risk_per_trade < 1):
        lg.error(f"Pos Sizing Fail ({symbol}): Invalid risk_per_trade ({risk_per_trade}). Must be > 0 and < 1.")
        return None
    if not isinstance(entry_price, Decimal) or entry_price <= 0:
         lg.error(f"Pos Sizing Fail ({symbol}): Invalid entry price ({entry_price}).")
         return None
    if not isinstance(initial_stop_loss_price, Decimal): # Allow SL=0 only if explicitly handled later
         lg.error(f"Pos Sizing Fail ({symbol}): Invalid SL price type ({initial_stop_loss_price}).")
         return None
    if initial_stop_loss_price == entry_price:
        lg.error(f"Pos Sizing Fail ({symbol}): SL price cannot equal entry price.")
        return None
    if initial_stop_loss_price <= 0:
         lg.warning(f"Pos Sizing ({symbol}): Initial SL price ({initial_stop_loss_price}) is zero or negative. Ensure this is intended.")
         # Allow proceeding, but risk calculation might be infinite/invalid if SL is truly zero.

    try:
        # --- Core Calculation ---
        risk_amount_quote = balance * Decimal(str(risk_per_trade))
        sl_distance_per_unit = abs(entry_price - initial_stop_loss_price)

        if sl_distance_per_unit <= 0:
            lg.error(f"Pos Sizing Fail ({symbol}): SL distance is zero or negative ({sl_distance_per_unit}). Cannot calculate size.")
            return None

        contract_size = safe_decimal(market_info.get('contractSize', '1'), Decimal('1'))
        if contract_size <= 0:
             lg.warning(f"Invalid contract size ({contract_size}) for {symbol}. Defaulting to 1.")
             contract_size = Decimal('1')

        calculated_size = Decimal('0')
        if is_linear or not is_contract: # Linear contracts or Spot
            # Risk per unit = SL distance * contract size (usually 1 for linear/spot)
            risk_per_unit_quote = sl_distance_per_unit * contract_size
            if risk_per_unit_quote > 0:
                calculated_size = risk_amount_quote / risk_per_unit_quote
            else:
                 lg.error(f"Pos Sizing Fail (Linear/Spot {symbol}): Risk per unit zero/negative ({risk_per_unit_quote}).")
                 return None
        else: # Inverse contract
            # Risk per contract = (SL distance * Contract Value in Quote) / Entry Price
            # Here, contract_size is the quote value (e.g., 1 USD)
            if entry_price > 0:
                risk_per_contract_quote = sl_distance_per_unit * contract_size / entry_price
                if risk_per_contract_quote > 0:
                    calculated_size = risk_amount_quote / risk_per_contract_quote
                else:
                    lg.error(f"Pos Sizing Fail (Inverse {symbol}): Risk per contract zero/negative ({risk_per_contract_quote}).")
                    return None
            else: # Should have been caught earlier, but double-check
                 lg.error(f"Pos Sizing Fail (Inverse {symbol}): Entry price is zero or negative.")
                 return None

        lg.info(f"Position Sizing ({symbol}): Balance={balance:.2f}{quote_currency}, Risk={risk_per_trade:.2%}, RiskAmt={risk_amount_quote:.4f}{quote_currency}")
        price_fmt = f".{abs(entry_price.normalize().as_tuple().exponent)}f"
        lg.info(f"  Entry={entry_price:{price_fmt}}, SL={initial_stop_loss_price:{price_fmt}}, SLDist={sl_distance_per_unit:{price_fmt}}")
        lg.info(f"  ContractSize={contract_size}, IsLinear/Spot={is_linear or not is_contract}, IsInverse={is_inverse}")
        lg.info(f"  Initial Calculated Size = {calculated_size:.8f} {size_unit}")

        # --- Apply Market Constraints ---
        limits = market_info.get('limits', {})
        amount_limits = limits.get('amount', {})
        cost_limits = limits.get('cost', {})

        min_amount = safe_decimal(amount_limits.get('min'), Decimal('0'))
        max_amount = safe_decimal(amount_limits.get('max'), Decimal('Infinity'))
        min_cost = safe_decimal(cost_limits.get('min'), Decimal('0'))
        max_cost = safe_decimal(cost_limits.get('max'), Decimal('Infinity'))

        adjusted_size = calculated_size

        # 1. Clamp size by Min/Max Amount
        original_calc_size = adjusted_size
        if adjusted_size < min_amount:
            lg.warning(f"{COLOR_WARNING}Calculated size {adjusted_size:.8f} < min amount {min_amount}. Adjusting to min amount.{RESET}")
            adjusted_size = min_amount
        elif adjusted_size > max_amount:
            lg.warning(f"{COLOR_WARNING}Calculated size {adjusted_size:.8f} > max amount {max_amount}. Capping at max amount.{RESET}")
            adjusted_size = max_amount
        if adjusted_size != original_calc_size:
             lg.info(f"  Size after Amount Limits: {adjusted_size:.8f} {size_unit}")


        # 2. Check and Adjust by Min/Max Cost
        # Estimate cost based on amount-adjusted size
        current_cost = Decimal('0')
        if is_linear or not is_contract: # Cost = Size * Price * ContractSize
            current_cost = adjusted_size * entry_price * contract_size
        else: # Inverse Cost = Size * ContractSize (Quote Value)
             current_cost = adjusted_size * contract_size

        lg.debug(f"  Cost Check: Size={adjusted_size:.8f}, Est. Cost={current_cost:.4f} {quote_currency}, MinCost={min_cost}, MaxCost={max_cost}")

        cost_adjusted = False
        # Adjust for Min Cost
        if min_cost > 0 and current_cost < min_cost:
            lg.warning(f"{COLOR_WARNING}Est. cost {current_cost:.4f} < min cost {min_cost}. Recalculating size for min cost.{RESET}")
            required_size = Decimal('0')
            if is_linear or not is_contract:
                 if entry_price > 0 and contract_size > 0: required_size = min_cost / (entry_price * contract_size)
            else: # Inverse
                 if contract_size > 0: required_size = min_cost / contract_size

            if required_size <= 0:
                 lg.error(f"{COLOR_ERROR}Cannot calculate required size for min cost. Aborting size calculation.{RESET}")
                 return None

            lg.info(f"  Required size for min cost: {required_size:.8f} {size_unit}")
            if required_size > max_amount:
                lg.error(f"{COLOR_ERROR}Cannot meet min cost ({min_cost}): Required size {required_size:.8f} exceeds max amount ({max_amount}). Aborted.{RESET}")
                return None
            # Ensure required size is not less than min amount (sanity check)
            if required_size < min_amount:
                 lg.warning(f"{COLOR_WARNING}Min cost requires size ({required_size:.8f}) less than min amount ({min_amount}). Using min amount instead.{RESET}")
                 required_size = min_amount # Use the larger minimum

            adjusted_size = required_size
            cost_adjusted = True

        # Adjust for Max Cost
        elif max_cost > 0 and current_cost > max_cost:
            lg.warning(f"{COLOR_WARNING}Est. cost {current_cost:.4f} > max cost {max_cost}. Recalculating size for max cost.{RESET}")
            allowed_size = Decimal('0')
            if is_linear or not is_contract:
                if entry_price > 0 and contract_size > 0: allowed_size = max_cost / (entry_price * contract_size)
            else: # Inverse
                if contract_size > 0: allowed_size = max_cost / contract_size

            if allowed_size <= 0:
                 lg.error(f"{COLOR_ERROR}Cannot calculate allowed size for max cost. Aborting size calculation.{RESET}")
                 return None

            lg.info(f"  Allowed size for max cost: {allowed_size:.8f} {size_unit}")
            if allowed_size < min_amount:
                lg.error(f"{COLOR_ERROR}Cannot meet max cost ({max_cost}): Allowed size {allowed_size:.8f} is below min amount ({min_amount}). Aborted.{RESET}")
                return None

            adjusted_size = allowed_size
            cost_adjusted = True

        if cost_adjusted:
            lg.info(f"  Size after Cost Limits: {adjusted_size:.8f} {size_unit}")

        # 3. Apply Amount Precision using ccxt (Truncate for safety)
        final_size = Decimal('0')
        try:
            # Use amount_to_precision with TRUNCATE mode
            formatted_size_str = exchange.amount_to_precision(symbol, float(adjusted_size)) # Default mode varies, check ccxt docs if needed
            # Explicitly truncate using Decimal quantization based on amount precision
            amount_prec_digits = market_info.get('precision', {}).get('amount')
            if isinstance(amount_prec_digits, int): # Decimal places
                 rounding_factor = Decimal('1e-' + str(amount_prec_digits))
                 final_size = adjusted_size.quantize(rounding_factor, rounding=ROUND_DOWN)
                 lg.info(f"Applied amount precision ({amount_prec_digits} decimals, Truncated): {adjusted_size:.8f} -> {final_size} {size_unit}")
            elif isinstance(amount_prec_digits, (float, str)): # Step size
                 step_size = safe_decimal(amount_prec_digits)
                 if step_size and step_size > 0:
                      final_size = (adjusted_size // step_size) * step_size
                      lg.info(f"Applied amount step size ({step_size}, Floored): {adjusted_size:.8f} -> {final_size}")
                 else: # Invalid step size
                      final_size = safe_decimal(formatted_size_str) # Fallback to ccxt default format
                      lg.warning(f"Invalid amount step size ({amount_prec_digits}). Using ccxt default formatted size: {final_size}")
            else: # Unknown precision format
                final_size = safe_decimal(formatted_size_str) # Fallback to ccxt default format
                lg.warning(f"Unknown amount precision format ({amount_prec_digits}). Using ccxt default formatted size: {final_size}")

        except Exception as fmt_err:
            lg.error(f"{COLOR_ERROR}Error applying amount precision for {symbol}: {fmt_err}. Aborting.{RESET}", exc_info=True)
            return None

        # --- Final Validation ---
        if final_size <= 0:
            lg.error(f"{COLOR_ERROR}Position size became zero or negative ({final_size}) after precision/limit adjustments. Aborted.{RESET}")
            return None

        # Re-check against min amount (allow for small tolerance)
        if final_size < min_amount and not math.isclose(float(final_size), float(min_amount), rel_tol=1e-9):
            lg.error(f"{COLOR_ERROR}Final size {final_size} after precision is less than min amount {min_amount}. Aborted.{RESET}")
            return None

        # Re-check against min cost if applicable (allow small tolerance)
        if min_cost > 0:
            final_cost = Decimal('0')
            if is_linear or not is_contract: final_cost = final_size * entry_price * contract_size
            else: final_cost = final_size * contract_size

            if final_cost < min_cost and not math.isclose(float(final_cost), float(min_cost), rel_tol=1e-6):
                 lg.error(f"{COLOR_ERROR}Final cost {final_cost:.4f} after precision is less than min cost {min_cost}. Aborted.{RESET}")
                 return None

        lg.info(f"{COLOR_SUCCESS}Final calculated position size for {symbol}: {final_size} {size_unit}{RESET}")
        return final_size

    except KeyError as e:
        lg.error(f"{COLOR_ERROR}Pos Sizing Error ({symbol}): Missing key in market_info: {e}. Info: {market_info}{RESET}")
        return None
    except Exception as e:
        lg.error(f"{COLOR_ERROR}Unexpected error calculating position size for {symbol}: {e}{RESET}", exc_info=True)
        return None

def get_open_position(exchange: ccxt.Exchange, symbol: str, logger: logging.Logger) -> Optional[Dict]:
    """
    Fetches and validates the open position for a symbol, enhancing with SL/TP/TSL info.

    Args:
        exchange: Initialized ccxt.Exchange object.
        symbol: Trading symbol.
        logger: Logger instance.

    Returns:
        Enhanced position dictionary, or None if no active position or error.
    """
    lg = logger
    try:
        lg.debug(f"Fetching position for symbol: {symbol}")
        positions: List[Dict] = []
        params = {}
        # Add Bybit V5 category parameter
        if 'bybit' in exchange.id.lower():
            try:
                market = exchange.market(symbol)
                category = 'linear' if market.get('linear', True) else 'inverse'
                params['category'] = category
                lg.debug(f"Using params for fetch_positions: {params}")
            except (KeyError, ccxt.BadSymbol):
                 lg.warning(f"Market info not found for {symbol} during position check. Assuming 'linear' category.")
                 params['category'] = 'linear'

        # Attempt fetch_position (singular) first if supported
        if exchange.has.get('fetchPosition'):
             try:
                 single_pos = exchange.fetch_position(symbol, params=params)
                 # fetch_position might return a dict with size 0 if no position, or raise error
                 # Need to check the size within the returned dict
                 positions = [single_pos] if single_pos else []
             except ccxt.ExchangeError as e:
                 # Bybit V5 returns error code 110025 if position does not exist
                 if "110025" in str(e) or "position does not exist" in str(e).lower():
                      lg.info(f"No position found for {symbol} via fetch_position (Code 110025/Message).")
                      return None
                 # Re-raise other exchange errors if fetchPosition fails unexpectedly
                 lg.warning(f"fetch_position failed for {symbol}: {e}. Falling back to fetch_positions.")
                 positions = [] # Ensure positions is empty to trigger fallback
             except Exception as e:
                  lg.warning(f"Unexpected error in fetch_position for {symbol}: {e}. Falling back to fetch_positions.")
                  positions = []

        # Fallback to fetch_positions (plural) if fetchPosition failed or not supported
        if not positions and exchange.has.get('fetchPositions'):
            try:
                 # Fetch positions for the specific symbol if supported
                 lg.debug(f"Using fetch_positions for symbol: {symbol}")
                 positions = exchange.fetch_positions(symbols=[symbol], params=params)
            except ccxt.ArgumentsRequired:
                 # Fetch all if symbols argument not supported
                 lg.debug(f"Fetching all positions as exchange requires it...")
                 all_positions = exchange.fetch_positions(params=params) # Pass category here too if needed
                 positions = [p for p in all_positions if p.get('symbol') == symbol]
            except ccxt.ExchangeError as e:
                 # Handle errors indicating no position found within fetch_positions response
                 no_pos_msgs = ['no position found', 'position does not exist', 'position idx not exist']
                 err_str = str(e).lower()
                 if any(msg in err_str for msg in no_pos_msgs):
                     lg.info(f"No position found for {symbol} (Exchange message: {err_str}).")
                     return None
                 lg.error(f"Exchange error during fetch_positions for {symbol}: {e}", exc_info=True)
                 return None # Treat other errors as failure
            except Exception as e:
                 lg.error(f"Unexpected error fetching positions for {symbol}: {e}", exc_info=True)
                 return None

        # --- Find and Validate the Active Position ---
        active_position: Optional[Dict] = None
        for pos in positions:
            # Consolidate size fetching from various possible keys
            size_val = pos.get('contracts') # Standard ccxt
            if size_val is None: size_val = pos.get('contractSize') # Alternative standard
            if size_val is None: size_val = pos.get('info', {}).get('size') # Bybit V5 info
            if size_val is None: size_val = pos.get('info', {}).get('positionAmt') # Binance info
            if size_val is None: size_val = pos.get('amount') # Another possible key

            if size_val is None:
                lg.debug(f"Skipping position entry, missing/null size field: {pos}")
                continue

            position_size = safe_decimal(size_val)
            # Use a small threshold to consider a position active (handles potential dust)
            size_threshold = Decimal('1e-9')
            if position_size is not None and abs(position_size) > size_threshold:
                active_position = pos.copy() # Work on a copy
                lg.debug(f"Found candidate active position entry: Size={position_size}")
                break # Found the first active position

        # --- Process and Enhance ---
        if active_position:
            # Standardize Side
            side = active_position.get('side')
            size_decimal = safe_decimal(active_position.get('contracts', active_position.get('info',{}).get('size', '0')), Decimal('0'))

            if side not in ['long', 'short']:
                info_side = active_position.get('info', {}).get('side', '').lower() # Bybit: 'buy'/'sell'/'none'
                if info_side == 'buy': side = 'long'
                elif info_side == 'sell': side = 'short'
                elif size_decimal > size_threshold: side = 'long' # Infer from positive size
                elif size_decimal < -size_threshold: side = 'short' # Infer from negative size
                else: side = None # Cannot determine side

            if side is None:
                 lg.warning(f"Position found for {symbol}, but size ({size_decimal}) is near zero or side undetermined. Assuming no active position.")
                 return None

            active_position['side'] = side # Store standardized side

            # --- Enhance with SL/TP/TSL from 'info' (Bybit V5 focus) ---
            info_dict = active_position.get('info', {})
            price_prec = 4 # Default price precision for logging SL/TP
            try:
                market = exchange.market(symbol)
                tick_size = safe_decimal(market['precision']['price'])
                if tick_size: price_prec = abs(tick_size.normalize().as_tuple().exponent)
            except Exception: pass # Ignore errors getting market precision here

            def get_valid_price_from_info(key: str) -> Optional[Decimal]:
                val = safe_decimal(info_dict.get(key))
                return val if val and val > 0 else None

            # Populate standard keys if missing, using info dict
            if active_position.get('entryPrice') is None: active_position['entryPrice'] = info_dict.get('avgPrice')
            if active_position.get('markPrice') is None: active_position['markPrice'] = info_dict.get('markPrice')
            if active_position.get('liquidationPrice') is None: active_position['liquidationPrice'] = info_dict.get('liqPrice')
            if active_position.get('unrealizedPnl') is None: active_position['unrealizedPnl'] = info_dict.get('unrealisedPnl')
            if active_position.get('collateral') is None: active_position['collateral'] = info_dict.get('positionIM') # Initial margin as proxy
            if active_position.get('leverage') is None: active_position['leverage'] = info_dict.get('leverage')
            if active_position.get('contracts') is None: active_position['contracts'] = info_dict.get('size') # Ensure size is in standard field

            # Parse SL/TP
            sl_price = get_valid_price_from_info('stopLoss')
            tp_price = get_valid_price_from_info('takeProfit')
            active_position['stopLossPrice'] = sl_price
            active_position['takeProfitPrice'] = tp_price

            # Parse TSL (Bybit V5: trailingStop is distance/rate, activePrice is trigger)
            tsl_value = safe_decimal(info_dict.get('trailingStop', '0'))
            tsl_active_price = get_valid_price_from_info('activePrice')
            active_position['trailingStopLossValue'] = tsl_value if tsl_value and tsl_value > 0 else None
            active_position['trailingStopLossActivationPrice'] = tsl_active_price

            # Log enhanced position details
            details = {
                'Symbol': symbol, 'Side': side.upper(),
                'Size': f"{size_decimal}",
                'Entry': f"{safe_decimal(active_position.get('entryPrice')):.{price_prec}f}" if active_position.get('entryPrice') else 'N/A',
                'Mark': f"{safe_decimal(active_position.get('markPrice')):.{price_prec}f}" if active_position.get('markPrice') else 'N/A',
                'Liq': f"{safe_decimal(active_position.get('liquidationPrice')):.{price_prec}f}" if active_position.get('liquidationPrice') else 'N/A',
                'uPnL': f"{safe_decimal(active_position.get('unrealizedPnl')):.4f}" if active_position.get('unrealizedPnl') else 'N/A',
                'Coll': f"{safe_decimal(active_position.get('collateral')):.4f}" if active_position.get('collateral') else 'N/A',
                'Lev': f"{safe_decimal(active_position.get('leverage')):.1f}x" if active_position.get('leverage') else 'N/A',
                'TP': f"{tp_price:.{price_prec}f}" if tp_price else 'None',
                'SL': f"{sl_price:.{price_prec}f}" if sl_price else 'None',
                'TSL': f"{tsl_value}" if tsl_value and tsl_value > 0 else 'None',
                'TSLAct': f"{tsl_active_price:.{price_prec}f}" if tsl_active_price else ('N/A' if tsl_value and tsl_value > 0 else 'None'),
            }
            details_str = ', '.join(f"{k}={v}" for k, v in details.items())
            lg.info(f"{COLOR_SUCCESS}Active Position Found: {details_str}{RESET}")
            return active_position
        else:
            lg.info(f"No active position found for {symbol}.")
            return None

    except ccxt.AuthenticationError as e:
        lg.error(f"{COLOR_ERROR}Authentication error fetching positions: {e}{RESET}")
    except ccxt.NetworkError as e:
        lg.error(f"{COLOR_ERROR}Network error fetching positions: {e}{RESET}")
    except ccxt.ExchangeError as e:
        lg.error(f"{COLOR_ERROR}Exchange error fetching positions: {e}{RESET}", exc_info=True)
    except Exception as e:
        lg.error(f"{COLOR_ERROR}Unexpected error checking positions for {symbol}: {e}{RESET}", exc_info=True)
    return None

def place_market_order(
    exchange: ccxt.Exchange,
    symbol: str,
    side: str, # 'buy' or 'sell'
    amount: Decimal,
    market_info: Dict,
    logger: logging.Logger,
    params: Optional[Dict] = None
) -> Optional[Dict]:
    """
    Places a market order with safety checks and appropriate parameters.

    Args:
        exchange: Initialized ccxt.Exchange object.
        symbol: Trading symbol.
        side: 'buy' or 'sell'.
        amount: Order size (positive Decimal).
        market_info: Market info dictionary.
        logger: Logger instance.
        params: Additional parameters for create_order.

    Returns:
        The order dictionary from ccxt, or None if failed.
    """
    lg = logger
    if not CONFIG.get("enable_trading", False):
        lg.warning(f"{COLOR_WARNING}TRADING DISABLED. Skipping market {side} order for {amount} {symbol}.{RESET}")
        return None

    if not isinstance(amount, Decimal) or amount <= 0:
        lg.error(f"Invalid amount for market order: {amount}. Must be positive Decimal.")
        return None

    order_params = params.copy() if params else {}

    # --- Add Exchange Specific Params (Bybit V5 Example) ---
    if 'bybit' in exchange.id.lower():
        # Category
        if 'category' not in order_params:
            category = 'linear' if market_info.get('linear', True) else 'inverse'
            order_params['category'] = category
            lg.debug(f"Setting Bybit category='{category}' for market order.")
        # Position Mode (Assume One-way if not specified in params)
        if 'positionIdx' not in order_params:
            order_params['positionIdx'] = 0 # 0=One-way, 1=Buy Hedge, 2=Sell Hedge
            lg.debug(f"Setting default Bybit positionIdx=0 (One-way mode) for market order.")
        # Reduce-Only flag (should be passed in params if needed, e.g., {'reduceOnly': True} for closing)
        if order_params.get('reduceOnly'):
            lg.debug("Setting reduceOnly=True for market order.")

    order_desc = f"{side.upper()} {amount} {symbol} MARKET"
    lg.info(f"Attempting to place order: {order_desc} with params: {order_params}")

    try:
        # Ensure amount is float for ccxt
        amount_float = float(amount)
        order = exchange.create_order(
            symbol=symbol,
            type='market',
            side=side,
            amount=amount_float,
            params=order_params
        )
        # Add basic info if order seems successful but lacks details (rare)
        if order and not order.get('id'): order['id'] = 'unknown_market_fill'
        if order and not order.get('status'): order['status'] = 'filled' # Assume filled for market

        lg.info(f"{COLOR_SUCCESS}Successfully placed market order: {order_desc}. Order ID: {order.get('id')}{RESET}")
        lg.debug(f"Market order details: {order}")
        return order

    except ccxt.InsufficientFunds as e:
        lg.error(f"{COLOR_ERROR}Insufficient funds for {order_desc}: {e}{RESET}")
    except ccxt.InvalidOrder as e:
        lg.error(f"{COLOR_ERROR}Invalid market order {order_desc}: {e}. Check size/limits/params.{RESET}")
    except ccxt.OrderImmediatelyFillable:
        # Market orders are expected to fill immediately, this isn't usually an error.
        lg.info(f"{COLOR_SUCCESS}Market order {order_desc} filled immediately (as expected).{RESET}")
        # Return a simulated success response
        return {'id': 'immediate_fill', 'symbol': symbol, 'side': side, 'amount': amount, 'status': 'filled', 'info': 'OrderImmediatelyFillable'}
    except ccxt.ExchangeError as e:
        # Check for specific errors like reduceOnly issues
        if "reduce-only" in str(e).lower() and "size is zero" in str(e).lower():
             lg.error(f"{COLOR_ERROR}Reduce-only market order failed for {order_desc}: Position size likely already zero. {e}{RESET}")
        elif "order cost" in str(e).lower() and "minimum" in str(e).lower():
             lg.error(f"{COLOR_ERROR}Market order cost below minimum for {order_desc}: {e}{RESET}")
        else:
             lg.error(f"{COLOR_ERROR}Exchange error placing {order_desc}: {e}{RESET}", exc_info=True)
    except ccxt.NetworkError as e:
        lg.error(f"{COLOR_ERROR}Network error placing {order_desc}: {e}{RESET}")
    except Exception as e:
        lg.error(f"{COLOR_ERROR}Unexpected error placing {order_desc}: {e}{RESET}", exc_info=True)

    return None

def set_position_protection( # Renamed from _set_position_protection
    exchange: ccxt.Exchange,
    symbol: str,
    market_info: Dict,
    stop_loss_price: Optional[Decimal] = None,
    take_profit_price: Optional[Decimal] = None,
    trailing_stop_params: Optional[Dict] = None,
    current_position: Optional[Dict] = None, # Pass fetched position to avoid redundant API call
    logger: logging.Logger = None
) -> bool:
    """
    Sets/modifies SL, TP, and TSL for an existing position using appropriate ccxt methods.

    Args:
        exchange: ccxt.Exchange object.
        symbol: Trading symbol.
        market_info: Market info dict.
        stop_loss_price: Desired SL price (Decimal). Use 0 or None to remove/ignore.
        take_profit_price: Desired TP price (Decimal). Use 0 or None to remove/ignore.
        trailing_stop_params: Dict with TSL parameters (e.g., {'trailingStop': '50', 'activePrice': '...'})
                              Use {'trailingStop': '0'} to remove TSL. None leaves it unchanged.
        current_position: Optional pre-fetched position dictionary.
        logger: Logger instance.

    Returns:
        True if protection set/modified successfully, False otherwise.
    """
    lg = logger or logging.getLogger(__name__)
    if not CONFIG.get("enable_trading", False):
        lg.warning(f"{COLOR_WARNING}TRADING DISABLED. Skipping protection setting for {symbol}.{RESET}")
        return False # Cannot set protection if trading off

    # --- Get Position Info ---
    position = current_position
    if position is None:
        lg.debug(f"Fetching position for {symbol} before setting protection...")
        position = get_open_position(exchange, symbol, lg)
        if position is None:
            lg.info(f"No open position found for {symbol}. Cannot set protection.")
            # Not an error, just no position to protect.
            return True

    position_side = position.get('side')
    position_size = safe_decimal(position.get('contracts', position.get('info',{}).get('size')))

    if not position_side or position_size is None or abs(position_size) < Decimal('1e-9'):
        lg.info(f"Position side/size invalid or near zero for {symbol}. No protection action needed. Pos: {position}")
        return True # No action needed

    price_prec = 4 # Default precision for logging/formatting prices
    try:
        tick_size = safe_decimal(market_info['precision']['price'])
        if tick_size: price_prec = abs(tick_size.normalize().as_tuple().exponent)
    except Exception: pass
    price_fmt = f".{price_prec}f"

    # --- Prepare API Parameters ---
    params = {}
    log_parts = []
    needs_api_call = False

    # Exchange/API Specific Params (Bybit V5 Example)
    if 'bybit' in exchange.id.lower():
        category = 'linear' if market_info.get('linear', True) else 'inverse'
        params['category'] = category
        # Get positionIdx from the fetched position info, default to 0 (one-way)
        params['positionIdx'] = position.get('info', {}).get('positionIdx', 0)
        lg.debug(f"Using Bybit params: category={params['category']}, positionIdx={params['positionIdx']}")
        # Bybit requires tpslMode and trigger prices
        params['tpslMode'] = 'Partial' # Default to Partial if setting any TP/SL/TSL individually
        params['tpTriggerBy'] = 'MarkPrice' # Common trigger setting
        params['slTriggerBy'] = 'MarkPrice'

    # --- Format Stop Loss ---
    if stop_loss_price is not None:
        sl_str = "0" if stop_loss_price <= 0 else f"{stop_loss_price:.{price_prec}f}"
        # Check if SL actually changed from current state
        current_sl = position.get('stopLossPrice')
        if sl_str != "0" and current_sl != stop_loss_price:
             params['stopLoss'] = sl_str
             log_parts.append(f"SL={sl_str}")
             needs_api_call = True
        elif sl_str == "0" and current_sl is not None: # Request to remove existing SL
             params['stopLoss'] = sl_str
             log_parts.append("SL=Remove")
             needs_api_call = True
        else: # No change needed for SL
             lg.debug(f"SL price {sl_str} same as current ({current_sl}) or not provided. Skipping SL update.")
             # If only setting TP or TSL, may still need to pass existing SL if API requires it
             if current_sl and current_sl > 0:
                 params['stopLoss'] = f"{current_sl:.{price_prec}f}"


    # --- Format Take Profit ---
    if take_profit_price is not None:
        tp_str = "0" if take_profit_price <= 0 else f"{take_profit_price:.{price_prec}f}"
        current_tp = position.get('takeProfitPrice')
        if tp_str != "0" and current_tp != take_profit_price:
             params['takeProfit'] = tp_str
             log_parts.append(f"TP={tp_str}")
             needs_api_call = True
        elif tp_str == "0" and current_tp is not None: # Request to remove
             params['takeProfit'] = tp_str
             log_parts.append("TP=Remove")
             needs_api_call = True
        else: # No change needed
             lg.debug(f"TP price {tp_str} same as current ({current_tp}) or not provided. Skipping TP update.")
             if current_tp and current_tp > 0:
                 params['takeProfit'] = f"{current_tp:.{price_prec}f}"

    # --- Format Trailing Stop ---
    if trailing_stop_params is not None:
        tsl_distance = trailing_stop_params.get('trailingStop') # Expects string for Bybit V5
        tsl_activation = trailing_stop_params.get('activePrice') # Optional, expects string

        # Check if TSL distance is changing
        current_tsl_val = position.get('trailingStopLossValue') # Decimal or None
        tsl_distance_dec = safe_decimal(tsl_distance)

        # Condition to update TSL:
        # 1. New distance provided AND (it's different from current OR current is None)
        # 2. New distance is explicitly '0' and current TSL exists (removal request)
        update_tsl = False
        if tsl_distance_dec is not None:
             if tsl_distance_dec > 0 and tsl_distance_dec != current_tsl_val:
                  update_tsl = True
                  log_parts.append(f"TSL={tsl_distance}")
             elif tsl_distance_dec <= 0 and current_tsl_val is not None and current_tsl_val > 0:
                  update_tsl = True
                  tsl_distance = "0" # Ensure removal value is '0' string
                  log_parts.append("TSL=Remove")

        if update_tsl:
             params['trailingStop'] = str(tsl_distance) # Ensure string format
             needs_api_call = True
             # Handle activation price only if TSL is being set (distance > 0)
             if tsl_distance_dec is not None and tsl_distance_dec > 0 and tsl_activation is not None:
                 current_tsl_act = position.get('trailingStopLossActivationPrice') # Decimal or None
                 tsl_activation_dec = safe_decimal(tsl_activation)
                 if tsl_activation_dec and tsl_activation_dec > 0 and tsl_activation_dec != current_tsl_act:
                      act_price_str = f"{tsl_activation_dec:.{price_prec}f}"
                      params['activePrice'] = act_price_str
                      log_parts.append(f"TSLAct={act_price_str}")
                 elif tsl_activation_dec and tsl_activation_dec <= 0 and current_tsl_act is not None:
                      # If explicitly setting activation to 0 to remove it (though Bybit might ignore '0')
                      params.pop('activePrice', None) # Remove key if setting to 0
                      log_parts.append("TSLAct=Remove")
                 elif tsl_activation is None and current_tsl_act is not None:
                     # If new params omit activation but it existed, maybe remove? API dependent.
                     # Safest is to not include 'activePrice' if not in new params.
                     params.pop('activePrice', None)
             elif tsl_distance_dec is not None and tsl_distance_dec <= 0:
                 # If removing TSL, also remove activation price param
                  params.pop('activePrice', None)
        else:
             lg.debug(f"TSL params ({trailing_stop_params}) indicate no change needed from current (Val={current_tsl_val}). Skipping TSL update.")
             # If other params (TP/SL) are changing, we might need to resubmit existing TSL
             if needs_api_call and current_tsl_val and current_tsl_val > 0:
                  params['trailingStop'] = str(current_tsl_val)
                  current_tsl_act = position.get('trailingStopLossActivationPrice')
                  if current_tsl_act and current_tsl_act > 0:
                       params['activePrice'] = f"{current_tsl_act:.{price_prec}f}"


    # --- Check if API call is necessary ---
    if not needs_api_call:
        lg.info(f"No changes detected for position protection ({symbol}). No API call needed.")
        return True

    # Final check: Ensure essential Bybit params are present if making a call
    if 'bybit' in exchange.id.lower():
        if 'stopLoss' not in params: params['stopLoss'] = '0' # Bybit requires these even if not changing
        if 'takeProfit' not in params: params['takeProfit'] = '0'
        if 'trailingStop' not in params: params['trailingStop'] = '0'
        # Determine tpslMode based on final params
        has_tp = safe_decimal(params.get('takeProfit', '0'), 0) > 0
        has_sl = safe_decimal(params.get('stopLoss', '0'), 0) > 0
        has_tsl = safe_decimal(params.get('trailingStop', '0'), 0) > 0
        # Bybit: Use Full mode only if ONLY TP or ONLY SL is set. Use Partial if TSL is set, or if BOTH TP and SL are set.
        if has_tsl or (has_tp and has_sl):
             params['tpslMode'] = 'Partial'
        else: # Only TP or only SL (or neither, though 'needs_api_call' should prevent that)
             params['tpslMode'] = 'Full'


    set_desc = f"Set Protection for {symbol} ({position_side.upper()} {position_size}): {', '.join(log_parts)}"
    lg.info(f"Attempting: {set_desc}")
    lg.debug(f"  API Params: {params}")

    # --- API Call ---
    try:
        response = None
        # Bybit V5 uses a single endpoint for all TP/SL/TSL modifications
        if 'bybit' in exchange.id.lower():
            lg.debug("Using Bybit V5 private_post /v5/position/trading-stop...")
            response = exchange.private_post('/v5/position/trading-stop', params)
        # Add logic for other exchanges if needed, using edit_position or specific methods
        # elif exchange.has.get('editPosition'): ...
        else:
            lg.error(f"Protection setting not implemented for exchange {exchange.id}. Cannot set TP/SL/TSL.")
            return False

        lg.info(f"{COLOR_SUCCESS}Protection setting request successful for {symbol}.{RESET}")
        lg.debug(f"Protection setting response: {response}")

        # --- Response Validation (Bybit V5 Example) ---
        if isinstance(response, dict):
            ret_code = response.get('retCode')
            ret_msg = response.get('retMsg', '')
            if ret_code == 0:
                return True # Success
            else:
                # Check for non-critical "errors" that mean success or no change needed
                # 110043: Set TP/SL orders can only be modified or cancelled (Already set?)
                # 34036: The order is not modified (No change detected by exchange)
                # 110025: position idx not match position mode (Warning if mode is correct)
                # 110068: The trailing stop loss is not modified
                # 110067: The take profit/stop loss is not modified
                non_error_codes = [110043, 34036, 110025, 110067, 110068]
                no_change_msgs = ["not modified", "same tpsl"]
                if ret_code in non_error_codes or any(msg in ret_msg.lower() for msg in no_change_msgs):
                    lg.warning(f"{COLOR_WARNING}Protection setting for {symbol} - Non-critical code {ret_code}: '{ret_msg}'. Assuming success/no change.{RESET}")
                    return True
                else:
                    lg.error(f"{COLOR_ERROR}Protection setting failed ({symbol}). Code: {ret_code}, Msg: {ret_msg}{RESET}")
                    return False
        else:
            # If response is not a dict, assume success if no exception occurred (less reliable)
            lg.warning("Protection setting response format unknown, assuming success based on lack of exception.")
            return True

    except ccxt.InsufficientFunds as e:
        lg.error(f"{COLOR_ERROR}Insufficient funds during protection setting for {symbol}: {e}{RESET}")
    except ccxt.InvalidOrder as e:
        lg.error(f"{COLOR_ERROR}Invalid order parameters setting protection for {symbol}: {e}. Check values relative to price/position.{RESET}")
    except ccxt.ExchangeError as e:
        # Handle already logged non-critical errors again just in case
        err_code = getattr(e, 'code', None)
        err_str = str(e).lower()
        non_error_codes = [110043, 34036, 110025, 110067, 110068]
        no_change_msgs = ["not modified", "same tpsl"]
        if err_code in non_error_codes or any(msg in err_str for msg in no_change_msgs):
             lg.warning(f"{COLOR_WARNING}Protection setting for {symbol} - Non-critical error {err_code}: '{err_str}'. Assuming success/no change.{RESET}")
             return True
        lg.error(f"{COLOR_ERROR}Exchange error setting protection for {symbol}: {e}{RESET}", exc_info=True)
    except ccxt.NetworkError as e:
        lg.error(f"{COLOR_ERROR}Network error setting protection for {symbol}: {e}{RESET}")
    except Exception as e:
        lg.error(f"{COLOR_ERROR}Unexpected error setting protection for {symbol}: {e}{RESET}", exc_info=True)

    return False


# --- Main Trading Loop Function ---
def analyze_and_trade_symbol(exchange: ccxt.Exchange, symbol: str, config: Dict[str, Any], logger: logging.Logger) -> None:
    """
    Performs one cycle of analysis and potential trading for a single symbol.
    """
    lg = logger
    lg.info(f"--- Starting analysis cycle for {symbol} ---")
    cycle_start_time = time.monotonic()

    try:
        # --- 1. Fetch Market Info ---
        market_info = get_market_info(exchange, symbol, lg)
        if not market_info:
            lg.error(f"Skipping cycle for {symbol}: Could not retrieve valid market info.")
            return

        # --- 2. Fetch Kline Data ---
        interval_str = config.get("interval", "5")
        ccxt_timeframe = CCXT_INTERVAL_MAP.get(interval_str)
        if not ccxt_timeframe:
            lg.error(f"Invalid interval '{interval_str}' in config for {symbol}. Skipping cycle.")
            return

        # Determine appropriate lookback limit
        analyzer_temp = TradingAnalyzer(pd.DataFrame(), lg, config, market_info) # Temp analyzer for min length calc
        min_required_data = 150 # Fallback
        try:
             # Recalculate min required length based on config
             min_len_volbot = max(
                 config.get("volbot_length", DEFAULT_VOLBOT_LENGTH),
                 config.get("volbot_atr_length", DEFAULT_VOLBOT_ATR_LENGTH),
                 config.get("volbot_volume_percentile_lookback", DEFAULT_VOLBOT_VOLUME_PERCENTILE_LOOKBACK),
                 config.get("volbot_pivot_left_len_h", DEFAULT_VOLBOT_PIVOT_LEFT_LEN_H) + config.get("volbot_pivot_right_len_h", DEFAULT_VOLBOT_PIVOT_RIGHT_LEN_H) + 1,
                 config.get("volbot_pivot_left_len_l", DEFAULT_VOLBOT_PIVOT_LEFT_LEN_L) + config.get("volbot_pivot_right_len_l", DEFAULT_VOLBOT_PIVOT_RIGHT_LEN_L) + 1
             )
             min_len_risk = config.get("atr_period", DEFAULT_ATR_PERIOD)
             min_required_data = max(min_len_volbot, min_len_risk) + 100 # Add buffer
        except Exception: pass # Ignore errors in temp calc, use fallback
        finally: del analyzer_temp # Clean up temporary object

        kline_limit = min_required_data
        lg.debug(f"Fetching {kline_limit} klines for {symbol} {ccxt_timeframe}...")
        df_klines = fetch_klines_ccxt(exchange, symbol, ccxt_timeframe, limit=kline_limit, logger=lg)
        if df_klines.empty or len(df_klines) < 50: # Need a reasonable minimum
            lg.warning(f"{COLOR_WARNING}Insufficient kline data for {symbol} (got {len(df_klines)}). Skipping cycle.{RESET}")
            return

        # --- 3. Initialize Analyzer & Calculate Indicators ---
        analyzer = TradingAnalyzer(df=df_klines, logger=lg, config=config, market_info=market_info)
        if analyzer.df_processed.empty or not analyzer.strategy_state:
            lg.error(f"Failed to calculate indicators or update state for {symbol}. Skipping cycle.")
            return

        # --- 4. Check Current Position ---
        current_position = get_open_position(exchange, symbol, lg) # Already enhanced
        has_open_position = current_position is not None
        position_side = current_position.get('side') if has_open_position else None
        position_entry_price = safe_decimal(current_position.get('entryPrice')) if has_open_position else None
        position_size = safe_decimal(current_position.get('contracts')) if has_open_position else Decimal('0')

        # --- 5. Fetch Current Price ---
        current_price = fetch_current_price_ccxt(exchange, symbol, lg)
        if current_price is None:
            last_close = analyzer.strategy_state.get('close')
            if isinstance(last_close, Decimal) and last_close > 0:
                current_price = last_close
                lg.warning(f"{COLOR_WARNING}Ticker price fetch failed, using last kline close ({current_price}) for {symbol}.{RESET}")
            else:
                lg.error(f"{COLOR_ERROR}Failed to get current price for {symbol}. Cannot proceed.{RESET}")
                return

        price_fmt = f".{analyzer.get_price_precision()}f" # Use analyzer's precision

        # --- 6. Generate Trading Signal ---
        signal = analyzer.generate_trading_signal() # "BUY", "SELL", or "HOLD"

        # --- 7. Position Management Logic ---
        trading_enabled = config.get("enable_trading", False)

        # == Scenario 1: IN a position ==
        if has_open_position and position_entry_price and position_size != 0:
            pos_size_fmt = f".{analyzer.get_amount_precision()}f"
            lg.info(f"Managing existing {position_side.upper()} position ({position_size:{pos_size_fmt}} {symbol} @ {position_entry_price:{price_fmt}}). Current Price: {current_price:{price_fmt}}")

            # --- 7a. Check for Exit Signal ---
            exit_signal_triggered = (position_side == 'long' and signal == "SELL") or \
                                    (position_side == 'short' and signal == "BUY")

            if exit_signal_triggered:
                reason = f"{signal} signal received while in {position_side.upper()} position"
                color = COLOR_DN if signal == "SELL" else COLOR_UP
                lg.info(f"{color}Exit Signal: {reason}. Closing position.{RESET}")
                if trading_enabled:
                    close_side = 'sell' if position_side == 'long' else 'buy'
                    close_order = place_market_order(exchange, symbol, close_side, abs(position_size), market_info, lg, params={'reduceOnly': True})
                    if close_order:
                        lg.info(f"{COLOR_SUCCESS}Successfully closed {position_side} position.{RESET}")
                        # Cancel associated SL/TP orders (best effort)
                        try:
                             # Bybit V5 uses set_position_protection with SL/TP=0 to cancel
                             cancel_success = set_position_protection(exchange, symbol, market_info, stop_loss_price=Decimal(0), take_profit_price=Decimal(0), logger=lg)
                             if cancel_success: lg.info(f"Attempted to cancel SL/TP for {symbol} after closing.")
                             else: lg.warning(f"Could not cancel SL/TP orders for {symbol} after closing.")
                        except Exception as cancel_err:
                            lg.warning(f"Error cancelling stop orders for {symbol}: {cancel_err}")
                    else:
                        lg.error(f"{COLOR_ERROR}Failed to place market order to close {position_side} position.{RESET}")
                    # End cycle for this symbol after close attempt
                    return
                else:
                    lg.warning(f"{COLOR_WARNING}TRADING DISABLED: Would have closed {position_side} position ({reason}).{RESET}")
                    return # Don't proceed with risk management if exit signal and trading disabled

            # --- 7b. Risk Management (Only if no exit signal) ---
            else:
                lg.info("Performing risk management checks for open position...")
                new_sl_price, new_tp_price, new_tsl_params = None, None, None # Store potential changes
                needs_update = False

                # Get current protection state from enhanced position data
                current_sl = current_position.get('stopLossPrice') # Decimal or None
                current_tp = current_position.get('takeProfitPrice') # Decimal or None
                current_tsl_val = current_position.get('trailingStopLossValue') # Decimal or None
                has_current_tsl = current_tsl_val is not None and current_tsl_val > 0

                lg.debug(f"Current Protection: SL={current_sl}, TP={current_tp}, TSL Active={has_current_tsl} (Val={current_tsl_val})")

                # --- i. Break-Even ---
                enable_be = config.get("enable_break_even", True)
                risk_atr = analyzer.strategy_state.get("atr_risk") # Decimal or None
                min_tick = analyzer.get_min_tick_size()

                if enable_be and risk_atr and risk_atr > 0 and min_tick > 0:
                    be_trigger_multiple = safe_decimal(config.get("break_even_trigger_atr_multiple", 1.0), Decimal(1.0))
                    be_offset_ticks = int(config.get("break_even_offset_ticks", 2))
                    profit_target_for_be = risk_atr * be_trigger_multiple

                    current_profit = (current_price - position_entry_price) if position_side == 'long' else (position_entry_price - current_price)

                    if current_profit >= profit_target_for_be:
                        offset_amount = min_tick * be_offset_ticks
                        be_price_raw = position_entry_price + offset_amount if position_side == 'long' else position_entry_price - offset_amount
                        rounding = ROUND_UP if position_side == 'long' else ROUND_DOWN
                        be_price_rounded = (be_price_raw / min_tick).quantize(Decimal('1'), rounding=rounding) * min_tick

                        # Only move SL if BE price is better than current SL
                        sl_better = False
                        if position_side == 'long':
                            sl_better = current_sl is None or be_price_rounded > current_sl
                        else: # Short
                            sl_better = current_sl is None or be_price_rounded < current_sl

                        if sl_better:
                            lg.info(f"{COLOR_SUCCESS}Break-Even Triggered! Profit {current_profit:{price_fmt}} >= Target {profit_target_for_be:{price_fmt}}.{RESET}")
                            lg.info(f"  Old SL: {current_sl:{price_fmt} if current_sl else 'None'}. New BE SL: {be_price_rounded:{price_fmt}}")
                            new_sl_price = be_price_rounded # Set potential new SL
                            needs_update = True
                        else:
                            lg.debug(f"BE triggered, but new SL {be_price_rounded:{price_fmt}} not better than current SL {current_sl:{price_fmt} if current_sl else 'None'}.")
                    else:
                         lg.debug(f"BE not triggered. Profit: {current_profit:{price_fmt}}, Target: {profit_target_for_be:{price_fmt}}")
                elif enable_be:
                    lg.warning(f"Cannot calculate BE for {symbol}: Invalid Risk ATR ({risk_atr}) or Min Tick ({min_tick}).")

                # --- ii. Trailing Stop Activation Check ---
                # Checks if TSL is enabled but not currently active, and if activation conditions are met.
                # Assumes TSL, once set via set_position_protection, is managed by the exchange.
                enable_tsl = config.get("enable_trailing_stop", True)
                if enable_tsl and not has_current_tsl:
                    tsl_callback_rate = str(config.get("trailing_stop_callback_rate", "0.005")) # Keep as string for API
                    tsl_activation_perc = safe_decimal(config.get("trailing_stop_activation_percentage", "0.003"), 0)

                    # Check profit percentage for activation
                    current_profit_perc = Decimal('0')
                    if position_entry_price > 0:
                        current_profit_perc = (current_price / position_entry_price) - 1 if position_side == 'long' else 1 - (current_price / position_entry_price)

                    if current_profit_perc >= tsl_activation_perc:
                        lg.info(f"{COLOR_SUCCESS}Trailing Stop activation condition met (Profit {current_profit_perc:.2%} >= {tsl_activation_perc:.2%}). Setting TSL.{RESET}")

                        # Prepare TSL params (distance only, activation is implicit or handled by exchange)
                        # Bybit V5: setting trailingStop activates it based on current price vs entry/activation price
                        new_tsl_params = {'trailingStop': tsl_callback_rate}
                        # Activation price might be needed for some exchanges or if activation_perc > 0
                        # For Bybit V5, setting activePrice might override default activation logic.
                        # Let's omit activePrice unless explicitly required by API AND activation_perc > 0.
                        # if tsl_activation_perc > 0:
                        #    # Calculate activation price (optional, depends on exchange needs)
                        #    act_price_raw = ...
                        #    act_price = ...
                        #    new_tsl_params['activePrice'] = str(act_price)

                        lg.info(f"  Prepared TSL Params for activation: {new_tsl_params}")
                        needs_update = True
                    else:
                        lg.debug(f"TSL activation condition not met (Profit {current_profit_perc:.2%} < {tsl_activation_perc:.2%})")

                # --- iii. Update Protection ---
                if needs_update and trading_enabled:
                    # Prioritize BE SL if both BE and TSL triggered in the same cycle
                    final_sl = new_sl_price if new_sl_price is not None else current_sl # Use BE SL if set
                    final_tp = current_tp # TP usually doesn't change dynamically here
                    final_tsl = new_tsl_params # Use new TSL params if activation triggered

                    if new_sl_price is not None and new_tsl_params is not None:
                        lg.warning(f"{COLOR_WARNING}Both BE SL and TSL activation triggered. Applying BE SL ({final_sl:{price_fmt}}). TSL ({final_tsl}) will be set, potentially overriding BE SL effect depending on exchange logic.{RESET}")
                        # Note: Setting both might have unintended consequences. Consider disabling TSL if BE moves SL, or vice-versa, via config or logic.
                        # Current behavior: Apply both updates.

                    lg.info(f"Updating position protection: SL={final_sl}, TP={final_tp}, TSL Params={final_tsl}")
                    success = set_position_protection(
                        exchange, symbol, market_info,
                        stop_loss_price=final_sl,
                        take_profit_price=final_tp,
                        trailing_stop_params=final_tsl,
                        current_position=current_position, # Pass position to avoid refetch
                        logger=lg
                    )
                    if success: lg.info(f"{COLOR_SUCCESS}Successfully updated position protection.{RESET}")
                    else: lg.error(f"{COLOR_ERROR}Failed to update position protection.{RESET}")

                elif needs_update and not trading_enabled:
                    lg.warning(f"{COLOR_WARNING}TRADING DISABLED: Would have updated protection (SL={new_sl_price}, TSL={new_tsl_params}).{RESET}")

        # == Scenario 2: OUT of a position ==
        else:
            lg.info(f"No open position for {symbol}. Checking for entry signals.")

            # --- 7c. Check for Entry Signal ---
            if signal in ["BUY", "SELL"]:
                lg.info(f"{COLOR_INFO}Entry Signal Detected: {signal}. Current Price: {current_price:{price_fmt}}{RESET}")

                # Check balance
                quote_balance = fetch_balance(exchange, QUOTE_CURRENCY, lg)
                if quote_balance is None or quote_balance <= 0:
                    lg.error(f"{COLOR_ERROR}Cannot enter {signal}: Invalid or zero {QUOTE_CURRENCY} balance ({quote_balance}).{RESET}")
                    return

                # Calculate initial SL/TP based on current price as entry estimate
                _, potential_tp, potential_sl = analyzer.calculate_entry_tp_sl(current_price, signal)
                if potential_sl is None:
                    lg.error(f"{COLOR_ERROR}Cannot enter {signal}: Failed to calculate valid initial Stop Loss.{RESET}")
                    return

                # Calculate position size
                risk_per_trade = config.get("risk_per_trade", 0.01)
                position_size = calculate_position_size(
                    balance=quote_balance, risk_per_trade=risk_per_trade,
                    initial_stop_loss_price=potential_sl, entry_price=current_price,
                    market_info=market_info, exchange=exchange, logger=lg
                )

                if position_size is None or position_size <= 0:
                    lg.error(f"{COLOR_ERROR}Cannot enter {signal}: Position size calculation failed or resulted in zero.{RESET}")
                    return

                # --- Execute Entry ---
                if trading_enabled:
                    lg.info(f"Attempting to enter {signal} position: Size={position_size}, EstEntry={current_price:{price_fmt}}, SL={potential_sl:{price_fmt}}, TP={potential_tp:{price_fmt} if potential_tp else 'N/A'}")

                    # Set Leverage (Best effort, before placing order)
                    if market_info.get('is_contract', False):
                        desired_leverage = config.get("leverage", 10)
                        try:
                            lg.info(f"Setting leverage to {desired_leverage}x for {symbol}")
                            params={'buyLeverage': float(desired_leverage), 'sellLeverage': float(desired_leverage)}
                            if 'bybit' in exchange.id.lower():
                                 params['category'] = 'linear' if market_info.get('linear', True) else 'inverse'
                            exchange.set_leverage(desired_leverage, symbol, params=params)
                        except (ccxt.ExchangeError, ccxt.NetworkError) as e:
                            # Non-fatal leverage errors (already set, positions exist)
                            if "leverage not modified" in str(e).lower() or "position open" in str(e).lower():
                                lg.warning(f"{COLOR_WARNING}Could not set leverage to {desired_leverage}x (Reason: {e}). Proceeding with existing leverage.{RESET}")
                            else: # Potentially more serious errors
                                lg.error(f"{COLOR_ERROR}Failed to set leverage for {symbol}: {e}. Check permissions/exchange status.{RESET}")
                                # Decide whether to abort: return # Uncomment to abort if leverage fails critically
                        except Exception as e:
                            lg.error(f"{COLOR_ERROR}Unexpected error setting leverage: {e}{RESET}", exc_info=True)

                    # Place Market Order
                    entry_order = place_market_order(exchange, symbol, signal.lower(), position_size, market_info, lg)

                    if entry_order and entry_order.get('id'):
                        lg.info(f"{COLOR_SUCCESS}Entry order placed successfully (ID: {entry_order.get('id')}). Waiting briefly for fill...{RESET}")
                        # Wait for potential fill before setting protection
                        time.sleep(config.get('retry_delay', 5))

                        # --- Set Initial Protection ---
                        tsl_params = None
                        if config.get("enable_trailing_stop", True):
                            tsl_callback_rate = str(config.get("trailing_stop_callback_rate", "0.005"))
                            # Bybit V5: Set distance, activation handled by exchange based on price movement or activePrice if provided
                            tsl_params = {'trailingStop': tsl_callback_rate}
                            lg.info(f"Prepared initial TSL params: {tsl_params}")

                        lg.info(f"Setting initial protection: SL={potential_sl:{price_fmt}}, TP={potential_tp:{price_fmt} if potential_tp else 'N/A'}, TSL={tsl_params is not None}")
                        protection_success = set_position_protection(
                            exchange, symbol, market_info,
                            stop_loss_price=potential_sl,
                            take_profit_price=potential_tp,
                            trailing_stop_params=tsl_params,
                            current_position=None, # Force refetch after entry
                            logger=lg
                        )
                        if protection_success:
                            lg.info(f"{COLOR_SUCCESS}Initial protection set for new {signal} position.{RESET}")
                        else:
                            lg.error(f"{COLOR_ERROR}Failed to set initial protection after entry. MANUAL CHECK REQUIRED!{RESET}")
                    else:
                        lg.error(f"{COLOR_ERROR}Entry market order failed for {signal}.{RESET}")
                else:
                    lg.warning(f"{COLOR_WARNING}TRADING DISABLED: Would have entered {signal}. Size={position_size}, SL={potential_sl:{price_fmt}}, TP={potential_tp:{price_fmt} if potential_tp else 'N/A'}{RESET}")

            # --- 7d. No Signal, No Position ---
            else: # signal == "HOLD"
                lg.info(f"Signal is HOLD and no open position. No trading action.")

    except Exception as e:
         lg.error(f"{COLOR_ERROR}!!! Unhandled Exception in analyze_and_trade_symbol({symbol}) !!!: {e}{RESET}", exc_info=True)
         # Continue to next symbol or cycle if possible

    finally:
        cycle_duration = time.monotonic() - cycle_start_time
        lg.info(f"--- Finished analysis cycle for {symbol} ({cycle_duration:.2f}s) ---")


# --- Main Execution ---
def main() -> None:
    """
    Initializes the bot and runs the main trading loop.
    """
    # Use a generic init logger for setup
    init_logger = setup_logger("init") # Initial logger setup
    init_logger.info(f"{COLOR_HEADER}--- Volbot Initializing ---{RESET}")
    init_logger.info(f"Config File: {CONFIG_FILE}")
    init_logger.info(f"Log Directory: {LOG_DIRECTORY}")
    init_logger.info(f"Quote Currency: {QUOTE_CURRENCY}")
    init_logger.info(f"Trading Enabled: {CONFIG.get('enable_trading')}")
    init_logger.info(f"Use Sandbox: {CONFIG.get('use_sandbox')}")
    init_logger.info(f"Default Interval: {CONFIG.get('interval')}")
    init_logger.info(f"Timezone: {TIMEZONE.key}")
    init_logger.info(f"Console Log Level: {logging.getLevelName(console_log_level)}")


    # Initialize Exchange
    exchange = initialize_exchange(init_logger)
    if not exchange:
        init_logger.critical(f"{COLOR_ERROR}Exchange initialization failed. Exiting.{RESET}")
        return

    # --- Symbol Selection ---
    symbols_to_trade: List[str] = []
    while True:
        current_list_str = f"Current list: {symbols_to_trade}" if symbols_to_trade else "Current list is empty"
        prompt = (f"Enter trading symbol (e.g., BTC/USDT:USDT), "
                  f"'all' for linear {QUOTE_CURRENCY} swaps, "
                  f"or Enter to start ({current_list_str}): ")
        symbol_input = input(prompt).strip()

        if not symbol_input and symbols_to_trade:
            init_logger.info(f"Starting analysis with symbols: {', '.join(symbols_to_trade)}")
            break
        elif not symbol_input and not symbols_to_trade:
            print(f"{COLOR_WARNING}Please enter at least one symbol or 'all'.{RESET}")
            continue
        elif symbol_input.lower() == 'all':
            init_logger.info(f"Attempting to fetch all active linear {QUOTE_CURRENCY} perpetual swaps...")
            try:
                # Ensure markets are loaded (might have been done in init, but reload for safety)
                all_markets = exchange.load_markets(reload=True)
                linear_swaps = [
                    mkt['symbol'] for mkt in all_markets.values()
                    if mkt.get('active', True)
                       and mkt.get('linear', False)
                       and mkt.get('swap', True)
                       and mkt.get('quote', '').upper() == QUOTE_CURRENCY
                ]
                if not linear_swaps:
                     init_logger.error(f"{COLOR_ERROR}No active linear {QUOTE_CURRENCY} perpetual swaps found on {exchange.id}. Enter symbols manually.{RESET}")
                     continue

                symbols_to_trade = sorted(linear_swaps) # Sort for consistent order
                init_logger.info(f"Selected {len(symbols_to_trade)} linear {QUOTE_CURRENCY} swaps.")
                preview = f"{', '.join(symbols_to_trade[:5])}{', ...' if len(symbols_to_trade) > 5 else ''}"
                print(f"{COLOR_SUCCESS}Symbols selected ({len(symbols_to_trade)}): {preview}{RESET}")
                break # Start with the fetched list
            except Exception as e:
                init_logger.error(f"{COLOR_ERROR}Error fetching/filtering markets: {e}. Enter symbols manually.{RESET}")
                continue
        else:
            # Validate the entered symbol using get_market_info
            market_info = get_market_info(exchange, symbol_input, init_logger)
            if market_info:
                if symbol_input not in symbols_to_trade:
                    symbols_to_trade.append(symbol_input)
                    print(f"{COLOR_SUCCESS}Added symbol: {symbol_input}. {current_list_str.replace('Current list: ', 'New list: ')}{RESET}")
                else:
                    print(f"{COLOR_WARNING}Symbol {symbol_input} is already in the list.{RESET}")
            else:
                # get_market_info already logged the error
                print(f"{COLOR_ERROR}Invalid or unknown symbol '{symbol_input}'. Check format/availability.{RESET}")

    if not symbols_to_trade:
        init_logger.critical(f"{COLOR_ERROR}No valid symbols selected. Exiting.{RESET}")
        return

    # --- Setup Loggers for Each Symbol ---
    symbol_loggers: Dict[str, logging.Logger] = {}
    for sym in symbols_to_trade:
        # Re-setup logger with potentially updated console level from config
        symbol_loggers[sym] = setup_logger(sym)

    # --- Main Trading Loop ---
    init_logger.info(f"{COLOR_HEADER}--- Starting Main Trading Loop ({len(symbols_to_trade)} symbols) ---{RESET}")
    try:
        while True:
            loop_start_time = time.monotonic()
            now = datetime.now(TIMEZONE)
            init_logger.info(f"*** New Cycle Start: {now.strftime('%Y-%m-%d %H:%M:%S %Z')} ***")

            # Iterate through a copy of the list in case we want to modify it during the loop
            for symbol in list(symbols_to_trade):
                symbol_logger = symbol_loggers.get(symbol)
                if not symbol_logger: # Should not happen, but safety check
                     symbol_logger = setup_logger(symbol)
                     symbol_loggers[symbol] = symbol_logger
                     init_logger.warning(f"Re-initialized logger for {symbol} mid-loop.")

                try:
                    analyze_and_trade_symbol(exchange, symbol, CONFIG, symbol_logger)
                except ccxt.AuthenticationError as e:
                    symbol_logger.critical(f"{COLOR_ERROR}CRITICAL AUTH ERROR for {symbol}: {e}. Check keys/permissions. Stopping bot.{RESET}")
                    raise # Re-raise critical auth errors to stop the bot
                except ccxt.NetworkError as e:
                     symbol_logger.error(f"{COLOR_ERROR}Network Error during analysis for {symbol}: {e}. Will retry next cycle.{RESET}")
                except ccxt.ExchangeError as e:
                     symbol_logger.error(f"{COLOR_ERROR}Exchange Error during analysis for {symbol}: {e}.{RESET}", exc_info=True)
                except Exception as e:
                    symbol_logger.error(f"{COLOR_ERROR}Unhandled Exception during analysis for {symbol}: {e}{RESET}", exc_info=True)
                # Add a small delay between symbols to avoid hitting rate limits aggressively
                time.sleep(0.5) # 500ms delay between symbol analyses


            # --- Loop Delay ---
            loop_end_time = time.monotonic()
            cycle_duration = loop_end_time - loop_start_time
            sleep_time = max(0, LOOP_DELAY_SECONDS - cycle_duration)
            init_logger.info(f"Cycle completed in {cycle_duration:.2f}s. Sleeping for {sleep_time:.2f}s...")
            time.sleep(sleep_time)

    except KeyboardInterrupt:
        init_logger.info(f"\n{COLOR_WARNING}KeyboardInterrupt received. Shutting down gracefully...{RESET}")
        # Optional: Add cleanup logic here (e.g., attempt to close open positions)
        if CONFIG.get("enable_trading", False):
             init_logger.warning("Trading was enabled. Check exchange for open positions/orders.")
             # Example cleanup (run carefully):
             # print("Attempting to close open positions (if any)...")
             # for sym in symbols_to_trade:
             #     pos = get_open_position(exchange, sym, init_logger)
             #     if pos and safe_decimal(pos.get('contracts')) != 0:
             #         print(f"Closing position for {sym}...")
             #         close_side = 'sell' if pos.get('side') == 'long' else 'buy'
             #         place_market_order(exchange, sym, close_side, abs(safe_decimal(pos.get('contracts'))), get_market_info(exchange, sym, init_logger), init_logger, params={'reduceOnly': True})
             #         time.sleep(1) # Small delay between closures

    except ccxt.AuthenticationError:
         # Already handled and logged above, just prevents further execution
         init_logger.critical("Authentication error detected. Bot stopped.")
    except Exception as e:
        init_logger.critical(f"{COLOR_ERROR}--- FATAL UNHANDLED ERROR IN MAIN LOOP ---{RESET}", exc_info=True)
        init_logger.critical(f"{COLOR_ERROR}Error: {e}{RESET}")
    finally:
        init_logger.info(f"{COLOR_HEADER}--- Volbot Shut Down ---{RESET}")
        logging.shutdown() # Ensure all log handlers flush and close


if __name__ == "__main__":
    # Set console log level based on config before setting up initial logger
    try:
        config_level_name = load_config(CONFIG_FILE).get("console_log_level", "INFO").upper()
        console_log_level = getattr(logging, config_level_name, logging.INFO)
    except Exception as e:
        print(f"Warning: Could not read initial console log level from config: {e}")
        # Keep default INFO level

    main()

