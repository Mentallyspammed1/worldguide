Okay, let's review and enhance the provided `rsitrader_enhanced.py` code. The structure and core refactoring using classes and dataclasses are already excellent. The enhancements will focus on adding file logging, minor logic refinements, and ensuring robustness.

**Key Enhancements in this Version (Beyond the User's Refactoring):**

1.  **File Logging:** Added a `FileHandler` to save logs to a file (`trading_bot.log`) alongside console output. This is crucial for reviewing past activity, especially if the bot runs unattended.
2.  **TSL State Saving:** Optimized `update_trailing_stop` to save the state only when the peak price (`highest_price_since_entry` or `lowest_price_since_entry`) is actually updated, reducing unnecessary file I/O.
3.  **Clarity & Comments:** Added a few clarifying comments, particularly around critical sections like the TSL update mechanism and emergency close scenarios.
4.  **Minor Refinements:** Ensured `traceback` import is justified by its use in the main execution block's error handling. Added `.gitignore` suggestion.
5.  **OCO Placeholder Clarity:** Reinforced the comments around the OCO placeholder in `place_protection_orders` to emphasize that it requires exchange-specific implementation for live trading.

```python
# --- START OF ENHANCED FILE rsitrader_enhanced_v1.4.py ---

import ccxt
import os
import logging
import logging.handlers # Added for FileHandler
from dotenv import load_dotenv
import time
import pandas as pd
import pandas_ta as ta
import json
import sys
import math
from pathlib import Path
from typing import Optional, Tuple, Dict, Any, List, Union, Callable, Final, Type
import functools
from dataclasses import dataclass, field
import traceback # For detailed error logging in main execution block

# --- Load Environment Variables FIRST ---
# Explicitly load .env from the script's directory or CWD
try:
    script_dir = Path(__file__).resolve().parent
    dotenv_path = script_dir / '.env'
    print(f"Attempting to load environment variables from: {dotenv_path}")
except NameError:
    # __file__ might not be defined (e.g., in interactive interpreter)
    script_dir = Path.cwd()
    dotenv_path = script_dir / '.env'
    print(f"Warning: Could not determine script directory reliably. Looking for .env in current working directory: {dotenv_path}")

load_success = load_dotenv(dotenv_path=dotenv_path, verbose=True, override=False) # override=False won't overwrite existing env vars

if not load_success:
    if dotenv_path.exists():
        print(f"Warning: Found .env file at {dotenv_path}, but load_dotenv() reported failure or no variables loaded. Check file permissions or content formatting.")
    else:
        print(f"Warning: .env file not found at {dotenv_path}. Environment variables must be set externally.")
else:
    print(f"Successfully processed .env file check at: {dotenv_path}")

# --- Colorama Initialization ---
try:
    from colorama import init, Fore, Back, Style
    init(autoreset=True)
    # Define Neon Colors using Bright style
    NEON_GREEN: Final[str] = Fore.GREEN + Style.BRIGHT
    NEON_PINK: Final[str] = Fore.MAGENTA + Style.BRIGHT
    NEON_CYAN: Final[str] = Fore.CYAN + Style.BRIGHT
    NEON_RED: Final[str] = Fore.RED + Style.BRIGHT
    NEON_YELLOW: Final[str] = Fore.YELLOW + Style.BRIGHT
    NEON_BLUE: Final[str] = Fore.BLUE + Style.BRIGHT
    RESET: Final[str] = Style.RESET_ALL
    COLORAMA_AVAILABLE: Final[bool] = True
except ImportError:
    print("Warning: colorama library not found. Neon styling disabled. Consider installing it: `pip install colorama`")
    NEON_GREEN = NEON_PINK = NEON_CYAN = NEON_RED = NEON_YELLOW = NEON_BLUE = RESET = ""
    COLORAMA_AVAILABLE = False

# --- Logging Configuration ---
LOG_FILENAME: Final[str] = 'trading_bot.log'
log_format_base: str = '%(asctime)s %(levelname)s [%(filename)s:%(lineno)d] [%(funcName)s] %(message)s'
log_formatter = logging.Formatter(log_format_base, datefmt='%Y-%m-%d %H:%M:%S')

# Basic console handler
console_handler = logging.StreamHandler(sys.stdout)
console_handler.setFormatter(log_formatter)

# File handler (rotating)
# Use a rotating file handler to prevent log file from growing indefinitely
# Keep 5 backup files, max 5MB each
log_file_path = script_dir / LOG_FILENAME
file_handler = logging.handlers.RotatingFileHandler(
    log_file_path, maxBytes=5*1024*1024, backupCount=5
)
file_handler.setFormatter(log_formatter)

# Configure root logger
logging.basicConfig(level=logging.INFO, handlers=[console_handler, file_handler])
logger: logging.Logger = logging.getLogger(__name__)
logger.info("="*50)
logger.info(f"Logging initialized. Console output enabled. File output to: {log_file_path}")
logger.info("="*50)


# --- Constants ---
DEFAULT_PRICE_PRECISION: Final[int] = 4
DEFAULT_AMOUNT_PRECISION: Final[int] = 8
POSITION_STATE_FILE: Final[str] = 'position_state.json'
CONFIG_FILE: Final[str] = 'config.json'
SIMULATION_ORDER_PREFIX: Final[str] = "sim_"
RETRYABLE_EXCEPTIONS: Tuple[Type[Exception], ...] = (
    ccxt.NetworkError, ccxt.ExchangeNotAvailable, ccxt.RateLimitExceeded,
    ccxt.RequestTimeout, ccxt.DDoSProtection, ccxt.ExchangeError # Adding generic ExchangeError here can be risky but catches more transient issues
)

# --- Neon Display Functions (Enhanced clarity and consistency) ---
def print_neon_header() -> None:
    """Prints a visually appealing header for the bot."""
    box_width = 70
    header_text = f"{NEON_CYAN}{'=' * box_width}{RESET}\n" \
                  f"{NEON_PINK}{Style.BRIGHT}{'Enhanced RSI/OB Trader Neon Bot - v1.4':^{box_width}}{RESET}\n" \
                  f"{NEON_CYAN}{'=' * box_width}{RESET}"
    print(header_text)
    logger.info("Neon Header Printed") # Log that header was shown

def display_error_box(message: str) -> None:
    box_width = 70
    error_box = f"{NEON_RED}{'!' * box_width}{RESET}\n" \
                f"{NEON_RED}! {message.strip():^{box_width-4}} !{RESET}\n" \
                f"{NEON_RED}{'!' * box_width}{RESET}"
    print(error_box)

def display_warning_box(message: str) -> None:
    box_width = 70
    warning_box = f"{NEON_YELLOW}{'~' * box_width}{RESET}\n" \
                  f"{NEON_YELLOW}~ {message.strip():^{box_width-4}} ~{RESET}\n" \
                  f"{NEON_YELLOW}{'~' * box_width}{RESET}"
    print(warning_box)

# Wrapper functions for logging with color
# Note: Color codes won't appear in the log file, only on console if colorama is available.
def log_info(msg: str) -> None: logger.info(f"{NEON_GREEN}{msg}{RESET}")
def log_error(msg: str, exc_info: bool = False) -> None:
    first_line = msg.split('\n', 1)[0]
    display_error_box(first_line)
    logger.error(f"{NEON_RED}{msg}{RESET}", exc_info=exc_info)
def log_warning(msg: str) -> None:
    display_warning_box(msg)
    logger.warning(f"{NEON_YELLOW}{msg}{RESET}")
def log_debug(msg: str) -> None: logger.debug(f"{Fore.WHITE}{msg}{RESET}") # Keep debug white

def print_cycle_divider(timestamp: pd.Timestamp) -> None:
    box_width = 70
    divider_text = f"\n{NEON_BLUE}{'=' * box_width}{RESET}\n" \
                   f"{NEON_CYAN}Cycle Start: {timestamp.strftime('%Y-%m-%d %H:%M:%S %Z')}{RESET}\n" \
                   f"{NEON_BLUE}{'=' * box_width}{RESET}"
    print(divider_text)
    logger.info(f"Cycle Start: {timestamp.strftime('%Y-%m-%d %H:%M:%S %Z')}") # Log cycle start

def neon_sleep_timer(seconds: int) -> None:
    """Displays a countdown timer with changing colors."""
    if seconds <= 0:
        return
    if not COLORAMA_AVAILABLE:
        print(f"Sleeping for {seconds} seconds...")
        time.sleep(seconds)
        return

    interval: float = 0.5
    steps: int = int(seconds / interval)
    for i in range(steps, -1, -1):
        remaining_seconds = max(0, round(i * interval))
        if remaining_seconds <= 5 and i % 2 == 0: color = NEON_RED
        elif remaining_seconds <= 15: color = NEON_YELLOW
        else: color = NEON_CYAN
        # Use '\r' to return cursor to the start of the line
        print(f"{color}Next cycle in: {remaining_seconds} seconds... {RESET}", end='\r', flush=True)
        time.sleep(interval)
    # Clear the countdown line after finishing
    print(" " * 50, end='\r', flush=True)
    logger.debug(f"Finished sleep timer ({seconds}s).")

def print_shutdown_message() -> None:
    box_width = 70
    shutdown_msg = f"\n{NEON_PINK}{'=' * box_width}{RESET}\n" \
                   f"{NEON_CYAN}{Style.BRIGHT}{'RSI/OB Trader Bot Stopped - Goodbye!':^{box_width}}{RESET}\n" \
                   f"{NEON_PINK}{'=' * box_width}{RESET}"
    print(shutdown_msg)
    logger.info("Shutdown Message Printed")

# --- Retry Decorator ---
def retry_api_call(max_retries: int = 3, initial_delay: float = 5.0, backoff_factor: float = 2.0) -> Callable:
    """Decorator for retrying CCXT API calls on specific network/rate limit errors."""
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs) -> Any:
            retries, delay = 0, initial_delay
            last_exception = None
            # Extract instance from args if it's a method call for logging context
            instance_name = args[0].__class__.__name__ if args and hasattr(args[0], '__class__') else func.__module__

            while retries <= max_retries:
                try:
                    return func(*args, **kwargs)
                except RETRYABLE_EXCEPTIONS as e:
                    retries += 1
                    last_exception = e
                    if retries > max_retries:
                        log_error(f"[{instance_name}] API call '{func.__name__}' failed after {max_retries} retries. Last error: {type(e).__name__}: {e}", exc_info=False)
                        raise last_exception # Re-raise the last exception
                    log_warning(f"[{instance_name}] API call '{func.__name__}' failed due to {type(e).__name__}. Retrying in {delay:.1f}s ({retries}/{max_retries})... Error: {e}")
                    neon_sleep_timer(int(round(delay)))
                    delay *= backoff_factor
                except Exception as e:
                    # Log non-retryable errors immediately and re-raise
                    log_error(f"[{instance_name}] Non-retryable error in API call '{func.__name__}': {type(e).__name__}: {e}", exc_info=True)
                    raise
            # This part should ideally not be reached if exceptions are always raised
            if last_exception: raise last_exception
            # Fallback raise if loop finishes unexpectedly (shouldn't happen with current logic)
            raise RuntimeError(f"[{instance_name}] API call '{func.__name__}' failed unexpectedly after exhausting retries without raising.")
        return wrapper
    return decorator

# --- Data Structures ---

@dataclass
class Config:
    """Stores all configuration parameters loaded from config.json."""
    # Core settings
    exchange_id: str
    symbol: str
    timeframe: str
    risk_percentage: float
    simulation_mode: bool
    data_limit: int
    sleep_interval_seconds: int

    # Indicator settings
    rsi_length: int
    rsi_overbought: int
    rsi_oversold: int
    stoch_k: int
    stoch_d: int
    stoch_smooth_k: int
    stoch_overbought: int
    stoch_oversold: int

    # Order Block settings
    ob_volume_threshold_multiplier: float
    ob_lookback: int

    # Volume confirmation settings
    entry_volume_confirmation_enabled: bool
    entry_volume_ma_length: int = 20  # Default value
    entry_volume_multiplier: float = 1.2 # Default value

    # SL/TP and Trailing Stop settings
    enable_atr_sl_tp: bool
    enable_trailing_stop: bool
    atr_length: int = 14 # Default, used if needs_atr is True

    # Conditional SL/TP values (set during loading based on enable_atr_sl_tp)
    atr_sl_multiplier: float = 0.0
    atr_tp_multiplier: float = 0.0
    stop_loss_percentage: float = 0.0
    take_profit_percentage: float = 0.0

    # Conditional TSL values (set during loading based on enable_trailing_stop)
    trailing_stop_atr_multiplier: float = 0.0
    trailing_stop_activation_atr_multiplier: float = 0.0

    # Retry settings
    retry_max_retries: int = 3
    retry_initial_delay: float = 5.0
    retry_backoff_factor: float = 2.0

    # --- Derived properties ---
    @property
    def needs_atr(self) -> bool:
        """Checks if ATR calculation is required based on SL/TP or TSL settings."""
        return self.enable_atr_sl_tp or self.enable_trailing_stop

    @property
    def rsi_col_name(self) -> str: return f'RSI_{self.rsi_length}'

    @property
    def stoch_k_col_name(self) -> str: return f'STOCHk_{self.stoch_k}_{self.stoch_d}_{self.stoch_smooth_k}'

    @property
    def stoch_d_col_name(self) -> str: return f'STOCHd_{self.stoch_k}_{self.stoch_d}_{self.stoch_smooth_k}'

    @property
    def atr_col_name(self) -> Optional[str]: return f'ATRr_{self.atr_length}' if self.needs_atr else None

    @property
    def vol_ma_col_name(self) -> Optional[str]: return f'VOL_MA_{self.entry_volume_ma_length}' if self.entry_volume_confirmation_enabled else None

    @property
    def stoch_params(self) -> Dict[str, int]:
        """Returns Stochastic parameters as a dictionary."""
        return {'k': self.stoch_k, 'd': self.stoch_d, 'smooth_k': self.stoch_smooth_k}


@dataclass
class MarketDetails:
    """Stores symbol-specific information like precision, limits, currencies, etc."""
    symbol: str
    price_precision_digits: int = DEFAULT_PRICE_PRECISION
    amount_precision_digits: int = DEFAULT_AMOUNT_PRECISION
    min_tick: float = 1 / (10 ** DEFAULT_PRICE_PRECISION) # Tick size
    min_amount: Optional[float] = None # Minimum order size in base currency
    min_cost: Optional[float] = None   # Minimum order cost in quote currency
    base_currency: Optional[str] = None
    quote_currency: Optional[str] = None
    is_contract_market: bool = False # Spot, Swap, Future etc.
    # Exchange capabilities relevant to the symbol/market type
    supports_oco: bool = False
    supports_fetch_positions: bool = False
    supports_stop_market: bool = False
    supports_stop_limit: bool = False
    supports_reduce_only: bool = False # Tracks if 'reduceOnly' param is likely needed/supported


# --- Configuration Loading ---
def load_and_validate_config(filename: str = CONFIG_FILE) -> Config:
    """Loads, validates, and returns the configuration as a Config object."""
    log_info(f"Loading configuration from '{filename}'...")
    config_path = Path(filename)
    if not config_path.exists():
        log_error(f"CRITICAL: Configuration file '{filename}' not found. Please create it.")
        sys.exit(1)

    try:
        with config_path.open('r') as f:
            cfg_data: Dict[str, Any] = json.load(f)
        log_info(f"Configuration file '{filename}' loaded successfully. Validating...")

        # --- Validation Logic ---
        errors: List[str] = []
        def validate(key: str, types: Union[type, Tuple[type, ...]], condition: Optional[Callable[[Any], bool]] = None, required: bool = True):
            """Helper function to validate a config entry."""
            if key not in cfg_data:
                if required: errors.append(f"Missing required key: '{key}'")
                return # Skip further checks if missing
            val = cfg_data[key]
            if not isinstance(val, types):
                errors.append(f"Key '{key}': Expected type {types}, but got {type(val).__name__}.")
            elif condition and not condition(val):
                errors.append(f"Key '{key}' (value: {val}) failed validation condition.")

        # Perform validations using the validate helper...
        # Core settings
        validate("exchange_id", str, lambda x: len(x) > 0)
        validate("symbol", str, lambda x: len(x) > 0)
        validate("timeframe", str, lambda x: len(x) > 0)
        validate("risk_percentage", (float, int), lambda x: 0 < x < 1)
        validate("simulation_mode", bool)
        validate("data_limit", int, lambda x: x > 50) # Need sufficient data for indicators
        validate("sleep_interval_seconds", int, lambda x: x >= 1) # Allow 1s minimum

        # Indicators
        validate("rsi_length", int, lambda x: x > 0)
        validate("rsi_overbought", int, lambda x: 50 < x <= 100)
        validate("rsi_oversold", int, lambda x: 0 <= x < 50)
        if "rsi_oversold" in cfg_data and "rsi_overbought" in cfg_data and cfg_data.get("rsi_oversold", 0) >= cfg_data.get("rsi_overbought", 100):
             errors.append("rsi_oversold must be strictly less than rsi_overbought")
        validate("stoch_k", int, lambda x: x > 0)
        validate("stoch_d", int, lambda x: x > 0)
        validate("stoch_smooth_k", int, lambda x: x > 0)
        validate("stoch_overbought", int, lambda x: 50 < x <= 100)
        validate("stoch_oversold", int, lambda x: 0 <= x < 50)
        if "stoch_oversold" in cfg_data and "stoch_overbought" in cfg_data and cfg_data.get("stoch_oversold", 0) >= cfg_data.get("stoch_overbought", 100):
             errors.append("stoch_oversold must be strictly less than stoch_overbought")

        # Order Block
        validate("ob_volume_threshold_multiplier", (float, int), lambda x: x > 0)
        validate("ob_lookback", int, lambda x: x > 0)

        # Volume Confirmation
        validate("entry_volume_confirmation_enabled", bool)
        if cfg_data.get("entry_volume_confirmation_enabled"):
            # Use defaults if keys are missing but feature is enabled
            validate("entry_volume_ma_length", int, lambda x: x > 0, required=False)
            validate("entry_volume_multiplier", (float, int), lambda x: x > 0, required=False)

        # SL/TP & TSL (conditional validation)
        validate("enable_atr_sl_tp", bool)
        validate("enable_trailing_stop", bool)
        needs_atr_cfg = cfg_data.get("enable_atr_sl_tp", False) or cfg_data.get("enable_trailing_stop", False)
        if needs_atr_cfg:
            validate("atr_length", int, lambda x: x > 0, required=False) # Use default if missing

        if cfg_data.get("enable_atr_sl_tp"):
            validate("atr_sl_multiplier", (float, int), lambda x: x > 0)
            validate("atr_tp_multiplier", (float, int), lambda x: x > 0)
        else:
            validate("stop_loss_percentage", (float, int), lambda x: x > 0)
            validate("take_profit_percentage", (float, int), lambda x: x > 0)

        if cfg_data.get("enable_trailing_stop"):
             validate("trailing_stop_atr_multiplier", (float, int), lambda x: x > 0)
             validate("trailing_stop_activation_atr_multiplier", (float, int), lambda x: x >= 0) # Activation can be at entry (0)

        # Optional Retry settings (use defaults if missing)
        validate("retry_max_retries", int, lambda x: x >= 0, required=False)
        validate("retry_initial_delay", (float, int), lambda x: x > 0, required=False)
        validate("retry_backoff_factor", (float, int), lambda x: x >= 1, required=False)

        # --- Report Validation Results ---
        if errors:
            error_str = "\n - ".join(errors)
            log_error(f"CRITICAL: Configuration validation failed with {len(errors)} errors:\n - {error_str}")
            sys.exit(1)

        log_info("Configuration validation passed.")

        # --- Create Config Object ---
        # Use defaults from the Config dataclass definition if keys are missing
        config_instance = Config(**cfg_data)

        # --- Post-process conditional values and ensure types ---
        # (These override defaults only if the feature is enabled and the value was provided)
        if config_instance.entry_volume_confirmation_enabled:
            config_instance.entry_volume_ma_length = cfg_data.get("entry_volume_ma_length", config_instance.entry_volume_ma_length)
            config_instance.entry_volume_multiplier = float(cfg_data.get("entry_volume_multiplier", config_instance.entry_volume_multiplier))
        if config_instance.needs_atr:
             config_instance.atr_length = cfg_data.get("atr_length", config_instance.atr_length)

        # Set conditional SL/TP values explicitly based on the flag
        if config_instance.enable_atr_sl_tp:
             config_instance.atr_sl_multiplier = float(cfg_data.get("atr_sl_multiplier", 0.0)) # Ensure float
             config_instance.atr_tp_multiplier = float(cfg_data.get("atr_tp_multiplier", 0.0))
             config_instance.stop_loss_percentage = 0.0 # Zero out the other mode's values
             config_instance.take_profit_percentage = 0.0
        else:
             config_instance.stop_loss_percentage = float(cfg_data.get("stop_loss_percentage", 0.0)) # Ensure float
             config_instance.take_profit_percentage = float(cfg_data.get("take_profit_percentage", 0.0))
             config_instance.atr_sl_multiplier = 0.0 # Zero out the other mode's values
             config_instance.atr_tp_multiplier = 0.0

        # Set conditional TSL values
        if config_instance.enable_trailing_stop:
            config_instance.trailing_stop_atr_multiplier = float(cfg_data.get("trailing_stop_atr_multiplier", 0.0))
            config_instance.trailing_stop_activation_atr_multiplier = float(cfg_data.get("trailing_stop_activation_atr_multiplier", 0.0))
        else:
             config_instance.trailing_stop_atr_multiplier = 0.0
             config_instance.trailing_stop_activation_atr_multiplier = 0.0

        # Ensure other potentially integer inputs are float where needed
        config_instance.risk_percentage = float(config_instance.risk_percentage)
        config_instance.ob_volume_threshold_multiplier = float(config_instance.ob_volume_threshold_multiplier)

        return config_instance

    except json.JSONDecodeError as e:
        log_error(f"CRITICAL: Error decoding JSON from '{filename}'. Check syntax: {e}")
        sys.exit(1)
    except TypeError as e: # Catches errors during Config(**cfg_data) if structure mismatches
         log_error(f"CRITICAL: Mismatch between config file fields and expected Config structure: {e}", exc_info=True)
         sys.exit(1)
    except Exception as e:
        log_error(f"CRITICAL: Unexpected error loading or validating config '{filename}': {e}", exc_info=True)
        sys.exit(1)


# --- Exchange Handler Class ---
class ExchangeHandler:
    """Handles all interactions with the CCXT exchange."""

    def __init__(self, config: Config):
        """Initializes the handler, connects to the exchange, and loads market details."""
        self.config = config
        self._exchange: Optional[ccxt.Exchange] = None
        self._market_details: Dict[str, MarketDetails] = {}
        self._api_retry_decorator = retry_api_call(
            max_retries=config.retry_max_retries,
            initial_delay=config.retry_initial_delay,
            backoff_factor=config.retry_backoff_factor
        )
        self._connect() # Attempt connection on initialization
        # Load details for the primary symbol immediately after connection
        if self._exchange:
            if not self._load_market_details(self.config.symbol):
                log_error(f"CRITICAL: Failed to load initial market details for {self.config.symbol}. Exiting.")
                sys.exit(1)
        else:
            log_error("CRITICAL: Exchange connection failed during initialization. Exiting.")
            sys.exit(1)


    def _connect(self):
        """Establishes connection to the exchange using credentials from environment variables."""
        log_info(f"Attempting to connect to exchange: {self.config.exchange_id}")
        exchange_id = self.config.exchange_id.lower()
        # Standard environment variable naming convention
        api_key_env = f"{exchange_id.upper()}_API_KEY"
        secret_key_env = f"{exchange_id.upper()}_SECRET_KEY"
        passphrase_env = f"{exchange_id.upper()}_PASSPHRASE" # Needed for some exchanges (e.g., KuCoin, OKX)

        api_key = os.getenv(api_key_env)
        secret = os.getenv(secret_key_env)
        passphrase = os.getenv(passphrase_env) # Will be None if not set

        if not api_key or not secret:
            # Allow running without API keys ONLY in simulation mode
            if not self.config.simulation_mode:
                log_error(f"CRITICAL: API Key ('{api_key_env}') or Secret ('{secret_key_env}') not found in environment variables. Required for live trading.")
                sys.exit(1)
            else:
                log_warning(f"API Key or Secret not found, but running in SIMULATION mode. Some features might be limited (e.g., balance check).")
                # Proceed without credentials for simulation
                exchange_config = {'enableRateLimit': True}
        else:
            # Prepare config for CCXT instantiation
            exchange_config: Dict[str, Any] = {
                'apiKey': api_key,
                'secret': secret,
                'enableRateLimit': True, # Essential for preventing IP bans
                'options': {
                    # Adjust time difference between local machine and exchange server
                    'adjustForTimeDifference': True,
                }
            }
            if passphrase:
                exchange_config['password'] = passphrase
                log_info(f"Passphrase found ('{passphrase_env}') and included.")

        try:
            exchange_class: Type[ccxt.Exchange] = getattr(ccxt, exchange_id)

            # Add default market type guess to options (can be overridden by market data)
            symbol_upper = self.config.symbol.upper()
            is_perp = ':' in symbol_upper or 'PERP' in symbol_upper or 'SWAP' in symbol_upper or '-P' in symbol_upper
            market_type_guess = 'swap' if is_perp else 'spot'
            if 'options' not in exchange_config: exchange_config['options'] = {}
            exchange_config['options']['defaultType'] = market_type_guess
            log_info(f"Guessed market type from symbol '{self.config.symbol}': {market_type_guess} (used as `defaultType`)")

            self._exchange = exchange_class(exchange_config)

            # Load markets immediately after connecting
            self._load_markets_robustly(force_reload=True) # Initial load must succeed

            log_info(f"Successfully connected to {self.exchange.name} ({exchange_id}).")
            log_info(f"Using Market Type (default): {self.exchange.options.get('defaultType')}")

            # Log key capabilities after markets are loaded
            self._log_exchange_capabilities()

        except AttributeError:
            log_error(f"CRITICAL: Exchange ID '{exchange_id}' is not supported by ccxt.")
            sys.exit(1)
        except ccxt.AuthenticationError as e:
            log_error(f"CRITICAL: Authentication failed for {exchange_id}. Check API Key/Secret/Passphrase. Error: {e}")
            sys.exit(1)
        except ccxt.ExchangeError as e: # Catch other ccxt errors during init/load
            log_error(f"CRITICAL: Exchange error during connection or initial market loading: {e}", exc_info=True)
            sys.exit(1)
        except Exception as e: # Catch any other unexpected error
            log_error(f"CRITICAL: Unexpected error during exchange setup: {e}", exc_info=True)
            sys.exit(1)

    def _log_exchange_capabilities(self):
        """Logs important capabilities reported by the exchange via ccxt `has` structure."""
        if not self.exchange: return
        log_info("Exchange Capabilities reported by CCXT:")
        log_info(f"  OCO Orders: {self.exchange.has.get('oco', False)}")
        log_info(f"  Fetch Positions: {self.exchange.has.get('fetchPositions', False)}")
        log_info(f"  Create Stop Market Order: {self.exchange.has.get('createStopMarketOrder', False)}")
        log_info(f"  Create Stop Limit Order: {self.exchange.has.get('createStopLimitOrder', False)}")
        log_info(f"  Fetch Ticker: {self.exchange.has.get('fetchTicker', False)}")
        log_info(f"  Fetch OHLCV: {self.exchange.has.get('fetchOHLCV', False)}")
        log_info(f"  Fetch Balance: {self.exchange.has.get('fetchBalance', False)}")

    @property
    def exchange(self) -> ccxt.Exchange:
        """Provides access to the CCXT exchange instance, ensuring it's connected."""
        if self._exchange is None:
            # This should ideally not happen if __init__ succeeded, but acts as a safeguard.
            log_error("Exchange object is None. Attempting to reconnect...")
            self._connect()
            if self._exchange is None: # Still None after reconnect attempt
                 log_error("CRITICAL: Reconnection failed. Cannot proceed. Exiting.")
                 sys.exit(1)
        return self._exchange

    @property
    def name(self) -> str:
        """Returns the name of the connected exchange."""
        return self.exchange.name if self.exchange else "N/A"

    def get_market_details(self, symbol: str) -> Optional[MarketDetails]:
        """Gets cached market details or loads them if needed. Returns None on failure."""
        sym_upper = symbol.upper()
        details = self._market_details.get(sym_upper)
        if not details:
            log_warning(f"Market details for {sym_upper} not cached. Attempting to load.")
            if self._load_market_details(sym_upper):
                details = self._market_details.get(sym_upper)
            else:
                log_error(f"Failed to load market details for {sym_upper}. Cannot proceed with this symbol.")
                return None # Explicitly return None on failure
        return details

    @retry_api_call(max_retries=2, initial_delay=10.0) # Use decorator directly
    def _load_markets_robustly(self, force_reload: bool = False):
        """Internal method to load markets with retry logic."""
        log_info(f"[ExchangeHandler] Loading markets (force_reload={force_reload})...")
        self.exchange.load_markets(reload=force_reload)
        log_info(f"[ExchangeHandler] Markets loaded successfully. Found {len(self.exchange.markets)} markets.")

    def _load_market_details(self, symbol: str) -> bool:
        """Loads and caches precision, limits, and capabilities for a specific symbol. Returns True on success."""
        sym_upper = symbol.upper()
        try:
            # Ensure markets are loaded first
            if not self.exchange.markets or sym_upper not in self.exchange.markets:
                log_warning(f"Market data for {sym_upper} not available locally, attempting reload...")
                self._load_markets_robustly(force_reload=True) # Attempt reload
                # Check again after reload
                if sym_upper not in self.exchange.markets:
                    available = list(self.exchange.markets.keys())
                    hint = f"Available examples: {available[:10]}" if available else "No markets loaded?"
                    log_error(f"[ExchangeHandler] CRITICAL: Symbol '{sym_upper}' not found on {self.name} even after reload. {hint}")
                    return False

            market_info = self.exchange.markets[sym_upper]

            # Check if timeframe is supported
            if self.config.timeframe not in self.exchange.timeframes:
                available_tfs = list(self.exchange.timeframes.keys())
                hint = f"Available: {available_tfs}" if available_tfs else "No timeframes listed?"
                log_error(f"[ExchangeHandler] CRITICAL: Timeframe '{self.config.timeframe}' not supported by {self.name}. {hint}")
                # Allow continuing if market exists, but log critical error
                # return False # Decide if this should be fatal

            log_info(f"[ExchangeHandler] Loading market details for {sym_upper}...")

            details = MarketDetails(symbol=sym_upper) # Start with defaults

            # Precision
            price_prec_val = market_info.get('precision', {}).get('price')
            amount_prec_val = market_info.get('precision', {}).get('amount')
            # CCXT precision modes: TICK_SIZE, DECIMAL_PLACES, SIGNIFICANT_DIGITS
            # We primarily need decimal places for formatting, but tick size is crucial.
            if price_prec_val is not None:
                try:
                    # Attempt to get decimal places using standard method
                    details.price_precision_digits = int(self.exchange.decimal_to_precision(price_prec_val, ccxt.ROUND, counting_mode=ccxt.DECIMAL_PLACES))
                    # Tick size is often the precision value itself if mode is TICK_SIZE
                    if self.exchange.precisionMode == ccxt.TICK_SIZE:
                        details.min_tick = float(price_prec_val)
                    else: # Calculate tick size from decimal places if not TICK_SIZE mode
                        details.min_tick = 1 / (10 ** details.price_precision_digits)
                except Exception as e:
                    log_warning(f"Could not determine price precision/tick from market info ({price_prec_val}). Using defaults. Error: {e}")
                    details.price_precision_digits = DEFAULT_PRICE_PRECISION
                    details.min_tick = 1 / (10 ** DEFAULT_PRICE_PRECISION)
            else: log_warning("Price precision not found in market info. Using default.")

            if amount_prec_val is not None:
                try:
                     details.amount_precision_digits = int(self.exchange.decimal_to_precision(amount_prec_val, ccxt.ROUND, counting_mode=ccxt.DECIMAL_PLACES))
                except Exception as e:
                    log_warning(f"Could not determine amount precision from market info ({amount_prec_val}). Using default. Error: {e}")
                    details.amount_precision_digits = DEFAULT_AMOUNT_PRECISION
            else: log_warning("Amount precision not found in market info. Using default.")

            # Ensure min_tick is positive
            if details.min_tick <= 0:
                 details.min_tick = 1 / (10 ** details.price_precision_digits) if details.price_precision_digits >= 0 else 0.0001 # Small fallback
                 log_warning(f"Calculated min_tick was invalid, using fallback: {details.min_tick}")

            # Limits
            limits = market_info.get('limits', {})
            details.min_amount = limits.get('amount', {}).get('min')
            details.min_cost = limits.get('cost', {}).get('min')

            # Currencies & Market Type
            details.base_currency = market_info.get('base')
            details.quote_currency = market_info.get('quote')
            # Determine if it's a contract market (more reliable check)
            details.is_contract_market = market_info.get('contract', False) or \
                                         market_info.get('swap', False) or \
                                         market_info.get('future', False) or \
                                         market_info.get('type') in ['swap', 'future', 'option']

            # Capabilities (Leverage exchange 'has' structure where possible)
            details.supports_oco = self.exchange.has.get('oco', False)
            details.supports_fetch_positions = self.exchange.has.get('fetchPositions', False)
            details.supports_stop_market = self.exchange.has.get('createStopMarketOrder', False) or self.exchange.has.get('createOrderWithTakeProfitAndStopLoss', False) # Consider combined methods
            details.supports_stop_limit = self.exchange.has.get('createStopLimitOrder', False)
            # ReduceOnly support check - heuristic based on market type and common exchanges
            details.supports_reduce_only = details.is_contract_market and \
                                           self.config.exchange_id in ['bybit', 'binance', 'binanceusdm', 'kucoinfutures', 'okx', 'gateio', 'phemex'] # Add more as needed

            # Log the gathered details
            log_info(f"Market Info | Base: {details.base_currency}, Quote: {details.quote_currency}, Contract: {details.is_contract_market}")
            log_info(f"Precision   | Price: {details.price_precision_digits} decimals (Tick: {details.min_tick:.{details.price_precision_digits+2}f}), Amount: {details.amount_precision_digits} decimals")
            if details.min_amount is not None: log_info(f"Limits      | Min Amount: {details.min_amount} {details.base_currency or ''}")
            if details.min_cost is not None: log_info(f"Limits      | Min Cost: {details.min_cost} {details.quote_currency or ''}")
            log_info(f"Capabilities| OCO: {details.supports_oco}, FetchPos: {details.supports_fetch_positions}, StopMrkt: {details.supports_stop_market}, StopLim: {details.supports_stop_limit}, ReduceOnlyParam: {details.supports_reduce_only}")

            self._market_details[sym_upper] = details
            return True

        except KeyError as e:
            log_error(f"[ExchangeHandler] CRITICAL: Error accessing expected key in market info for {sym_upper}. Market data might be incomplete or structured differently. Key: {e}", exc_info=True)
            return False
        except Exception as e:
            log_error(f"[ExchangeHandler] CRITICAL: Unexpected error processing market details for {sym_upper}: {e}", exc_info=True)
            return False

    # --- Formatting Helpers ---
    def format_price(self, symbol: str, price: float) -> float:
        """Formats the price according to the symbol's precision rules."""
        details = self.get_market_details(symbol)
        if not details: raise ValueError(f"Cannot format price, market details not found for {symbol}")
        # Use price_to_precision which respects tick size
        return float(self.exchange.price_to_precision(symbol, price))

    def format_amount(self, symbol: str, amount: float) -> float:
        """Formats the amount according to the symbol's precision rules."""
        details = self.get_market_details(symbol)
        if not details: raise ValueError(f"Cannot format amount, market details not found for {symbol}")
        # Use amount_to_precision
        return float(self.exchange.amount_to_precision(symbol, amount))

    # --- API Call Wrappers (Decorated for Retries) ---
    @_api_retry_decorator
    def fetch_ohlcv(self, symbol: str, timeframe: str, limit: int) -> Optional[pd.DataFrame]:
        """Fetches OHLCV data, cleans it, and returns a DataFrame."""
        log_debug(f"[ExchangeHandler] Fetching {limit} OHLCV for {symbol} ({timeframe})...")
        try:
            details = self.get_market_details(symbol) # Ensures market is known
            if not details: return None

            # Check if OHLCV fetching is supported
            if not self.exchange.has.get('fetchOHLCV'):
                log_error(f"Exchange {self.name} does not support fetchOHLCV via ccxt.")
                return None

            ohlcv = self.exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
            if not ohlcv:
                log_warning(f"[ExchangeHandler] No OHLCV data returned for {symbol} ({timeframe}). Exchange might have no data for this period.")
                return None

            # Convert to DataFrame and process
            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms', utc=True)
            df = df.set_index('timestamp')
            numeric_cols = ['open', 'high', 'low', 'close', 'volume']
            for col in numeric_cols:
                df[col] = pd.to_numeric(df[col], errors='coerce') # Convert, set non-numeric to NaN
            df.dropna(subset=numeric_cols, inplace=True) # Drop rows with NaN in essential columns

            if df.empty:
                log_warning(f"[ExchangeHandler] DataFrame empty after cleaning OHLCV for {symbol} ({timeframe}). Original data might have been malformed.")
                return None

            log_debug(f"[ExchangeHandler] Successfully fetched and cleaned {len(df)} OHLCV candles.")
            return df

        except ccxt.BadSymbol as e:
            log_error(f"[ExchangeHandler] CCXT BadSymbol error fetching OHLCV for {symbol}: {e}. Check symbol format.")
            return None
        except ccxt.ExchangeError as e:
            # Handled by retry decorator if retryable, otherwise log here
             if not isinstance(e, RETRYABLE_EXCEPTIONS):
                log_error(f"[ExchangeHandler] Non-retryable CCXT ExchangeError fetching OHLCV: {e}", exc_info=True)
             return None # Return None if error occurs (even after retries)
        except Exception as e:
             # Catch any other unexpected error not handled by decorator
             if not isinstance(e, RETRYABLE_EXCEPTIONS):
                  log_error(f"[ExchangeHandler] Unexpected error fetching OHLCV: {e}", exc_info=True)
             return None

    @_api_retry_decorator
    def fetch_balance(self) -> Dict[str, Any]:
         """Fetches account balance. Returns empty dict on failure."""
         log_debug("[ExchangeHandler] Fetching balance...")
         if not self.exchange.has.get('fetchBalance'):
             log_error(f"Exchange {self.name} does not support fetchBalance.")
             return {}
         # Handle simulation mode where keys might be missing
         if self.config.simulation_mode and (not os.getenv(f"{self.config.exchange_id.upper()}_API_KEY") or not os.getenv(f"{self.config.exchange_id.upper()}_SECRET_KEY")):
             log_warning("SIMULATION: Skipping real balance fetch due to missing API keys.")
             # Return a dummy balance structure if needed for calculations downstream
             details = self.get_market_details(self.config.symbol)
             quote_curr = details.quote_currency if details else 'USDT'
             return {
                 quote_curr: {'free': 10000.0, 'total': 10000.0, 'used': 0.0}, # Example large dummy balance
                 'info': {'simulated': True}
             }
         try:
             balance = self.exchange.fetch_balance()
             log_debug("[ExchangeHandler] Balance fetched successfully.")
             return balance
         except ccxt.AuthenticationError as e:
             log_error(f"Authentication error fetching balance: {e}. Check credentials.", exc_info=False)
             return {}
         except Exception as e:
             if not isinstance(e, RETRYABLE_EXCEPTIONS):
                 log_error(f"Unexpected error fetching balance: {e}", exc_info=True)
             return {} # Return empty on error

    @_api_retry_decorator
    def fetch_ticker(self, symbol: str) -> Dict[str, Any]:
        """Fetches the latest ticker information for a symbol. Returns empty dict on failure."""
        log_debug(f"[ExchangeHandler] Fetching ticker for {symbol}...")
        if not self.exchange.has.get('fetchTicker'):
            log_error(f"Exchange {self.name} does not support fetchTicker.")
            return {}
        try:
            ticker = self.exchange.fetch_ticker(symbol)
            log_debug(f"[ExchangeHandler] Ticker fetched for {symbol}.")
            return ticker
        except ccxt.BadSymbol as e:
            log_error(f"BadSymbol error fetching ticker for {symbol}: {e}")
            return {}
        except Exception as e:
             if not isinstance(e, RETRYABLE_EXCEPTIONS):
                  log_error(f"Unexpected error fetching ticker for {symbol}: {e}", exc_info=True)
             return {}

    @_api_retry_decorator
    def fetch_open_orders(self, symbol: str) -> List[Dict[str, Any]]:
         """Fetches open orders for a specific symbol. Returns empty list on failure."""
         log_debug(f"[ExchangeHandler] Fetching open orders for {symbol}...")
         if not self.exchange.has.get('fetchOpenOrders'):
             log_error(f"Exchange {self.name} does not support fetchOpenOrders.")
             return []
         try:
             orders = self.exchange.fetch_open_orders(symbol)
             log_debug(f"[ExchangeHandler] Found {len(orders)} open orders for {symbol}.")
             return orders
         except ccxt.AuthenticationError as e:
             log_error(f"Authentication error fetching open orders: {e}. Check credentials.", exc_info=False)
             return []
         except Exception as e:
             if not isinstance(e, RETRYABLE_EXCEPTIONS):
                 log_error(f"Unexpected error fetching open orders for {symbol}: {e}", exc_info=True)
             return []

    @_api_retry_decorator
    def fetch_positions(self, symbol: Optional[str] = None) -> List[Dict[str, Any]]:
        """Fetches open positions, optionally filtered by symbol. Returns empty list on failure or if not supported."""
        target_symbol = symbol or self.config.symbol # Use provided symbol or default from config
        details = self.get_market_details(target_symbol)
        if not details:
            log_error(f"Cannot fetch positions, market details unavailable for {target_symbol}.")
            return []
        if not details.supports_fetch_positions:
            log_debug(f"[ExchangeHandler] fetchPositions not supported by {self.name} or for market {target_symbol}.")
            return []

        symbols_list = [target_symbol] if target_symbol else None # Pass symbol if specified, otherwise might fetch all
        log_debug(f"[ExchangeHandler] Fetching positions{' for ' + target_symbol if target_symbol else ' (all)'}...")
        try:
            # Some exchanges require authentication even if just reading positions
            if self.config.simulation_mode and (not os.getenv(f"{self.config.exchange_id.upper()}_API_KEY") or not os.getenv(f"{self.config.exchange_id.upper()}_SECRET_KEY")):
                 log_warning("SIMULATION: Skipping real position fetch due to missing API keys.")
                 return [] # Cannot simulate positions without state persistence across runs easily

            positions = self.exchange.fetch_positions(symbols=symbols_list)
            log_debug(f"[ExchangeHandler] Fetched {len(positions)} position entries {'matching ' + target_symbol if target_symbol else ''}.")
            # Filter again client-side just in case the exchange API didn't filter correctly
            if target_symbol and positions:
                positions = [p for p in positions if p.get('symbol') == target_symbol]
                log_debug(f"Filtered down to {len(positions)} positions for symbol {target_symbol}.")
            return positions
        except ccxt.NotSupported:
             log_warning(f"[ExchangeHandler] Exchange reports fetchPositions not supported, despite 'has' flag or capability check.")
             details.supports_fetch_positions = False # Update cache
             return []
        except ccxt.AuthenticationError as e:
             log_error(f"Authentication error fetching positions: {e}. Check credentials.", exc_info=False)
             return []
        except Exception as e:
             if not isinstance(e, RETRYABLE_EXCEPTIONS):
                  log_error(f"[ExchangeHandler] Error fetching positions: {e}", exc_info=True)
             return [] # Return empty list on error


    @_api_retry_decorator
    def cancel_order(self, order_id: str, symbol: str) -> bool:
        """Cancels a specific order by ID. Returns True if successful or order not found."""
        if not order_id or not isinstance(order_id, str):
            log_warning(f"[ExchangeHandler] Invalid order ID type for cancellation: '{order_id}' ({type(order_id)}).")
            return False
        # Avoid cancelling simulation orders
        if self.config.simulation_mode and order_id.startswith(SIMULATION_ORDER_PREFIX):
             log_warning(f"SIMULATION: Skipped cancelling simulated order {order_id}.")
             return True
        if self.config.simulation_mode:
            log_warning(f"SIMULATION: Would cancel order {order_id} (but it's likely not real).")
            return True # Assume success in sim mode if not a sim prefix ID

        # Proceed with live cancellation
        details = self.get_market_details(symbol)
        if not details:
            log_error(f"Cannot cancel order {order_id}, market details not found for {symbol}.")
            return False

        log_info(f"[ExchangeHandler] Attempting to cancel order ID {order_id} for {symbol}...")

        try:
            log_warning(f"!!! LIVE MODE: Sending cancel request for order {order_id}.")
            self.exchange.cancel_order(order_id, symbol)
            log_info(f"[ExchangeHandler] Cancel request for order {order_id} sent successfully.")
            # Consider adding a small delay or fetch order status to confirm cancellation
            time.sleep(0.5) # Small delay
            return True
        except ccxt.OrderNotFound:
            log_info(f"[ExchangeHandler] Order {order_id} not found on exchange. Assumed already closed or cancelled.")
            return True # Treat as success
        except ccxt.InvalidOrder as e:
             log_error(f"[ExchangeHandler] Invalid order state or ID for cancelling {order_id}: {e}")
             return False
        except ccxt.ExchangeError as e:
             if not isinstance(e, RETRYABLE_EXCEPTIONS):
                 log_error(f"[ExchangeHandler] Exchange error cancelling order {order_id}: {type(e).__name__} - {e}")
             # May fail due to retries, return False
             return False
        except Exception as e:
             if not isinstance(e, RETRYABLE_EXCEPTIONS):
                  log_error(f"[ExchangeHandler] Unexpected error cancelling order {order_id}: {e}", exc_info=True)
             return False

    @_api_retry_decorator
    def place_market_order(self, symbol: str, side: str, amount: float, reduce_only: bool = False) -> Optional[Dict[str, Any]]:
        """Places a market order. Returns the order dictionary on success, None on failure."""
        details = self.get_market_details(symbol)
        if not details: return None

        # Validate inputs
        if side not in ['buy', 'sell']:
            log_error(f"[ExchangeHandler] Invalid side '{side}' for market order."); return None
        if not isinstance(amount, (float, int)) or amount <= 0:
            log_error(f"[ExchangeHandler] Invalid amount '{amount}' ({type(amount)}) for market order."); return None

        try:
            amount_fmt = self.format_amount(symbol, amount)
            if amount_fmt <= 0:
                log_error(f"Amount {amount} formatted to {amount_fmt}, which is <= 0. Check precision and min amount."); return None
            # Check against min amount limit if available
            if details.min_amount is not None and amount_fmt < details.min_amount:
                 log_error(f"Formatted amount {amount_fmt} is less than minimum required {details.min_amount}."); return None
        except Exception as fmt_e:
            log_error(f"[ExchangeHandler] Failed to format market order amount {amount}: {fmt_e}"); return None

        params = {}
        reduce_only_applied = False
        if reduce_only and details.is_contract_market:
            if details.supports_reduce_only:
                 params['reduceOnly'] = True
                 reduce_only_applied = True
                 log_debug("[ExchangeHandler] Applying reduceOnly=True parameter.")
            else:
                 log_warning(f"[ExchangeHandler] ReduceOnly requested for {symbol} but capability check is False or unclear. Order might fail or ignore the flag.")
                 # Decide whether to still attempt sending the param or not. Safer not to if unsupported.
                 # params['reduceOnly'] = True # Attempt anyway? Risky.
                 # Safer: Do not add the param if check is False.

        log_info(f"[ExchangeHandler] Preparing MARKET {side.upper()} order:")
        log_info(f"  Symbol: {symbol}, Amount: {amount_fmt:.{details.amount_precision_digits}f} {details.base_currency or ''}{' (Reduce-Only intended)' if reduce_only_applied else ''}")

        order_result: Optional[Dict[str, Any]] = None
        if self.config.simulation_mode:
            # Simulate market order execution
            sim_ts = int(time.time() * 1000)
            sim_id = f"{SIMULATION_ORDER_PREFIX}market_{side}_{sim_ts}"
            sim_price = 0.0
            try:
                # Fetch ticker for realistic simulation price
                ticker = self.fetch_ticker(symbol) # Already decorated
                sim_price = ticker.get('last', ticker.get('close')) # Prefer 'last', fallback 'close'
                if not sim_price or sim_price <= 0: # Further fallback for ask/bid
                    sim_price = ticker.get('bid') if side == 'sell' else ticker.get('ask')
                if not sim_price or sim_price <= 0: sim_price = 0.0 # Final fallback
            except Exception as e:
                log_warning(f"Simulation price fetch failed: {e}. Using 0.0.")

            sim_cost = amount_fmt * sim_price if sim_price > 0 else 0.0
            order_result = {
                'id': sim_id, 'clientOrderId': sim_id, 'timestamp': sim_ts,
                'datetime': pd.Timestamp.now(tz='UTC').isoformat(), 'status': 'closed', # Assume instant fill
                'symbol': symbol, 'type': 'market', 'timeInForce': 'IOC', 'side': side,
                'price': sim_price, 'average': sim_price, # Use sim_price for both
                'amount': amount_fmt, 'filled': amount_fmt, 'remaining': 0.0,
                'cost': sim_cost, 'fee': None, # Fee simulation is complex, omit for now
                'reduceOnly': reduce_only_applied,
                'info': {'simulated': True, 'simulated_price': sim_price, 'notes': 'Simulated market order'}
            }
            log_info(f"SIMULATION: Market order executed. ID: {sim_id}, Price: ~{sim_price:.{details.price_precision_digits}f}, Cost: ~{sim_cost:.{details.price_precision_digits}f}")
        else:
            # Execute live market order
            try:
                log_warning(f"!!! LIVE MODE: Placing real market order{' (Reduce-Only)' if reduce_only_applied else ''}.")
                order_result = self.exchange.create_market_order(symbol=symbol, side=side, amount=amount_fmt, params=params)
                log_info("[ExchangeHandler] Market order request sent successfully.")
                # Consider adding a delay to allow the order to potentially fill before proceeding
                time.sleep(1.5) # Wait 1.5 seconds
            except ccxt.InsufficientFunds as e:
                log_error(f"[ExchangeHandler] Insufficient funds for market order: {e}"); return None
            except ccxt.InvalidOrder as e:
                 log_error(f"[ExchangeHandler] Invalid market order parameters or state: {e}"); return None
            except ccxt.ExchangeError as e:
                 if not isinstance(e, RETRYABLE_EXCEPTIONS):
                     log_error(f"[ExchangeHandler] Exchange error placing market order: {type(e).__name__} - {e}");
                 return None # Return None after retry failure or if non-retryable
            except Exception as e:
                 if not isinstance(e, RETRYABLE_EXCEPTIONS):
                      log_error(f"[ExchangeHandler] Unexpected error placing market order: {e}", exc_info=True)
                 return None

        # Process result (common logic for simulated or live)
        if order_result:
            o_id = order_result.get('id', 'N/A')
            o_status = order_result.get('status', 'N/A')
            o_avg_price = order_result.get('average', order_result.get('price')) # Prefer 'average' if available
            o_filled = order_result.get('filled')
            o_cost = order_result.get('cost')
            o_reduce = order_result.get('reduceOnly', params.get('reduceOnly', False)) # Reflect actual param if available

            # Safely format numbers for logging
            p_str = f"{float(o_avg_price):.{details.price_precision_digits}f}" if isinstance(o_avg_price, (float, int, str)) and str(o_avg_price).replace('.', '', 1).isdigit() else "N/A"
            f_str = f"{float(o_filled):.{details.amount_precision_digits}f}" if isinstance(o_filled, (float, int, str)) and str(o_filled).replace('.', '', 1).isdigit() else "N/A"
            c_str = f"{float(o_cost):.{details.price_precision_digits}f}" if isinstance(o_cost, (float, int, str)) and str(o_cost).replace('.', '', 1).isdigit() else "N/A"

            log_info(f"Order Result | ID: {o_id}, Status: {o_status}, Avg Px: {p_str}, Filled: {f_str}, Cost: {c_str}, ReduceOnly: {o_reduce}")

            # Check status for potential issues
            if not self.config.simulation_mode and o_status == 'open':
                 log_warning(f"Live market order {o_id} has status 'open'. It might not have filled instantly or requires polling.")
            elif o_status in ['rejected', 'expired', 'canceled']: # Use 'canceled' spelling too
                 log_error(f"Market order {o_id} failed or was cancelled/rejected by exchange. Status: {o_status}"); return None

            # Return the result if successful or potentially open
            return order_result
        else:
            # This case should ideally be caught by specific exceptions earlier
            log_error("[ExchangeHandler] Market order placement attempt did not return a result object."); return None


    # @_api_retry_decorator # Applying retry here might be complex if OCO places multiple orders implicitly
    def place_protection_orders(self, symbol: str, pos_side: str, qty: float, sl_pr: float, tp_pr: float) -> Tuple[Optional[str], Optional[str], Optional[str]]:
        """
        Places Stop Loss (SL) and Take Profit (TP) protection orders.
        Attempts OCO (One-Cancels-the-Other) if supported, otherwise places separate SL and TP orders.
        Returns a tuple: (sl_order_id, tp_order_id, oco_order_id).
        oco_order_id will be populated if OCO was successful, otherwise sl/tp IDs might be populated.
        Returns (None, None, None) on total failure.
        """
        details = self.get_market_details(symbol)
        if not details: return None, None, None

        sl_order_id: Optional[str] = None
        tp_order_id: Optional[str] = None
        oco_ref_id: Optional[str] = None # Stores the OCO list ID or reference

        # --- Input Validation ---
        if pos_side not in ['long', 'short']: log_error("Invalid position side for protection orders"); return None, None, None
        if not (isinstance(qty, (float, int)) and qty > 0): log_error(f"Invalid quantity {qty} for protection orders"); return None, None, None
        if not (isinstance(sl_pr, (float, int)) and sl_pr > 0 and isinstance(tp_pr, (float, int)) and tp_pr > 0): log_error(f"Invalid SL ({sl_pr}) or TP ({tp_pr}) price"); return None, None, None
        # Basic logic check
        if (pos_side == 'long' and sl_pr >= tp_pr): log_error(f"Invalid SL/TP logic for LONG: SL ({sl_pr}) >= TP ({tp_pr})"); return None, None, None
        if (pos_side == 'short' and sl_pr <= tp_pr): log_error(f"Invalid SL/TP logic for SHORT: SL ({sl_pr}) <= TP ({tp_pr})"); return None, None, None

        close_side: str = 'sell' if pos_side == 'long' else 'buy'

        try: # Format Inputs according to market rules
            qty_fmt = self.format_amount(symbol, qty)
            sl_pr_fmt = self.format_price(symbol, sl_pr)
            tp_pr_fmt = self.format_price(symbol, tp_pr)
            if qty_fmt <= 0: raise ValueError(f"Quantity {qty} formatted to zero or less ({qty_fmt})")
            # Re-check logic after formatting
            if (pos_side == 'long' and sl_pr_fmt >= tp_pr_fmt): raise ValueError(f"SL/TP logic invalid after formatting: SL={sl_pr_fmt}, TP={tp_pr_fmt}")
            if (pos_side == 'short' and sl_pr_fmt <= tp_pr_fmt): raise ValueError(f"SL/TP logic invalid after formatting: SL={sl_pr_fmt}, TP={tp_pr_fmt}")
        except Exception as fmt_e:
            log_error(f"[ExchangeHandler] Failed to format SL/TP inputs: {fmt_e}"); return None, None, None

        # --- Common Parameters (especially for contract markets) ---
        params = {}
        if details.is_contract_market and details.supports_reduce_only:
            params['reduceOnly'] = True
            log_debug("[ExchangeHandler] Applying reduceOnly=True to protection orders.")
        elif details.is_contract_market:
             log_warning("Contract market but reduceOnly capability unclear/unsupported. Protection orders might increase position if flag isn't implicitly handled.")

        # --- Determine SL Order Type and Parameters ---
        sl_order_type: Optional[str] = None
        sl_limit_price: Optional[float] = None
        stop_price_param_name = 'stopPrice' # Common name, but check CCXT unified API or exchange specifics
        sl_params = params.copy() # Start with common params

        # Prefer Stop Market if available
        if details.supports_stop_market:
            sl_order_type = 'stop_market' # Use unified 'stop_market' type
            sl_params[stop_price_param_name] = sl_pr_fmt # Trigger price
            log_debug(f"[ExchangeHandler] Selected SL type: {sl_order_type}. Trigger: {sl_pr_fmt}")
        # Fallback to Stop Limit if Stop Market isn't supported
        elif details.supports_stop_limit:
            sl_order_type = 'stop_limit' # Use unified 'stop_limit' type
            sl_params[stop_price_param_name] = sl_pr_fmt # Trigger price

            # Calculate a reasonable limit price slightly away from the trigger
            # This helps avoid missing fills in fast markets but risks not filling if price gaps past the limit
            limit_offset_ticks = 10 # Number of ticks away
            limit_offset = details.min_tick * limit_offset_ticks
            limit_raw = sl_pr_fmt - limit_offset if close_side == 'sell' else sl_pr_fmt + limit_offset

            # Ensure limit price doesn't cross the trigger in the wrong direction
            if (close_side == 'sell' and limit_raw >= sl_pr_fmt):
                limit_raw = sl_pr_fmt - details.min_tick # Place it one tick away if offset crossed
            elif (close_side == 'buy' and limit_raw <= sl_pr_fmt):
                limit_raw = sl_pr_fmt + details.min_tick # Place it one tick away

            try:
                sl_limit_price = self.format_price(symbol, limit_raw)
                sl_params['price'] = sl_limit_price # The 'price' param is used for the limit price in stop_limit orders
            except Exception as fmt_e:
                log_error(f"Failed to format SL limit price {limit_raw}: {fmt_e}"); return None, None, None

            log_warning(f"[ExchangeHandler] Using fallback SL type: {sl_order_type}. Trigger: {sl_pr_fmt}, Limit: {sl_limit_price}.")
        else:
            log_error(f"[ExchangeHandler] Exchange {self.name} supports neither Stop Market nor Stop Limit orders via ccxt for {symbol}. Cannot place SL."); return None, None, None

        # --- Attempt OCO Placement (if supported) ---
        oco_attempted = False
        oco_succeeded = False
        if details.supports_oco:
            oco_attempted = True
            log_info(f"[ExchangeHandler] Attempting OCO {close_side.upper()} placement...")
            log_info(f"  Qty: {qty_fmt}, TP Limit: {tp_pr_fmt}, SL Trigger: {sl_pr_fmt} ({sl_order_type}{f', SL Limit: {sl_limit_price}' if sl_limit_price else ''})")
            if params: log_info(f"  Params: {params}")

            # --- !!! EXCHANGE-SPECIFIC OCO IMPLEMENTATION REQUIRED HERE !!! ---
            # The `create_order` method with OCO often requires specific `params` structure.
            # Examples (CHECK YOUR EXCHANGE DOCS / CCXT UNIFIED API):
            # Binance: Might use `stopPrice` for SL trigger, `price` for TP limit, and potentially `stopLimitPrice` and `stopLimitTimeInForce` for SL Limit part.
            # Bybit: Often uses `slTriggerBy`, `tpTriggerBy`, `stopLoss`, `takeProfit` within params.
            # The generic `create_order` might not work directly for OCO on all exchanges.
            # You might need `create_oco_order` if available or carefully construct params.

            # Placeholder structure - THIS WILL LIKELY FAIL OR NEED ADJUSTMENT
            oco_params = sl_params.copy() # Start with SL params (includes reduceOnly, stopPrice, maybe price for SL limit)
            # 'price' is typically the TP limit price in OCO calls that use create_order structure
            # oco_params['price'] = tp_pr_fmt # Set TP price - CAUTION: This might overwrite SL limit price if using stop_limit
            # Need to check how the specific exchange handles TP price and SL limit price in one call.

            # Example using a hypothetical unified OCO method (check if your exchange wrapper has one)
            # try:
            #     order_result = self.exchange.create_oco_order(symbol, 'limit', close_side, qty_fmt, tp_pr_fmt, sl_pr_fmt, sl_limit_price, params)
            # except ccxt.NotSupported: ...

            # Example trying generic create_order (HIGHLY LIKELY TO NEED ADJUSTMENT)
            # For a stop_market SL + limit TP OCO:
            oco_order_type_guess = 'limit' # Often, the TP type is primary
            oco_params_for_create = params.copy()
            oco_params_for_create['stopPrice'] = sl_pr_fmt # SL trigger
            # OCO flag might be needed: oco_params_for_create['oco'] = True ? or similar
            # oco_params_for_create['otherParams'] = ... specific to exchange

            try:
                if self.config.simulation_mode:
                    sim_oco_id = f"{SIMULATION_ORDER_PREFIX}oco_{close_side}_{int(time.time())}"
                    log_warning("SIMULATION: OCO order placement skipped. Assuming success for simulation flow.")
                    # Simulate getting back IDs. In reality, OCO might return one list ID or multiple order IDs.
                    # We'll use a reference ID for simulation.
                    oco_ref_id = sim_oco_id
                    # We might also simulate the individual SL/TP IDs being linked to this OCO
                    sl_order_id = f"{SIMULATION_ORDER_PREFIX}sl_linked_{int(time.time())}"
                    tp_order_id = f"{SIMULATION_ORDER_PREFIX}tp_linked_{int(time.time())}"
                    oco_succeeded = True
                    log_info(f"SIMULATION: OCO Ref ID: {oco_ref_id}, Sim SL ID: {sl_order_id}, Sim TP ID: {tp_order_id}")
                else:
                    # --- !!! REPLACE WITH ACTUAL EXCHANGE-SPECIFIC OCO CALL !!! ---
                    log_warning(f"!!! LIVE MODE: Attempting OCO for {self.name}. This is a PLACEHOLDER and likely needs exchange-specific code.")
                    log_warning(f"  Attempting with Type='{oco_order_type_guess}', Qty={qty_fmt}, TP Price={tp_pr_fmt}, Params={oco_params_for_create}") # Log the attempt details

                    # If your exchange REQUIRES specific params not handled here, this will fail.
                    # It's safer to assume it's not supported generically.
                    raise ccxt.NotSupported(f"Generic OCO structure used for {self.name}. Implement exchange-specific OCO logic using create_order params or a dedicated OCO method if available, or rely on separate SL/TP fallback.")

                    # --- Example of processing result IF a real call was made and succeeded ---
                    # order_result = self.exchange.create_order(
                    #     symbol=symbol, type=oco_order_type_guess, side=close_side,
                    #     amount=qty_fmt, price=tp_pr_fmt, # TP price
                    #     params=oco_params_for_create
                    # )
                    # if order_result:
                    #     # --- Extract OCO reference ID (HIGHLY exchange dependent) ---
                    #     # Try common fields first
                    #     oco_ref_id = order_result.get('id') # Sometimes the list ID is the main ID
                    #     info = order_result.get('info', {})
                    #     if not oco_ref_id and isinstance(info, dict):
                    #          # Common patterns (e.g., Binance, Bybit)
                    #          oco_ref_id = info.get('listClientOrderId', info.get('orderListId'))
                    #
                    #     if oco_ref_id:
                    #         log_info(f"OCO request seems processed. Ref ID/OrderListId: {oco_ref_id}, Status: {order_result.get('status','?')}")
                    #         # How to get individual SL/TP IDs from OCO result varies wildly.
                    #         # Sometimes they are in 'orders' list within 'info', sometimes need separate fetch.
                    #         # For simplicity, we might just store the oco_ref_id.
                    #         oco_succeeded = True
                    #         # Try to extract individual IDs if possible (Example structure)
                    #         # if 'orders' in info and isinstance(info['orders'], list):
                    #         #     for linked_order in info['orders']:
                    #         #         if linked_order.get('type') == 'STOP_MARKET' or linked_order.get('type') == 'STOP': sl_order_id = linked_order.get('orderId')
                    #         #         if linked_order.get('type') == 'LIMIT': tp_order_id = linked_order.get('orderId')
                    #         # log_info(f"  Extracted SL ID: {sl_order_id}, TP ID: {tp_order_id}")
                    #     else:
                    #         log_error(f"OCO placed but failed to extract a reference ID. Result: {order_result}")
                    # else:
                    #     log_error(f"OCO placement failed or returned unexpected result: {order_result}")
                    # --- End of Example Result Processing ---

            except ccxt.NotSupported as e:
                log_warning(f"OCO not supported or generic structure failed for {self.name}: {e}. Falling back to separate SL/TP.")
            except (ccxt.InvalidOrder, ccxt.ExchangeError) as e:
                log_error(f"OCO placement failed: {type(e).__name__} - {e}. Falling back.")
            except Exception as e:
                 if not isinstance(e, RETRYABLE_EXCEPTIONS):
                     log_error(f"Unexpected error during OCO attempt: {e}. Falling back.", exc_info=True)
                 # Fallback will be attempted if retryable error exhausted here

        # If OCO succeeded, we have the IDs (or ref ID), return them
        if oco_succeeded:
            # Return structure depends on whether individual IDs were extracted
            # Returning the reference ID is often the most practical approach
            return sl_order_id, tp_order_id, oco_ref_id # Return simulated or extracted IDs

        # --- Fallback: Place Separate Orders ---
        log_info(f"[ExchangeHandler] Placing separate SL and TP orders{' (OCO not supported/failed)' if oco_attempted else ''}.")
        sl_placed_ok = False
        tp_placed_ok = False

        # 1. Place SL Order (Stop Market or Stop Limit)
        try:
            log_info(f"Attempting separate SL ({sl_order_type}): Qty={qty_fmt}, Side={close_side}, Trigger={sl_pr_fmt}{f', Limit={sl_limit_price}' if sl_limit_price else ''}, Params={sl_params}")

            if self.config.simulation_mode:
                sl_order_id = f"{SIMULATION_ORDER_PREFIX}sl_{close_side}_{int(time.time())}"
                log_warning(f"SIMULATION: Separate SL ({sl_order_type}) skipped. Mock ID: {sl_order_id}"); sl_placed_ok = True
            else:
                log_warning(f"!!! LIVE MODE: Placing separate {sl_order_type} SL order.")
                # Use create_order for flexibility with stop types (already determined)
                # 'price' param is used for the limit price in stop_limit, ignored/None for stop_market
                sl_order = self.exchange.create_order(
                    symbol=symbol, type=sl_order_type, side=close_side,
                    amount=qty_fmt, price=sl_limit_price,
                    params=sl_params # Contains stopPrice and reduceOnly etc.
                )
                if sl_order and sl_order.get('id'):
                    sl_order_id = sl_order['id']
                    sl_placed_ok = True
                    log_info(f"Separate SL ({sl_order_type}) placed successfully. ID: {sl_order_id}, Status: {sl_order.get('status', '?')}")
                    time.sleep(0.5) # Small delay between orders
                else:
                    log_error(f"Separate SL ({sl_order_type}) placement failed or did not return an ID. Result: {sl_order}")
        except (ccxt.InvalidOrder, ccxt.ExchangeError, ccxt.InsufficientFunds) as e:
            log_error(f"Error placing separate SL ({sl_order_type}): {type(e).__name__} - {e}")
        except Exception as e:
             if not isinstance(e, RETRYABLE_EXCEPTIONS):
                 log_error(f"Unexpected error placing separate SL: {e}", exc_info=True)

        # 2. Place TP Order (Standard Limit Order)
        # Only place TP if SL was placed successfully OR if partial protection is acceptable
        # Current logic: attempt TP regardless of SL success, report outcome later.
        try:
            log_info(f"Attempting separate TP (Limit): Qty={qty_fmt}, Side={close_side}, Price={tp_pr_fmt}, Params={params}") # Use original common params
            tp_params_sep = params.copy() # Make a copy

            if self.config.simulation_mode:
                tp_order_id = f"{SIMULATION_ORDER_PREFIX}tp_{close_side}_{int(time.time())}"
                log_warning(f"SIMULATION: Separate TP (Limit) skipped. Mock ID: {tp_order_id}"); tp_placed_ok = True
            else:
                log_warning(f"!!! LIVE MODE: Placing separate limit TP order.")
                tp_order = self.exchange.create_limit_order(
                    symbol=symbol, side=close_side, amount=qty_fmt, price=tp_pr_fmt, params=tp_params_sep
                )
                if tp_order and tp_order.get('id'):
                    tp_order_id = tp_order['id']
                    tp_placed_ok = True
                    log_info(f"Separate TP (Limit) placed successfully. ID: {tp_order_id}, Status: {tp_order.get('status', '?')}")
                    time.sleep(0.5) # Small delay
                else:
                    log_error(f"Separate TP (Limit) placement failed or did not return an ID. Result: {tp_order}")
        except (ccxt.InvalidOrder, ccxt.ExchangeError, ccxt.InsufficientFunds) as e:
            log_error(f"Error placing separate TP (Limit): {type(e).__name__} - {e}")
        except Exception as e:
             if not isinstance(e, RETRYABLE_EXCEPTIONS):
                 log_error(f"Unexpected error placing separate TP: {e}", exc_info=True)

        # --- Final Outcome Reporting for Separate Orders ---
        if not sl_placed_ok and not tp_placed_ok:
            log_error("Both separate SL and TP placements failed. No protection orders active.")
        elif not sl_placed_ok:
            log_warning("Separate TP placed, but SL FAILED. Partial protection (TP only).")
            # Consider cancelling the lone TP? Depends on strategy risk tolerance.
            # self.cancel_order(tp_order_id, symbol) # Example cancellation
        elif not tp_placed_ok:
            log_warning("Separate SL placed, but TP FAILED. Partial protection (SL only).")
            # Usually keep SL if TP fails.

        # Return the IDs obtained (None if failed)
        return sl_order_id, tp_order_id, None # OCO ID is None in this fallback path


# --- Position Manager Class ---
@dataclass
class PositionState:
    """Holds the state of the current trading position, including TSL data."""
    status: Optional[str] = None      # 'long', 'short', or None
    entry_price: Optional[float] = None
    quantity: Optional[float] = None
    order_id: Optional[str] = None      # Initial entry market order ID
    stop_loss: Optional[float] = None     # Current target SL price (can be updated by TSL)
    take_profit: Optional[float] = None   # Original target TP price
    entry_time: Optional[pd.Timestamp] = None # UTC timestamp of entry

    # Protection order tracking (can be OCO ref or separate SL/TP)
    sl_order_id: Optional[str] = None   # ID of the separate SL order (if not OCO)
    tp_order_id: Optional[str] = None   # ID of the separate TP order (if not OCO)
    oco_order_id: Optional[str] = None  # Reference ID for the OCO order list (if used)

    # Trailing Stop Loss tracking
    highest_price_since_entry: Optional[float] = None # Tracks highest price for longs
    lowest_price_since_entry: Optional[float] = None  # Tracks lowest price for shorts
    current_trailing_sl_price: Optional[float] = None # The actively set TSL price (if different from initial stop_loss)

    def is_active(self) -> bool:
        """Checks if there is an active long or short position."""
        return self.status in ['long', 'short']

    def get_protection_order_ids(self) -> List[str]:
        """Returns a list of active protection order IDs (OCO ref or separate SL/TP)."""
        ids = []
        if self.oco_order_id:
            # If OCO ID is present, it's the primary reference.
            # Sometimes individual SL/TP IDs linked to OCO might also be stored,
            # but relying on the OCO ref is often sufficient for cancellation/checking.
            ids.append(self.oco_order_id)
            # Optionally add linked SL/TP if stored and needed:
            # if self.sl_order_id: ids.append(self.sl_order_id)
            # if self.tp_order_id: ids.append(self.tp_order_id)
        else:
            # If no OCO ID, use separate SL and TP IDs if they exist.
            if self.sl_order_id: ids.append(self.sl_order_id)
            if self.tp_order_id: ids.append(self.tp_order_id)
        return ids

    def to_dict(self) -> Dict[str, Any]:
        """Converts the dataclass state to a dictionary suitable for JSON serialization."""
        d = self.__dict__.copy()
        # Convert Timestamp to ISO 8601 string format
        if isinstance(d.get('entry_time'), pd.Timestamp):
            d['entry_time'] = d['entry_time'].isoformat()
        return d

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'PositionState':
        """Creates a PositionState instance from a dictionary (e.g., loaded from JSON)."""
        # Ensure all expected keys exist in the instance, using None if missing in data
        state_data = {k: data.get(k) for k in cls.__annotations__}

        # Convert ISO 8601 timestamp string back to Timestamp object
        entry_time_str = state_data.get('entry_time')
        if isinstance(entry_time_str, str):
            try:
                ts = pd.Timestamp(entry_time_str)
                # Ensure timezone is UTC (or make timezone-aware if needed)
                state_data['entry_time'] = ts.tz_convert('UTC') if ts.tzinfo else ts.tz_localize('UTC')
            except ValueError:
                log_warning(f"Invalid timestamp format '{entry_time_str}' found in state file. Resetting entry_time to None.")
                state_data['entry_time'] = None
        elif entry_time_str is not None and not isinstance(entry_time_str, pd.Timestamp):
             log_warning(f"Unexpected type for entry_time ('{type(entry_time_str)}') in state file. Resetting.")
             state_data['entry_time'] = None

        # Ensure numeric fields are floats (JSON might load integers)
        numeric_keys = ['entry_price', 'quantity', 'stop_loss', 'take_profit',
                        'highest_price_since_entry', 'lowest_price_since_entry',
                        'current_trailing_sl_price']
        for key in numeric_keys:
            if key in state_data and isinstance(state_data[key], int):
                state_data[key] = float(state_data[key])
            # Handle potential None values loaded from JSON correctly
            elif key in state_data and state_data[key] is None:
                 pass # Keep None as None
            # Optional: Add check for non-numeric types that aren't None
            elif key in state_data and state_data[key] is not None and not isinstance(state_data[key], float):
                 log_warning(f"Non-numeric, non-None value found for '{key}' ({state_data[key]}). Setting to None.")
                 state_data[key] = None


        # Create instance using validated/converted data
        try:
             return cls(**state_data)
        except TypeError as e:
             log_error(f"Error creating PositionState from dict due to unexpected field types/names: {e}. Data: {state_data}")
             # Return a default empty state on creation failure
             return cls()

class PositionManager:
    """Manages the bot's trading position state, including loading/saving and consistency checks."""

    def __init__(self, config: Config, exchange_handler: ExchangeHandler, state_file: str = POSITION_STATE_FILE):
        """Initializes the PositionManager, loading state from the file."""
        self.config = config
        self.exchange_handler = exchange_handler
        # Ensure state file path is relative to the script directory for consistency
        try:
             script_dir = Path(__file__).resolve().parent
        except NameError:
             script_dir = Path.cwd()
             log_warning("Could not reliably determine script directory, using CWD for state file.")
        self.state_file_path = script_dir / state_file
        self.state = PositionState() # Initialize with an empty state
        self.load_state() # Load existing state from file

    def save_state(self):
        """Saves the current position state to the JSON file."""
        log_debug(f"[PositionManager] Saving position state to '{self.state_file_path}'")
        try:
            state_dict = self.state.to_dict()
            # Ensure the directory exists before writing
            self.state_file_path.parent.mkdir(parents=True, exist_ok=True)
            with self.state_file_path.open('w') as f:
                json.dump(state_dict, f, indent=4, sort_keys=True) # Sort keys for consistent diffs
            log_debug("[PositionManager] Position state saved successfully.")
        except IOError as e:
            log_error(f"[PositionManager] I/O Error saving state file '{self.state_file_path}': {e}", exc_info=True)
        except Exception as e:
            log_error(f"[PositionManager] Unexpected error saving state: {e}", exc_info=True)

    def load_state(self):
        """Loads and validates position state from the JSON file."""
        log_info(f"[PositionManager] Attempting to load state from '{self.state_file_path}'...")
        if not self.state_file_path.exists():
            log_info(f"[PositionManager] No state file found at '{self.state_file_path}'. Starting with a fresh state.")
            self.state = PositionState()
            return # Nothing more to do

        try:
            with self.state_file_path.open('r') as f:
                loaded_data = json.load(f)

            # Basic validation: Is it a dictionary?
            if not isinstance(loaded_data, dict):
                log_error(f"State file '{self.state_file_path}' content is not a valid JSON dictionary. Starting fresh.")
                self.state = PositionState()
                # Optionally backup the corrupted file
                try:
                    corrupted_path = self.state_file_path.with_suffix('.json.corrupted')
                    self.state_file_path.rename(corrupted_path)
                    log_info(f"Renamed corrupted state file to: {corrupted_path}")
                except OSError as rename_err:
                     log_warning(f"Could not rename corrupted state file: {rename_err}")
                return

            # Convert dictionary to PositionState object using the classmethod
            self.state = PositionState.from_dict(loaded_data)
            log_info("[PositionManager] State file loaded successfully. Validating content consistency...")

            # --- Additional Validation Checks ---
            issues_found = []
            if self.state.is_active():
                # Check essential numeric data for active positions
                essential_numeric = ['entry_price', 'quantity', 'stop_loss', 'take_profit']
                missing_essentials = [k for k in essential_numeric if getattr(self.state, k) is None or not isinstance(getattr(self.state, k), (float, int))]
                if missing_essentials:
                    issues_found.append(f"Active position ('{self.state.status}') missing/invalid essential numeric data: {missing_essentials}.")

                # Check TSL data consistency if TSL is enabled in config
                if self.config.enable_trailing_stop:
                    if self.state.highest_price_since_entry is None or self.state.lowest_price_since_entry is None:
                         issues_found.append("TSL enabled in config, but peak price tracking data (highest/lowest) is missing in state.")
                    # Check if current_trailing_sl_price makes sense relative to initial SL
                    if self.state.current_trailing_sl_price is not None and self.state.stop_loss is not None:
                         if self.state.status == 'long' and self.state.current_trailing_sl_price < self.state.stop_loss:
                              issues_found.append(f"TSL Inconsistency: Active TSL ({self.state.current_trailing_sl_price}) is below initial SL ({self.state.stop_loss}) for LONG.")
                         elif self.state.status == 'short' and self.state.current_trailing_sl_price > self.state.stop_loss:
                              issues_found.append(f"TSL Inconsistency: Active TSL ({self.state.current_trailing_sl_price}) is above initial SL ({self.state.stop_loss}) for SHORT.")

                # Check if protection order IDs are missing when expected
                if not self.state.get_protection_order_ids():
                     issues_found.append("Active position has no tracked protection order IDs (SL/TP/OCO). Position might be unprotected if this state is old.")

            if issues_found:
                log_warning(f"[PositionManager] {len(issues_found)} issues found during state validation:")
                for issue in issues_found: log_warning(f"  - {issue}")
                log_warning("[PositionManager] Review the state file and config. Current state kept, but might require manual reset or intervention.")
                # Decide if state should be invalidated based on severity
                if any("missing/invalid essential numeric data" in issue for issue in issues_found):
                     log_error("CRITICAL: Essential position data invalid in state file. Resetting state to None to prevent inconsistent behavior.")
                     self.reset_state(reason="Invalid essential data in loaded state")
                     # Save the reset state immediately
                     self.save_state()

            log_info("[PositionManager] Position state loaded and validated.")
            self.display_status() # Show the status after loading

        except json.JSONDecodeError as e:
            log_error(f"[PositionManager] Error decoding JSON from '{self.state_file_path}': {e}. Starting fresh.", exc_info=False)
            self.state = PositionState()
        except Exception as e:
            log_error(f"[PositionManager] Unexpected error loading state from '{self.state_file_path}': {e}. Starting fresh.", exc_info=True)
            self.state = PositionState()

    def update_entry(self, side: str, entry_price: float, quantity: float, entry_order_id: str, sl_price: float, tp_price: float, sl_order_id: Optional[str], tp_order_id: Optional[str], oco_order_id: Optional[str]):
        """Updates the state when a new position is successfully entered and protected."""
        log_info(f"[PositionManager] Updating state for new {side.upper()} entry.")
        self.state = PositionState(
            status=side,
            entry_price=entry_price,
            quantity=quantity,
            order_id=entry_order_id,      # Store the entry order ID
            stop_loss=sl_price,           # This is the initial SL, might be updated by TSL
            take_profit=tp_price,         # This is the original TP target
            entry_time=pd.Timestamp.now(tz='UTC'), # Record entry time in UTC
            sl_order_id=sl_order_id,      # Store protection order IDs
            tp_order_id=tp_order_id,
            oco_order_id=oco_order_id,
            # Initialize TSL tracking variables
            highest_price_since_entry=entry_price if side == 'long' else None, # Track highest price for longs
            lowest_price_since_entry=entry_price if side == 'short' else None,  # Track lowest price for shorts
            current_trailing_sl_price=None # Initially, no TSL is active beyond the initial SL
        )
        self.save_state() # Persist the new state immediately
        self.display_status() # Show the updated status

    def reset_state(self, reason: str = "Unknown"):
        """Resets the position state to default (no active position) and saves."""
        log_info(f"[PositionManager] Resetting position state. Reason: {reason}")
        self.state = PositionState() # Create a new empty state object
        self.save_state() # Persist the reset state
        self.display_status() # Show the 'None' status

    def display_status(self):
        """Displays the current position status in a formatted way."""
        details = self.exchange_handler.get_market_details(self.config.symbol)
        price_prec = details.price_precision_digits if details else DEFAULT_PRICE_PRECISION
        amount_prec = details.amount_precision_digits if details else DEFAULT_AMOUNT_PRECISION

        state = self.state
        status = state.status
        entry_price = state.entry_price
        quantity = state.quantity
        sl_target = state.stop_loss # The current SL target
        tp_target = state.take_profit # The original TP target
        tsl_active_price = state.current_trailing_sl_price # The price set by TSL if active
        entry_time = state.entry_time

        # Format numbers safely, handling None
        entry_str = f"{entry_price:.{price_prec}f}" if isinstance(entry_price, (float, int)) else "N/A"
        qty_str = f"{quantity:.{amount_prec}f}" if isinstance(quantity, (float, int)) else "N/A"
        sl_str = f"{sl_target:.{price_prec}f}" if isinstance(sl_target, (float, int)) else "N/A"
        tp_str = f"{tp_target:.{price_prec}f}" if isinstance(tp_target, (float, int)) else "N/A"
        # Display active TSL price if it exists
        tsl_info_str = f" | TSL Active @ {tsl_active_price:.{price_prec}f}" if isinstance(tsl_active_price, (float, int)) else ""
        time_str = f" | Entered: {entry_time.strftime('%Y-%m-%d %H:%M %Z')}" if isinstance(entry_time, pd.Timestamp) else ""

        # Determine color based on status
        if status == 'long': status_color, status_text = NEON_GREEN, "LONG"
        elif status == 'short': status_color, status_text = NEON_RED, "SHORT"
        else: status_color, status_text = NEON_CYAN, "None"

        # Print main status line
        print(f"{status_color}Position Status: {status_text}{RESET} | Entry: {entry_str} | Qty: {qty_str} | SL Target: {sl_str} | TP Target: {tp_str}{tsl_info_str}{time_str}")

        # Print protection order info
        protection_info = []
        if state.oco_order_id:
            protection_info.append(f"OCO Ref ID: {state.oco_order_id}")
            # Optionally add linked IDs if they are stored and relevant
            # if state.sl_order_id: protection_info.append(f" (SL ID: {state.sl_order_id})")
            # if state.tp_order_id: protection_info.append(f" (TP ID: {state.tp_order_id})")
        else:
            if state.sl_order_id: protection_info.append(f"SL ID: {state.sl_order_id}")
            if state.tp_order_id: protection_info.append(f"TP ID: {state.tp_order_id}")

        if protection_info:
            print(f"    Protection Orders: {', '.join(protection_info)}")
        elif state.is_active():
             # Warn if active but no protection IDs are tracked
             print(f"    {NEON_YELLOW}Warning: Position is active but no protection order IDs are currently tracked in state.{RESET}")

    def check_position_and_orders(self) -> bool:
        """
        Checks consistency of the local state against exchange orders and positions (if applicable).
        Resets the local state if a closure (SL/TP hit, manual close) is detected based on orders or positions.
        Attempts to cancel any lingering opposite protection order if one is found filled/cancelled.
        Returns True if the local state was reset, False otherwise.
        """
        if not self.state.is_active():
            return False # No active position to check

        log_debug(f"[PositionManager] Checking state consistency for active {self.state.status} position...")
        reset_required = False
        closure_reason = "Unknown closure reason"
        order_to_cancel: Optional[str] = None # ID of the lingering order to cancel (e.g., TP if SL hit)
        cancel_label: str = "" # Label for logging cancellation (e.g., "TP")
        symbol = self.config.symbol
        details = self.exchange_handler.get_market_details(symbol)
        if not details:
            log_error("Cannot check position consistency, market details unavailable.")
            return False # Cannot proceed without details

        try:
            # --- 1. Check Tracked Protection Orders Status ---
            tracked_ids = self.state.get_protection_order_ids()
            protection_order_still_open = False # Assume closed until proven open

            if tracked_ids:
                log_debug(f"Fetching open orders for {symbol} to check status of tracked IDs: {tracked_ids}")
                # Fetch open orders specifically for the symbol
                open_orders = self.exchange_handler.fetch_open_orders(symbol)
                # Create a set of open order IDs for quick lookup
                open_order_ids = {o['id'] for o in open_orders if 'id' in o}
                log_debug(f"Found {len(open_order_ids)} open order IDs on exchange: {open_order_ids if open_order_ids else 'None'}")

                # --- Check OCO Order Status (if applicable) ---
                if self.state.oco_order_id:
                    # Checking OCO status is complex. An OCO might resolve into one order filling and the other cancelling.
                    # The most reliable check is often seeing if *any* part of the OCO is still listed as open.
                    # Some exchanges might remove the OCO list ID once resolved.
                    # We check if the reference ID or potentially linked SL/TP IDs are still open.
                    oco_related_ids = {self.state.oco_order_id}
                    # Add linked IDs if they were stored:
                    if self.state.sl_order_id: oco_related_ids.add(self.state.sl_order_id)
                    if self.state.tp_order_id: oco_related_ids.add(self.state.tp_order_id)

                    if any(oid in open_order_ids for oid in oco_related_ids):
                        protection_order_still_open = True
                        log_debug(f"Tracked OCO order ({self.state.oco_order_id}) or linked component appears to still be open.")
                    else:
                        # If no component of the OCO is found open, assume it resolved (SL or TP hit)
                        reset_required = True
                        closure_reason = f"Tracked OCO {self.state.oco_order_id} (or linked orders) not found in open orders"
                        log_info(f"{NEON_YELLOW}Closure Detected: {closure_reason}. Assuming OCO resolved (SL/TP hit).{RESET}")
                        # No lingering order to cancel typically with OCO

                # --- Check Separate SL/TP Order Status ---
                else:
                    sl_is_open = self.state.sl_order_id in open_order_ids if self.state.sl_order_id else False
                    tp_is_open = self.state.tp_order_id in open_order_ids if self.state.tp_order_id else False
                    log_debug(f"Separate Order Check: SL Open = {sl_is_open} (ID: {self.state.sl_order_id}), TP Open = {tp_is_open} (ID: {self.state.tp_order_id})")

                    # Scenario 1: Both SL and TP orders exist in state, but neither is found open -> Position likely closed
                    if self.state.sl_order_id and not sl_is_open and self.state.tp_order_id and not tp_is_open:
                        reset_required = True
                        closure_reason = f"Neither tracked SL ({self.state.sl_order_id}) nor TP ({self.state.tp_order_id}) found in open orders"
                        log_info(f"{NEON_YELLOW}Closure Detected: {closure_reason}.{RESET}")
                    # Scenario 2: SL existed but is not open -> Assume SL was hit
                    elif self.state.sl_order_id and not sl_is_open:
                        reset_required = True
                        closure_reason = f"Tracked SL order {self.state.sl_order_id} not found in open orders"
                        log_info(f"{NEON_RED}Closure Detected: {closure_reason} (SL likely hit).{RESET}")
                        # If SL hit, the TP order should be cancelled if it's still open
                        if tp_is_open:
                            order_to_cancel = self.state.tp_order_id
                            cancel_label = "lingering TP"
                    # Scenario 3: TP existed but is not open -> Assume TP was hit
                    elif self.state.tp_order_id and not tp_is_open:
                        reset_required = True
                        closure_reason = f"Tracked TP order {self.state.tp_order_id} not found in open orders"
                        log_info(f"{NEON_GREEN}Closure Detected: {closure_reason} (TP likely hit).{RESET}")
                        # If TP hit, the SL order should be cancelled if it's still open
                        if sl_is_open:
                            order_to_cancel = self.state.sl_order_id
                            cancel_label = "lingering SL"
                    # Scenario 4: At least one of the separate orders is still open
                    elif sl_is_open or tp_is_open:
                        protection_order_still_open = True
                        log_debug("At least one separate protection order (SL or TP) is still open.")

            else:
                # State is active, but no protection IDs were tracked. This is risky.
                log_warning("Position is active, but no protection order IDs were tracked in state. Cannot check order status.")
                # Proceed to check actual position if possible

            # --- 2. Fallback/Confirmation: Check Actual Position (Primarily for Contract Markets) ---
            # This check is useful if order checking is unreliable or if state might be out of sync.
            should_check_pos = details.is_contract_market and details.supports_fetch_positions

            # Only run this expensive check if needed (e.g., order check suggests closure or was inconclusive)
            # Or always run if supported, for maximum safety? Let's run it if supported.
            if should_check_pos:
                log_info("Checking actual position status via fetchPositions as fallback/confirmation...")
                positions_data = self.exchange_handler.fetch_positions(symbol) # Fetch for the specific symbol
                position_found_on_exchange = False
                # Define a small threshold for considering a position closed (dust amount)
                # Use min_amount if available, otherwise a small number based on typical precision
                min_amount_threshold = details.min_amount if details.min_amount is not None else (1 / (10**details.amount_precision_digits)) * 0.1

                if positions_data: # Check if list is not empty
                    for pos_info in positions_data:
                        # Ensure we are looking at the correct symbol's position info
                        if isinstance(pos_info, dict) and pos_info.get('symbol') == symbol:
                            # --- Extract Position Size (handle variations in field names) ---
                            size_val = 0.0
                            contracts = pos_info.get('contracts') # Unified field
                            if contracts is not None:
                                size_val = contracts
                            else: # Fallback to info dictionary
                                info_dict = pos_info.get('info', {})
                                if isinstance(info_dict, dict):
                                     # Common keys: 'size' (Bybit), 'positionAmt' (Binance), 'qty' (Kucoin?), 'contracts'
                                     size_val = info_dict.get('size', info_dict.get('positionAmt', info_dict.get('qty', info_dict.get('contracts', 0.0))))
                            try:
                                current_pos_size = abs(float(size_val)) if size_val is not None else 0.0
                            except (ValueError, TypeError):
                                current_pos_size = 0.0
                                log_warning(f"Could not parse position size from fetchPositions: {size_val}")

                            # --- Extract Position Side (handle variations) ---
                            pos_side_exch = 'unknown'
                            side_val = pos_info.get('side') # Unified field
                            if side_val in ['long', 'short']:
                                pos_side_exch = side_val
                            else: # Fallback to info or infer from amount sign
                                info_dict = pos_info.get('info', {})
                                if isinstance(info_dict, dict):
                                     side_val_info = info_dict.get('side', info_dict.get('positionSide')) # e.g., 'BOTH', 'LONG', 'SHORT'
                                     if isinstance(side_val_info, str) and side_val_info.lower() in ['long', 'short']:
                                          pos_side_exch = side_val_info.lower()
                                     elif 'positionAmt' in info_dict: # Infer from Binance 'positionAmt' sign
                                          try:
                                               amt_sign = float(info_dict.get('positionAmt', 0.0))
                                               if amt_sign > min_amount_threshold: pos_side_exch = 'long'
                                               elif amt_sign < -min_amount_threshold: pos_side_exch = 'short'
                                          except (ValueError, TypeError): pass # Ignore if cannot parse amount

                            log_debug(f"fetchPositions found {symbol}: Size={current_pos_size:.{details.amount_precision_digits}f}, Exchange Side='{pos_side_exch}'")

                            # --- Compare with local state ---
                            if current_pos_size > min_amount_threshold:
                                position_found_on_exchange = True
                                log_info(f"fetchPositions confirms active {pos_side_exch.upper()} position exists (Size: {current_pos_size:.{details.amount_precision_digits}f}).")
                                # If fetchPositions confirms an active position matching our state, override any reset triggered by order checks
                                if self.state.status == pos_side_exch:
                                    if reset_required:
                                        log_warning("Position check via fetchPositions confirms active state. Overriding reset previously triggered by order status check.")
                                        reset_required = False
                                        order_to_cancel = None # Cancel the cancellation :)
                                # If fetchPositions shows a position but it *mismatches* our state (or state is None) -> Critical Mismatch
                                elif self.state.status != pos_side_exch:
                                    log_error(f"!!! CRITICAL STATE MISMATCH !!! Local state: {self.state.status}, Exchange position: {pos_side_exch} (Size: {current_pos_size:.{details.amount_precision_digits}f})")
                                    reset_required = True # Force reset due to mismatch
                                    closure_reason = f"State Mismatch: Local={self.state.status}, Exchange={pos_side_exch}"
                                    # Attempt to cancel any orders associated with the incorrect local state
                                    order_to_cancel = self.state.oco_order_id or self.state.sl_order_id or self.state.tp_order_id
                                    cancel_label = "orders due to state mismatch"
                                break # Stop checking positions once we found the relevant symbol

                # If fetchPositions was supported and run, but found no active position for the symbol
                if not position_found_on_exchange:
                    log_info(f"Position check via fetchPositions confirmed no active position for {symbol}.")
                    # If order checks didn't already trigger a reset, this confirms closure
                    if not reset_required:
                        reset_required = True
                        closure_reason = f"Position not found via fetchPositions for {symbol}"
                        log_info(f"{NEON_YELLOW}Closure Confirmed: {closure_reason}. Resetting local state.{RESET}")
                        # If we thought we had orders, try to cancel them just in case fetchPositions was delayed
                        order_to_cancel = self.state.oco_order_id or self.state.sl_order_id or self.state.tp_order_id
                        cancel_label = "orders as position confirmed closed"

            # --- 3. Perform State Reset and Order Cleanup if Required ---
            if reset_required:
                log_info(f"Initiating state reset. Final Reason: {closure_reason}")
                # Attempt to cancel any identified lingering order
                if order_to_cancel and cancel_label:
                    log_info(f"Attempting cancellation of {cancel_label}: {order_to_cancel}")
                    # Use the exchange handler's cancel method (already handles simulation mode)
                    cancelled = self.exchange_handler.cancel_order(order_to_cancel, symbol)
                    log_info(f"Cancellation request for {order_to_cancel} {'sent/confirmed closed' if cancelled else 'failed or already closed'}.")

                # Reset the local state
                self.reset_state(closure_reason) # Resets state object and saves the reset state
                return True # Signal that state was reset

            # If no reset was required
            log_debug("Position state appears consistent with exchange orders/positions.")
            return False # State not reset

        except ccxt.AuthenticationError as e:
            # If authentication fails during check, we cannot be sure of the state
            log_error(f"[PositionManager] Authentication Error during consistency check: {e}. Cannot reliably check state. State unchanged.", exc_info=False)
            return False # Do not reset state if check fails due to auth
        except ccxt.ExchangeError as e:
            # Handle other exchange errors during the check
            log_error(f"[PositionManager] Exchange communication error during consistency check: {e}. State unchanged.", exc_info=False)
            return False # Avoid changing state if check is unreliable
        except Exception as e:
             # Catch any unexpected errors during the check process
             if not isinstance(e, RETRYABLE_EXCEPTIONS): # Avoid logging retryable errors excessively here
                 log_error(f"[PositionManager] Unexpected error during consistency check: {e}. State unchanged.", exc_info=True)
             return False


    def update_trailing_stop(self, current_price: float, current_atr: Optional[float]):
        """Checks and updates the trailing stop loss if conditions are met."""
        # --- Pre-checks ---
        if not self.config.enable_trailing_stop: return # TSL not enabled
        if not self.state.is_active(): return # No active position
        if current_atr is None or current_atr <= 0:
            log_debug("TSL Check: Skipping, invalid ATR value.")
            return # Need valid ATR for TSL calculation

        details = self.exchange_handler.get_market_details(self.config.symbol)
        if not details: log_error("TSL Check: Cannot proceed, market details unavailable."); return

        # --- Gather necessary state variables ---
        state = self.state
        pos_side = state.status
        entry_price = state.entry_price
        initial_sl = state.stop_loss # This is the *current* SL target, which TSL updates
        original_tp = state.take_profit # Original TP target remains fixed
        qty = state.quantity
        current_tsl_price = state.current_trailing_sl_price # The SL price set by the last TSL update (if any)
        highest_seen = state.highest_price_since_entry
        lowest_seen = state.lowest_price_since_entry

        # Ensure essential data is present
        if None in [pos_side, entry_price, initial_sl, original_tp, qty, highest_seen if pos_side == 'long' else lowest_seen]:
            log_warning("[PositionManager] TSL Check: Skipping due to missing essential position data (side, entry, sl, tp, qty, or peak price)."); return

        # Use the currently active TSL price if it exists, otherwise use the initial SL
        effective_sl_price = current_tsl_price if current_tsl_price is not None else initial_sl
        log_debug(f"TSL Check ({pos_side}): Price={current_price:.{details.price_precision_digits}f}, Eff SL={effective_sl_price:.{details.price_precision_digits}f}, TP={original_tp:.{details.price_precision_digits}f}, ATR={current_atr:.{details.price_precision_digits}f}")

        # --- Update Peak Prices Since Entry ---
        peak_updated = False
        if pos_side == 'long' and current_price > highest_seen:
            state.highest_price_since_entry = current_price
            peak_updated = True
            log_debug(f"TSL: New highest price recorded for LONG: {current_price:.{details.price_precision_digits}f}")
        elif pos_side == 'short' and current_price < lowest_seen:
            state.lowest_price_since_entry = current_price
            peak_updated = True
            log_debug(f"TSL: New lowest price recorded for SHORT: {current_price:.{details.price_precision_digits}f}")

        # Save state ONLY if peak price was updated to reduce file I/O
        if peak_updated:
            self.save_state()

        # --- Check TSL Activation and Calculate Potential New SL ---
        tsl_activated = False
        potential_new_tsl: Optional[float] = None
        cfg_act_mult = self.config.trailing_stop_activation_atr_multiplier
        cfg_trail_mult = self.config.trailing_stop_atr_multiplier

        if pos_side == 'long':
            # Activation threshold: Price must move this much *above* entry
            activation_thresh = entry_price + (current_atr * cfg_act_mult)
            # Check if highest price seen has crossed the activation threshold
            if state.highest_price_since_entry > activation_thresh:
                tsl_activated = True
                # Calculate potential new SL based on highest price seen minus trail distance
                potential_new_tsl = state.highest_price_since_entry - (current_atr * cfg_trail_mult)
        else: # Short position
            # Activation threshold: Price must move this much *below* entry
            activation_thresh = entry_price - (current_atr * cfg_act_mult)
            # Check if lowest price seen has crossed the activation threshold
            if state.lowest_price_since_entry < activation_thresh:
                tsl_activated = True
                # Calculate potential new SL based on lowest price seen plus trail distance
                potential_new_tsl = state.lowest_price_since_entry + (current_atr * cfg_trail_mult)

        if not tsl_activated:
            log_debug("TSL activation threshold not met."); return
        if potential_new_tsl is None:
             log_warning("TSL activated but potential new SL calculation failed."); return

        # --- Validate Potential New TSL Price ---
        try:
            new_tsl_fmt = self.exchange_handler.format_price(self.config.symbol, potential_new_tsl)
        except Exception as fmt_e:
            log_error(f"TSL Update: Failed to format potential TSL price {potential_new_tsl}: {fmt_e}"); return

        # Conditions for updating the SL:
        # 1. The new SL must be 'better' than the effective current SL (higher for long, lower for short).
        # 2. The new SL must not cross the current price (SL below price for long, above price for short).
        # 3. The new SL must not cross the original TP (don't trail past the TP target).
        should_update = False
        if pos_side == 'long':
            if new_tsl_fmt > effective_sl_price and new_tsl_fmt < current_price and new_tsl_fmt < original_tp:
                should_update = True
        else: # Short
            if new_tsl_fmt < effective_sl_price and new_tsl_fmt > current_price and new_tsl_fmt > original_tp:
                should_update = True

        if not should_update:
             log_debug(f"TSL Update Check Failed: New SL ({new_tsl_fmt:.{details.price_precision_digits}f}) not improved vs Eff SL ({effective_sl_price:.{details.price_precision_digits}f}) / Price ({current_price:.{details.price_precision_digits}f}) / TP ({original_tp:.{details.price_precision_digits}f}).")
             return

        # --- Execute TSL Update (Cancel old protection, place new) ---
        log_info(f"{NEON_YELLOW}{Style.BRIGHT}*** TRAILING STOP UPDATE TRIGGERED ***{RESET}")
        log_info(f"  Moving SL from {effective_sl_price:.{details.price_precision_digits}f} to {new_tsl_fmt:.{details.price_precision_digits}f}")

        # 1. Cancel Existing Protection Orders
        ids_to_cancel = state.get_protection_order_ids()
        if not ids_to_cancel:
            # This is a critical situation: TSL triggered, but no orders to modify. State might be corrupt.
            log_error("TSL CRITICAL: Update triggered, but no existing protection order IDs found in state! Aborting TSL update. Position might be unprotected.")
            # Consider emergency action?
            # self.attempt_emergency_close()
            return

        log_info(f"TSL: Cancelling existing protection order(s): {ids_to_cancel}")
        all_cancelled_successfully = True
        for order_id in ids_to_cancel:
            if not self.exchange_handler.cancel_order(order_id, self.config.symbol):
                # If cancellation fails, it could be due to network issues, or the order might have already filled.
                # It's risky to proceed if we can't confirm cancellation.
                log_error(f"TSL CRITICAL: Failed to cancel existing protection order {order_id}. Aborting TSL update to avoid duplicate orders or unprotected position.")
                all_cancelled_successfully = False
                break # Stop cancellation attempts
        if not all_cancelled_successfully:
             return # Do not proceed if cancellation failed

        log_info("TSL: Existing protection order(s) cancelled successfully or confirmed closed.")
        # Clear old IDs from state immediately after successful cancellation
        state.sl_order_id = state.tp_order_id = state.oco_order_id = None
        # Save state temporarily reflecting no protection? Maybe wait until new ones placed.

        # 2. Place New Protection Orders with Updated SL and Original TP
        log_info(f"TSL: Placing new protection orders: SL @ {new_tsl_fmt:.{details.price_precision_digits}f}, Original TP @ {original_tp:.{details.price_precision_digits}f}")
        new_sl_id, new_tp_id, new_oco_id = self.exchange_handler.place_protection_orders(
            symbol=self.config.symbol, pos_side=pos_side, qty=qty,
            sl_pr=new_tsl_fmt, # Use the newly calculated and formatted TSL price
            tp_pr=original_tp  # Use the original take profit price
        )

        # 3. Update State based on New Protection Order Placement Outcome
        # Check if at least the new SL order was placed successfully (either via OCO or separate SL)
        protection_placed = bool(new_oco_id or new_sl_id)

        if protection_placed:
            log_info(f"{NEON_GREEN}TSL Update Successful: New protection order(s) placed.{RESET}")
            if new_oco_id: log_info(f"  New OCO Ref ID: {new_oco_id}")
            if new_sl_id: log_info(f"  New Separate SL ID: {new_sl_id}")
            if new_tp_id: log_info(f"  New Separate TP ID: {new_tp_id}") # May be None if OCO used

            # Update state with the new order IDs and the activated TSL price
            state.sl_order_id = new_sl_id
            state.tp_order_id = new_tp_id
            state.oco_order_id = new_oco_id
            state.stop_loss = new_tsl_fmt  # Update the main stop_loss field to the new TSL price
            state.current_trailing_sl_price = new_tsl_fmt # Mark that TSL is now active at this price
            self.save_state() # Save the updated state
            self.display_status() # Show the new status

            # Warn if only partial protection was placed (e.g., SL ok, TP failed in separate mode)
            if not new_oco_id and new_sl_id and not new_tp_id:
                 log_warning("TSL Update Warning: New SL placed, but placing separate TP failed. Position protected by SL only.")
        else:
            # --- CRITICAL FAILURE SCENARIO ---
            log_error(f"!!! TSL CRITICAL FAILURE !!!")
            log_error(f"  Old protection orders were cancelled, but FAILED to place new protection orders.")
            log_error(f"  POSITION '{pos_side.upper()}' (Qty: {qty}) IS CURRENTLY UNPROTECTED.")
            # State already reflects no protection IDs because they were cleared after cancellation.
            # Update the target SL for reference, but clear active TSL marker.
            state.stop_loss = new_tsl_fmt
            state.current_trailing_sl_price = None # TSL attempt failed
            self.save_state() # Save the state reflecting the failure and lack of protection
            log_error("State saved reflecting unprotected status. MANUAL INTERVENTION REQUIRED IMMEDIATELY.")
            # Consider automatically attempting an emergency market close here as a safety measure
            # self.attempt_emergency_close()


    def calculate_position_size(self, entry_price: float, stop_loss_price: float) -> Optional[float]:
        """
        Calculates the position size based on risk percentage, available balance,
        entry price, stop loss price, and exchange limits.
        Returns the calculated quantity (in base currency) or None if calculation fails.
        """
        details = self.exchange_handler.get_market_details(self.config.symbol)
        if not details: log_error("Cannot calculate position size, market details unavailable."); return None

        # --- Validate Inputs ---
        if not (0 < self.config.risk_percentage < 1):
            log_error(f"Invalid risk percentage configured: {self.config.risk_percentage}. Must be between 0 and 1."); return None
        if entry_price <= 0 or stop_loss_price <= 0:
            log_error(f"Invalid entry ({entry_price}) or SL ({stop_loss_price}) price for size calculation."); return None
        price_diff = abs(entry_price - stop_loss_price)
        if price_diff < details.min_tick: # Ensure difference is at least one tick size
            log_error(f"Stop loss ({stop_loss_price}) is too close to entry price ({entry_price}). Difference ({price_diff}) < min tick ({details.min_tick})."); return None

        log_debug(f"Calculating position size: Entry={entry_price:.{details.price_precision_digits}f}, SL={stop_loss_price:.{details.price_precision_digits}f}, Risk={self.config.risk_percentage*100:.2f}%")

        try:
            # --- Get Available Balance ---
            balance_info = self.exchange_handler.fetch_balance() # Already decorated
            if not balance_info: log_error("Failed to fetch balance for size calculation."); return None

            quote_curr = details.quote_currency
            available_balance = 0.0
            source_info = "N/A" # For logging where balance came from

            if quote_curr:
                # Try common ways to access free quote balance
                if quote_curr in balance_info and isinstance(balance_info[quote_curr], dict) and 'free' in balance_info[quote_curr]:
                    available_balance = float(balance_info[quote_curr].get('free', 0.0))
                    source_info = f"['{quote_curr}']['free']"
                # Fallback: Check top-level 'free' dictionary (some exchanges structure it this way)
                elif 'free' in balance_info and isinstance(balance_info['free'], dict) and quote_curr in balance_info['free']:
                    available_balance = float(balance_info['free'].get(quote_curr, 0.0))
                    source_info = f"['free']['{quote_curr}']"
                # Fallback: Use 'total' balance if 'free' is zero or unavailable (less safe, might include locked funds)
                elif quote_curr in balance_info and isinstance(balance_info[quote_curr], dict) and 'total' in balance_info[quote_curr] and available_balance <= 0:
                     available_balance = float(balance_info[quote_curr].get('total', 0.0))
                     source_info = f"['{quote_curr}']['total'] (used as fallback)"
                     if available_balance > 0: log_warning(f"Using 'total' balance ({available_balance}) as 'free' was zero or unavailable. Ensure sufficient free funds exist.")
                # Add more specific exchange structures if needed
                # elif self.config.exchange_id == 'some_exchange' and ... :

            if available_balance <= 0:
                log_error(f"Insufficient available balance ({available_balance}) found for quote currency '{quote_curr}'. Source check: {source_info}. Cannot calculate position size."); return None
            log_info(f"Available balance ({quote_curr}): {available_balance:.{details.price_precision_digits}f} (Source: {source_info})")

            # --- Calculate Quantity ---
            risk_amount_quote = available_balance * self.config.risk_percentage
            # Quantity = (Amount to Risk in Quote) / (Distance per unit in Quote)
            quantity_raw = risk_amount_quote / price_diff
            # Format the raw quantity according to exchange rules (precision)
            quantity_adj = self.exchange_handler.format_amount(self.config.symbol, quantity_raw)

            if quantity_adj <= 0:
                 log_error(f"Calculated quantity ({quantity_raw=}, {quantity_adj=}) is zero or less after formatting. Risk amount or price difference might be too small."); return None

            # --- Check Exchange Limits ---
            # 1. Minimum Amount Limit (Base Currency)
            if details.min_amount is not None and quantity_adj < details.min_amount:
                log_error(f"Calculated quantity {quantity_adj:.{details.amount_precision_digits}f} {details.base_currency} is below the exchange minimum amount limit of {details.min_amount}."); return None
            # 2. Minimum Cost Limit (Quote Currency)
            estimated_cost = quantity_adj * entry_price
            if details.min_cost is not None and estimated_cost < details.min_cost:
                log_error(f"Estimated order cost {estimated_cost:.{details.price_precision_digits}f} {quote_curr} is below the exchange minimum cost limit of {details.min_cost}."); return None
            # 3. Check if estimated cost exceeds available balance (with a small buffer)
            # Use a slightly lower multiplier for safety (e.g., 0.99 for 1% buffer)
            if estimated_cost > available_balance * 0.99:
                log_error(f"Estimated order cost {estimated_cost:.{details.price_precision_digits}f} {quote_curr} exceeds 99% of available balance ({available_balance:.{details.price_precision_digits}f}). Reduce risk % or add funds."); return None

            log_info(f"{NEON_GREEN}Calculated position size: {quantity_adj:.{details.amount_precision_digits}f} {details.base_currency}{RESET} (Cost: ~{estimated_cost:.{details.price_precision_digits}f} {quote_curr})")
            return quantity_adj

        except ccxt.AuthenticationError as e:
             log_error(f"Authentication error during balance fetch for size calculation: {e}"); return None
        except Exception as e:
             # Catch formatting errors or other unexpected issues
             if not isinstance(e, RETRYABLE_EXCEPTIONS): # Avoid logging retry noise
                  log_error(f"[PositionManager] Unexpected error calculating position size: {e}", exc_info=True)
             return None

    def attempt_emergency_close(self):
        """
        Attempts to close the currently active position with a market order.
        This is a safety measure called when the bot enters an unexpected or unprotected state.
        """
        if not self.state.is_active():
            log_info("[PositionManager] No active position found for emergency close.")
            return
        if self.config.simulation_mode:
            log_warning("SIMULATION: Emergency close requested, but skipped in simulation mode.")
            # Decide if state should be reset even in simulation upon emergency close request
            # self.reset_state("Simulated Emergency Close Triggered")
            return

        log_warning(f"!!! {NEON_RED}ATTEMPTING EMERGENCY MARKET CLOSE{RESET} for {self.state.status.upper()} position (Qty: {self.state.quantity}) !!!")
        close_side = 'sell' if self.state.status == 'long' else 'buy'
        qty_to_close = self.state.quantity

        if qty_to_close is None or qty_to_close <= 0:
             log_error("Emergency close failed: Invalid or zero quantity found in state.")
             # State might be corrupt, attempt reset anyway?
             self.reset_state("Emergency close attempted but quantity invalid")
             return

        # --- Best Effort: Cancel Existing Protection Orders First ---
        # Avoids potential conflicts if protection orders are somehow still active
        ids_to_cancel = self.state.get_protection_order_ids()
        if ids_to_cancel:
            log_warning(f"Emergency Close: Attempting to cancel existing protection orders first: {ids_to_cancel}")
            for oid in ids_to_cancel:
                # Use cancel_order directly (handles logging and simulation check internally)
                self.exchange_handler.cancel_order(oid, self.config.symbol)
                time.sleep(0.2) # Small delay between cancellations

        # --- Place the Market Close Order ---
        log_warning(f"Emergency Close: Placing {close_side.upper()} market order for {qty_to_close} {self.config.symbol} (Reduce-Only).")
        # Use reduce_only=True to ensure it only closes the position
        emergency_order = self.exchange_handler.place_market_order(
            symbol=self.config.symbol,
            side=close_side,
            amount=qty_to_close,
            reduce_only=True
        )

        # --- Process Outcome ---
        if emergency_order and emergency_order.get('id'):
             # Order was placed (might still be filling or fail later, but request sent)
             o_id = emergency_order['id']
             o_status = emergency_order.get('status', 'N/A')
             log_warning(f"Emergency market close order placed (ID: {o_id}). Status: {o_status}. Position *should* be closing.")
             # Reset the local state AFTER successfully placing the close order
             # Assume the market order will close the position.
             self.reset_state(f"Emergency Market Close order placed (ID: {o_id})")
        else:
             # Failed to even place the emergency close order
             log_error(f"!!! {NEON_RED}EMERGENCY CLOSE ORDER FAILED TO PLACE{RESET} !!!")
             log_error(f"  Position {self.state.status.upper()} (Qty: {qty_to_close}) remains active.")
             log_error(f"  MANUAL INTERVENTION REQUIRED IMMEDIATELY ON THE EXCHANGE.")
             # Do NOT reset state if the close order failed. The position is still live.


# --- Technical Analysis Functions ---
def calculate_technical_indicators(df: Optional[pd.DataFrame], config: Config) -> Optional[pd.DataFrame]:
    """
    Calculates technical indicators based on the configuration and appends them to the DataFrame.
    Returns the DataFrame with indicators, or None if input is invalid or calculation fails.
    """
    if df is None or df.empty:
        log_warning("Cannot calculate indicators: Input DataFrame is None or empty.")
        return None

    # Check for required base columns
    required_cols = ['high', 'low', 'close']
    # Add 'volume' if needed for Volume MA or OB analysis (implicitly needed)
    if config.entry_volume_confirmation_enabled or config.ob_volume_threshold_multiplier > 0:
        required_cols.append('volume')
    missing_cols = [col for col in required_cols if col not in df.columns]
    if missing_cols:
        log_error(f"Cannot calculate indicators: Input DataFrame is missing required columns: {missing_cols}")
        return None
    # Check if required columns have numeric data
    for col in required_cols:
        if not pd.api.types.is_numeric_dtype(df[col]):
             log_error(f"Required column '{col}' is not numeric. Cannot calculate indicators.")
             # Attempt conversion or return None? Safer to return None.
             # df[col] = pd.to_numeric(df[col], errors='coerce') # Risky if unexpected non-numeric data
             return None

    log_debug("Calculating technical indicators...")
    try:
        # Use a copy to avoid modifying the original DataFrame passed to the function
        df_ind = df.copy()
        added_cols = [] # Keep track of columns added by pandas_ta

        # --- Calculate Indicators using pandas_ta ---
        # RSI
        df_ind.ta.rsi(length=config.rsi_length, append=True, col_names=(config.rsi_col_name,))
        added_cols.append(config.rsi_col_name)

        # Stochastic (%K, %D)
        df_ind.ta.stoch(k=config.stoch_k, d=config.stoch_d, smooth_k=config.stoch_smooth_k, append=True,
                       col_names=(config.stoch_k_col_name, config.stoch_d_col_name))
        added_cols.extend([config.stoch_k_col_name, config.stoch_d_col_name])

        # ATR (Conditionally calculated if needed)
        if config.needs_atr and config.atr_col_name:
            df_ind.ta.atr(length=config.atr_length, append=True, col_names=(config.atr_col_name,))
            added_cols.append(config.atr_col_name)

        # Volume Moving Average (Conditionally calculated)
        if config.entry_volume_confirmation_enabled and config.vol_ma_col_name and 'volume' in df_ind.columns:
            # Ensure sufficient non-NaN periods for a meaningful average
            min_periods_vol = max(1, config.entry_volume_ma_length // 2)
            df_ind[config.vol_ma_col_name] = df_ind['volume'].rolling(window=config.entry_volume_ma_length, min_periods=min_periods_vol).mean()
            added_cols.append(config.vol_ma_col_name)
        elif config.entry_volume_confirmation_enabled:
            log_warning("Volume MA requested in config, but 'volume' column missing or Volume MA name invalid.")

        # --- Post-Calculation Processing ---
        # Drop rows with NaN values introduced by indicator calculations (especially at the start)
        valid_added_cols = [col for col in added_cols if col in df_ind.columns]
        if valid_added_cols:
            initial_rows = len(df_ind)
            # Drop rows where ANY of the newly added indicator columns are NaN
            df_ind.dropna(subset=valid_added_cols, inplace=True)
            rows_dropped = initial_rows - len(df_ind)
            if rows_dropped > 0:
                log_debug(f"Dropped {rows_dropped} rows due to NaN values in indicators ({valid_added_cols}).")
        else:
            # This case should not happen if indicators were calculated, but handles edge cases
            log_warning("No valid indicator columns seem to have been generated or appended.")
            # Return original df? Or None? Return None as calculation likely failed.
            return None

        if df_ind.empty:
            log_warning("DataFrame became empty after calculating indicators and dropping NaNs. Check data limit and indicator lengths.")
            return None

        log_debug(f"Indicator calculation complete. Resulting DataFrame rows: {len(df_ind)}")
        return df_ind

    except Exception as e:
        log_error(f"Error occurred during technical indicator calculation: {e}", exc_info=True)
        return None # Return None on any calculation error


def identify_potential_order_block(df: pd.DataFrame, config: Config, market_details: MarketDetails) -> Tuple[Optional[Dict[str, Any]], Optional[Dict[str, Any]]]:
    """
    Identifies the most recent potential bullish and bearish order blocks based on
    a down/up candle followed by a high-volume imbalance candle that sweeps liquidity.
    Returns (bullish_ob, bearish_ob), where each OB is a dict or None.
    """
    bullish_ob: Optional[Dict[str, Any]] = None
    bearish_ob: Optional[Dict[str, Any]] = None
    required_cols = ['open', 'high', 'low', 'close', 'volume']
    price_prec = market_details.price_precision_digits

    # --- Input Validation ---
    if df is None or df.empty:
        log_debug("OB Detection: Input DataFrame is None or empty."); return None, None
    if not all(c in df.columns for c in required_cols):
        log_debug(f"OB Detection: Missing required columns: {[c for c in required_cols if c not in df.columns]}"); return None, None
    # Need at least 2 candles to compare, plus lookback for volume average
    if len(df) < max(2, config.ob_lookback):
        log_debug(f"OB Detection: Not enough data ({len(df)} rows) for analysis (need at least {max(2, config.ob_lookback)})."); return None, None

    try:
        # --- Calculate Volume Threshold ---
        # Use data excluding the latest (potentially incomplete) candle for volume average
        df_completed = df.iloc[:-1]
        avg_volume = 0.0
        # Ensure enough data for a meaningful rolling average
        min_vol_periods = max(1, config.ob_lookback // 2)
        if len(df_completed) >= min_vol_periods:
             # Calculate rolling average volume over the lookback period
             rolling_volume = df_completed['volume'].rolling(window=config.ob_lookback, min_periods=min_vol_periods).mean()
             # Take the most recent calculated average (from the second to last candle)
             if not rolling_volume.empty and pd.notna(rolling_volume.iloc[-1]):
                 avg_volume = rolling_volume.iloc[-1]

        # Fallback to simple mean if rolling average failed (e.g., too many NaNs)
        if avg_volume <= 0 and len(df_completed) > 0 and pd.notna(df_completed['volume'].mean()):
             avg_volume = df_completed['volume'].mean()
             log_debug("OB Detection: Using simple average volume as rolling average failed.")

        # Define the volume threshold for the imbalance candle
        volume_threshold = avg_volume * config.ob_volume_threshold_multiplier if avg_volume > 0 else float('inf') # Avoid threshold if avg vol is 0
        log_debug(f"OB Analysis | Lookback={config.ob_lookback}, AvgVol={avg_volume:.2f}, Volume Threshold={volume_threshold:.2f}")

        # --- Search for OB Pattern ---
        # Search backwards from the second to last candle (index -2)
        # Limit search depth to avoid excessive computation on large dataframes
        search_depth = min(len(df) - 2, config.ob_lookback * 3) # Look back up to 3x lookback period
        search_start_index = len(df) - 2 # Index of the potential 'imbalance' candle
        search_end_index = max(0, search_start_index - search_depth) # Oldest index to check

        # Iterate backwards through potential imbalance candles
        for i in range(search_start_index, search_end_index -1, -1):
            if i < 1: break # Need at least one preceding candle (index i-1) for the OB

            try:
                # Candle 'i' is the potential imbalance/breakout candle
                imbalance_candle = df.iloc[i]
                # Candle 'i-1' is the potential Order Block candle
                ob_candidate_candle = df.iloc[i-1]
            except IndexError:
                log_warning(f"OB Detection: IndexError accessing candles at index {i} or {i-1}. Skipping.")
                continue # Should not happen with loop bounds, but safety check

            # Skip if essential data is missing in either candle
            if imbalance_candle.isnull().any(axis=None) or ob_candidate_candle.isnull().any(axis=None):
                 continue

            # --- Define Conditions ---
            # Imbalance candle conditions
            is_high_volume_imb = imbalance_candle['volume'] > volume_threshold
            # Bullish imbalance: Strong close breaking above the OB candidate's high
            is_bullish_imb = imbalance_candle['close'] > imbalance_candle['open'] and imbalance_candle['close'] > ob_candidate_candle['high']
            # Bearish imbalance: Strong close breaking below the OB candidate's low
            is_bearish_imb = imbalance_candle['close'] < imbalance_candle['open'] and imbalance_candle['close'] < ob_candidate_candle['low']

            # OB candidate candle conditions
            ob_is_down_candle = ob_candidate_candle['close'] < ob_candidate_candle['open'] # Bearish candle (potential Bullish OB)
            ob_is_up_candle = ob_candidate_candle['close'] > ob_candidate_candle['open'] # Bullish candle (potential Bearish OB)

            # Liquidity sweep conditions (imbalance candle sweeps the low/high of the OB candle)
            imb_sweeps_ob_low = imbalance_candle['low'] < ob_candidate_candle['low']
            imb_sweeps_ob_high = imbalance_candle['high'] > ob_candidate_candle['high']

            # --- Identify Blocks ---
            # Potential Bullish OB: Down candle (i-1) followed by high-volume bullish imbalance (i) that sweeps the low of (i-1).
            if not bullish_ob and ob_is_down_candle and is_bullish_imb and is_high_volume_imb and imb_sweeps_ob_low:
                bullish_ob = {
                    'high': ob_candidate_candle['high'],
                    'low': ob_candidate_candle['low'],
                    'time': ob_candidate_candle.name, # Timestamp of the OB candle
                    'type': 'bullish'
                }
                log_debug(f"Potential Bullish OB identified @ {bullish_ob['time'].strftime('%Y-%m-%d %H:%M')}: Low={bullish_ob['low']:.{price_prec}f}, High={bullish_ob['high']:.{price_prec}f}")
                # If we found both types, stop searching further back
                if bearish_ob: break

            # Potential Bearish OB: Up candle (i-1) followed by high-volume bearish imbalance (i) that sweeps the high of (i-1).
            elif not bearish_ob and ob_is_up_candle and is_bearish_imb and is_high_volume_imb and imb_sweeps_ob_high:
                 bearish_ob = {
                     'high': ob_candidate_candle['high'],
                     'low': ob_candidate_candle['low'],
                     'time': ob_candidate_candle.name, # Timestamp of the OB candle
                     'type': 'bearish'
                 }
                 log_debug(f"Potential Bearish OB identified @ {bearish_ob['time'].strftime('%Y-%m-%d %H:%M')}: Low={bearish_ob['low']:.{price_prec}f}, High={bearish_ob['high']:.{price_prec}f}")
                 # If we found both types, stop searching
                 if bullish_ob: break

        # Return the most recently found blocks (or None if none found)
        return bullish_ob, bearish_ob
    except Exception as e:
        log_error(f"Error identifying order blocks: {e}", exc_info=True)
        return None, None # Return None on error

# --- Display Helper Functions ---
def display_market_stats(current_price: float, rsi: float, stoch_k: float, stoch_d: float, atr: Optional[float], details: MarketDetails) -> None:
    """Displays key market indicators with formatting."""
    price_prec = details.price_precision_digits
    atr_prec = details.price_precision_digits # Usually same as price, adjust if needed
    print(f"{NEON_PINK}--- Market Stats ---{RESET}")
    print(f"{NEON_GREEN}Price:{RESET}  {current_price:.{price_prec}f}")
    print(f"{NEON_CYAN}RSI:{RESET}    {rsi:.2f}")
    print(f"{NEON_YELLOW}StochK:{RESET} {stoch_k:.2f}")
    print(f"{NEON_YELLOW}StochD:{RESET} {stoch_d:.2f}")
    if atr is not None:
        print(f"{NEON_BLUE}ATR:{RESET}    {atr:.{atr_prec}f}")
    else:
         print(f"{NEON_BLUE}ATR:{RESET}    N/A")
    print(f"{NEON_PINK}--------------------{RESET}")

def display_order_blocks(bullish_ob: Optional[Dict[str, Any]], bearish_ob: Optional[Dict[str, Any]], details: MarketDetails) -> None:
    """Displays identified potential order blocks."""
    price_prec = details.price_precision_digits
    found_any = False
    print(f"{NEON_PINK}--- Order Blocks ---{RESET}")
    if bullish_ob and isinstance(bullish_ob.get('time'), pd.Timestamp):
        print(f"{NEON_GREEN}Bullish OB:{RESET} {bullish_ob['time'].strftime('%H:%M')} | Range: {bullish_ob['low']:.{price_prec}f} - {bullish_ob['high']:.{price_prec}f}")
        found_any = True
    if bearish_ob and isinstance(bearish_ob.get('time'), pd.Timestamp):
        print(f"{NEON_RED}Bearish OB:{RESET} {bearish_ob['time'].strftime('%H:%M')} | Range: {bearish_ob['low']:.{price_prec}f} - {bearish_ob['high']:.{price_prec}f}")
        found_any = True
    if not found_any:
        print(f"{NEON_BLUE}Order Blocks: None detected in recent search range.{RESET}")
    print(f"{NEON_PINK}--------------------{RESET}")

def display_signal(signal_type: str, direction: str, reason: str) -> None:
    """Displays an entry or exit signal."""
    color = NEON_GREEN if direction.lower() == 'long' else NEON_RED if direction.lower() == 'short' else NEON_YELLOW
    print(f"\n{color}{Style.BRIGHT}*** {signal_type.upper()} {direction.upper()} SIGNAL DETECTED ***{RESET}")
    print(f"   Reason: {reason}\n")
    # Log the signal as well
    logger.info(f"SIGNAL: Type={signal_type.upper()}, Direction={direction.upper()}, Reason={reason}")

# --- Trading Bot Class ---
class TradingBot:
    """
    The main trading bot class orchestrating the fetch-analyze-execute loop.
    It integrates configuration, exchange interaction, and position management.
    """

    def __init__(self):
        """Initializes the bot, loads config, connects to exchange, loads position state."""
        print_neon_header()
        log_info("Initializing Trading Bot...")
        try:
            self.config = load_and_validate_config()
            self.exchange_handler = ExchangeHandler(self.config)
            self.position_manager = PositionManager(self.config, self.exchange_handler)
            self._validate_live_mode() # Ask for confirmation if running in live mode
            log_info("Trading Bot Initialization Complete.")
        except (SystemExit, Exception) as e:
             log_error(f"FATAL ERROR during bot initialization: {e}", exc_info=True)
             # Ensure logging is flushed before exiting if possible
             logging.shutdown()
             # Re-raise SystemExit or exit explicitly
             if isinstance(e, SystemExit): raise
             else: sys.exit(1)

    def _validate_live_mode(self):
        """Checks if simulation_mode is False and prompts for confirmation if running interactively."""
        if self.config.simulation_mode:
            log_warning("###########################")
            log_warning("# SIMULATION MODE ACTIVE  #")
            log_warning("###########################")
            log_info("No real trades will be executed.")
        else:
            log_warning("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
            log_warning("!!!               LIVE MODE ACTIVE           !!!")
            log_warning("!!! REAL TRADES WILL BE EXECUTED WITH REAL FUNDS !!!")
            log_warning("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
            try:
                # Check if running in an interactive terminal
                if sys.stdin.isatty():
                    confirm = input(f"{NEON_RED}{Style.BRIGHT}>>> Type 'LIVE' to confirm live trading, or press Enter/Ctrl+C to exit: {RESET}").strip().upper()
                    if confirm != "LIVE":
                        log_info("Live trading not confirmed by user. Exiting.")
                        sys.exit(0)
                    log_info("Live trading confirmed by user. Proceeding with caution.")
                else:
                    # Not interactive (e.g., running as a service, background process)
                    log_warning("Running in non-interactive mode (e.g., Docker, systemd).")
                    log_warning("Assuming live mode confirmation. Pausing for 5 seconds...")
                    time.sleep(5) # Give a moment to cancel if needed
                    log_info("Proceeding with live trading.")
            except EOFError: # Raised if input stream is closed (e.g., piped input)
                log_error("Cannot get user confirmation in this environment (EOFError). Exiting for safety.")
                sys.exit(1)
            except KeyboardInterrupt:
                 log_info("Shutdown requested during live mode confirmation. Exiting.")
                 sys.exit(0)

    def _log_config_summary(self):
        """Logs a summary of the key trading configuration parameters."""
        cfg = self.config
        details = self.exchange_handler.get_market_details(cfg.symbol)
        if not details: log_warning("Cannot log full config summary, market details unavailable."); return

        summary = ["-" * 70, "Trading Configuration Summary:"]
        summary.append(f"  Exchange: {self.exchange_handler.name}, Symbol: {cfg.symbol}, Timeframe: {cfg.timeframe}")
        summary.append(f"  Market Type: {'Contract' if details.is_contract_market else 'Spot'}")
        summary.append(f"  Risk Per Trade: {cfg.risk_percentage*100:.2f}%")
        summary.append(f"  Simulation Mode: {cfg.simulation_mode}")
        summary.append(f"  Cycle Interval: {cfg.sleep_interval_seconds}s, Data Limit: {cfg.data_limit}")
        summary.append(f"  SL/TP Mode: {'ATR Based' if cfg.enable_atr_sl_tp else 'Fixed Percentage'}")
        if cfg.enable_atr_sl_tp:
            summary.append(f"    ATR SL Multiplier: {cfg.atr_sl_multiplier}x, ATR TP Multiplier: {cfg.atr_tp_multiplier}x (ATR Length: {cfg.atr_length})")
        else:
            summary.append(f"    Fixed SL: {cfg.stop_loss_percentage*100:.2f}%, Fixed TP: {cfg.take_profit_percentage*100:.2f}%")
        summary.append(f"  Trailing Stop: {'Enabled' if cfg.enable_trailing_stop else 'Disabled'}")
        if cfg.enable_trailing_stop:
            summary.append(f"    TSL Activation ATR Multiplier: {cfg.trailing_stop_activation_atr_multiplier}x")
            summary.append(f"    TSL Trail ATR Multiplier: {cfg.trailing_stop_atr_multiplier}x")
        summary.append(f"  Order Block Vol Multiplier: {cfg.ob_volume_threshold_multiplier}x (Lookback: {cfg.ob_lookback})")
        summary.append(f"  Entry Volume Confirmation: {'Enabled' if cfg.entry_volume_confirmation_enabled else 'Disabled'}")
        if cfg.entry_volume_confirmation_enabled:
            summary.append(f"    Volume MA Length: {cfg.entry_volume_ma_length}, Volume Multiplier: {cfg.entry_volume_multiplier}x")
        summary.append(f"  API Retry Settings: Max Retries={cfg.retry_max_retries}, Initial Delay={cfg.retry_initial_delay}s, Backoff Factor={cfg.retry_backoff_factor}x")
        summary.append("-" * 70)

        for line in summary: log_info(line)


    def run(self):
        """Starts the main trading loop of the bot."""
        self._log_config_summary() # Log the config at the start
        if not self.config.simulation_mode:
            log_warning("LIVE TRADING IS ACTIVE. Monitor closely. Press Ctrl+C to stop gracefully.")
        else:
            log_info("SIMULATION MODE IS ACTIVE. Press Ctrl+C to stop.")

        while True:
            try:
                cycle_start_time = pd.Timestamp.now(tz='UTC')
                print_cycle_divider(cycle_start_time)

                # === 1. Check Position Consistency & Display Status ===
                # This checks if the locally stored state matches reality (orders/positions)
                # and resets the local state if closure is detected.
                position_was_reset = self.position_manager.check_position_and_orders()
                # Always display status after check (shows current state or 'None' if reset)
                self.position_manager.display_status()
                if position_was_reset:
                    log_info("Position state was reset based on exchange data. Ready for new signals.")
                    # Continue to the rest of the loop to fetch fresh data and check for entries

                # === 2. Fetch Fresh Market Data ===
                df_ohlcv = self.exchange_handler.fetch_ohlcv(
                    self.config.symbol, self.config.timeframe, self.config.data_limit
                )
                # Basic check for valid data
                if df_ohlcv is None or df_ohlcv.empty:
                    log_warning("Failed to fetch valid OHLCV data this cycle. Waiting for next cycle.")
                    self._wait_for_next_cycle(cycle_start_time)
                    continue # Skip the rest of the loop for this cycle

                # === 3. Calculate Technical Indicators ===
                df_indicators = calculate_technical_indicators(df_ohlcv, self.config)
                if df_indicators is None or df_indicators.empty:
                    log_warning("Indicator calculation failed or resulted in empty DataFrame. Waiting for next cycle.")
                    self._wait_for_next_cycle(cycle_start_time)
                    continue

                # === 4. Extract Latest Data & Market Details ===
                market_details = self.exchange_handler.get_market_details(self.config.symbol)
                if not market_details: # Should have been loaded on init, but critical if missing now
                    log_error("Market details unavailable. Cannot proceed this cycle.")
                    self._wait_for_next_cycle(cycle_start_time)
                    continue

                try:
                    # Get the most recent complete candle's data
                    latest_candle = df_indicators.iloc[-1]
                    latest_timestamp = latest_candle.name # Index is timestamp
                    current_price = float(latest_candle['close'])
                    current_high = float(latest_candle['high']) # Used for TSL peak tracking
                    current_low = float(latest_candle['low'])   # Used for TSL peak tracking
                    # Volume might not always be present or needed
                    current_volume = float(latest_candle['volume']) if 'volume' in latest_candle and pd.notna(latest_candle['volume']) else None

                    # Extract indicator values, handling potential KeyError if columns missing
                    latest_rsi = float(latest_candle[self.config.rsi_col_name])
                    latest_stoch_k = float(latest_candle[self.config.stoch_k_col_name])
                    latest_stoch_d = float(latest_candle[self.config.stoch_d_col_name])

                    # Extract ATR safely if needed
                    latest_atr: Optional[float] = None
                    if self.config.needs_atr and self.config.atr_col_name:
                        atr_val = latest_candle.get(self.config.atr_col_name)
                        if pd.notna(atr_val):
                            latest_atr = float(atr_val)
                            if latest_atr <= 0: # ATR should be positive
                                 log_warning(f"Calculated ATR is zero or negative ({latest_atr}). Treating as invalid.")
                                 latest_atr = None

                    # Extract Volume MA safely if needed
                    latest_vol_ma: Optional[float] = None
                    if self.config.entry_volume_confirmation_enabled and self.config.vol_ma_col_name:
                         vol_ma_val = latest_candle.get(self.config.vol_ma_col_name)
                         if pd.notna(vol_ma_val):
                              latest_vol_ma = float(vol_ma_val)

                    # Final check for NaN in essential extracted values
                    if any(math.isnan(v) for v in [current_price, latest_rsi, latest_stoch_k, latest_stoch_d]):
                        raise ValueError("NaN value detected in essential extracted data (Price, RSI, Stoch).")

                except (KeyError, ValueError, TypeError, IndexError) as e:
                     log_error(f"Error extracting latest data/indicators at {latest_timestamp}: {e}. Check config column names and indicator calculations.", exc_info=False)
                     self._wait_for_next_cycle(cycle_start_time); continue

                # Log warnings if optional-but-needed data is missing
                if self.config.needs_atr and latest_atr is None:
                    log_warning(f"ATR calculation required by config but result is missing or invalid at {latest_timestamp}.")
                if self.config.entry_volume_confirmation_enabled and (current_volume is None or latest_vol_ma is None):
                    log_debug(f"Volume confirmation enabled but current volume or MA is missing/invalid at {latest_timestamp}.")

                # Display current market stats
                display_market_stats(current_price, latest_rsi, latest_stoch_k, latest_stoch_d, latest_atr, market_details)

                # === 5. Identify Potential Order Blocks ===
                bullish_ob, bearish_ob = identify_potential_order_block(df_indicators, self.config, market_details)
                display_order_blocks(bullish_ob, bearish_ob, market_details)

                # === 6. Core Trading Logic Execution ===
                if self.position_manager.state.is_active():
                    # --- Monitor Active Position & Update Trailing Stop ---
                    log_info(f"Monitoring active {self.position_manager.state.status.upper()} position entered at {self.position_manager.state.entry_price:.{market_details.price_precision_digits}f}...")
                    # Pass the current price (close) and ATR to the TSL update function
                    self.position_manager.update_trailing_stop(current_price, latest_atr)
                    # Note: Position consistency check already happened at the start of the loop
                else:
                    # --- No Active Position: Check for New Entry Signals ---
                    log_info("No active position. Checking for new entry signals...")
                    self._check_and_execute_entry(
                        current_price=current_price,
                        latest_rsi=latest_rsi,
                        latest_stoch_k=latest_stoch_k,
                        latest_stoch_d=latest_stoch_d,
                        latest_atr=latest_atr,
                        current_volume=current_volume,
                        latest_vol_ma=latest_vol_ma,
                        bullish_ob=bullish_ob,
                        bearish_ob=bearish_ob,
                        market_details=market_details
                    )

                # === 7. Wait for Next Cycle ===
                self._wait_for_next_cycle(cycle_start_time)

            # --- Graceful Shutdown Handling ---
            except KeyboardInterrupt:
                log_info("Shutdown signal (Ctrl+C) received. Initiating graceful shutdown...")
                self.shutdown() # Call the shutdown routine
                break # Exit the main loop

            # --- Loop Error Handling ---
            # Handle specific retryable CCXT errors first
            except (ccxt.RateLimitExceeded, *RETRYABLE_EXCEPTIONS) as e:
                 # Log the error and wait longer, especially for rate limits
                 wait_time = self.config.sleep_interval_seconds + (60 if isinstance(e, ccxt.RateLimitExceeded) else 20)
                 log_error(f"Recoverable CCXT Error encountered: {type(e).__name__}: {e}. Waiting {wait_time}s before next cycle.", exc_info=False)
                 neon_sleep_timer(wait_time)
            # Handle critical authentication errors separately - usually requires intervention
            except ccxt.AuthenticationError as e:
                 log_error(f"!!! CRITICAL AUTHENTICATION ERROR: {e} !!!")
                 log_error("Check API Key/Secret/Passphrase. Bot will stop.")
                 self.shutdown(save_state=True) # Try to save state before stopping
                 break # Exit loop
            # Handle other non-retryable CCXT errors
            except ccxt.ExchangeError as e:
                 # Log these as errors but attempt to continue after a delay
                 log_error(f"Unhandled CCXT Exchange Error: {type(e).__name__}: {e}. Waiting...", exc_info=True)
                 neon_sleep_timer(self.config.sleep_interval_seconds + 30)
            # Catch any other unexpected exception
            except Exception as e:
                log_error(f"!!! CRITICAL UNEXPECTED LOOP ERROR: {type(e).__name__}: {e} !!!", exc_info=True)
                log_info("An unhandled error occurred in the main loop. Attempting to save state...")
                try:
                    # Best effort to save state before potentially crashing or waiting
                    self.position_manager.save_state()
                except Exception as save_err:
                    log_error(f"Failed to save state during critical error handling: {save_err}")
                # Wait for a longer period before potentially retrying the loop
                log_warning("Waiting 60 seconds before attempting to continue the loop...")
                neon_sleep_timer(60)

        log_info("Bot run loop has finished.")


    def _wait_for_next_cycle(self, cycle_start_time: pd.Timestamp):
        """Calculates the remaining time in the cycle and waits."""
        cycle_end_time = pd.Timestamp.now(tz='UTC')
        elapsed_seconds = (cycle_end_time - cycle_start_time).total_seconds()
        wait_time = max(0, self.config.sleep_interval_seconds - elapsed_seconds)

        log_info(f"Cycle execution time: {elapsed_seconds:.2f}s.")
        if wait_time > 0:
            log_info(f"Waiting {wait_time:.1f}s until the next cycle (Total interval: {self.config.sleep_interval_seconds}s).")
            neon_sleep_timer(int(round(wait_time)))
        else:
            # Log if the cycle took longer than the interval
            log_warning(f"Cycle took {elapsed_seconds:.2f}s, which is longer than the configured interval ({self.config.sleep_interval_seconds}s). Starting next cycle immediately.")


    def _check_and_execute_entry(self, current_price: float, latest_rsi: float,
                                latest_stoch_k: float, latest_stoch_d: float,
                                latest_atr: Optional[float], current_volume: Optional[float],
                                latest_vol_ma: Optional[float], bullish_ob: Optional[Dict],
                                bearish_ob: Optional[Dict], market_details: MarketDetails):
        """
        Checks all entry conditions (RSI, Stoch, OB, Volume) and executes
        the complete entry sequence (size calc, market order, protection orders, state update)
        if all conditions are met.
        """

        cfg = self.config
        price_prec = market_details.price_precision_digits
        amount_prec = market_details.amount_precision_digits

        # --- 1. Evaluate Volume Confirmation (if enabled) ---
        volume_confirmed = True # Default to True if not enabled
        if cfg.entry_volume_confirmation_enabled:
            if current_volume is not None and latest_vol_ma is not None and latest_vol_ma > 0:
                volume_confirmed = current_volume > (latest_vol_ma * cfg.entry_volume_multiplier)
                log_debug(f"Volume Check: Current Vol={current_volume:.2f}, Vol MA({cfg.entry_volume_ma_length})={latest_vol_ma:.2f}, Threshold Multiplier={cfg.entry_volume_multiplier} -> Confirmed={volume_confirmed}")
            else:
                # Fail confirmation if data is missing
                volume_confirmed = False
                log_debug(f"Volume Check: FAILED (Missing current volume or volume MA data)")

        # --- 2. Evaluate Base RSI/Stochastic Conditions ---
        base_long_signal = latest_rsi < cfg.rsi_oversold and latest_stoch_k < cfg.stoch_oversold and latest_stoch_d < cfg.stoch_oversold
        base_short_signal = latest_rsi > cfg.rsi_overbought and latest_stoch_k > cfg.stoch_overbought and latest_stoch_d > cfg.stoch_overbought

        # --- 3. Evaluate Order Block Confirmation ---
        ob_confirmed = False
        ob_reason = "N/A"
        entry_ob = None # Store the specific OB used for the entry

        # Check if price is currently within the zone of a relevant OB
        if base_long_signal and bullish_ob:
            # Check if current price is within the Bullish OB range (low <= price <= high)
            if bullish_ob['low'] <= current_price <= bullish_ob['high']:
                ob_confirmed = True
                entry_ob = bullish_ob
                ob_reason = f"Price ({current_price:.{price_prec}f}) within Bullish OB ({bullish_ob['low']:.{price_prec}f}-{bullish_ob['high']:.{price_prec}f} @ {bullish_ob['time'].strftime('%H:%M')})"
                log_debug(f"OB Confirmation: Bullish OB confirmed. {ob_reason}")
            else: log_debug(f"OB Confirmation: Price ({current_price:.{price_prec}f}) outside Bullish OB range.")
        elif base_short_signal and bearish_ob:
            # Check if current price is within the Bearish OB range (low <= price <= high)
            if bearish_ob['low'] <= current_price <= bearish_ob['high']:
                ob_confirmed = True
                entry_ob = bearish_ob
                ob_reason = f"Price ({current_price:.{price_prec}f}) within Bearish OB ({bearish_ob['low']:.{price_prec}f}-{bearish_ob['high']:.{price_prec}f} @ {bearish_ob['time'].strftime('%H:%M')})"
                log_debug(f"OB Confirmation: Bearish OB confirmed. {ob_reason}")
            else: log_debug(f"OB Confirmation: Price ({current_price:.{price_prec}f}) outside Bearish OB range.")
        else:
            # Log if base signal exists but no relevant OB found or price not in zone
            if base_long_signal or base_short_signal: log_debug("OB Confirmation: Base signal present but no confirming OB found or price not in zone.")


        # --- 4. Determine Final Entry Signal & Reason ---
        entry_side: Optional[str] = None
        entry_reason: str = ""

        if base_long_signal and ob_confirmed and volume_confirmed and entry_ob:
            entry_side = 'long'
            entry_reason = f"RSI({latest_rsi:.1f})<OS({cfg.rsi_oversold}), Stoch({latest_stoch_k:.1f},{latest_stoch_d:.1f})<OS({cfg.stoch_oversold}), {ob_reason}"
            if cfg.entry_volume_confirmation_enabled: entry_reason += ", Volume Confirmed"
        elif base_short_signal and ob_confirmed and volume_confirmed and entry_ob:
            entry_side = 'short'
            entry_reason = f"RSI({latest_rsi:.1f})>OB({cfg.rsi_overbought}), Stoch({latest_stoch_k:.1f},{latest_stoch_d:.1f})>OB({cfg.stoch_overbought}), {ob_reason}"
            if cfg.entry_volume_confirmation_enabled: entry_reason += ", Volume Confirmed"
        else:
            # Log why entry didn't happen if a base signal was present
            if base_long_signal or base_short_signal:
                reasons_blocked = []
                if not ob_confirmed: reasons_blocked.append("Order Block confirmation failed")
                if not volume_confirmed: reasons_blocked.append("Volume confirmation failed")
                log_info(f"Entry signal blocked for {'LONG' if base_long_signal else 'SHORT'}. Reason(s): {', '.join(reasons_blocked)}")
            else:
                 log_info("No base entry signal (RSI/Stoch) detected.")

        # --- 5. Execute Entry Sequence if Signal Found ---
        if not entry_side or not entry_ob:
             # log_info("Entry conditions not fully met.") # Already logged specifics above
             return # Exit if no valid entry signal

        display_signal("Entry", entry_side, entry_reason)

        # --- 5a. Calculate Initial SL/TP based on Config (ATR or Fixed %) ---
        initial_sl_price: Optional[float] = None
        initial_tp_price: Optional[float] = None

        if cfg.enable_atr_sl_tp:
            if latest_atr: # Ensure ATR is valid
                sl_distance = latest_atr * cfg.atr_sl_multiplier
                tp_distance = latest_atr * cfg.atr_tp_multiplier
                initial_sl_price = current_price - sl_distance if entry_side == 'long' else current_price + sl_distance
                initial_tp_price = current_price + tp_distance if entry_side == 'long' else current_price - tp_distance
            else:
                log_error("Cannot calculate ATR-based SL/TP: Invalid or missing ATR value. Aborting entry.")
                return # Cannot proceed without valid ATR
        else: # Fixed Percentage SL/TP
            sl_multiplier = 1.0 - cfg.stop_loss_percentage if entry_side == 'long' else 1.0 + cfg.stop_loss_percentage
            tp_multiplier = 1.0 + cfg.take_profit_percentage if entry_side == 'long' else 1.0 - cfg.take_profit_percentage
            initial_sl_price = current_price * sl_multiplier
            initial_tp_price = current_price * tp_multiplier

        # Check if calculation succeeded
        if initial_sl_price is None or initial_tp_price is None or initial_sl_price <= 0 or initial_tp_price <= 0:
            log_error(f"Failed to calculate valid initial SL ({initial_sl_price}) or TP ({initial_tp_price}). Aborting entry."); return
        log_info(f"Initial SL/TP Calculation: SL={initial_sl_price:.{price_prec}f}, TP={initial_tp_price:.{price_prec}f}")

        # --- 5b. Refine Stop Loss using Order Block ---
        # Place SL just beyond the low of a bullish OB or high of a bearish OB, if it provides more room than initial calc.
        sl_buffer_ticks = 5 # Number of ticks buffer beyond the OB edge
        sl_buffer = market_details.min_tick * sl_buffer_ticks
        refined_sl_price = initial_sl_price # Start with the initial calculation

        if entry_side == 'long' and entry_ob: # Bullish OB for long entry
            potential_sl = entry_ob['low'] - sl_buffer
            # Use the OB SL only if it's further away (lower) than the initial SL and still below entry price
            if potential_sl < initial_sl_price and potential_sl < current_price:
                refined_sl_price = potential_sl
                log_info(f"Refined SL using Bullish OB Low ({entry_ob['low']:.{price_prec}f}): New SL target = {refined_sl_price:.{price_prec}f}")
        elif entry_side == 'short' and entry_ob: # Bearish OB for short entry
            potential_sl = entry_ob['high'] + sl_buffer
            # Use the OB SL only if it's further away (higher) than the initial SL and still above entry price
            if potential_sl > initial_sl_price and potential_sl > current_price:
                refined_sl_price = potential_sl
                log_info(f"Refined SL using Bearish OB High ({entry_ob['high']:.{price_prec}f}): New SL target = {refined_sl_price:.{price_prec}f}")

        final_sl_target = refined_sl_price
        final_tp_target = initial_tp_price # Keep initial TP target

        # --- 5c. Format and Validate Final SL/TP ---
        try:
            final_sl_fmt = self.exchange_handler.format_price(cfg.symbol, final_sl_target)
            final_tp_fmt = self.exchange_handler.format_price(cfg.symbol, final_tp_target)

            # Final sanity check on SL/TP logic relative to current price
            if entry_side == 'long':
                if final_sl_fmt >= current_price: raise ValueError(f"Final SL ({final_sl_fmt}) is not below current price ({current_price}) for LONG.")
                if final_tp_fmt <= current_price: raise ValueError(f"Final TP ({final_tp_fmt}) is not above current price ({current_price}) for LONG.")
                if final_sl_fmt >= final_tp_fmt: raise ValueError(f"Final SL ({final_sl_fmt}) is not below Final TP ({final_tp_fmt}) for LONG.")
            else: # Short
                if final_sl_fmt <= current_price: raise ValueError(f"Final SL ({final_sl_fmt}) is not above current price ({current_price}) for SHORT.")
                if final_tp_fmt >= current_price: raise ValueError(f"Final TP ({final_tp_fmt}) is not below current price ({current_price}) for SHORT.")
                if final_sl_fmt <= final_tp_fmt: raise ValueError(f"Final SL ({final_sl_fmt}) is not above Final TP ({final_tp_fmt}) for SHORT.")

        except Exception as e:
            log_error(f"Final SL/TP formatting or validation failed: {e}. Aborting entry.")
            return
        log_info(f"Final Target Prices after formatting: SL={final_sl_fmt:.{price_prec}f}, TP={final_tp_fmt:.{price_prec}f}")

        # --- 5d. Calculate Position Size ---
        entry_quantity = self.position_manager.calculate_position_size(current_price, final_sl_fmt)
        if entry_quantity is None or entry_quantity <= 0:
            log_error("Position size calculation failed or resulted in zero/negative quantity. Aborting entry."); return

        # --- 5e. Place Entry Market Order ---
        market_order_side = 'buy' if entry_side == 'long' else 'sell'
        # Ensure reduce_only is False for entry orders
        entry_market_order = self.exchange_handler.place_market_order(
            symbol=cfg.symbol,
            side=market_order_side,
            amount=entry_quantity,
            reduce_only=False
        )

        # --- 5f. Process Entry Order Result & Place Protection ---
        if entry_market_order and entry_market_order.get('id'):
            entry_order_id = entry_market_order['id']
            entry_status = entry_market_order.get('status', 'N/A')
            # Use 'average' price if available (more accurate for filled market orders), fallback to 'price' or current_price
            actual_entry_price = entry_market_order.get('average')
            if actual_entry_price is None or actual_entry_price <= 0:
                actual_entry_price = entry_market_order.get('price', current_price) # Fallback
            try: actual_entry_price = float(actual_entry_price)
            except ValueError: actual_entry_price = current_price # Final fallback

            # Use 'filled' amount if available, fallback to intended quantity
            actual_filled_quantity = entry_market_order.get('filled')
            if actual_filled_quantity is None or actual_filled_quantity <= 0:
                actual_filled_quantity = entry_quantity # Fallback
            try: actual_filled_quantity = float(actual_filled_quantity)
            except ValueError: actual_filled_quantity = entry_quantity # Final fallback

            log_info(f"Entry market order ({entry_order_id}) placed/processed. Status: {entry_status}.")
            log_info(f"  Actual Entry Price: ~{actual_entry_price:.{price_prec}f}, Filled Quantity: {actual_filled_quantity:.{amount_prec}f}")

            # If market order failed immediately (e.g., rejected), handle it
            if entry_status in ['rejected', 'expired', 'canceled']:
                 log_error(f"Entry market order {entry_order_id} failed with status: {entry_status}. No position taken."); return

            # --- Place SL/TP Protection Orders ---
            # Use the actual filled quantity and final formatted SL/TP prices
            log_info("Placing protection orders (SL/TP)...")
            sl_id, tp_id, oco_id = self.exchange_handler.place_protection_orders(
                symbol=cfg.symbol,
                pos_side=entry_side,
                qty=actual_filled_quantity,
                sl_pr=final_sl_fmt,
                tp_pr=final_tp_fmt
            )

            # --- 5g. Update Position State (ONLY if protection was successfully placed) ---
            # Check if at least the SL component was successfully placed (either via OCO or separate SL)
            if oco_id or sl_id:
                log_info(f"Protection orders placed successfully (OCO Ref: {oco_id}, SL ID: {sl_id}, TP ID: {tp_id}).")
                self.position_manager.update_entry(
                    side=entry_side,
                    entry_price=actual_entry_price,
                    quantity=actual_filled_quantity,
                    entry_order_id=entry_order_id,
                    sl_price=final_sl_fmt, # Store the final SL target
                    tp_price=final_tp_fmt, # Store the final TP target
                    sl_order_id=sl_id,
                    tp_order_id=tp_id,
                    oco_order_id=oco_id
                )
                log_info(f"{NEON_GREEN}Successfully opened {entry_side.upper()} position and saved state.{RESET}")
                # Log warning if only partial protection placed (e.g., SL ok, but separate TP failed)
                if not oco_id and sl_id and not tp_id:
                    log_warning("Entry successful and SL placed, but placing separate TP order failed.")
            else:
                # --- CRITICAL FAILURE: Entry filled, but protection failed ---
                log_error(f"!!! {NEON_RED}CRITICAL ENTRY FAILURE{RESET} !!!")
                log_error(f"  Entry order {entry_order_id} was placed (Status: {entry_status}), but FAILED to place required protection orders (SL/TP).")
                log_error(f"  Position for {actual_filled_quantity:.{amount_prec}f} {cfg.symbol} is likely ACTIVE but UNPROTECTED.")
                # Attempt emergency market close as a safety measure
                self.position_manager.attempt_emergency_close()

        else:
             # Entry market order itself failed to place or returned no result
             log_error(f"Entry market order placement failed or returned invalid result: {entry_market_order}. No position taken.")


    def shutdown(self, save_state: bool = True):
        """Handles graceful shutdown: saves state, cancels open orders (in live mode)."""
        log_info("Initiating shutdown sequence...")
        # 1. Save Final State
        if save_state:
            try:
                log_info("Saving final position state...")
                self.position_manager.save_state()
                log_info("Final state saved.")
            except Exception as e:
                log_error(f"Error saving state during shutdown: {e}")

        # 2. Cancel Open Orders (Only in Live Mode)
        if not self.config.simulation_mode:
            log_warning(f"Attempting to cancel any remaining open orders for {self.config.symbol} in LIVE mode...")
            try:
                # Fetch open orders one last time
                open_orders = self.exchange_handler.fetch_open_orders(self.config.symbol) # Retries handled inside
                if open_orders:
                    log_info(f"Found {len(open_orders)} open order(s). Attempting cancellation...")
                    cancelled_count, failed_count = 0, 0
                    for order in open_orders:
                        oid = order.get('id')
                        if not oid:
                            log_warning(f"Found open order without ID: {order.get('info')}")
                            continue
                        log_info(f"  Cancelling Order ID: {oid}, Side: {order.get('side')}, Type: {order.get('type')}, Price: {order.get('price')}")
                        # Use cancel_order method (handles retries, OrderNotFound, logging)
                        if self.exchange_handler.cancel_order(oid, self.config.symbol):
                            cancelled_count += 1
                        else:
                            failed_count += 1
                        time.sleep(0.3) # Small delay between cancellations

                    log_info(f"Exit cancellation summary: {cancelled_count} cancelled/closed, {failed_count} failed.")
                    if failed_count > 0:
                        log_error("!!! Some orders failed cancellation. Manual verification on the exchange is required! !!!")
                else:
                    log_info("No open orders found for the symbol to cancel.")
            except ccxt.AuthenticationError:
                 log_error("Authentication failed during shutdown order cancellation. Manual check required.")
            except Exception as e:
                log_error(f"Error fetching or cancelling orders during shutdown: {e}", exc_info=True)
                log_error("Manual check of open orders on the exchange is strongly recommended.")
        else:
            log_info("Simulation mode: No real orders to cancel.")

        print_shutdown_message()
        log_info("Bot shutdown sequence complete.")
        # Ensure log handlers are closed properly
        logging.shutdown()

# --- Script Entry Point ---
if __name__ == "__main__":
    instance = None
    try:
        # Consider adding to .gitignore:
        # .env
        # *.log
        # position_state.json
        # __pycache__/
        # .vscode/
        # venv/

        bot = TradingBot()
        bot.run() # Start the main loop
    except SystemExit as e:
        # Logged inside relevant functions usually, but catch here too
        log_info(f"Bot exited via SystemExit (Code: {e.code}).")
        # No need to call shutdown again if exited cleanly
    except Exception as main_exec_error:
        # Catch unexpected errors during initialization or potentially escaped from run loop
        log_error(f"--- !!! CRITICAL UNHANDLED ERROR AT TOP LEVEL !!! ---", exc_info=False)
        # Use traceback to print detailed stack trace to stderr AND log it
        tb_str = traceback.format_exc()
        print(f"\n{NEON_RED}{Style.BRIGHT}--- TRACEBACK ---{RESET}\n{tb_str}{NEON_RED}{Style.BRIGHT}-----------------{RESET}", file=sys.stderr)
        logger.critical(f"Critical unhandled error at top level: {main_exec_error}\n{tb_str}")
        # Attempt shutdown if bot instance exists
        if isinstance(getattr(bot, 'shutdown', None), Callable):
             log_info("Attempting emergency shutdown after top-level error...")
             try: bot.shutdown(save_state=True)
             except Exception as shutdown_err: log_error(f"Error during emergency shutdown: {shutdown_err}")
        sys.exit(1) # Exit with error code
    finally:
        # Ensure logging is always shut down
        log_info("Executing final logging shutdown.")
        logging.shutdown()
        print("Logging shut down.")

# --- END OF ENHANCED FILE ---
```

**How to Use:**

1.  **Save:** Save this code as `rsitrader_enhanced_v1.4.py` (or your preferred name).
2.  **Dependencies:** Ensure libraries are installed: `pip install ccxt pandas pandas_ta python-dotenv colorama`
3.  **Configuration (`config.json`):** Make sure your `config.json` is present and contains all the necessary fields defined in the `Config` dataclass.
4.  **Environment (`.env`):** Create a `.env` file in the same directory as the script (or ensure variables are set externally) with your exchange API credentials:
    ```dotenv
    # Example for Binance
    BINANCE_API_KEY=YOUR_API_KEY_HERE
    BINANCE_SECRET_KEY=YOUR_SECRET_KEY_HERE
    # Add BINANCE_PASSPHRASE=YOUR_PASSPHRASE if needed by your exchange/subaccount
    ```
    *(Replace `BINANCE` with your exchange ID in uppercase, e.g., `BYBIT`, `KUCOIN`, `OKX`)*
5.  **Run:** `python rsitrader_enhanced_v1.4.py`
6.  **Log File:** A `trading_bot.log` file will be created/updated in the script's directory.
7.  **State File:** `position_state.json` will store the bot's current position. Add this and `.env` and `*.log` to your `.gitignore` if using version control.

This version builds upon the solid foundation of your refactoring, adding robustness primarily through file logging and refining some internal logic like state saving and error handling details. Remember the critical point about implementing exchange-specific OCO logic if you intend to use live OCO trading.
