# File: analyzer.py
import logging
import pandas as pd
import pandas_ta as ta
import numpy as np
from decimal import Decimal, ROUND_DOWN, ROUND_UP, InvalidOperation, getcontext
from typing import Any, Dict, Optional, Tuple, List, Union

# Import constants and utilities
import constants
import utils

class TradingAnalyzer:
    """Analyzes trading data using pandas_ta and generates weighted signals."""

    def __init__(
        self,
        df: pd.DataFrame,
        logger: logging.Logger,
        config: Dict[str, Any],
        market_info: Dict[str, Any],
    ) -> None:
        self.df = df
        self.logger = logger
        self.config = config
        self.market_info = market_info
        self.symbol = market_info.get('symbol', 'UNKNOWN_SYMBOL')
        self.interval = config.get("interval", "5")
        self.ccxt_interval = constants.CCXT_INTERVAL_MAP.get(self.interval)
        if not self.ccxt_interval:
             self.logger.error(f"Invalid interval '{self.interval}' in config, cannot map to CCXT timeframe. Defaulting calculation logic if possible, but fetching will fail.")

        self.indicator_values: Dict[str, Union[Decimal, float, np.nan]] = {}
        self.signals: Dict[str, int] = {"BUY": 0, "SELL": 0, "HOLD": 1}
        self.active_weight_set_name = config.get("active_weight_set", "default")
        self.weights = config.get("weight_sets",{}).get(self.active_weight_set_name, {})
        self.fib_levels_data: Dict[str, Decimal] = {}
        self.ta_column_names: Dict[str, Optional[str]] = {}

        if not self.weights:
             logger.error(f"Active weight set '{self.active_weight_set_name}' not found or empty in config for {self.symbol}.")

        self._calculate_all_indicators()
        self._update_latest_indicator_values()
        self.calculate_fibonacci_levels()


    def _get_ta_col_name(self, base_name: str, result_df: pd.DataFrame) -> Optional[str]:
        """Helper to find the actual column name generated by pandas_ta."""
        # Use DEFAULT_INDICATOR_PERIODS as fallback for config lookups
        def cfg_or_def(key): return self.config.get(key, constants.DEFAULT_INDICATOR_PERIODS[key])

        expected_patterns = {
            "ATR": [f"ATRr_{cfg_or_def('atr_period')}"],
            "EMA_Short": [f"EMA_{cfg_or_def('ema_short_period')}"],
            "EMA_Long": [f"EMA_{cfg_or_def('ema_long_period')}"],
            "Momentum": [f"MOM_{cfg_or_def('momentum_period')}"],
            "CCI": [f"CCI_{cfg_or_def('cci_window')}"], # May have suffix
            "Williams_R": [f"WILLR_{cfg_or_def('williams_r_window')}"],
            "MFI": [f"MFI_{cfg_or_def('mfi_window')}"],
            "VWAP": ["VWAP_D"],
            "PSAR_long": [f"PSARl_{cfg_or_def('psar_af')}_{cfg_or_def('psar_max_af')}"],
            "PSAR_short": [f"PSARs_{cfg_or_def('psar_af')}_{cfg_or_def('psar_max_af')}"],
            "SMA10": [f"SMA_{cfg_or_def('sma_10_window')}"],
            "StochRSI_K": [f"STOCHRSIk_{cfg_or_def('stoch_rsi_window')}_{cfg_or_def('stoch_rsi_rsi_window')}_{cfg_or_def('stoch_rsi_k')}", f"STOCHRSIk_{cfg_or_def('stoch_rsi_window')}"],
            "StochRSI_D": [f"STOCHRSId_{cfg_or_def('stoch_rsi_window')}_{cfg_or_def('stoch_rsi_rsi_window')}_{cfg_or_def('stoch_rsi_k')}_{cfg_or_def('stoch_rsi_d')}", f"STOCHRSId_{cfg_or_def('stoch_rsi_window')}"],
            "RSI": [f"RSI_{cfg_or_def('rsi_period')}"],
            "BB_Lower": [f"BBL_{cfg_or_def('bollinger_bands_period')}_{float(cfg_or_def('bollinger_bands_std_dev')):.1f}", f"BBL_{cfg_or_def('bollinger_bands_period')}"],
            "BB_Middle": [f"BBM_{cfg_or_def('bollinger_bands_period')}_{float(cfg_or_def('bollinger_bands_std_dev')):.1f}", f"BBM_{cfg_or_def('bollinger_bands_period')}"],
            "BB_Upper": [f"BBU_{cfg_or_def('bollinger_bands_period')}_{float(cfg_or_def('bollinger_bands_std_dev')):.1f}", f"BBU_{cfg_or_def('bollinger_bands_period')}"],
            "Volume_MA": [f"VOL_SMA_{cfg_or_def('volume_ma_period')}"]
        }

        patterns = expected_patterns.get(base_name, [])
        for col in result_df.columns:
             for pattern in patterns:
                 if col.startswith(pattern): self.logger.debug(f"Mapped '{base_name}' to column '{col}'"); return col

        base_name_lower = base_name.lower()
        for col in result_df.columns:
            if base_name_lower in col.lower(): self.logger.debug(f"Found column '{col}' for base '{base_name}' using fallback substring search."); return col

        self.logger.warning(f"Could not find column name for indicator '{base_name}' in DataFrame columns: {result_df.columns.tolist()}")
        return None


    def _calculate_all_indicators(self):
        """Calculates all enabled indicators using pandas_ta and stores column names."""
        if self.df.empty: self.logger.warning(f"{constants.NEON_YELLOW}DataFrame is empty, cannot calculate indicators for {self.symbol}.{constants.RESET}"); return

        required_periods = []
        indicators_config = self.config.get("indicators", {})
        def get_period(key): return self.config.get(key, constants.DEFAULT_INDICATOR_PERIODS[key])

        if indicators_config.get("atr_period"): required_periods.append(get_period("atr_period"))
        if indicators_config.get("ema_alignment"): required_periods.extend([get_period("ema_short_period"), get_period("ema_long_period")])
        if indicators_config.get("momentum"): required_periods.append(get_period("momentum_period"))
        if indicators_config.get("cci"): required_periods.append(get_period("cci_window"))
        if indicators_config.get("wr"): required_periods.append(get_period("williams_r_window"))
        if indicators_config.get("mfi"): required_periods.append(get_period("mfi_window"))
        if indicators_config.get("sma_10"): required_periods.append(get_period("sma_10_window"))
        if indicators_config.get("stoch_rsi"): required_periods.extend([get_period("stoch_rsi_window"), get_period("stoch_rsi_rsi_window")])
        if indicators_config.get("rsi"): required_periods.append(get_period("rsi_period"))
        if indicators_config.get("bollinger_bands"): required_periods.append(get_period("bollinger_bands_period"))
        if indicators_config.get("volume_confirmation"): required_periods.append(get_period("volume_ma_period"))
        required_periods.append(get_period("fibonacci_window"))

        min_required_data = max(required_periods) + 20 if required_periods else 50
        if len(self.df) < min_required_data: self.logger.warning(f"{constants.NEON_YELLOW}Insufficient data ({len(self.df)} points) for {self.symbol} to calculate all indicators reliably (min recommended: {min_required_data}). Results may contain NaNs.{constants.RESET}")

        try:
            df_calc = self.df.copy()
            atr_period = get_period("atr_period")
            df_calc.ta.atr(length=atr_period, append=True)
            self.ta_column_names["ATR"] = self._get_ta_col_name("ATR", df_calc)

            if indicators_config.get("ema_alignment", False):
                df_calc.ta.ema(length=get_period("ema_short_period"), append=True); self.ta_column_names["EMA_Short"] = self._get_ta_col_name("EMA_Short", df_calc)
                df_calc.ta.ema(length=get_period("ema_long_period"), append=True); self.ta_column_names["EMA_Long"] = self._get_ta_col_name("EMA_Long", df_calc)
            if indicators_config.get("momentum", False): df_calc.ta.mom(length=get_period("momentum_period"), append=True); self.ta_column_names["Momentum"] = self._get_ta_col_name("Momentum", df_calc)
            if indicators_config.get("cci", False): df_calc.ta.cci(length=get_period("cci_window"), append=True); self.ta_column_names["CCI"] = self._get_ta_col_name("CCI", df_calc)
            if indicators_config.get("wr", False): df_calc.ta.willr(length=get_period("williams_r_window"), append=True); self.ta_column_names["Williams_R"] = self._get_ta_col_name("Williams_R", df_calc)
            if indicators_config.get("mfi", False): df_calc.ta.mfi(length=get_period("mfi_window"), append=True); self.ta_column_names["MFI"] = self._get_ta_col_name("MFI", df_calc)
            if indicators_config.get("vwap", False): df_calc.ta.vwap(append=True); self.ta_column_names["VWAP"] = self._get_ta_col_name("VWAP", df_calc)
            if indicators_config.get("sma_10", False): df_calc.ta.sma(length=get_period("sma_10_window"), append=True); self.ta_column_names["SMA10"] = self._get_ta_col_name("SMA10", df_calc)
            if indicators_config.get("rsi", False): df_calc.ta.rsi(length=get_period("rsi_period"), append=True); self.ta_column_names["RSI"] = self._get_ta_col_name("RSI", df_calc)

            if indicators_config.get("psar", False):
                psar_result = df_calc.ta.psar(af=get_period("psar_af"), max_af=get_period("psar_max_af"))
                if psar_result is not None and not psar_result.empty:
                    df_calc = pd.concat([df_calc, psar_result], axis=1)
                    self.ta_column_names["PSAR_long"] = self._get_ta_col_name("PSAR_long", df_calc)
                    self.ta_column_names["PSAR_short"] = self._get_ta_col_name("PSAR_short", df_calc)

            if indicators_config.get("stoch_rsi", False):
                stochrsi_result = df_calc.ta.stochrsi(length=get_period("stoch_rsi_window"), rsi_length=get_period("stoch_rsi_rsi_window"), k=get_period("stoch_rsi_k"), d=get_period("stoch_rsi_d"))
                if stochrsi_result is not None and not stochrsi_result.empty:
                     df_calc = pd.concat([df_calc, stochrsi_result], axis=1)
                     self.ta_column_names["StochRSI_K"] = self._get_ta_col_name("StochRSI_K", df_calc)
                     self.ta_column_names["StochRSI_D"] = self._get_ta_col_name("StochRSI_D", df_calc)

            if indicators_config.get("bollinger_bands", False):
                bbands_result = df_calc.ta.bbands(length=get_period("bollinger_bands_period"), std=float(get_period("bollinger_bands_std_dev")))
                if bbands_result is not None and not bbands_result.empty:
                    df_calc = pd.concat([df_calc, bbands_result], axis=1)
                    self.ta_column_names["BB_Lower"] = self._get_ta_col_name("BB_Lower", df_calc)
                    self.ta_column_names["BB_Middle"] = self._get_ta_col_name("BB_Middle", df_calc)
                    self.ta_column_names["BB_Upper"] = self._get_ta_col_name("BB_Upper", df_calc)

            if indicators_config.get("volume_confirmation", False):
                vol_ma_period = get_period("volume_ma_period")
                vol_ma_col_name = f"VOL_SMA_{vol_ma_period}"
                df_calc[vol_ma_col_name] = ta.sma(df_calc['volume'].fillna(0), length=vol_ma_period)
                self.ta_column_names["Volume_MA"] = vol_ma_col_name

            self.df = df_calc
            self.logger.debug(f"Finished indicator calculations for {self.symbol}. Final DF columns: {self.df.columns.tolist()}")

        except AttributeError as e: self.logger.error(f"{constants.NEON_RED}AttributeError calculating indicators for {self.symbol}: {e}{constants.RESET}. Check pandas_ta usage and data.", exc_info=True)
        except Exception as e: self.logger.error(f"{constants.NEON_RED}Error calculating indicators with pandas_ta for {self.symbol}: {e}{constants.RESET}", exc_info=True)


    def _update_latest_indicator_values(self):
        """Updates the indicator_values dict with the latest values."""
        decimal_keys = ["ATR", "Open", "High", "Low", "Close", "Volume", "BB_Lower", "BB_Middle", "BB_Upper", "PSAR_long", "PSAR_short"]
        float_keys = ["EMA_Short", "EMA_Long", "Momentum", "CCI", "Williams_R", "MFI", "VWAP", "SMA10", "StochRSI_K", "StochRSI_D", "RSI", "Volume_MA"]

        if self.df.empty: self.logger.warning(f"Cannot update latest values: DataFrame empty for {self.symbol}."); self.indicator_values = {k: np.nan for k in list(self.ta_column_names.keys()) + ["Close", "Volume", "High", "Low", "Open"]}; return
        if self.df.iloc[-1].isnull().all(): self.logger.warning(f"Cannot update latest values: Last row contains all NaNs for {self.symbol}."); self.indicator_values = {k: np.nan for k in list(self.ta_column_names.keys()) + ["Close", "Volume", "High", "Low", "Open"]}; return

        try:
            latest = self.df.iloc[-1]
            updated_values: Dict[str, Union[Decimal, float, np.nan]] = {}

            for key, col_name in self.ta_column_names.items():
                if col_name and col_name in latest.index:
                    value = latest[col_name]
                    if pd.notna(value):
                        try:
                            if key in decimal_keys: updated_values[key] = Decimal(str(value))
                            elif key in float_keys: updated_values[key] = float(value)
                            else: self.logger.debug(f"Indicator key '{key}' not pre-classified, storing as float."); updated_values[key] = float(value)
                        except (ValueError, TypeError, InvalidOperation) as conv_err: self.logger.warning(f"Could not convert value for {key} ('{col_name}': {value}) for {self.symbol}. Storing NaN. Error: {conv_err}"); updated_values[key] = np.nan
                    else: updated_values[key] = np.nan
                else:
                    if key in self.ta_column_names: self.logger.debug(f"Indicator column '{col_name}' for key '{key}' not found in latest data row for {self.symbol}. Storing NaN.")
                    updated_values[key] = np.nan

            for base_col in ['open', 'high', 'low', 'close', 'volume']:
                 key_name = base_col.capitalize(); value = latest.get(base_col)
                 if pd.notna(value):
                      try: updated_values[key_name] = Decimal(str(value))
                      except (ValueError, TypeError, InvalidOperation) as conv_err: self.logger.warning(f"Could not convert base value for '{base_col}' ({value}) to Decimal for {self.symbol}. Storing NaN. Error: {conv_err}"); updated_values[key_name] = np.nan
                 else: updated_values[key_name] = np.nan

            self.indicator_values = updated_values

            valid_values_log = {}; price_prec = utils.get_price_precision(self.market_info, self.logger)
            for k, v in self.indicator_values.items():
                 if pd.notna(v):
                     if isinstance(v, Decimal):
                          prec = price_prec if k in ['Open','High','Low','Close','ATR', 'BB_Lower', 'BB_Middle', 'BB_Upper', 'PSAR_long', 'PSAR_short'] else 6
                          valid_values_log[k] = f"{v:.{prec}f}"
                     elif isinstance(v, float): valid_values_log[k] = f"{v:.5f}"
                     else: valid_values_log[k] = str(v)
            self.logger.debug(f"Latest indicator values updated for {self.symbol}: {valid_values_log}")

        except IndexError: self.logger.error(f"Error accessing latest row (iloc[-1]) for {self.symbol}. DataFrame might be empty or too short after cleaning."); self.indicator_values = {k: np.nan for k in list(self.ta_column_names.keys()) + ["Close", "Volume", "High", "Low", "Open"]}
        except Exception as e: self.logger.error(f"Unexpected error updating latest indicator values for {self.symbol}: {e}", exc_info=True); self.indicator_values = {k: np.nan for k in list(self.ta_column_names.keys()) + ["Close", "Volume", "High", "Low", "Open"]}


    def calculate_fibonacci_levels(self, window: Optional[int] = None) -> Dict[str, Decimal]:
        """Calculates Fibonacci retracement levels."""
        window = window or self.config.get("fibonacci_window", constants.DEFAULT_INDICATOR_PERIODS['fibonacci_window'])
        if len(self.df) < window: self.logger.debug(f"Not enough data ({len(self.df)} points) for Fibonacci window ({window}) on {self.symbol}."); self.fib_levels_data = {}; return {}

        df_slice = self.df.tail(window)
        try:
            high_price_raw = df_slice["high"].dropna().max(); low_price_raw = df_slice["low"].dropna().min()
            if pd.isna(high_price_raw) or pd.isna(low_price_raw): self.logger.warning(f"Could not find valid high/low prices within the last {window} periods for Fibonacci calculation on {self.symbol}."); self.fib_levels_data = {}; return {}

            high = Decimal(str(high_price_raw)); low = Decimal(str(low_price_raw)); diff = high - low
            levels = {}; price_precision = utils.get_price_precision(self.market_info, self.logger); min_tick_size = utils.get_min_tick_size(self.market_info, self.logger)

            if diff > 0:
                for level_pct in constants.FIB_LEVELS:
                    level_name = f"Fib_{level_pct * 100:.1f}%"; level_price_raw = high - (diff * Decimal(str(level_pct)))
                    if min_tick_size > 0: level_price_quantized = (level_price_raw / min_tick_size).quantize(Decimal('1'), rounding=ROUND_DOWN) * min_tick_size
                    else: rounding_factor = Decimal('1e-' + str(price_precision)); level_price_quantized = level_price_raw.quantize(rounding_factor, rounding=ROUND_DOWN)
                    levels[level_name] = level_price_quantized
            else:
                 self.logger.debug(f"Fibonacci range is zero or negative (High={high}, Low={low}) for {self.symbol} over last {window} periods. All levels set to High/Low.")
                 if min_tick_size > 0: level_price_quantized = (high / min_tick_size).quantize(Decimal('1'), rounding=ROUND_DOWN) * min_tick_size
                 else: rounding_factor = Decimal('1e-' + str(price_precision)); level_price_quantized = high.quantize(rounding_factor, rounding=ROUND_DOWN)
                 for level_pct in constants.FIB_LEVELS: levels[f"Fib_{level_pct * 100:.1f}%"] = level_price_quantized

            self.fib_levels_data = levels
            log_levels = {k: str(v) for k, v in levels.items()}
            self.logger.debug(f"Calculated Fibonacci levels for {self.symbol} (Window: {window}): {log_levels}")
            return levels

        except KeyError as e: self.logger.error(f"{constants.NEON_RED}Fibonacci calculation error for {self.symbol}: Missing column '{e}'. Ensure 'high' and 'low' columns exist.{constants.RESET}"); self.fib_levels_data = {}; return {}
        except Exception as e: self.logger.error(f"{constants.NEON_RED}Unexpected Fibonacci calculation error for {self.symbol}: {e}{constants.RESET}", exc_info=True); self.fib_levels_data = {}; return {}


    def get_nearest_fibonacci_levels(self, current_price: Decimal, num_levels: int = 5) -> list[Tuple[str, Decimal]]:
        """Finds the N nearest Fibonacci levels to the current price."""
        if not self.fib_levels_data: self.logger.debug(f"Fibonacci levels not calculated yet for {self.symbol}. Cannot find nearest."); return []
        if not isinstance(current_price, Decimal) or pd.isna(current_price) or current_price <= 0: self.logger.warning(f"Invalid current price ({current_price}) provided for Fibonacci comparison on {self.symbol}."); return []

        try:
            level_distances = []
            for name, level_price in self.fib_levels_data.items():
                if isinstance(level_price, Decimal) and level_price > 0:
                    distance = abs(current_price - level_price)
                    level_distances.append({'name': name, 'level': level_price, 'distance': distance})
                else: self.logger.warning(f"Invalid or non-decimal value found in fib_levels_data: {name}={level_price}. Skipping.")

            level_distances.sort(key=lambda x: x['distance'])
            return [(item['name'], item['level']) for item in level_distances[:num_levels]]
        except Exception as e: self.logger.error(f"{constants.NEON_RED}Error finding nearest Fibonacci levels for {self.symbol}: {e}{constants.RESET}", exc_info=True); return []


    def calculate_ema_alignment_score(self) -> float:
        """Calculates EMA alignment score."""
        ema_short = self.indicator_values.get("EMA_Short"); ema_long = self.indicator_values.get("EMA_Long")
        close_decimal = self.indicator_values.get("Close"); current_price_float = float(close_decimal) if isinstance(close_decimal, Decimal) else np.nan

        if pd.isna(ema_short) or pd.isna(ema_long) or pd.isna(current_price_float): self.logger.debug("EMA alignment check skipped: Missing required values."); return np.nan

        if current_price_float > ema_short > ema_long: return 1.0
        elif current_price_float < ema_short < ema_long: return -1.0
        else: return 0.0


    def generate_trading_signal(self, current_price: Decimal, orderbook_data: Optional[Dict]) -> str:
        """Generates a final trading signal (BUY/SELL/HOLD) based on weighted score."""
        self.signals = {"BUY": 0, "SELL": 0, "HOLD": 1}; final_signal_score = Decimal("0.0"); total_weight_applied = Decimal("0.0"); active_indicator_count = 0; nan_indicator_count = 0; debug_scores = {}

        if not self.indicator_values: self.logger.warning(f"{constants.NEON_YELLOW}Cannot generate signal for {self.symbol}: Indicator values dictionary is empty.{constants.RESET}"); return "HOLD"
        core_indicators_present = any(pd.notna(v) for k, v in self.indicator_values.items() if k not in ['Open', 'High', 'Low', 'Close', 'Volume'])
        if not core_indicators_present: self.logger.warning(f"{constants.NEON_YELLOW}Cannot generate signal for {self.symbol}: All core indicator values are NaN.{constants.RESET}"); return "HOLD"
        if pd.isna(current_price) or not isinstance(current_price, Decimal) or current_price <= 0: self.logger.warning(f"{constants.NEON_YELLOW}Cannot generate signal for {self.symbol}: Invalid current price ({current_price}).{constants.RESET}"); return "HOLD"

        active_weights = self.config.get("weight_sets", {}).get(self.active_weight_set_name)
        if not active_weights: self.logger.error(f"Active weight set '{self.active_weight_set_name}' missing or empty in config for {self.symbol}. Cannot generate signal."); return "HOLD"

        for indicator_key, enabled in self.config.get("indicators", {}).items():
            if not enabled: continue
            weight_str = active_weights.get(indicator_key)
            if weight_str is None: continue
            try: weight = Decimal(str(weight_str));
                 if weight == 0: continue
            except (InvalidOperation, ValueError, TypeError): self.logger.warning(f"Invalid weight format '{weight_str}' for indicator '{indicator_key}' in weight set '{self.active_weight_set_name}'. Skipping."); continue

            check_method_name = f"_check_{indicator_key}"
            if hasattr(self, check_method_name) and callable(getattr(self, check_method_name)):
                method_to_call = getattr(self, check_method_name); indicator_score_float = np.nan
                try:
                    if indicator_key == "orderbook":
                         if orderbook_data: indicator_score_float = method_to_call(orderbook_data, current_price)
                         else:
                              if weight != 0: self.logger.debug(f"Orderbook check skipped for {self.symbol}: No orderbook data provided.")
                    else: indicator_score_float = method_to_call()
                except Exception as e: self.logger.error(f"Error executing indicator check method {check_method_name} for {self.symbol}: {e}", exc_info=True)

                debug_scores[indicator_key] = f"{indicator_score_float:.3f}" if pd.notna(indicator_score_float) else "NaN"
                if pd.notna(indicator_score_float):
                    try:
                        score_decimal = Decimal(str(indicator_score_float))
                        clamped_score = max(Decimal("-1.0"), min(Decimal("1.0"), score_decimal))
                        score_contribution = clamped_score * weight
                        final_signal_score += score_contribution
                        total_weight_applied += weight; active_indicator_count += 1
                    except (InvalidOperation, ValueError, TypeError) as calc_err: self.logger.error(f"Error processing score for {indicator_key} (Score: {indicator_score_float}, Weight: {weight}): {calc_err}"); nan_indicator_count += 1
                else: nan_indicator_count += 1
            else:
                if weight != 0: self.logger.warning(f"Indicator check method '{check_method_name}' not found for enabled/weighted indicator: {indicator_key} ({self.symbol})")

        final_signal = "HOLD"
        if total_weight_applied == 0: self.logger.warning(f"No indicators contributed valid scores to the signal calculation for {self.symbol}. Defaulting to HOLD.")
        else:
            threshold_str = self.config.get("signal_score_threshold", "1.5")
            try: threshold = Decimal(str(threshold_str))
            except (InvalidOperation, ValueError, TypeError): self.logger.warning(f"Invalid signal_score_threshold '{threshold_str}'. Using default 1.5."); threshold = Decimal("1.5")
            if final_signal_score >= threshold: final_signal = "BUY"
            elif final_signal_score <= -threshold: final_signal = "SELL"

        price_prec = utils.get_price_precision(self.market_info, self.logger)
        log_msg = (f"Signal Summary ({self.symbol} @ {current_price:.{price_prec}f}): "
                   f"Set='{self.active_weight_set_name}', Indicators=[Active:{active_indicator_count}, NaN:{nan_indicator_count}], "
                   f"TotalWeight={total_weight_applied:.2f}, FinalScore={final_signal_score:.4f} (Threshold: +/-{threshold:.2f}) "
                   f"==> {constants.NEON_GREEN if final_signal == 'BUY' else constants.NEON_RED if final_signal == 'SELL' else constants.NEON_YELLOW}{final_signal}{constants.RESET}")
        self.logger.info(log_msg); self.logger.debug(f"  Indicator Scores ({self.symbol}): {debug_scores}")

        if final_signal == "BUY": self.signals = {"BUY": 1, "SELL": 0, "HOLD": 0}
        elif final_signal == "SELL": self.signals = {"BUY": 0, "SELL": 1, "HOLD": 0}
        else: self.signals = {"BUY": 0, "SELL": 0, "HOLD": 1}
        return final_signal


    # --- Indicator Check Methods (returning float score -1.0 to 1.0 or np.nan) ---
    def _check_ema_alignment(self) -> float:
        if "EMA_Short" not in self.indicator_values or "EMA_Long" not in self.indicator_values: self.logger.debug("EMA Alignment check skipped: EMA values not found."); return np.nan
        return self.calculate_ema_alignment_score()

    def _check_momentum(self) -> float:
        momentum = self.indicator_values.get("Momentum"); last_close = self.indicator_values.get("Close")
        if pd.isna(momentum): return np.nan
        if not isinstance(last_close, Decimal) or last_close <= 0: return 0.0
        try:
            mom_pct = Decimal(str(momentum)) / last_close if last_close else Decimal(0); threshold_pct = Decimal("0.001")
            if mom_pct > threshold_pct: return min(1.0, float(mom_pct / (threshold_pct * 5)))
            elif mom_pct < -threshold_pct: return max(-1.0, float(mom_pct / (threshold_pct * 5)))
            else: return float(mom_pct / threshold_pct)
        except (InvalidOperation, ValueError, TypeError): return 0.0

    def _check_volume_confirmation(self) -> float:
        current_volume = self.indicator_values.get("Volume"); volume_ma_float = self.indicator_values.get("Volume_MA")
        multiplier = float(self.config.get("volume_confirmation_multiplier", 1.5))
        if pd.isna(current_volume) or not isinstance(current_volume, Decimal) or pd.isna(volume_ma_float): return np.nan
        try:
            volume_ma = Decimal(str(volume_ma_float)); multiplier_decimal = Decimal(str(multiplier))
            if volume_ma > 0:
                volume_ratio = current_volume / volume_ma
                if volume_ratio > multiplier_decimal: return min(1.0, 0.5 + float(volume_ratio - multiplier_decimal) / (multiplier_decimal * 2))
                elif volume_ratio < (Decimal(1) / multiplier_decimal): return -0.4
                else: return 0.0
            else: return 0.0 if current_volume == 0 else 0.5
        except (InvalidOperation, ValueError, TypeError) as e: self.logger.warning(f"Error during volume confirmation check: {e}"); return np.nan

    def _check_stoch_rsi(self) -> float:
        k = self.indicator_values.get("StochRSI_K"); d = self.indicator_values.get("StochRSI_D")
        if pd.isna(k) or pd.isna(d): return np.nan
        oversold = float(self.config.get("stoch_rsi_oversold_threshold", 25)); overbought = float(self.config.get("stoch_rsi_overbought_threshold", 75)); score = 0.0
        if k < oversold and d < oversold: score = 1.0
        elif k > overbought and d > overbought: score = -1.0
        diff = k - d
        if abs(diff) > 5:
             if diff > 0: score = max(score, 0.6) if score >= 0 else 0.6
             else: score = min(score, -0.6) if score <= 0 else -0.6
        elif k > d : score = max(score, 0.2)
        elif k < d: score = min(score, -0.2)
        if 40 < k < 60: score *= 0.5
        return score

    def _check_rsi(self) -> float:
        rsi = self.indicator_values.get("RSI")
        if pd.isna(rsi): return np.nan
        if rsi <= 30: return 1.0;
        if rsi >= 70: return -1.0;
        if rsi < 40: return 0.5;
        if rsi > 60: return -0.5;
        if 40 <= rsi <= 60: return (rsi - 50) / 50.0
        return 0.0

    def _check_cci(self) -> float:
        cci = self.indicator_values.get("CCI")
        if pd.isna(cci): return np.nan
        if cci <= -150: return 1.0;
        if cci >= 150: return -1.0;
        if cci < -80: return 0.6;
        if cci > 80: return -0.6;
        if -80 <= cci < 0: return 0.1;
        if 0 < cci <= 80: return -0.1;
        if cci == 0: return 0.0;
        return 0.0

    def _check_wr(self) -> float:
        wr = self.indicator_values.get("Williams_R")
        if pd.isna(wr): return np.nan
        if wr <= -80: return 1.0;
        if wr >= -20: return -1.0;
        if -80 < wr < -50: return 0.4;
        if -50 < wr < -20: return -0.4;
        if wr == -50: return 0.0;
        return 0.0

    def _check_psar(self) -> float:
        psar_long_signal = self.indicator_values.get("PSAR_long"); psar_short_signal = self.indicator_values.get("PSAR_short")
        long_active = pd.notna(psar_long_signal); short_active = pd.notna(psar_short_signal)
        if long_active and not short_active: return 1.0
        elif short_active and not long_active: return -1.0
        elif not long_active and not short_active: return np.nan
        else: self.logger.warning(f"PSAR check encountered unexpected state: Long={psar_long_signal}, Short={psar_short_signal}"); return 0.0

    def _check_sma_10(self) -> float:
        sma_10 = self.indicator_values.get("SMA10"); last_close_decimal = self.indicator_values.get("Close")
        last_close_float = float(last_close_decimal) if isinstance(last_close_decimal, Decimal) else np.nan
        if pd.isna(sma_10) or pd.isna(last_close_float): return np.nan
        if last_close_float > sma_10: return 0.6
        elif last_close_float < sma_10: return -0.6
        else: return 0.0

    def _check_vwap(self) -> float:
        vwap = self.indicator_values.get("VWAP"); last_close_decimal = self.indicator_values.get("Close")
        last_close_float = float(last_close_decimal) if isinstance(last_close_decimal, Decimal) else np.nan
        if pd.isna(vwap) or pd.isna(last_close_float): return np.nan
        if last_close_float > vwap: return 0.7
        elif last_close_float < vwap: return -0.7
        else: return 0.0

    def _check_mfi(self) -> float:
        mfi = self.indicator_values.get("MFI")
        if pd.isna(mfi): return np.nan
        if mfi <= 20: return 1.0;
        if mfi >= 80: return -1.0;
        if mfi < 40: return 0.4;
        if mfi > 60: return -0.4;
        return 0.0

    def _check_bollinger_bands(self) -> float:
        bb_lower_dec = self.indicator_values.get("BB_Lower"); bb_middle_dec = self.indicator_values.get("BB_Middle")
        bb_upper_dec = self.indicator_values.get("BB_Upper"); last_close_decimal = self.indicator_values.get("Close")
        if not all(isinstance(val, Decimal) for val in [bb_lower_dec, bb_middle_dec, bb_upper_dec, last_close_decimal]): return np.nan
        if last_close_decimal <= bb_lower_dec: return 1.0
        if last_close_decimal >= bb_upper_dec: return -1.0
        band_width_dec = bb_upper_dec - bb_lower_dec
        if band_width_dec > 0:
            try:
                relative_position_dec = (last_close_decimal - bb_middle_dec) / (band_width_dec / Decimal("2.0"))
                score_dec = max(Decimal("-1.0"), min(Decimal("1.0"), relative_position_dec))
                return float(score_dec * Decimal("0.7"))
            except (InvalidOperation, ValueError, TypeError): self.logger.warning("Error calculating relative position within Bollinger Bands."); return 0.0
        return 0.0

    def _check_orderbook(self, orderbook_data: Optional[Dict], current_price: Decimal) -> float:
        """Analyzes order book depth (imbalance)."""
        if not orderbook_data: self.logger.debug("Orderbook check skipped: No data provided."); return np.nan
        try:
            bids = orderbook_data.get('bids', []); asks = orderbook_data.get('asks', [])
            if not bids or not asks: self.logger.debug("Orderbook check skipped: Missing bids or asks."); return np.nan
            num_levels_to_check = 10; top_bids = bids[:num_levels_to_check]; top_asks = asks[:num_levels_to_check]
            bid_volume_sum = sum(Decimal(str(bid[1])) for bid in top_bids if len(bid) == 2 and bid[1] is not None)
            ask_volume_sum = sum(Decimal(str(ask[1])) for ask in top_asks if len(ask) == 2 and ask[1] is not None)
            total_volume = bid_volume_sum + ask_volume_sum
            if total_volume == 0: self.logger.debug(f"Orderbook check ({self.symbol}): Zero total volume in top {num_levels_to_check} levels."); return 0.0
            obi_decimal = (bid_volume_sum - ask_volume_sum) / total_volume; score = float(obi_decimal)
            self.logger.debug(f"Orderbook check ({self.symbol}): Top {num_levels_to_check} levels -> BidVol={bid_volume_sum:.4f}, AskVol={ask_volume_sum:.4f}, OBI={obi_decimal:.4f} -> Score={score:.4f}")
            return score
        except (InvalidOperation, ValueError, TypeError) as e: self.logger.warning(f"{constants.NEON_YELLOW}Orderbook analysis failed for {self.symbol} (data conversion error): {e}{constants.RESET}", exc_info=False); return np.nan
        except Exception as e: self.logger.warning(f"{constants.NEON_YELLOW}Orderbook analysis failed for {self.symbol} (unexpected error): {e}{constants.RESET}", exc_info=True); return np.nan


    def calculate_entry_tp_sl(self, entry_price_estimate: Decimal, signal: str) -> Tuple[Optional[Decimal], Optional[Decimal], Optional[Decimal]]:
        """Calculates potential Take Profit (TP) and initial Stop Loss (SL) levels."""
        if signal not in ["BUY", "SELL"]: self.logger.debug(f"TP/SL calculation skipped: Signal is '{signal}'."); return entry_price_estimate, None, None
        atr_val = self.indicator_values.get("ATR")
        if not isinstance(atr_val, Decimal) or pd.isna(atr_val) or atr_val <= 0: self.logger.warning(f"{constants.NEON_YELLOW}Cannot calculate TP/SL for {self.symbol} {signal}: Invalid or missing ATR ({atr_val}).{constants.RESET}"); return entry_price_estimate, None, None
        if not isinstance(entry_price_estimate, Decimal) or pd.isna(entry_price_estimate) or entry_price_estimate <= 0: self.logger.warning(f"{constants.NEON_YELLOW}Cannot calculate TP/SL for {self.symbol} {signal}: Invalid entry price estimate ({entry_price_estimate}).{constants.RESET}"); return entry_price_estimate, None, None

        try:
            tp_multiple_str = self.config.get("take_profit_multiple", "1.0"); sl_multiple_str = self.config.get("stop_loss_multiple", "1.5")
            tp_multiple = Decimal(str(tp_multiple_str)); sl_multiple = Decimal(str(sl_multiple_str))
            price_precision = utils.get_price_precision(self.market_info, self.logger); min_tick = utils.get_min_tick_size(self.market_info, self.logger)
            tp_offset = atr_val * tp_multiple; sl_offset = atr_val * sl_multiple
            take_profit_raw: Optional[Decimal] = None; stop_loss_raw: Optional[Decimal] = None

            if signal == "BUY": take_profit_raw = entry_price_estimate + tp_offset; stop_loss_raw = entry_price_estimate - sl_offset
            elif signal == "SELL": take_profit_raw = entry_price_estimate - tp_offset; stop_loss_raw = entry_price_estimate + sl_offset

            take_profit_quantized: Optional[Decimal] = None; stop_loss_quantized: Optional[Decimal] = None
            if take_profit_raw is not None:
                 if min_tick > 0: tp_rounding = ROUND_UP if signal == "BUY" else ROUND_DOWN; take_profit_quantized = (take_profit_raw / min_tick).quantize(Decimal('1'), rounding=tp_rounding) * min_tick
                 else: rounding_factor = Decimal('1e-' + str(price_precision)); tp_rounding = ROUND_UP if signal == "BUY" else ROUND_DOWN; take_profit_quantized = take_profit_raw.quantize(rounding_factor, rounding=tp_rounding)
            if stop_loss_raw is not None:
                 if min_tick > 0: sl_rounding = ROUND_DOWN if signal == "BUY" else ROUND_UP; stop_loss_quantized = (stop_loss_raw / min_tick).quantize(Decimal('1'), rounding=sl_rounding) * min_tick
                 else: rounding_factor = Decimal('1e-' + str(price_precision)); sl_rounding = ROUND_DOWN if signal == "BUY" else ROUND_UP; stop_loss_quantized = stop_loss_raw.quantize(rounding_factor, rounding=sl_rounding)

            final_tp = take_profit_quantized; final_sl = stop_loss_quantized
            if final_sl is not None and min_tick > 0:
                 if signal == "BUY" and final_sl >= entry_price_estimate: original_sl = final_sl; final_sl = ((entry_price_estimate - min_tick) / min_tick).quantize(Decimal('1'), rounding=ROUND_DOWN) * min_tick; self.logger.debug(f"Adjusted BUY SL below entry: {original_sl} -> {final_sl}")
                 elif signal == "SELL" and final_sl <= entry_price_estimate: original_sl = final_sl; final_sl = ((entry_price_estimate + min_tick) / min_tick).quantize(Decimal('1'), rounding=ROUND_UP) * min_tick; self.logger.debug(f"Adjusted SELL SL above entry: {original_sl} -> {final_sl}")
            if final_tp is not None and min_tick > 0:
                 if signal == "BUY" and final_tp <= entry_price_estimate: self.logger.warning(f"{constants.NEON_YELLOW}BUY TP calculation non-profitable (TP {final_tp} <= Entry {entry_price_estimate}). Setting TP to None.{constants.RESET}"); final_tp = None
                 elif signal == "SELL" and final_tp >= entry_price_estimate: self.logger.warning(f"{constants.NEON_YELLOW}SELL TP calculation non-profitable (TP {final_tp} >= Entry {entry_price_estimate}). Setting TP to None.{constants.RESET}"); final_tp = None
            if final_sl is not None and final_sl <= 0: self.logger.error(f"{constants.NEON_RED}Stop loss calculation resulted in non-positive price ({final_sl}). Setting SL to None.{constants.RESET}"); final_sl = None
            if final_tp is not None and final_tp <= 0: self.logger.warning(f"{constants.NEON_YELLOW}Take profit calculation resulted in non-positive price ({final_tp}). Setting TP to None.{constants.RESET}"); final_tp = None

            tp_str = f"{final_tp:.{price_precision}f}" if final_tp else "None"; sl_str = f"{final_sl:.{price_precision}f}" if final_sl else "None"
            self.logger.debug(f"Calculated TP/SL for {self.symbol} {signal}: EntryEst={entry_price_estimate:.{price_precision}f}, ATR={atr_val:.{price_precision+1}f}, TP={tp_str} (Mult: {tp_multiple}), SL={sl_str} (Mult: {sl_multiple})")
            return entry_price_estimate, final_tp, final_sl

        except (InvalidOperation, ValueError, TypeError) as e: self.logger.error(f"{constants.NEON_RED}Error calculating TP/SL for {self.symbol} {signal} (Decimal/Type Error): {e}{constants.RESET}", exc_info=False); return entry_price_estimate, None, None
        except Exception as e: self.logger.error(f"{constants.NEON_RED}Unexpected error calculating TP/SL for {self.symbol} {signal}: {e}{constants.RESET}", exc_info=True); return entry_price_estimate, None, None

```

```python
