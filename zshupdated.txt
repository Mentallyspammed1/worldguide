    # ~/.zshrc
    # Main Zsh configuration file.

    # --- Instant Prompt (Powerlevel10k) ---
    # Source P10k instant prompt for faster startup if it exists.
    if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
      source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
    fi

    # --- Environment Variables ---
    export TERM="xterm-256color"
    export LANG="en_US.UTF-8"
    export SHELL="/data/data/com.termux/files/usr/bin/zsh"
    export EDITOR="vim" # Changed from nano back to vim as per later settings
    export VISUAL="$EDITOR"
    # Ensure Python path is correct for Termux and consistent
    export PYTHONPATH="/data/data/com.termux/files/usr/bin/python"
    export JAVA_HOME="/data/data/com.termux/files/usr/libexec/java_home"
    export ZSH="$HOME/.oh-my-zsh"
    export ZSHRC="$HOME/.zshrc" # Standard location
    export ZSH_CUSTOM="$HOME/.config/zsh" # Custom user config directory

    # Consolidated PATH (Order matters - prioritize user bins)
    export PATH="$HOME/bin:$HOME/search:$HOME/.local/bin:$HOME/.cargo/bin:$HOME/platform-tools:/data/data/com.termux/files/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"

    # --- API Keys & Secrets (SECURITY WARNING) ---
    # DO NOT HARDCODE API KEYS HERE!
    # Use a .env file in your $HOME directory and ensure it's in .gitignore
    # Example .env file:
    # BYBIT_API_KEY="YourBybitApiKey"
    # BYBIT_API_SECRET="YourBybitApiSecret"
    # OPENROUTER_API_KEY="YourOpenRouterKey"
    # GOOGLE_API_KEY="YourGoogleApiKey"
    #
    # The Python functions below attempt to load these from .env using python-dotenv.
    # The export lines below are REMOVED FOR SECURITY. Ensure they are in your .env file.
    export BYBIT_API_KEY="I9iTUO2iaVFK1NjNo1" # REMOVED - USE .env
    export BYBIT_API_SECRET="B4KBZej8Mo6j4VwNpLqZ4M64BQJIqI4opiTR" # REMOVED - USE .env
    # export OPENROUTER_API_KEY="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" # REMOVED - USE .env
    export GOOGLE_API_KEY="AIzaSyBZ3Bl6zCbJSdgL3y4VYOOupxZe50nVIUg" # REMOVED - USE .env
    # export GEMINI_API_KEY="$GOOGLE_API_KEY" # Reuse Google key if desired, but keep value in .env

    # --- Zsh Options ---
    setopt auto_cd             # Change dir without cd
    setopt correct             # Auto correct commands
    setopt numeric_glob_sort   # Sort filenames numerically when globbing
    setopt no_flow_control     # Disable ^S/^Q flow control
    setopt extended_glob       # Use extended globbing features
    setopt interactive_comments # Allow comments in interactive shell
    setopt glob_dots           # Include dotfiles in globbing results
    setopt promptsubst         # Allow prompt substitutions
    setopt hist_verify         # Show command from history before executing
    setopt share_history       # Share history between terminals
    setopt inc_append_history  # Append history incrementally
    setopt hist_no_functions   # Do not store functions in history

    # --- History Settings ---
    # Consider using a more secure directory like ~/.local/share/zsh/
    export HISTFILE="$HOME/.zsh_history_encrypted"
    export HISTSIZE=50000
    export SAVEHIST=50000
    # Ignore commands starting with space, duplicates, and common non-essential commands
    export HIST_IGNORE_SPACE="true"
    export HIST_IGNORE_DUPS="true"
    export HIST_NO_STORE="ls:cd:pwd:exit:history:bg:fg:jobs"

    # --- Oh My Zsh Configuration ---
    # Powerlevel10k theme configuration (handled by ~/.p10k.zsh usually)
    ZSH_THEME="powerlevel10k/powerlevel10k" # Needs Powerlevel10k installed in $ZSH/custom/themes

    # List of Oh My Zsh plugins to load.
    # Ensure these plugins are installed in $ZSH/custom/plugins or $ZSH/plugins
    plugins=(
        git                   # Git aliases and functions
        zsh-z               # Smart directory jumping (formerly z) - Requires separate install usually
        command-not-found   # Suggest packages for missing commands (needs package installed)
        zsh-completions     # Additional Zsh completions
        # NOTE: 'aichat' plugin listed here. If it provides completions,
        # the explicit 'source' line later might be unnecessary.
        aichat                # Assume this provides aichat integration/completions
        # Recommended additions:
        # zsh-syntax-highlighting # Provides syntax highlighting (Install separately)
        # zsh-autosuggestions   # Provides command suggestions based on history (Install separately)
    )

    # Source Oh My Zsh
    if [[ -f "$ZSH/oh-my-zsh.sh" ]]; then
        source "$ZSH/oh-my-zsh.sh"
    else
        echo "Oh My Zsh not found at $ZSH. Install with: sh -c \"\$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\""
        [[ -x "$(command -v termux-toast)" ]] && termux-toast "Install Oh My Zsh"
    fi

    # --- Optional Plugins (Manual Sourcing Example) ---
    # Example of sourcing plugins not managed directly by OMZ 'plugins' array.
    # Ensure these paths are correct.
    # optional_plugins=(
    #     "fast-syntax-highlighting https://github.com/zdharma-continuum/fast-syntax-highlighting"
    #     # aichat is already in the main plugins list, possibly redundant here?
    #     # "aichat https://github.com/sigoden/aichat"
    # )
    # for plugin_entry in "${optional_plugins[@]}"; do
    #     plugin_name=$(echo "$plugin_entry" | cut -d' ' -f1)
    #     plugin_url=$(echo "$plugin_entry" | cut -d' ' -f2-)
    #     plugin_dir="$ZSH/custom/plugins/$plugin_name" # Standard OMZ custom plugin location
    #     plugin_init_file=""

    #     # Check for common plugin init file names
    #     if [[ -r "$plugin_dir/$plugin_name.plugin.zsh" ]]; then
    #         plugin_init_file="$plugin_dir/$plugin_name.plugin.zsh"
    #     elif [[ -r "$plugin_dir/$plugin_name.zsh" ]]; then
    #         plugin_init_file="$plugin_dir/$plugin_name.zsh"
    #     elif [[ -r "$plugin_dir/init.zsh" ]]; then
    #          plugin_init_file="$plugin_dir/init.zsh"
    #     fi

    #     if [[ -n "$plugin_init_file" ]]; then
    #          source "$plugin_init_file"
    #     else
    #         echo "Optional plugin '$plugin_name' not found or initialization script missing. Install with: git clone $plugin_url $plugin_dir"
    #     fi
    # done

    # --- Custom Zsh Settings ---
    # Source custom configuration files from ~/.config/zsh
    if [[ -d "$ZSH_CUSTOM" ]]; then
        for config_file in "$ZSH_CUSTOM"/*.zsh; do
            [[ -f "$config_file" ]] && source "$config_file"
        done
    fi
    # Source specific overrides if they exist
    [[ -f "$ZSH_CUSTOM/custom.zsh" ]] && source "$ZSH_CUSTOM/custom.zsh"
    [[ -f "$ZSH_CUSTOM/aliases.zsh" ]] && source "$ZSH_CUSTOM/aliases.zsh"

    # --- Completion Settings ---
    # These should ideally be loaded after Oh My Zsh and compinit
    # Ensure compinit is loaded later in the file.
    zstyle ':completion:*' menu select=1                 # Enable menu selection
    zstyle ':completion:*' list-colors "${LS_COLORS}"    # Use LS_COLORS for completion highlighting
    zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}' 'r:|=*' 'l:|=* r:|=*' # Case-insensitive matching
    zstyle ':completion:*' use-cache on                  # Enable caching
    zstyle ':completion:*' cache-path "$HOME/.zsh_cache" # Cache directory

    # --- Aliases ---
    # Check for existence of enhanced tools before aliasing
    [[ -x "$(command -v bat)" ]] && alias cat="bat --theme=Dracula --paging=auto" # Use bat if available
    [[ -x "$(command -v eza)" ]] && {
        alias ls="eza --group-directories-first --icons"
        alias l="eza -lah --icons" # Common short alias for detailed list
        alias la="eza -lah --icons"
        alias ll="eza -l --icons"  # Long format
        alias lt="eza -T --level=2 --icons" # Tree view
    } || {
        alias ls="ls --color=auto -F" # Add indicators (-F) for classic ls
        alias l="ls -lah"
        alias la="ls -lah"
        alias ll="ls -l"
        # No easy tree view for standard ls
    }
    [[ -x "$(command -v fd)" ]] && alias find="fd"               # Use fd if available
    alias grep="grep --color=auto"
    alias df="df -h"
    alias du="du -h --max-depth=1"
    alias mkdir="mkdir -p"
    alias vim="vim" # Use vim if EDITOR is vim
    alias vi="vim"
    alias cls="clear" # Common alias for clear screen
    alias gs="git status"
    alias ga="git add"
    alias gc="git commit"
    alias pkg="pkg"   # Termux package manager
    alias sudo="tsudo" # Termux sudo replacement
    alias rustup="rustup"
    # Ensure python alias points to the correct executable path from PYTHONPATH
    alias python="$PYTHONPATH"
    # Custom script aliases
    alias gimg="bash '$HOME/gimg'"       # Ensure gimg script is executable and in $HOME
    alias price="python '$HOME/price'" # Ensure price script is executable and in $HOME
    alias pyrm="node '$HOME/bin/neoncli.js'" # Ensure node script exists
    # Kubernetes alias
    alias kb="kubectl"

    # --- Custom Functions ---

    # Search man pages
    man-search() {
        man -k "$@" | less 2>/dev/null || echo "No man pages found matching '$@'."
    }

    # List processes sorted by memory usage
    list_processes_by_memory() {
        ps -eo pid,user,%mem,%cpu,start,command --sort=-%mem | head -n 20 2>/dev/null || ps aux --sort=-%mem | head -n 20
    }

    # Update Termux packages
    update_all() {
        echo "Updating and upgrading Termux packages..."
        pkg update && pkg upgrade -y
        echo "Update complete."
    }

    # Sync dotfiles (assuming dotfiles are in $HOME and managed by git)
    sync_dotfiles() {
        local dotfiles_dir="$HOME" # Or specify your dotfiles repo path if different
        echo "Syncing dotfiles in $dotfiles_dir..."
        (cd "$dotfiles_dir" && git pull) && {
            echo "Dotfiles synced. Reloading Zsh configuration..."
            source "$ZSHRC"
        } || {
            echo "Failed to sync dotfiles." >&2
            return 1
        }
    }

    # Generate SSH key (consider adding path options)
    manage_ssh_keys() {
        local email="${1:-$(whoami)@$(hostname)}"
        local key_path="$HOME/.ssh/id_ed25519"
        echo "Generating ED25519 SSH key for $email"
        echo "Saving key to $key_path"
        ssh-keygen -t ed25519 -C "$email" -f "$key_path"
    }

    # Example SSH connection function (customize user/server)
    ssh_work() {
        local user="your_user"
        local server="work_server_address"
        echo "Connecting to $user@$server..."
        ssh "${user}@${server}"
    }

    # Generate a random password
    gen_password() {
        local length="${1:-16}" # Default length 16
        LC_ALL=C tr -dc 'A-Za-z0-9_!@#$%^&*()-+' < /dev/urandom | head -c "$length" ; echo
    }

    # Open current directory using Termux API
    open_dir() {
        if command -v termux-open > /dev/null 2>&1; then
            termux-open .
        else
            echo "Error: termux-open command not found. Install Termux:API package?" >&2
        fi
    }

    # Run a command in each subdirectory
    run_in_dirs() {
        if [[ $# -eq 0 ]]; then
            echo "Usage: run_in_dirs <command> [args...]" >&2
            return 1
        fi
        local cmd_to_run=("$@")
        for dir in */; do
            if [[ -d "$dir" ]]; then
                echo "--- Running in $dir ---"
                ( cd "$dir" && "${cmd_to_run[@]}" )
                echo "--- Done in $dir ---"
            fi
        done
    }

    # Find large files (default >100M) in current directory and subdirectories
    find_large_files() {
        local size_limit="${1:-+100M}"
        echo "Finding files larger than ${size_limit#+}..."
        find . -type f -size "$size_limit" -exec ls -lh {} \; 2>/dev/null || echo "Error during find operation."
    }

    # Shorten URL using a web service (example requires parsing, might break)
    # Consider a dedicated CLI tool for reliability.
    shorten_url() {
        if [[ -z "$1" ]]; then
            echo "Usage: shorten_url <URL>" >&2
            return 1
        fi
        echo "Shortening URL (using tinyurl as example)..."
        curl -s "https://tinyurl.com/api-create.php?url=$1" || echo "Error shortening URL."
    }

    # Clean temporary files (use with caution)
    clean_temp_files() {
        echo "Cleaning *.tmp files in home directory..."
        find "$HOME" -maxdepth 3 -type f -name "*.tmp" -print -delete
        echo "Done."
    }

    # Encrypt Zsh history using GnuPG
    encrypt_history() {
        local hist_file="$HISTFILE"
        local encrypted_hist_file="${hist_file}.gpg"
        if [[ -f "$hist_file" ]] && command -v gpg > /dev/null 2>&1; then
            echo "Encrypting Zsh history..."
            # Use --batch and --yes to avoid prompts, assumes key is available or password caching is setup
            gpg -c --batch --yes -o "$encrypted_hist_file" "$hist_file" && rm "$hist_file"
            echo "History encrypted to $encrypted_hist_file"
        elif ! command -v gpg > /dev/null 2>&1; then
            echo "gpg command not found. Cannot encrypt history." >&2
        fi
    }

    # Decrypt Zsh history using GnuPG
    decrypt_history() {
        local hist_file="$HISTFILE"
        local encrypted_hist_file="${hist_file}.gpg"
        if [[ -f "$encrypted_hist_file" ]] && command -v gpg > /dev/null 2>&1; then
            echo "Decrypting Zsh history..."
            # Suppress stderr for potentially noisy gpg messages during automated decryption
            gpg -d --batch --yes --quiet -o "$hist_file" "$encrypted_hist_file" 2>/dev/null
            # Check if decryption was successful
            if [[ $? -eq 0 ]]; then
              echo "History decrypted."
            else
              echo "Failed to decrypt history. Check GPG setup/password." >&2
              # Keep the encrypted file if decryption fails
            fi
        elif ! command -v gpg > /dev/null 2>&1; then
            # Silently fail if gpg not found, history won't load
            :
        fi
    }

    # Show Termux system information
    system_info() {
        if command -v termux-info > /dev/null 2>&1; then
            termux-info
        else
            echo "termux-info command not found. Install Termux:API package?" >&2
        fi
    }

    # Reload Zsh configuration
    update_shell() {
        echo "Reloading Zsh configuration..."
        source "$ZSHRC"
        echo "Zsh configuration reloaded."
    }

    # Simple welcome message
    welcome_message() {
        echo "Welcome back to Zsh! [$(date '+%Y-%m-%d %H:%M:%S')]"
    }

    # List currently defined aliases
    list_aliases() {
        alias
    }

    # List currently defined functions (excluding internal/private ones starting with _)
    list_functions() {
        typeset -f | grep -E '^[a-zA-Z][a-zA-Z0-9_]* \(\)' | sed 's/ \(\) {//'
    }

    # Search command history
    history_search() {
        if [[ $# -eq 0 ]]; then
            echo "Usage: history_search <pattern>" >&2
            return 1
        fi
        history | grep "$@"
    }

    # Backup essential dotfiles
    backup_dotfiles() {
        local backup_file="$HOME/dotfiles_backup_$(date +%Y%m%d_%H%M%S).tar.gz"
        local files_to_backup=("$ZSHRC")
        # Add custom config directory if it exists
        [[ -d "$ZSH_CUSTOM" ]] && files_to_backup+=("$ZSH_CUSTOM")
        # Add other important files/dirs, e.g., .vimrc, .gitconfig, .ssh/config
        [[ -f "$HOME/.vimrc" ]] && files_to_backup+=("$HOME/.vimrc")
        [[ -f "$HOME/.gitconfig" ]] && files_to_backup+=("$HOME/.gitconfig")
        [[ -f "$HOME/.config/aichat/config.yaml" ]] && files_to_backup+=("$HOME/.config/aichat/config.yaml") # Example

        echo "Backing up dotfiles to $backup_file..."
        tar -czf "$backup_file" "${files_to_backup[@]}" && echo "Backup successful." || echo "Backup failed." >&2
    }

    # Run a Python script safely
    run_python() {
        if [[ $# -ne 1 ]]; then
            echo "Usage: run_python <script.py>" >&2
            return 1
        fi
        local script_path="$1"
        if [[ ! -f "$script_path" ]]; then
            echo "Error: Script '$script_path' not found." >&2
            return 1
        fi
        if [[ -x "$PYTHONPATH" ]]; then
            "$PYTHONPATH" "$script_path"
        else
            echo "Error: Python interpreter at '$PYTHONPATH' not found or not executable." >&2
            return 1
        fi
    }

    # --- AIChat Integration ---
    # Assumes aichat is installed and in PATH
    export AICHA_CONFIG="$HOME/.config/aichat" # Standard config location

    # Check if aichat command exists
    if ! command -v aichat >/dev/null 2>&1; then
        echo "Warning: 'aichat' command not found. AI features will not work."
        echo "Install with: pkg install rust && cargo install aichat"
        echo "See: https://github.com/sigoden/aichat"
    fi

    # ZLE widget to get AI suggestions for the current command line buffer
    _aichat_zsh_suggest() {
        local current_buffer="$BUFFER"
        if [[ -z "$current_buffer" ]]; then
            zle send-break # Do nothing if buffer is empty
            echo "AIChat: Type a command first to get suggestions (Alt+E)"
            return 1
        fi

        if command -v aichat >/dev/null 2>&1; then
            echo -n "AI Suggesting for: '$current_buffer' ... "
            local suggestion
            # Use 'aichat gen' or 'aichat run' or appropriate subcommand based on aichat's features
            # This example assumes 'aichat explain' or similar might suggest improvements/alternatives
            suggestion=$(aichat --no-stream -m gemini-pro -q "$current_buffer" 2>/dev/null) # Example - adjust command as needed

            if [[ -n "$suggestion" ]]; then
                 echo "Suggestion ready."
                # Replace buffer with suggestion (or append, or offer choice - complex)
                # Simple replacement:
                # BUFFER="$suggestion"
                # CURSOR=${#BUFFER} # Move cursor to end
                # Or just display it:
                echo "\n--- AI Suggestion ---"
                echo "$suggestion"
                echo "---------------------"
                # Refresh prompt without executing
                 zle redisplay
            else
                echo "Error or no suggestion from aichat."
                zle send-break
            fi
        else
            echo "AIChat: 'aichat' command not found."
            zle send-break
        fi
        # Default: Do not execute automatically, let user review
        # zle accept-line
    }
    # Bind Alt+E (^[e) to the suggestion widget
    zle -N _aichat_zsh_suggest
    bindkey '^[e' _aichat_zsh_suggest # Meta+E (Alt+E or Esc then E)

    # Function to summarize output using aichat (if available)
    summarize_output() {
        local input_data
        # Read from stdin if no argument provided
        if [[ -t 0 ]] && [[ $# -eq 0 ]]; then
            echo "Usage: <command> | summarize_output"
            echo "   or: summarize_output \"Text to summarize\"" >&2
            return 1
        elif [[ $# -gt 0 ]]; then
            input_data="$1"
        else
            input_data=$(cat) # Read from pipe
        fi

        if command -v aichat >/dev/null 2>&1; then
            echo "$input_data" | aichat --no-stream -r summarize --max-length 5000 2>/dev/null || echo "Error summarizing with aichat."
        else
            # Fallback: Show first few lines
            echo "--- Output (aichat not found, showing beginning) ---"
            echo "$input_data" | head -n 5
        fi
    }


    # --- CCXT Bybit Trading Functions ---

    # IMPORTANT: Requires 'ccxt' and 'python-dotenv' Python libraries.
    # Install with: pip install ccxt python-dotenv
    # Ensure API keys are set in $HOME/.env file

    # Helper function to execute Bybit commands via Python/CCXT
    # Loads API keys from $HOME/.env
    _ccxt_bybit_python() {
      if ! command -v python >/dev/null 2>&1; then
        echo "Error: Python command not found." >&2
        return 1
      fi
      python -c "
    import ccxt
    import os
    import sys
    import warnings
    from dotenv import load_dotenv

    # Suppress specific warnings if needed (e.g., DeprecationWarning from ccxt)
    warnings.filterwarnings('ignore', category=UserWarning, module='ccxt')

    # Load environment variables from $HOME/.env
    dotenv_path = os.path.join(os.path.expanduser('~'), '.env')
    load_dotenv(dotenv_path=dotenv_path)

    exchange_id = 'bybit' # Or change if needed
    api_key = os.getenv('BYBIT_API_KEY')
    api_secret = os.getenv('BYBIT_SECRET')

    if not api_key or not api_secret:
        print(f'Error: BYBIT_API_KEY and BYBIT_API_SECRET must be set in {dotenv_path}.', file=sys.stderr)
        sys.exit(1)

    exchange_class = getattr(ccxt, exchange_id)
    exchange = exchange_class({
        'apiKey': api_key,
        'secret': api_secret,
        # Optional: Enable rate limiting
        # 'enableRateLimit': True,
        # Optional: Set sandbox mode if testing
        # 'urls': { 'api': 'https://api-testnet.bybit.com' }
    })

    # Ensure markets are loaded for symbol validation etc.
    try:
        exchange.load_markets()
    except Exception as e:
        print(f'Warning: Could not load markets: {e}', file=sys.stderr)
        # Decide if this is critical - for many operations it is.
        # sys.exit(1) # Uncomment to exit if markets can't load

    # Python code block passed as argument
    ${1}
    " || return 1 # Propagate Python exit code to Zsh
    }

    # --- Bybit Account & Market Data Functions (1-10) ---

    # 1. Get Account Balance (Shows non-zero balances)
    bybit_balance() {
      _ccxt_bybit_python "
    try:
        balance = exchange.fetch_balance()
        print('Bybit Account Balance:')
        # Check structure, could be balance['total'], balance['info'], etc.
        total_balance = balance.get('total', {})
        if total_balance:
            has_balance = False
            for currency, amount in sorted(total_balance.items()):
                if amount and float(amount) > 0:
                    print(f'  {currency}: {amount}')
                    has_balance = True
            if not has_balance:
                print('  No balances > 0 found.')
        else:
            print('Could not retrieve balance information or account is empty.')
            print(f'Raw balance response: {balance}') # Debug print
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching balance: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching balance: {e}', file=sys.stderr)
      "
    }

    # 2. Get Open Positions
    bybit_positions() {
      _ccxt_bybit_python "
    try:
        # Unified method fetch_positions should work for Bybit futures/swaps
        positions = exchange.fetch_positions()
        # Filter for positions that are actually open (amount != 0)
        # Bybit might return closed positions with amount 0 or side None
        open_positions = [p for p in positions if p.get('contracts') and float(p.get('contracts', 0)) != 0]

        if open_positions:
            print('Open Positions:')
            for pos in sorted(open_positions, key=lambda x: x['symbol']):
                symbol = pos.get('symbol', 'N/A')
                side = pos.get('side', 'N/A')
                contracts = pos.get('contracts', 'N/A') # Amount in contracts
                entry_price = pos.get('entryPrice', 'N/A')
                mark_price = pos.get('markPrice', 'N/A')
                liq_price = pos.get('liquidationPrice', 'N/A')
                leverage = pos.get('leverage', 'N/A')
                unrealized_pnl = pos.get('unrealizedPnl', 'N/A')
                margin = pos.get('initialMargin', 'N/A') # Or 'maintMargin'

                print(f\"\"\"\
      Symbol: {symbol}
        Side: {side.capitalize() if side else 'N/A'}, Size: {contracts}
        Entry: {entry_price}, Mark: {mark_price}, Liq: {liq_price}
        Leverage: {leverage}x, Margin: {margin}
        Unrealized PNL: {unrealized_pnl}
    \"\"\")
        else:
            print('No open positions found.')
    except ccxt.NotSupported as e:
        print(f'Error: fetch_positions might not be fully supported or requires specific market type params: {e}', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching positions: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching positions: {e}', file=sys.stderr)
      "
    }

    # 3. Get Current Leverage (Requires symbol - for perpetuals/futures)
    bybit_leverage() {
      if [ -z "$1" ]; then echo "Usage: bybit_leverage <symbol (e.g., BTC/USDT:USDT)>"; return 1; fi
      local symbol="$1"
      _ccxt_bybit_python "
    symbol = '$symbol'
    try:
        # Bybit requires symbol for fetching leverage
        leverage_info = exchange.fetch_leverage(symbol)
        print(f'Leverage Settings for {symbol}:')
        print(f'  Leverage: {leverage_info.get('leverage', 'N/A')}')
        # Bybit might return more info like margin mode in the response
        print(f'  Margin Mode: {leverage_info.get('marginMode', 'N/A').capitalize()}') # cross or isolated
        # print(f'Raw response: {leverage_info}') # Debug print
    except ccxt.NotSupported:
         print(f'Error: fetch_leverage not supported by exchange or for this symbol type.', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'. Use format like BTC/USDT:USDT for USDT perpetuals.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching leverage for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching leverage for {symbol}: {e}', file=sys.stderr)
      "
    }

    # 4. Set Leverage (Requires symbol and leverage value - for perpetuals/futures)
    bybit_set_leverage() {
      if [ -z "$1" ] || [ -z "$2" ]; then echo "Usage: bybit_set_leverage <symbol (e.g., BTC/USDT:USDT)> <leverage (e.g., 10)>"; return 1; fi
      local symbol="$1"
      local leverage_value="$2"
      _ccxt_bybit_python "
    symbol = '$symbol'
    leverage = float('$leverage_value') # Leverage can be float (e.g., 10.5) on some exchanges/tiers
    if leverage <= 0:
        print('Error: Leverage must be a positive number.', file=sys.stderr)
        sys.exit(1)
    try:
        result = exchange.set_leverage(leverage, symbol)
        print(f'Leverage for {symbol} set request sent.')
        # The response from set_leverage varies; might confirm the set value or just acknowledge
        print(f'Response: {result}')
    except ccxt.NotSupported:
         print(f'Error: set_leverage not supported by exchange or for this symbol type.', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'. Use format like BTC/USDT:USDT for USDT perpetuals.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error setting leverage for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error setting leverage for {symbol}: {e}', file=sys.stderr)
      "
    }

    # 5. Get All Available Markets from Bybit
    bybit_markets() {
      _ccxt_bybit_python "
    try:
        # load_markets is usually called implicitly, but can be called explicitly
        markets = exchange.markets
        if markets:
            print('Bybit Markets (Loaded):')
            # Filter example: Show only USDT perpetuals
            usdt_perps = {s: m for s, m in markets.items() if m.get('swap') and m.get('linear') and m.get('quote') == 'USDT'}
            print(f'Found {len(usdt_perps)} USDT Perpetual Markets:')
            for symbol, market in sorted(usdt_perps.items()):
                 print(f'  {symbol}') # Add more details if needed: market['type'], market['base'], market['active']
            print(f'\nTotal markets loaded: {len(markets)}')
        else:
            print('No markets seem to be loaded.')
    except Exception as e:
        print(f'Error fetching or processing markets: {e}', file=sys.stderr)
      "
    }

    # 6. Get Tickers for All Markets (Can be very verbose and slow)
    bybit_tickers() {
      echo "Fetching tickers for all markets... this may take a while."
      _ccxt_bybit_python "
    try:
        tickers = exchange.fetch_tickers()
        if tickers:
            print('Bybit Tickers (Showing USDT Perpetuals Example):')
            for symbol, ticker in sorted(tickers.items()):
                # Example filter: Only show USDT perpetuals
                 market = exchange.markets_by_id.get(ticker.get('info', {}).get('symbol')) # Need to map back to market info
                 if market and market.get('swap') and market.get('linear') and market.get('quote') == 'USDT':
                    last_price = ticker.get('last', 'N/A')
                    change_24h = ticker.get('percentage', 'N/A')
                    volume_24h = ticker.get('baseVolume', 'N/A') # Volume in base currency
                    print(f'  {symbol}: Last={last_price}, Change={change_24h}%, Vol={volume_24h}')
            print(f'\nTotal tickers fetched: {len(tickers)}')
        else:
            print('Could not fetch tickers.')
    except ccxt.NotSupported:
         print(f'Error: fetch_tickers not supported by exchange.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching tickers: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching tickers: {e}', file=sys.stderr)
      "
    }

    # 7. Get Ticker for a Specific Symbol
    bybit_ticker() {
      if [ -z "$1" ]; then echo "Usage: bybit_ticker <symbol (e.g., BTC/USDT:USDT)>"; return 1; fi
      local symbol="$1"
      _ccxt_bybit_python "
    symbol = '$symbol'
    try:
        ticker = exchange.fetch_ticker(symbol)
        print(f'Ticker for {symbol}:')
        print(f\"\"\"\
      Last Price: {ticker.get('last', 'N/A')}
      Bid: {ticker.get('bid', 'N/A')}, Ask: {ticker.get('ask', 'N/A')}
      High (24h): {ticker.get('high', 'N/A')}, Low (24h): {ticker.get('low', 'N/A')}
      Volume (24h Base): {ticker.get('baseVolume', 'N/A')}, Volume (24h Quote): {ticker.get('quoteVolume', 'N/A')}
      Change (24h %): {ticker.get('percentage', 'N/A')}%
      Timestamp: {ticker.get('datetime', 'N/A')}
    \"\"\")
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'. Use format like BTC/USDT:USDT for USDT perpetuals.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching ticker for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching ticker for {symbol}: {e}', file=sys.stderr)
      "
    }

    # 8. Get Order Book for a Symbol
    bybit_orderbook() {
      if [ -z "$1" ]; then echo "Usage: bybit_orderbook <symbol (e.g., BTC/USDT:USDT)> [limit=5]"; return 1; fi
      local symbol="$1"
      local limit=${2:-5} # Default limit 5 levels
      _ccxt_bybit_python "
    symbol = '$symbol'
    limit = int('$limit')
    try:
        orderbook = exchange.fetch_order_book(symbol, limit=limit)
        print(f'Order Book for {symbol} (Top {limit} Levels):')
        print('  Asks (Price, Amount):')
        for price, amount in orderbook.get('asks', []):
            print(f'    {price}, {amount}')
        print('\\n  Bids (Price, Amount):')
        for price, amount in orderbook.get('bids', []):
            print(f'    {price}, {amount}')
        print(f'\\n  Timestamp: {orderbook.get('datetime', 'N/A')}')
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'. Use format like BTC/USDT:USDT for USDT perpetuals.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching order book for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching order book for {symbol}: {e}', file=sys.stderr)
      "
    }

    # 9. Get Recent Public Trades for a Symbol
    bybit_trades() {
      if [ -z "$1" ]; then echo "Usage: bybit_trades <symbol (e.g., BTC/USDT:USDT)> [limit=10]"; return 1; fi
      local symbol="$1"
      local limit=${2:-10} # Default limit 10 trades
      _ccxt_bybit_python "
    symbol = '$symbol'
    limit = int('$limit')
    try:
        trades = exchange.fetch_trades(symbol, limit=limit)
        if trades:
            print(f'Recent Public Trades for {symbol} (Last {limit}):')
            # Trades are usually returned newest first by ccxt
            for trade in trades:
                 timestamp = trade.get('datetime', 'N/A')
                 side = trade.get('side', 'N/A')
                 price = trade.get('price', 'N/A')
                 amount = trade.get('amount', 'N/A') # Amount in base currency
                 cost = trade.get('cost', 'N/A')     # Amount in quote currency
                 print(f'  {timestamp} - {side.upper()} - Price: {price}, Amount: {amount}, Cost: {cost}')
        else:
            print(f'No recent trades found for {symbol}.')
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'. Use format like BTC/USDT:USDT for USDT perpetuals.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching trades for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching trades for {symbol}: {e}', file=sys.stderr)
      "
    }

    # 10. Get OHLCV Data (Candlesticks)
    bybit_ohlcv() {
      # Usage: bybit_ohlcv <symbol> [timeframe=1h] [limit=20] [since_timestamp_ms]
      if [ -z "$1" ]; then echo "Usage: bybit_ohlcv <symbol> [timeframe=1h] [limit=20] [since_timestamp_ms]"; return 1; fi
      local symbol="$1"
      local timeframe=${2:-'1h'} # Default timeframe 1 hour
      local limit=${3:-20}      # Default limit 20 candles
      local since=${4:-None}     # Optional: Start time in milliseconds UTC
      _ccxt_bybit_python "
    symbol = '$symbol'
    timeframe = '$timeframe'
    limit = int('$limit')
    since = int('$since') if '$since' != 'None' else None

    # Validate timeframe against exchange's known timeframes
    if timeframe not in exchange.timeframes:
        print(f'Error: Invalid timeframe \'{timeframe}\'. Available timeframes:', list(exchange.timeframes.keys()), file=sys.stderr)
        sys.exit(1)

    try:
        ohlcv = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit, since=since)
        if ohlcv:
            print(f'OHLCV Data for {symbol} ({timeframe}, Limit: {limit}{", Since: " + exchange.iso8601(since) if since else ""}):')
            print('  Timestamp (UTC)        Open     High      Low     Close    Volume')
            print('  ------------------- -------- -------- -------- -------- ---------')
            for candle in ohlcv:
                ts, o, h, l, c, v = candle
                dt = exchange.iso8601(ts)
                print(f'  {dt} {o:>8.2f} {h:>8.2f} {l:>8.2f} {c:>8.2f} {v:>9.2f}') # Adjust precision as needed
        else:
            print(f'No OHLCV data found for {symbol} with the given parameters.')
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'. Use format like BTC/USDT:USDT for USDT perpetuals.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching OHLCV for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching OHLCV for {symbol}: {e}', file=sys.stderr)
     "
    }


    # --- Bybit Trading Execution Functions (11-20) ---

    # 11. Create Market Buy Order
    # Usage: bybit_market_buy <symbol> <amount_base_currency> [params_json]
    bybit_market_buy() {
      if [ -z "$1" ] || [ -z "$2" ]; then echo "Usage: bybit_market_buy <symbol> <amount> [params_json='{\"timeInForce\":\"IOC\"}']"; return 1; fi
      local symbol="$1"
      local amount="$2"
      local params_json="${3:-{\}}" # Default empty JSON object for params
      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    amount = float('$amount')
    params = json.loads('''$params_json''') # Parse JSON params string
    if amount <= 0:
        print('Error: Amount must be positive.', file=sys.stderr); sys.exit(1)
    try:
        print(f'Attempting Market Buy: {amount} {symbol.split('/')[0]}...')
        order = exchange.create_market_buy_order(symbol, amount, params)
        print('Market Buy Order Submitted Successfully:')
        print(json.dumps(order, indent=2)) # Pretty print the order details
    except ccxt.InsufficientFunds as e:
         print(f'Error: Insufficient funds to place market buy order. Details: {e}', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error creating market buy order: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error creating market buy order: {e}', file=sys.stderr)
      "
    }

    # 12. Create Market Sell Order
    # Usage: bybit_market_sell <symbol> <amount_base_currency> [params_json]
    bybit_market_sell() {
      if [ -z "$1" ] || [ -z "$2" ]; then echo "Usage: bybit_market_sell <symbol> <amount> [params_json='{\"reduceOnly\":false}']"; return 1; fi
      local symbol="$1"
      local amount="$2"
      local params_json="${3:-{\}}"
       _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    amount = float('$amount')
    params = json.loads('''$params_json''')
    if amount <= 0:
        print('Error: Amount must be positive.', file=sys.stderr); sys.exit(1)
    try:
        print(f'Attempting Market Sell: {amount} {symbol.split('/')[0]}...')
        order = exchange.create_market_sell_order(symbol, amount, params)
        print('Market Sell Order Submitted Successfully:')
        print(json.dumps(order, indent=2))
    except ccxt.InsufficientFunds as e: # Might occur if trying to sell more than owned/margined
         print(f'Error: Insufficient funds/position for market sell order. Details: {e}', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error creating market sell order: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error creating market sell order: {e}', file=sys.stderr)
      "
    }

    # 13. Create Limit Buy Order
    # Usage: bybit_limit_buy <symbol> <amount> <price> [params_json]
    bybit_limit_buy() {
      if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]; then echo "Usage: bybit_limit_buy <symbol> <amount> <price> [params_json='{\"postOnly\":false}']"; return 1; fi
      local symbol="$1"
      local amount="$2"
      local price="$3"
      local params_json="${4:-{\}}"
      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    amount = float('$amount')
    price = float('$price')
    params = json.loads('''$params_json''')
    if amount <= 0 or price <= 0:
        print('Error: Amount and Price must be positive.', file=sys.stderr); sys.exit(1)
    try:
        print(f'Attempting Limit Buy: {amount} {symbol.split('/')[0]} @ {price}...')
        order = exchange.create_limit_buy_order(symbol, amount, price, params)
        print('Limit Buy Order Submitted Successfully:')
        print(json.dumps(order, indent=2))
    except ccxt.InsufficientFunds as e:
         print(f'Error: Insufficient funds for limit buy order. Details: {e}', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error creating limit buy order: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error creating limit buy order: {e}', file=sys.stderr)
      "
    }

    # 14. Create Limit Sell Order
    # Usage: bybit_limit_sell <symbol> <amount> <price> [params_json]
    bybit_limit_sell() {
      if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]; then echo "Usage: bybit_limit_sell <symbol> <amount> <price> [params_json='{\"reduceOnly\":false}']"; return 1; fi
      local symbol="$1"
      local amount="$2"
      local price="$3"
      local params_json="${4:-{\}}"
      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    amount = float('$amount')
    price = float('$price')
    params = json.loads('''$params_json''')
    if amount <= 0 or price <= 0:
        print('Error: Amount and Price must be positive.', file=sys.stderr); sys.exit(1)
    try:
        print(f'Attempting Limit Sell: {amount} {symbol.split('/')[0]} @ {price}...')
        order = exchange.create_limit_sell_order(symbol, amount, price, params)
        print('Limit Sell Order Submitted Successfully:')
        print(json.dumps(order, indent=2))
    except ccxt.InsufficientFunds as e: # Selling more than available
         print(f'Error: Insufficient funds/position for limit sell order. Details: {e}', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error creating limit sell order: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error creating limit sell order: {e}', file=sys.stderr)
      "
    }

    # 15. Cancel Order (Requires order ID and symbol)
    bybit_cancel_order() {
      if [ -z "$1" ] || [ -z "$2" ]; then echo "Usage: bybit_cancel_order <order_id> <symbol>"; return 1; fi
      local order_id="$1"
      local symbol="$2"
      _ccxt_bybit_python "
    import json
    order_id = '$order_id'
    symbol = '$symbol'
    try:
        print(f'Attempting to cancel order {order_id} for {symbol}...')
        result = exchange.cancel_order(order_id, symbol)
        print(f'Cancel request for order {order_id} sent. Response:')
        # Response format varies; sometimes it's the order info after cancellation attempt
        print(json.dumps(result, indent=2))
    except ccxt.OrderNotFound as e:
         print(f'Error: Order {order_id} for {symbol} not found or already closed/cancelled. Details: {e}', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error cancelling order {order_id}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error cancelling order {order_id}: {e}', file=sys.stderr)
      "
    }

    # 16. Cancel All Open Orders (Requires symbol)
    bybit_cancel_all_orders() {
      if [ -z "$1" ]; then echo "Usage: bybit_cancel_all_orders <symbol>"; return 1; fi
      local symbol="$1"
      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    try:
        print(f'Attempting to cancel ALL open orders for {symbol}...')
        result = exchange.cancel_all_orders(symbol)
        print(f'Cancel all orders request for {symbol} sent. Response:')
        print(json.dumps(result, indent=2)) # Often returns a list of cancelled order statuses
    except ccxt.NotSupported:
         print(f'Error: cancel_all_orders not supported by exchange or requires different params.', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error cancelling all orders for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error cancelling all orders for {symbol}: {e}', file=sys.stderr)
      "
    }

    # 17. Fetch Order Details (Requires order ID and symbol)
    bybit_fetch_order() {
      if [ -z "$1" ] || [ -z "$2" ]; then echo "Usage: bybit_fetch_order <order_id> <symbol>"; return 1; fi
      local order_id="$1"
      local symbol="$2"
      _ccxt_bybit_python "
    import json
    order_id = '$order_id'
    symbol = '$symbol'
    try:
        order = exchange.fetch_order(order_id, symbol)
        print(f'Details for Order ID {order_id} ({symbol}):')
        print(json.dumps(order, indent=2))
    except ccxt.OrderNotFound as e:
         print(f'Error: Order {order_id} for {symbol} not found. Details: {e}', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching order {order_id}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching order {order_id}: {e}', file=sys.stderr)
      "
    }

    # 18. Fetch Open Orders (Requires symbol)
    # Note: fetch_orders without status usually gets open orders, but behavior can vary.
    bybit_fetch_open_orders() { # Renamed for clarity
      if [ -z "$1" ]; then echo "Usage: bybit_fetch_open_orders <symbol>"; return 1; fi
      local symbol="$1"
      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    try:
        # fetch_open_orders is the explicit method for this
        orders = exchange.fetch_open_orders(symbol)
        if orders:
            print(f'Open Orders for {symbol}:')
            for order in sorted(orders, key=lambda x: x['timestamp']):
                order_id = order.get('id', 'N/A')
                status = order.get('status', 'N/A')
                otype = order.get('type', 'N/A')
                side = order.get('side', 'N/A')
                amount = order.get('amount', 'N/A')
                price = order.get('price', 'N/A')
                filled = order.get('filled', 'N/A')
                timestamp = order.get('datetime', 'N/A')
                print(f'  ID: {order_id}, Status: {status}, Type: {otype}, Side: {side}, Amount: {amount}, Filled: {filled}, Price: {price}, Time: {timestamp}')
        else:
            print(f'No open orders found for {symbol}.')
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching open orders for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching open orders for {symbol}: {e}', file=sys.stderr)
      "
    }

    # 19. Fetch Closed Orders (Requires symbol, optional limit)
    bybit_fetch_closed_orders() {
      if [ -z "$1" ]; then echo "Usage: bybit_fetch_closed_orders <symbol> [limit=10]"; return 1; fi
      local symbol="$1"
      local limit=${2:-10}
      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    limit = int('$limit')
    try:
        orders = exchange.fetch_closed_orders(symbol, limit=limit)
        if orders:
            print(f'Last {limit} Closed/Cancelled Orders for {symbol}:')
            # Orders usually returned newest first
            for order in orders:
                order_id = order.get('id', 'N/A')
                status = order.get('status', 'N/A') # should be 'closed' or 'canceled'
                otype = order.get('type', 'N/A')
                side = order.get('side', 'N/A')
                amount = order.get('amount', 'N/A')
                price = order.get('average') or order.get('price', 'N/A') # Use average fill price if available
                filled = order.get('filled', 'N/A')
                timestamp = order.get('datetime', 'N/A')
                print(f'  ID: {order_id}, Status: {status}, Type: {otype}, Side: {side}, Amount: {amount}, Filled: {filled}, Price: {price}, Time: {timestamp}')
        else:
            print(f'No closed orders found for {symbol}.')
    except ccxt.NotSupported:
         print(f'Error: fetch_closed_orders not directly supported. Try fetch_orders with status params if available.', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching closed orders for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching closed orders for {symbol}: {e}', file=sys.stderr)
      "
    }

    # 20. Fetch My Trades (Requires symbol, optional limit)
    bybit_fetch_my_trades() {
      if [ -z "$1" ]; then echo "Usage: bybit_fetch_my_trades <symbol> [limit=10]"; return 1; fi
      local symbol="$1"
      local limit=${2:-10}
      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    limit = int('$limit')
    try:
        trades = exchange.fetch_my_trades(symbol, limit=limit)
        if trades:
            print(f'Last {limit} Trades for {symbol}:')
            # Trades usually returned newest first
            for trade in trades:
                trade_id = trade.get('id', 'N/A')
                order_id = trade.get('order', 'N/A')
                timestamp = trade.get('datetime', 'N/A')
                side = trade.get('side', 'N/A')
                price = trade.get('price', 'N/A')
                amount = trade.get('amount', 'N/A')
                cost = trade.get('cost', 'N/A')
                fee_cost = trade.get('fee', {}).get('cost', 'N/A')
                fee_curr = trade.get('fee', {}).get('currency', 'N/A')
                print(f'  ID: {trade_id}, OrderID: {order_id}, Time: {timestamp}, Side: {side.upper()}, Price: {price}, Amount: {amount}, Cost: {cost}, Fee: {fee_cost} {fee_curr}')
        else:
            print(f'No trades found for {symbol}.')
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching trades for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching trades for {symbol}: {e}', file=sys.stderr)
      "
    }

    # --- Bybit Advanced Account/Market Functions (21-40) ---

    # 21. Get Wallet Balance (Specific Currency - e.g., USDT)
    bybit_wallet_balance() {
      if [ -z "$1" ]; then echo "Usage: bybit_wallet_balance <currency_code (e.g., USDT)>"; return 1; fi
      local currency_code=$(echo "$1" | tr '[:lower:]' '[:upper:]') # Ensure uppercase
      _ccxt_bybit_python "
    currency = '$currency_code'
    try:
        # Fetch balance for all assets, then filter
        balance = exchange.fetch_balance()
        print(f'Wallet Balance for {currency}:')

        if currency in balance:
            details = balance[currency]
            total = details.get('total', 'N/A')
            free = details.get('free', 'N/A')
            used = details.get('used', 'N/A')
            print(f'  Total: {total}')
            print(f'  Free:  {free}')
            print(f'  Used:  {used}')
        elif currency in balance.get('total', {}): # Sometimes it's just in 'total'
             total = balance['total'][currency]
             # Free/used might need parsing from balance['info'] or other keys
             print(f'  Total: {total}')
             print('  (Detailed free/used might require parsing balance info)')

        else:
            print(f'Could not retrieve balance details for {currency}. Currency might not exist or have zero balance.')
            # print(f'Available currencies with balance: {list(balance.get('total', {}).keys())}') # Debug
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching wallet balance: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching wallet balance for {currency}: {e}', file=sys.stderr)
      "
    }

    # 22. Get Order History (All orders, Requires symbol, optional limit, optional since)
    bybit_order_history() {
      # Usage: bybit_order_history <symbol> [limit=20] [since_timestamp_ms]
      if [ -z "$1" ]; then echo "Usage: bybit_order_history <symbol> [limit=20] [since_timestamp_ms]"; return 1; fi
      local symbol="$1"
      local limit=${2:-20}
      local since=${3:-None}
      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    limit = int('$limit')
    since = int('$since') if '$since' != 'None' else None
    try:
        orders = exchange.fetch_orders(symbol, limit=limit, since=since) # fetches both open and closed/cancelled within timeframe
        if orders:
            print(f'Last {len(orders)} Orders (History) for {symbol}{" Since " + exchange.iso8601(since) if since else ""}:')
            # Orders usually returned newest first
            sorted_orders = sorted(orders, key=lambda x: x['timestamp'], reverse=True)
            for order in sorted_orders:
                order_id = order.get('id', 'N/A')
                status = order.get('status', 'N/A')
                otype = order.get('type', 'N/A')
                side = order.get('side', 'N/A')
                amount = order.get('amount', 'N/A')
                price = order.get('average') or order.get('price', 'N/A') # Prefer avg fill price
                filled = order.get('filled', 'N/A')
                timestamp = order.get('datetime', 'N/A')
                print(f'  ID: {order_id}, Time: {timestamp}, Status: {status}, Type: {otype}, Side: {side.upper()}, Amount: {amount}, Filled: {filled}, Price: {price}')
        else:
            print(f'No order history found for {symbol} within the specified parameters.')
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching order history for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching order history for {symbol}: {e}', file=sys.stderr)
      "
    }


    # 23. Get Funding Rate History (Requires symbol, optional limit, optional since)
    bybit_funding_rates() {
      # Usage: bybit_funding_rates <symbol> [limit=20] [since_timestamp_ms]
      if [ -z "$1" ]; then echo "Usage: bybit_funding_rates <symbol> [limit=20] [since_timestamp_ms]"; return 1; fi
      local symbol="$1"
      local limit=${2:-20}
      local since=${3:-None}
      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    limit = int('$limit')
    since = int('$since') if '$since' != 'None' else None
    try:
        # Ensure the symbol is a swap/future market
        market = exchange.market(symbol)
        if not market.get('swap'):
            print(f'Error: Funding rates only apply to swap/futures markets. {symbol} is a {market.get('type')} market.', file=sys.stderr)
            sys.exit(1)

        funding_rates = exchange.fetch_funding_rate_history(symbol, limit=limit, since=since)
        if funding_rates:
            print(f'Last {len(funding_rates)} Funding Rates for {symbol}{" Since " + exchange.iso8601(since) if since else ""}:')
            # Rates usually returned newest first
            for rate in funding_rates:
                timestamp = rate.get('datetime', 'N/A')
                funding_rate = rate.get('fundingRate', 'N/A')
                # Convert rate to percentage for display
                funding_rate_percent = f'{funding_rate * 100:.4f}%' if isinstance(funding_rate, (int, float)) else 'N/A'
                print(f'  {timestamp} - Rate: {funding_rate_percent}')
        else:
            print(f'No funding rate history found for {symbol} within the specified parameters.')
    except ccxt.NotSupported:
        print(f'Error: fetch_funding_rate_history is not supported by the exchange via CCXT.', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\' or not a swap market.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching funding rates for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching funding rates for {symbol}: {e}', file=sys.stderr)
      "
    }

    # 24. Get Last Funding Rate (Requires symbol)
    bybit_last_funding_rate() {
      if [ -z "$1" ]; then echo "Usage: bybit_last_funding_rate <symbol>"; return 1; fi
      local symbol="$1"
      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    try:
        market = exchange.market(symbol)
        if not market.get('swap'):
            print(f'Error: Funding rates only apply to swap/futures markets. {symbol} is a {market.get('type')} market.', file=sys.stderr)
            sys.exit(1)

        # fetchFundingRate gets the *next* predicted rate. fetchFundingRates/History gets past rates.
        # Let's get the most recent historical rate instead for 'last' paid/received rate.
        last_funding_event = exchange.fetch_funding_rate_history(symbol, limit=1) # Fetch the single most recent history entry

        if last_funding_event:
            last_rate_info = last_funding_event[0]
            timestamp = last_rate_info.get('datetime', 'N/A')
            funding_rate = last_rate_info.get('fundingRate', 'N/A')
            funding_rate_percent = f'{funding_rate * 100:.4f}%' if isinstance(funding_rate, (int, float)) else 'N/A'
            print(f'Last Funding Rate Event for {symbol} @ {timestamp}:')
            print(f'  Rate: {funding_rate_percent}')

            # Optional: Fetch predicted next rate too
            try:
                next_funding_rate_info = exchange.fetch_funding_rate(symbol)
                next_timestamp = next_funding_rate_info.get('datetime', 'N/A')
                next_rate = next_funding_rate_info.get('fundingRate', 'N/A')
                next_rate_percent = f'{next_rate * 100:.4f}%' if isinstance(next_rate, (int, float)) else 'N/A'
                print(f'\\nPredicted Next Funding Rate Event for {symbol} @ {next_timestamp}:')
                print(f'  Predicted Rate: {next_rate_percent}')
            except Exception as next_e:
                print(f'\\nCould not fetch predicted next funding rate: {next_e}', file=sys.stderr)

        else:
           print(f'Could not fetch the last funding rate for {symbol}.')

    except ccxt.NotSupported:
        print(f'Error: fetch_funding_rate_history/fetch_funding_rate is not supported.', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\' or not a swap market.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching last funding rate for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching last funding rate for {symbol}: {e}', file=sys.stderr)
      "
    }

    # 25. Create Stop Loss Order (Market Stop - Requires symbol, side, amount, stopPrice)
    # Usage: bybit_market_stop_loss <symbol> <side> <amount> <stop_price> [params_json='{\"reduceOnly\": true}']
    bybit_market_stop_loss() {
      if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ] || [ -z "$4" ]; then
          echo "Usage: bybit_market_stop_loss <symbol> <side (buy/sell)> <amount> <stop_price> [params_json='{\"reduceOnly\": true}']"
          echo "Example (Stop loss for a Long position): bybit_market_stop_loss BTC/USDT:USDT sell 0.01 20000"
          echo "Example (Stop loss for a Short position): bybit_market_stop_loss BTC/USDT:USDT buy 0.01 30000"
          return 1
      fi
      local symbol="$1"
      local side=$(echo "$2" | tr '[:upper:]' '[:lower:]')
      local amount="$3"
      local stop_price="$4"
      local params_json="${5:-{\"reduceOnly\": true}}" # Default to reduceOnly for safety

      if [[ "$side" != "buy" && "$side" != "sell" ]]; then echo "Error: side must be 'buy' or 'sell'"; return 1; fi

      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    side = '$side'
    amount = float('$amount')
    stop_price = float('$stop_price')
    # Base params for a market stop loss order
    params = {
        'stopPrice': stop_price, # The trigger price for the stop loss
        'trigger': 'market',    # Type of order once triggered (market) - specific to some exchanges? CCXT handles this.
        'type': 'stop_market', # Often needed explicitly for Bybit via CCXT unified API (check create_order unified params)
        'basePrice': stop_price, # Bybit might use basePrice for trigger
        'triggerPrice': stop_price, # Bybit API often uses triggerPrice
        'triggerDirection': 1 if side == 'buy' else 2, # Bybit specific: 1=above trigger, 2=below trigger
    }
    # Merge with user-provided params (e.g., reduceOnly)
    user_params = json.loads('''$params_json''')
    params.update(user_params)

    if amount <= 0 or stop_price <= 0:
        print('Error: Amount and Stop Price must be positive.', file=sys.stderr); sys.exit(1)

    try:
        # Using create_order which is more flexible for stop orders
        # Market stops often mean type=market, with stopPrice in params
        # Let's try explicit stop_market type via create_order
        print(f'Attempting Market Stop {side.capitalize()} Order: {amount} {symbol.split(\"/\")[0]} triggered at {stop_price}...')
        # Use create_order with type='stop_market' or 'market' and stopPrice param
        # Exact method depends on CCXT implementation for Bybit
        # Trial 1: create_order with specific type
        # order = exchange.create_order(symbol, 'stop_market', side, amount, None, params)
        # Trial 2: create_market_order with stopPrice param (might be simpler if supported)
        market_order_params = {'stopPrice': stop_price}
        market_order_params.update(user_params) # Add reduceOnly etc.
        # Market stop buy/sell functions might support stopPrice directly
        if side == 'buy':
            order = exchange.create_market_buy_order(symbol, amount, market_order_params)
        else: # side == 'sell'
            order = exchange.create_market_sell_order(symbol, amount, market_order_params)

        print('Market Stop Loss Order Submitted Successfully:')
        print(json.dumps(order, indent=2))

    except ccxt.NotSupported as e:
         print(f'Error: Stop Loss order type or params not supported as specified. Try different params/type. Details: {e}', file=sys.stderr)
    except ccxt.InsufficientFunds as e:
         print(f'Error: Insufficient funds/position for stop loss order. Details: {e}', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error creating market stop loss order: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error creating market stop loss order: {e}', file=sys.stderr)
      "
    }


    # 26. Create Take Profit Order (Market Take Profit - Requires symbol, side, amount, takeProfitPrice)
    # Usage: bybit_market_take_profit <symbol> <side> <amount> <tp_price> [params_json='{\"reduceOnly\": true}']
    bybit_market_take_profit() {
       if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ] || [ -z "$4" ]; then
          echo "Usage: bybit_market_take_profit <symbol> <side (buy/sell)> <amount> <tp_price> [params_json='{\"reduceOnly\": true}']"
          echo "Example (Take profit for a Long position): bybit_market_take_profit BTC/USDT:USDT sell 0.01 30000"
          echo "Example (Take profit for a Short position): bybit_market_take_profit BTC/USDT:USDT buy 0.01 20000"
          return 1
      fi
      local symbol="$1"
      local side=$(echo "$2" | tr '[:upper:]' '[:lower:]')
      local amount="$3"
      local tp_price="$4"
      local params_json="${5:-{\"reduceOnly\": true}}"

      if [[ "$side" != "buy" && "$side" != "sell" ]]; then echo "Error: side must be 'buy' or 'sell'"; return 1; fi

      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    side = '$side'
    amount = float('$amount')
    tp_price = float('$tp_price')
    # Base params for a market take profit order
    params = {
        'takeProfitPrice': tp_price, # The trigger price for the take profit
        'type': 'take_profit_market', # Often needed explicitly for Bybit via CCXT
        'basePrice': tp_price, # Bybit might use basePrice for trigger
        'triggerPrice': tp_price, # Bybit API often uses triggerPrice
        'triggerDirection': 1 if side == 'sell' else 2, # TP trigger direction opposite to position: 1=above (for shorts), 2=below (for longs) - Bybit logic might vary, double check docs
    }
    # Merge with user-provided params
    user_params = json.loads('''$params_json''')
    params.update(user_params)

    if amount <= 0 or tp_price <= 0:
        print('Error: Amount and Take Profit Price must be positive.', file=sys.stderr); sys.exit(1)

    try:
        # Using create_order which is more flexible for TP orders
        print(f'Attempting Market Take Profit {side.capitalize()} Order: {amount} {symbol.split(\"/\")[0]} triggered at {tp_price}...')
        # Use create_order with type='take_profit_market' or 'market' and takeProfit price param
        # Exact method depends on CCXT implementation for Bybit
        # order = exchange.create_order(symbol, 'take_profit_market', side, amount, None, params)

        # Simpler approach if market buy/sell support takeProfitPrice:
        market_order_params = {'takeProfitPrice': tp_price}
        market_order_params.update(user_params) # Add reduceOnly etc.
        if side == 'buy':
            order = exchange.create_market_buy_order(symbol, amount, market_order_params)
        else: # side == 'sell'
            order = exchange.create_market_sell_order(symbol, amount, market_order_params)

        print('Market Take Profit Order Submitted Successfully:')
        print(json.dumps(order, indent=2))

    except ccxt.NotSupported as e:
         print(f'Error: Take Profit order type or params not supported as specified. Try different params/type. Details: {e}', file=sys.stderr)
    except ccxt.InsufficientFunds as e:
         print(f'Error: Insufficient funds/position for take profit order. Details: {e}', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error creating market take profit order: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error creating market take profit order: {e}', file=sys.stderr)
      "
    }

    # 27. Set Position Mode (Hedge Mode or One-Way Mode - affects applicable markets)
    bybit_set_position_mode() {
      if [ -z "$1" ]; then echo "Usage: bybit_set_position_mode <Hedged | OneWay>"; return 1; fi
      local mode_input="$1"
      local mode_bool # CCXT uses True for Hedged, False for OneWay

      if [[ "${mode_input,,}" == "hedged" || "${mode_input,,}" == "hedge" ]]; then
          mode_bool="True"
      elif [[ "${mode_input,,}" == "oneway" ]]; then
          mode_bool="False"
      else
          echo "Error: Invalid mode. Use 'Hedged' or 'OneWay'." >&2; return 1
      fi

      _ccxt_bybit_python "
    hedged_mode = $mode_bool
    try:
        # Check if the exchange supports setting position mode
        if not exchange.has.get('setPositionMode'):
             print('Error: Exchange does not support setting position mode via CCXT.', file=sys.stderr)
             sys.exit(1)

        result = exchange.set_position_mode(hedged=hedged_mode) # Pass hedged=True/False
        mode_str = 'Hedged' if hedged_mode else 'One-Way'
        print(f'Position mode set request to {mode_str} sent.')
        print(f'Response: {result}') # Response might just be success/failure status
    except ccxt.NotSupported:
         print(f'Error: Setting position mode not supported by exchange via CCXT.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e: # Could be because mode is already set, or conflicts
        print(f'Exchange Error setting position mode: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error setting position mode: {e}', file=sys.stderr)
     "
    }

    # 28. Get Position Mode
    bybit_get_position_mode() {
      _ccxt_bybit_python "
    try:
        # Check if the exchange supports fetching position mode
        if not exchange.has.get('fetchPositionMode'):
             print('Error: Exchange does not support fetching position mode via CCXT.', file=sys.stderr)
             sys.exit(1)

        # fetchPositionMode might require a symbol or return a general setting
        # Bybit's setting is usually account-wide for a market type (e.g., USDT perpetuals)
        position_mode_result = exchange.fetch_position_mode() # May need adjustments based on exact CCXT implementation for Bybit

        # Parse the result which might be in 'info' or a specific field
        # Example hypothetical structure: {'info': {'positionMode': 'Hedged'}}
        mode_str = position_mode_result.get('info', {}).get('positionMode', 'Unknown') # Adjust keys based on actual response

        print(f'Current Position Mode Setting: {mode_str}')
        # print(f'Raw Response: {position_mode_result}') # Debug print

    except ccxt.NotSupported:
         print(f'Error: Fetching position mode not supported by exchange via CCXT.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching position mode: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching position mode: {e}', file=sys.stderr)
     "
    }

    # 29. Get Account Leverage Settings (Might be general or per symbol - check output)
    bybit_account_leverage() {
      echo "Fetching overall leverage settings (may depend on context, e.g., margin mode)..."
      _ccxt_bybit_python "
    import json
    try:
        # fetchLeverage without symbol might return default/account settings or error
        # fetchLeverages might return settings for all symbols (very verbose)
        # Try fetching for a common symbol like BTC perpetual as a proxy for account settings if applicable
        btc_symbol = 'BTC/USDT:USDT' # Assuming USDT perpetuals context

        if btc_symbol in exchange.markets:
            leverage_settings = exchange.fetch_leverage(btc_symbol)
            print(f'Leverage Settings (using {btc_symbol} as example):')
            print(json.dumps(leverage_settings, indent=2))
        else:
            # Fallback or alternative method if needed
            # May need to check balance info or account info endpoints
            print(f'BTC/USDT perpetual market not found, cannot fetch example leverage. Try checking a specific symbol or balance info.')
            # balance = exchange.fetch_balance()
            # print(json.dumps(balance.get('info', {}), indent=2)) # Look for leverage settings in raw balance info


    except ccxt.NotSupported:
         print(f'Error: Fetching general leverage settings might not be directly supported. Try specific symbol.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching leverage settings: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching leverage settings: {e}', file=sys.stderr)
     "
    }

    # 30. Set Margin Mode (Isolated or Cross - Requires symbol, 'isolated' or 'cross')
    bybit_set_margin_mode() {
      if [ -z "$1" ] || [ -z "$2" ]; then echo "Usage: bybit_set_margin_mode <symbol> <isolated | cross>"; return 1; fi
      local symbol="$1"
      local mode_input=$(echo "$2" | tr '[:upper:]' '[:lower:]')

      if [[ "$mode_input" != "isolated" && "$mode_input" != "cross" ]]; then
          echo "Error: Invalid mode. Use 'isolated' or 'cross'." >&2; return 1
      fi

      _ccxt_bybit_python "
    symbol = '$symbol'
    mode = '$mode_input'
    try:
        # Check if exchange supports setting margin mode
        if not exchange.has.get('setMarginMode'):
             print('Error: Exchange does not support setting margin mode via CCXT for this market type.', file=sys.stderr)
             sys.exit(1)

        result = exchange.set_margin_mode(mode, symbol)
        print(f'Margin mode for {symbol} set request to {mode.capitalize()} sent.')
        print(f'Response: {result}') # Response might confirm or just acknowledge

    except ccxt.NotSupported:
         print(f'Error: Setting margin mode not supported for {symbol} or by exchange via CCXT.', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e: # Could be due to open positions/orders in the other mode
        print(f'Exchange Error setting margin mode for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error setting margin mode for {symbol}: {e}', file=sys.stderr)
     "
    }

    # 31. Get Margin Mode (Requires symbol)
    bybit_get_margin_mode() {
      if [ -z "$1" ]; then echo "Usage: bybit_get_margin_mode <symbol>"; return 1; fi
      local symbol="$1"
      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    try:
        # Check if exchange supports fetching margin mode
        if not exchange.has.get('fetchMarginMode'): # Assuming CCXT provides this unified method check
             # Fallback: Try fetching leverage info which often includes margin mode for Bybit
             if exchange.has.get('fetchLeverage'):
                  leverage_info = exchange.fetch_leverage(symbol)
                  margin_mode = leverage_info.get('marginMode', 'Unknown').capitalize()
                  print(f'Margin Mode for {symbol} (from leverage info): {margin_mode}')
                  # print(f'Raw Leverage Info: {json.dumps(leverage_info, indent=2)}') # Debug
                  sys.exit(0)
             else:
                 print('Error: Exchange does not support fetching margin mode or leverage info via CCXT.', file=sys.stderr)
                 sys.exit(1)

        # If fetchMarginMode exists ( hypothetical ):
        # margin_mode_result = exchange.fetchMarginMode(symbol)
        # margin_mode = margin_mode_result.get('marginMode', 'Unknown').capitalize() # Parse based on actual structure
        # print(f'Margin Mode for {symbol}: {margin_mode}')
        # print(f'Raw Response: {margin_mode_result}') # Debug print

    except ccxt.NotSupported:
         # This branch might be hit if fetchLeverage also fails or isn't supported
         print(f'Error: Fetching margin mode not supported for {symbol} via CCXT.', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching margin mode for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching margin mode for {symbol}: {e}', file=sys.stderr)
     "
    }

    # 32. Get Funding Payments History (Optional symbol, optional since/limit)
    bybit_funding_payments() {
      # Usage: bybit_funding_payments [symbol] [limit=20] [since_timestamp_ms]
      local symbol="${1:-None}" # Symbol is optional
      local limit="${2:-20}"
      local since="${3:-None}"
      _ccxt_bybit_python "
    import json
    symbol = '$symbol' if '$symbol' != 'None' else None
    limit = int('$limit')
    since = int('$since') if '$since' != 'None' else None
    try:
        # fetchFundingHistory usually gets payments/receipts
        funding_payments = exchange.fetch_funding_history(symbol=symbol, limit=limit, since=since)
        if funding_payments:
            print(f'Last {len(funding_payments)} Funding Payments/Receipts{" for " + symbol if symbol else ""}{" Since " + exchange.iso8601(since) if since else ""}:')
            # Payments usually returned newest first
            for payment in funding_payments:
                timestamp = payment.get('datetime', 'N/A')
                currency = payment.get('info', {}).get('execType', 'N/A') # Bybit might put details in 'info'
                amount = payment.get('amount', 'N/A') # Positive for receipt, negative for payment
                payment_symbol = payment.get('symbol', 'N/A') # Should match input symbol if provided
                print(f'  {timestamp} - Symbol: {payment_symbol}, Amount: {amount} {currency}') # Currency might need parsing from info
                # print(json.dumps(payment, indent=2)) # Debug print detailed structure
        else:
            print(f'No funding payment history found with the specified parameters.')
    except ccxt.NotSupported:
        print(f'Error: fetch_funding_history (funding payments) not supported by exchange via CCXT.', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching funding payments: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching funding payments: {e}', file=sys.stderr)
     "
    }

    # 33. Set Order TP/SL (Modify existing OPEN order - Requires order ID, symbol, Optional TP/SL prices)
    # NOTE: Bybit often requires TP/SL to be set *when creating* the order, or attached to a position.
    # Modifying an existing *open limit order* to add TP/SL might not be supported directly.
    # This function attempts using edit_order; check Bybit API/CCXT docs for feasibility.
    bybit_set_order_tp_sl() {
      if [ -z "$1" ] || [ -z "$2" ] || { [ -z "$3" ] && [ -z "$4" ]; }; then
        echo "Usage: bybit_set_order_tp_sl <order_id> <symbol> [takeProfitPrice] [stopLossPrice]"
        echo "  Provide at least one of takeProfitPrice or stopLossPrice (use 'None' or 0 for unused)."
        echo "Example: bybit_set_order_tp_sl 123456789 BTC/USDT:USDT 31000 24000" # Set both
        echo "Example: bybit_set_order_tp_sl 123456789 BTC/USDT:USDT 31000 None"   # Set only TP
        return 1
      fi
      local order_id="$1"
      local symbol="$2"
      local tp_price="${3:-None}"
      local sl_price="${4:-None}"

      _ccxt_bybit_python "
    import json
    order_id = '$order_id'
    symbol = '$symbol'
    tp_price_str = '$tp_price'
    sl_price_str = '$sl_price'

    params_to_edit = {}
    if tp_price_str.lower() != 'none' and float(tp_price_str) > 0:
        params_to_edit['takeProfitPrice'] = float(tp_price_str) # Check Bybit param name ('takeProfit', 'triggerPrice'?)
        # May need trigger type/direction params too
    if sl_price_str.lower() != 'none' and float(sl_price_str) > 0:
        params_to_edit['stopLossPrice'] = float(sl_price_str) # Check Bybit param name ('stopLoss', 'slTriggerPrice'?)
        # May need trigger type/direction params too

    if not params_to_edit:
        print('Error: No valid Take Profit or Stop Loss price provided.', file=sys.stderr)
        sys.exit(1)

    try:
        # Check if edit_order is supported
        if not exchange.has.get('editOrder'):
             print('Error: Editing orders (edit_order) is not supported by CCXT for this exchange.', file=sys.stderr)
             print('Info: TP/SL often needs to be set at order creation or attached to a position on Bybit.')
             sys.exit(1)

        print(f'Attempting to edit order {order_id} ({symbol}) to add TP/SL...')
        print(f'  Params: {params_to_edit}')

        # edit_order requires amount and price for limit orders, even if not changing them. Fetch first?
        # Fetch the order first to get its original parameters (might be needed)
        # original_order = exchange.fetch_order(order_id, symbol)
        # type = original_order['type']
        # side = original_order['side']
        # amount = original_order['amount']
        # price = original_order['price'] # Price required for editing limit orders

        # Call edit_order with ID, symbol, type, side, amount, price, and new TP/SL params
        # This is complex and highly dependent on exact CCXT implementation
        # Simplified attempt: Assume edit_order can take just ID and params for TP/SL modification
        updated_order = exchange.edit_order(order_id, symbol, params=params_to_edit)

        print(f'Order {order_id} edit request sent. Response:')
        print(json.dumps(updated_order, indent=2))

    except ccxt.NotSupported as e:
         print(f'Error: Editing order TP/SL is likely not supported this way. Set at creation or manage position TP/SL. Details: {e}', file=sys.stderr)
    except ccxt.OrderNotFound as e:
         print(f'Error: Order {order_id} for {symbol} not found or not open for editing. Details: {e}', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e: # Could be because editing TP/SL isn't allowed
        print(f'Exchange Error setting TP/SL for order {order_id}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error setting TP/SL for order {order_id}: {e}', file=sys.stderr)
     "
    }

    # 34. Close Position (Market Close - Requires symbol)
    # This places a market order for the *opposite* side of the current position for the full amount.
    bybit_close_position() {
      if [ -z "$1" ]; then echo "Usage: bybit_close_position <symbol>"; return 1; fi
      local symbol="$1"
      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    try:
        # Fetch current position details
        positions = exchange.fetch_positions([symbol]) # Fetch specifically for the symbol
        position = None
        if positions:
             # Find the non-zero position for the symbol
             for p in positions:
                  if p.get('symbol') == symbol and p.get('contracts') and float(p.get('contracts', 0)) != 0:
                       position = p
                       break

        if position:
            side = position.get('side') # 'long' or 'short'
            amount_to_close = abs(float(position.get('contracts', 0))) # Absolute amount of contracts
            side_to_close = 'sell' if side == 'long' else 'buy' # Opposite side to close

            if amount_to_close > 0:
                print(f'Current Position: {side.capitalize()} {amount_to_close} {symbol}')
                print(f'Attempting to close position with Market {side_to_close.capitalize()} order...')
                # Set reduceOnly=True to ensure it only closes the position
                params = {'reduceOnly': True}
                order = exchange.create_order(symbol, 'market', side_to_close, amount_to_close, params=params)
                # Alternatively, use create_market_buy/sell order with reduceOnly param
                # if side_to_close == 'buy':
                #    order = exchange.create_market_buy_order(symbol, amount_to_close, params)
                # else:
                #    order = exchange.create_market_sell_order(symbol, amount_to_close, params)

                print(f'Market order to close position for {symbol} submitted:')
                print(json.dumps(order, indent=2))
            else:
                 print(f'Position amount for {symbol} is zero, nothing to close.')

        else:
            print(f'No open position found for {symbol} to close.')

    except ccxt.InsufficientFunds as e: # Should not happen with reduceOnly=True if position exists
         print(f'Error: Insufficient funds/margin (unexpected for reduceOnly). Details: {e}', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error closing position for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error closing position for {symbol}: {e}', file=sys.stderr)
     "
    }

    # 35. Reduce Position (Market Reduce Only Order - Requires symbol, amount, side 'buy' or 'sell')
    # Places a market order to specifically reduce the position size.
    bybit_reduce_position() {
      if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]; then
        echo "Usage: bybit_reduce_position <symbol> <amount> <side>"
        echo "  Side should be 'buy' (to reduce short) or 'sell' (to reduce long)"
        echo "Example: bybit_reduce_position BTC/USDT:USDT 0.005 sell" # Reduce long position by selling 0.005 BTC
        return 1
      fi
      local symbol="$1"
      local amount="$2"
      local side=$(echo "$3" | tr '[:upper:]' '[:lower:]')

      if [[ "$side" != "buy" && "$side" != "sell" ]]; then echo "Error: side must be 'buy' or 'sell'"; return 1; fi

      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    amount = float('$amount')
    side = '$side'

    if amount <= 0:
        print('Error: Amount to reduce must be positive.', file=sys.stderr); sys.exit(1)

    try:
        # Ensure reduceOnly=True is set
        params = {'reduceOnly': True}
        print(f'Attempting Market order to Reduce position for {symbol} by {amount} via {side.capitalize()}...')

        # Use create_order or create_market_buy/sell with reduceOnly param
        order = exchange.create_order(symbol, 'market', side, amount, params=params)
        # Or:
        # if side == 'buy':
        #     order = exchange.create_market_buy_order(symbol, amount, params)
        # else:
        #     order = exchange.create_market_sell_order(symbol, amount, params)

        print(f'Market order to reduce position submitted:')
        print(json.dumps(order, indent=2))

    except ccxt.InsufficientFunds as e: # Might happen if reduce amount > position size
         print(f'Error: Cannot reduce position by {amount}. Check position size. Details: {e}', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e: # E.g., order would increase position if reduceOnly incorrect
        print(f'Exchange Error creating reduce position order for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error creating reduce position order for {symbol}: {e}', file=sys.stderr)
     "
    }


    # 36. Get Leverage Brackets/Tiers (Requires symbol - for tiered margin/leverage)
    bybit_leverage_tiers() { # Renamed from brackets
      if [ -z "$1" ]; then echo "Usage: bybit_leverage_tiers <symbol>"; return 1; fi
      local symbol="$1"
      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    try:
        # Check if fetching leverage tiers is supported
        if not exchange.has.get('fetchLeverageTiers'):
             print(f'Error: Fetching leverage tiers not supported by CCXT for this exchange or symbol \'{symbol}\'.', file=sys.stderr)
             sys.exit(1)

        leverage_tiers = exchange.fetch_leverage_tiers([symbol]) # Usually takes a list of symbols

        if symbol in leverage_tiers:
            tiers = leverage_tiers[symbol]
            print(f'Leverage Tiers for {symbol}:')
            print('  Tier | Max Leverage | Min Notional | Max Notional | Maint Margin Rate | Initial Margin Rate')
            print('  -----|--------------|--------------|--------------|-------------------|-------------------')
            for tier in sorted(tiers, key=lambda x: x['tier']):
                 t = tier.get('tier', 'N/A')
                 max_lev = tier.get('maxLeverage', 'N/A')
                 min_not = tier.get('minNotional', 'N/A') # Check naming convention
                 max_not = tier.get('maxNotional', 'N/A') # Check naming convention
                 mmr = tier.get('maintenanceMarginRate', 'N/A')
                 imr = tier.get('initialMarginRate', 'N/A') # May not be present in all tiers info
                 print(f'  {t:>4} | {max_lev:>12} | {min_not:>12} | {max_not:>12} | {mmr:>17.4f} | {imr:>17.4f}') # Adjust formatting
        else:
            print(f'No leverage tier information found for {symbol}.')
            # print(f'Raw response keys: {list(leverage_tiers.keys())}') # Debug

    except ccxt.NotSupported:
         print(f'Error: Fetching leverage tiers not supported by exchange via CCXT.', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching leverage tiers for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching leverage tiers for {symbol}: {e}', file=sys.stderr)
     "
    }


    # 37. Get Position Risk Limit / Tiers (Requires symbol)
    # Bybit uses Risk Limits which are similar to leverage tiers but based on position value.
    bybit_position_risk_limit() {
      if [ -z "$1" ]; then echo "Usage: bybit_position_risk_limit <symbol>"; return 1; fi
      local symbol="$1"
      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    try:
        # Check if fetching position risk limits (market data endpoint usually) is supported
        # This might be part of fetchMarket or need a specific method
        # Let's try fetching market data again and look inside 'info'

        market = exchange.market(symbol)
        if market and 'info' in market and 'riskLimit' in market['info']: # Hypothetical structure, check Bybit API / CCXT source
            risk_limits = market['info']['riskLimit'] # Array of risk limit tiers
            print(f'Position Risk Limit Tiers for {symbol}:')
            print('  ID | Limit Value | Maint Margin | Initial Margin | Max Leverage')
            print('  ---|-------------|--------------|----------------|--------------')
             # Assuming risk_limits is a list of dictionaries
            for limit in sorted(risk_limits, key=lambda x: int(x.get('id', 0))):
                rid = limit.get('id', 'N/A')
                rlimit = limit.get('riskLimitValue', 'N/A') # Or just 'limit'
                mm = limit.get('maintainMargin', 'N/A') # Check names
                im = limit.get('initialMargin', 'N/A') # Check names
                max_lev = limit.get('startingLeverage', 'N/A') # Check names
                print(f'  {rid:>2} | {rlimit:>11} | {mm:>12.4f} | {im:>14.4f} | {max_lev:>12}')

        # Alternative: Try fetchPositionsRisk, if available
        elif exchange.has.get('fetchPositionsRisk'):
            risk_info = exchange.fetch_positions_risk([symbol]) # Takes list of symbols
            if symbol in risk_info:
                print(f'Position Risk Limit Info for {symbol}:')
                # Parse risk_info[symbol] based on its actual structure
                print(json.dumps(risk_info[symbol], indent=2))
            else:
                 print(f'No position risk limit information found for {symbol} via fetchPositionsRisk.')
        else:
             print(f'Could not find risk limit information for {symbol} in market data.')
             print('Info: Risk limits might be under market["info"]["riskLimits"] or require fetchPositionsRisk.')
             # print(f"Market Info Keys: {market.get('info', {}).keys()}") # Debug available keys

    except ccxt.NotSupported:
         print(f'Error: Fetching position risk limits not directly supported or method unknown.', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching position risk limits for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching position risk limits for {symbol}: {e}', file=sys.stderr)
     "
    }

    # 38. Set Position Risk Limit (Requires symbol, riskLimit ID - check Bybit API/UI for valid IDs)
    # WARNING: Changing risk limit can affect margin requirements and liquidation price significantly. Use with caution.
    bybit_set_position_risk_limit() {
      if [ -z "$1" ] || [ -z "$2" ]; then
        echo "Usage: bybit_set_position_risk_limit <symbol> <riskLimitID>"
        echo "  Find valid riskLimitID using 'bybit_position_risk_limit <symbol>'"
        echo "WARNING: Changing risk limit impacts margin and liquidation. Understand the implications."
        echo "Example: bybit_set_position_risk_limit BTC/USDT:USDT 2" # Example ID
        return 1
      fi
      local symbol="$1"
      local risk_limit_id="$2"
      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    risk_limit_id = int('$risk_limit_id') # Bybit API likely uses the integer ID
    try:
        # Check if setting risk limit is supported
        if not exchange.has.get('setRiskLimit'): # Hypothetical check for a specific CCXT method
             # Bybit's API endpoint might be private/account POST /v5/position/set-risk-limit
             # CCXT might expose this via a unified or implicit method, or require calling private API
             # Try a potential implicit method or fallback to private API call structure

             # Option 1: Try modifying position with riskLimit parameter (if CCXT supports it)
             # This is unlikely to be the standard way
             # params = {'riskLimit': risk_limit_id}
             # result = exchange.modify_position(symbol, params) # modify_position is hypothetical

             # Option 2: Use generic private POST call structure (less safe, version dependent)
             print(f'Info: Attempting to set risk limit using private API call structure (may be unstable)...')
             path = 'v5/position/set-risk-limit' # V5 API path
             method = 'POST'
             params = {
                 'symbol': exchange.market(symbol)['id'], # Need Bybit's internal market ID
                 'riskId': risk_limit_id,
                 'category': 'linear' # Or 'inverse' or 'option' depending on market
             }
             # Need to determine if symbol requires linear/inverse category
             market = exchange.market(symbol)
             if market.get('linear'): params['category'] = 'linear'
             elif market.get('inverse'): params['category'] = 'inverse'
             elif market.get('option'): params['category'] = 'option'
             else: params['category'] = 'linear' # Default assumption


             result = getattr(exchange, f'privatePost{path.replace("/", "")}')(params) # Generic call
             print(f'Set position risk limit request sent (using private API structure). Response:')
             print(json.dumps(result, indent=2))

        else:
            # If CCXT explicitly supports setRiskLimit:
            # result = exchange.setRiskLimit(symbol, risk_limit_id) # Hypothetical unified call
            # print(f'Set position risk limit request sent. Response:')
            # print(json.dumps(result, indent=2))
            print("Error: Placeholder for explicit CCXT setRiskLimit call if it exists.", file=sys.stderr)


    except ccxt.NotSupported as e:
         print(f'Error: Setting risk limit is not supported or structure used is incorrect. Details: {e}', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e: # E.g., invalid risk ID, insufficient margin for new limit
        print(f'Exchange Error setting position risk limit for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error setting position risk limit for {symbol}: {e}', file=sys.stderr)
     "
    }

    # 39. Get Server Time (Exchange Time)
    bybit_server_time() {
      _ccxt_bybit_python "
    try:
        server_time_ms = exchange.fetch_time()
        server_time_iso = exchange.iso8601(server_time_ms)
        print(f'Bybit Server Time (UTC): {server_time_iso} ({server_time_ms} ms)')
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching server time: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching server time: {e}', file=sys.stderr)
     "
    }


    # 40. Fetch Deposit Address (Requires currency - e.g., USDT, and potentially network/chain)
    bybit_deposit_address() {
      # Usage: bybit_deposit_address <currency> [network]
      if [ -z "$1" ]; then echo "Usage: bybit_deposit_address <currency> [network (e.g., TRC20, ERC20, BEP20)]"; return 1; fi
      local currency="$1"
      local network="${2:-None}" # Network is often required
      _ccxt_bybit_python "
    import json
    currency_code = '$currency'.upper()
    network_code = '$network' if '$network' != 'None' else None

    # Prepare params, CCXT often uses 'network' or 'chain' in the params dict
    params = {}
    if network_code:
        params['network'] = network_code # Or 'chain', check CCXT docs for Bybit specifics
        print(f'Attempting to fetch deposit address for {currency_code} on network {network_code}...')
    else:
         print(f'Attempting to fetch deposit address for {currency_code} (default network)...')
         print('Warning: Network/Chain parameter is often required for accurate deposit addresses.')

    try:
        # fetchDepositAddress requires currency code
        deposit_address_data = exchange.fetch_deposit_address(currency_code, params=params)

        if deposit_address_data and 'address' in deposit_address_data:
            print(f'Deposit Address for {currency_code} (Network: {deposit_address_data.get('network', 'N/A')}):')
            print(f'  Address: {deposit_address_data['address']}')
            tag = deposit_address_data.get('tag') # Tag/Memo
            if tag:
                print(f'  Tag/Memo: {tag}   ** REQUIRED FOR DEPOSIT **')
            else:
                print(f'  Tag/Memo: Not required (Verify on Bybit website)')

            # print(f'Raw response: {json.dumps(deposit_address_data, indent=2)}') # Debug
        else:
            print(f'Could not retrieve deposit address for {currency_code} on network {network_code}.')
            print('Possible reasons: Invalid currency/network, address generation pending, API permissions.')
            # print(f'Raw response: {deposit_address_data}') # Debug

    except ccxt.ExchangeError as e: # Handles cases like invalid currency/network, permissions
        print(f'Exchange Error fetching deposit address for {currency_code}: {e}', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret and permissions. Details: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching deposit address for {currency_code}: {e}', file=sys.stderr)
     "
    }


    # --- Bybit Further Data & Execution Functions (41-60) ---

    # 41. Get Open Interest (Requires symbol)
    bybit_open_interest() {
      if [ -z "$1" ]; then echo "Usage: bybit_open_interest <symbol>"; return 1; fi
      local symbol="$1"
      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    try:
        # Check if fetching open interest is supported
        if not exchange.has.get('fetchOpenInterest'):
             print(f'Error: Fetching open interest not supported by CCXT for this exchange or symbol \'{symbol}\'.', file=sys.stderr)
             sys.exit(1)

        market = exchange.market(symbol)
        if not market.get('swap') and not market.get('future') and not market.get('option'):
            print(f'Error: Open Interest typically applies to derivatives (swaps, futures, options). {symbol} is a {market.get('type')} market.', file=sys.stderr)
            sys.exit(1)

        open_interest = exchange.fetch_open_interest(symbol)
        print(f'Open Interest for {symbol}:')
        oi_value = open_interest.get('openInterestValue', 'N/A') # Usually in quote currency
        oi_amount = open_interest.get('openInterestAmount', 'N/A') # Usually in base currency
        timestamp = open_interest.get('datetime', 'N/A')
        print(f'  Value (Quote): {oi_value}')
        print(f'  Amount (Base): {oi_amount}')
        print(f'  Timestamp: {timestamp}')
        # print(f'Raw OI Data: {json.dumps(open_interest, indent=2)}') # Debug

    except ccxt.NotSupported:
         print(f'Error: Fetching open interest not supported by exchange via CCXT.', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\' or not a derivatives market.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching open interest for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching open interest for {symbol}: {e}', file=sys.stderr)
     "
    }

    # 42. Get Long/Short Ratio (Requires symbol, timeframe - e.g., '5m', '1h', '4h', '1d')
    # NOTE: This data is often provided via specific non-standard API endpoints. CCXT support may vary.
    bybit_long_short_ratio() {
      if [ -z "$1" ] || [ -z "$2" ]; then
        echo "Usage: bybit_long_short_ratio <symbol> <timeframe>"
        echo "  Timeframe examples: 5m, 15m, 1h, 4h, 1d (Check Bybit API for supported periods)"
        echo "Example: bybit_long_short_ratio BTC/USDT:USDT 1h"
        return 1
      fi
      local symbol="$1"
      local timeframe="$2"
      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    timeframe = '$timeframe' # Bybit uses period like 5min, 15min, 1h, 4h, 1d

    # Bybit internal Market ID needed for some endpoints
    try:
        market = exchange.market(symbol)
        bybit_symbol_id = market['id']
    except Exception as e:
        print(f'Error getting market ID for {symbol}: {e}', file=sys.stderr)
        sys.exit(1)


    # Convert common timeframe to Bybit period format
    period_map = {'5m':'5min', '15m':'15min', '30m':'30min', '1h':'1h', '2h':'2h', '4h':'4h', '6h':'6h', '12h':'12h', '1d':'1d'}
    bybit_period = period_map.get(timeframe.lower())

    if not bybit_period:
        print(f'Error: Timeframe \'{timeframe}\' not mapped to a known Bybit period. Use: {list(period_map.keys())}', file=sys.stderr)
        sys.exit(1)


    try:
        # Check for specific fetchLongShortRatio method or use private API call
        if exchange.has.get('fetchLongShortRatio'): # Hypothetical CCXT standard method
            # This method might require different parameters
            ratio_data = exchange.fetch_long_short_ratio(symbol, timeframe=timeframe) # Adjust params as needed
        else:
            # Fallback to private/public API call structure for Bybit's specific endpoint
            print(f'Info: Attempting to use Bybit specific endpoint for Long/Short ratio...')
            # Bybit V5 Public Endpoint: /v5/market/account-ratio
            path = 'v5/market/account-ratio'
            method = 'publicGet' # Or 'privateGet' if it requires auth
            params = {
                'symbol': bybit_symbol_id,
                'period': bybit_period,
                'limit': 1 # We only need the latest ratio
            }
            # Construct the call based on method type (publicGetV5MarketAccountRatio)
            # The exact function name depends on CCXT's internal mapping. Requires checking CCXT Bybit source.
            # Example generic structure:
            api_method_name = f'{method}{path.replace("/", "")}'
            if hasattr(exchange, api_method_name):
                 raw_response = getattr(exchange, api_method_name)(params)
            else:
                 print(f'Error: Could not find corresponding CCXT method {api_method_name} for path {path}. Check CCXT Bybit implementation.', file=sys.stderr)
                 sys.exit(1)

            # Parse the raw response (structure specific to Bybit API)
            # Example Structure: {'result': {'list': [{'buyRatio': '0.55', 'sellRatio': '0.45', 'timestamp': '...'}]}, 'retCode': 0, ...}
            if raw_response.get('retCode') == 0 and raw_response.get('result', {}).get('list'):
                 latest_ratio = raw_response['result']['list'][0]
                 ratio_data = { # Convert to a more standard structure if needed
                     'symbol': symbol,
                     'timestamp': int(latest_ratio['timestamp']),
                     'datetime': exchange.iso8601(int(latest_ratio['timestamp'])),
                     'longAccount': float(latest_ratio['buyRatio']), # Renaming for clarity
                     'shortAccount': float(latest_ratio['sellRatio']),
                     'longShortRatio': float(latest_ratio['buyRatio']) / float(latest_ratio['sellRatio']) if float(latest_ratio['sellRatio']) != 0 else None,
                     'info': latest_ratio # Keep original info
                 }
            else:
                 print(f'Error: Failed to parse long/short ratio from Bybit response. Code: {raw_response.get('retCode')}, Msg: {raw_response.get('retMsg')}', file=sys.stderr)
                 # print(f'Raw Response: {json.dumps(raw_response, indent=2)}') # Debug
                 sys.exit(1)


        # Display the fetched ratio data
        if ratio_data:
            print(f'Long/Short Account Ratio for {symbol} ({timeframe}):')
            long_ratio = ratio_data.get('longAccount', 'N/A')
            short_ratio = ratio_data.get('shortAccount', 'N/A')
            timestamp = ratio_data.get('datetime', 'N/A')
            ratio = ratio_data.get('longShortRatio', 'N/A')

            print(f'  Timestamp: {timestamp}')
            print(f'  Long Ratio: {long_ratio*100:.2f}%')
            print(f'  Short Ratio: {short_ratio*100:.2f}%')
            if ratio != 'N/A': print(f'  Ratio (Long/Short): {ratio:.3f}')
            # print(f'Raw Ratio Data: {json.dumps(ratio_data, indent=2)}') # Debug
        else:
            print(f'Could not retrieve long/short ratio for {symbol} ({timeframe}).')

    except ccxt.NotSupported:
         print(f'Error: Fetching long/short ratio not supported directly or indirectly.', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching long/short ratio for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching long/short ratio for {symbol}: {e}', file=sys.stderr)
     "
    }


    # 43. Get Insurance Fund Balance (Usually per currency)
    bybit_insurance_fund() {
      _ccxt_bybit_python "
    import json
    try:
        # Check if fetching insurance fund info is supported
        if not exchange.has.get('fetchInsuranceFund'): # Hypothetical capability check
             print(f'Info: Attempting to use Bybit specific endpoint for insurance fund...')
             # Bybit V5 Public Endpoint: /v5/market/insurance-fund
             path = 'v5/market/insurance-fund'
             method = 'publicGet'
             params = {} # Optional: 'coin=USDT' to filter by currency
             api_method_name = f'{method}{path.replace("/", "")}'

             if hasattr(exchange, api_method_name):
                  raw_response = getattr(exchange, api_method_name)(params)
             else:
                  print(f'Error: Could not find corresponding CCXT method {api_method_name}.', file=sys.stderr)
                  sys.exit(1)

             # Parse Bybit response
             # Example Structure: {'result': {'list': [{'coin': 'USDT', 'balance': '...', 'value': '...'}, ...]}, 'retCode': 0, ...}
             if raw_response.get('retCode') == 0 and raw_response.get('result', {}).get('list'):
                 insurance_data = raw_response['result']['list']
                 # Convert to potential CCXT-like structure if needed, or just display
             else:
                  print(f'Error: Failed to parse insurance fund data. Code: {raw_response.get('retCode')}, Msg: {raw_response.get('retMsg')}', file=sys.stderr)
                  sys.exit(1)

        else:
            # If fetchInsuranceFund exists
            # insurance_data = exchange.fetchInsuranceFund() # Adjust params if needed
            print('Error: Placeholder for explicit CCXT fetchInsuranceFund call.', file=sys.stderr)
            sys.exit(1)


        if insurance_data:
            print('Bybit Insurance Fund Balances:')
            print('  Currency | Balance')
            print('  ---------|--------------------')
            for entry in sorted(insurance_data, key=lambda x: x.get('coin')):
                currency = entry.get('coin', 'N/A') # check key name
                balance = entry.get('balance', 'N/A') # check key name
                print(f'  {currency:<8} | {balance}')
        else:
            print('Could not retrieve Bybit insurance fund balance.')

    except ccxt.NotSupported:
         print(f'Error: Fetching insurance fund balance not supported via checked methods.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching insurance fund balance: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching insurance fund balance: {e}', file=sys.stderr)
     "
    }

    # 44. Get Liquidations (Recent Liquidations, Optional symbol, optional limit)
    # NOTE: Requires specific Bybit API endpoint. CCXT support may vary.
    bybit_liquidations() {
      # Usage: bybit_liquidations [symbol] [limit=20] [start_time_ms] [end_time_ms]
      local symbol="${1:-None}"
      local limit="${2:-20}"
      local start_time="${3:-None}"
      local end_time="${4:-None}"
      _ccxt_bybit_python "
    import json
    symbol = '$symbol' if '$symbol' != 'None' else None
    limit = int('$limit')
    start_time = int('$start_time') if '$start_time' != 'None' else None
    end_time = int('$end_time') if '$end_time' != 'None' else None

    # Convert symbol to Bybit Market ID if symbol is provided
    bybit_symbol_id = None
    if symbol:
        try:
            market = exchange.market(symbol)
            bybit_symbol_id = market['id']
        except Exception as e:
            print(f'Error getting market ID for {symbol}: {e}', file=sys.stderr)
            # Continue without symbol filter if ID lookup fails? Or exit?
            # sys.exit(1)

    try:
        # Check for fetchLiquidations method or use private/public API call
        if exchange.has.get('fetchLiquidations'): # Hypothetical standard method
            liquidation_data = exchange.fetch_liquidations(symbol=symbol, limit=limit, since=start_time, params={'endTime': end_time}) # Adjust params
        else:
            # Fallback to Bybit V5 Public Endpoint: /v5/market/tickers (Liquidation info might be here or separate)
            # Or /v5/market/recent-trade ? Needs verification where Bybit exposes this reliably.
            # Let's assume a hypothetical /v5/market/liquidations endpoint structure for example
            print(f'Info: Attempting to use Bybit specific endpoint for liquidations (endpoint hypothetical)...')
            path = 'v5/market/liquidations' # THIS PATH IS LIKELY INCORRECT - Find correct Bybit API path
            method = 'publicGet'
            params = {
                'limit': limit,
                'category': 'linear' # Or inverse? Assume linear for now
            }
            if bybit_symbol_id: params['symbol'] = bybit_symbol_id
            if start_time: params['startTime'] = start_time
            if end_time: params['endTime'] = end_time

            api_method_name = f'{method}{path.replace("/", "")}'
            if hasattr(exchange, api_method_name):
                 raw_response = getattr(exchange, api_method_name)(params)
            else:
                  print(f'Error: Could not find corresponding CCXT method {api_method_name}.', file=sys.stderr)
                  print(f'Error: The endpoint \'{path}\' for liquidations is hypothetical/likely incorrect. Check Bybit API documentation.', file=sys.stderr)
                  sys.exit(1)

            # Parse hypothetical response
            if raw_response.get('retCode') == 0 and raw_response.get('result', {}).get('list'):
                liquidation_data = raw_response['result']['list']
            else:
                print(f'Error: Failed to parse liquidations. Code: {raw_response.get('retCode')}, Msg: {raw_response.get('retMsg')}', file=sys.stderr)
                sys.exit(1)

        # Display the data
        if liquidation_data:
            print(f'Last {len(liquidation_data)} Liquidations{" for " + symbol if symbol else ""}:')
            # Structure depends heavily on actual endpoint/method
            print('  Timestamp | Symbol | Side | Price | Amount')
            print('  ----------|--------|------|-------|--------')
            for liq in liquidation_data:
                 # These keys are guesses based on typical liquidation data
                 ts = liq.get('datetime', exchange.iso8601(int(liq.get('execTime', 0)))) # Check timestamp key
                 sym = liq.get('symbol', 'N/A')
                 side = liq.get('side', 'N/A') # Liquidation side (Buy=Short Liq, Sell=Long Liq)
                 price = liq.get('price', 'N/A') # Liquidation fill price
                 amount = liq.get('size', 'N/A') # Liquidated amount

                 print(f'  {ts} | {sym} | {side:<4} | {price:>7} | {amount:>8}')
                 # print(json.dumps(liq, indent=2)) # Debug structure
        else:
            print(f'No recent liquidations found with the specified parameters.')


    except ccxt.NotSupported:
         print(f'Error: Fetching liquidations not supported via checked methods.', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching liquidations: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching liquidations: {e}', file=sys.stderr)
     "
    }


    # 45. Create Post-Only Limit Order (Limit Maker Order - ensures it doesn't immediately fill)
    # Usage: bybit_limit_maker <symbol> <side> <amount> <price> [params_json]
    bybit_limit_maker() { # Renamed for clarity
      if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ] || [ -z "$4" ]; then
        echo "Usage: bybit_limit_maker <symbol> <side (buy/sell)> <amount> <price> [params_json]"
        echo "  Ensures order is added to book (maker) or cancelled."
        echo "Example: bybit_limit_maker BTC/USDT:USDT buy 0.01 27000"
        return 1
      fi
      local symbol="$1"
      local side=$(echo "$2" | tr '[:upper:]' '[:lower:]')
      local amount="$3"
      local price="$4"
      local params_json="${5:-{\}}"

      if [[ "$side" != "buy" && "$side" != "sell" ]]; then echo "Error: side must be 'buy' or 'sell'"; return 1; fi

      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    side = '$side'
    amount = float('$amount')
    price = float('$price')
    # Base params for post-only
    params = {'postOnly': True}
    # Merge with user-provided params
    user_params = json.loads('''$params_json''')
    params.update(user_params)

    if amount <= 0 or price <= 0:
        print('Error: Amount and Price must be positive.', file=sys.stderr); sys.exit(1)

    try:
        print(f'Attempting Post-Only Limit {side.capitalize()} Order: {amount} {symbol.split(\"/\")[0]} @ {price}...')
        # Use create_limit_buy/sell_order which should support postOnly param
        if side == 'buy':
            order = exchange.create_limit_buy_order(symbol, amount, price, params)
        else: # side == 'sell'
            order = exchange.create_limit_sell_order(symbol, amount, price, params)

        print('Post-Only Limit Order Submitted Successfully (or cancelled if taker):')
        print(json.dumps(order, indent=2)) # Check status in response

    except ccxt.OrderImmediatelyFillable as e:
         # This can happen if postOnly=True and the order would match immediately
         print(f'Info: Post-Only order for {symbol} was cancelled because it would immediately fill (taker). Details: {e}', file=sys.stderr)
    except ccxt.InsufficientFunds as e:
         print(f'Error: Insufficient funds for post-only limit order. Details: {e}', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error creating post-only limit order: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error creating post-only limit order: {e}', file=sys.stderr)
      "
    }

    # 46. Create Reduce-Only Limit Order (Limit order to only reduce position size)
    # Usage: bybit_limit_reduce <symbol> <side> <amount> <price> [params_json]
    bybit_limit_reduce() { # Renamed for clarity
      if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ] || [ -z "$4" ]; then
        echo "Usage: bybit_limit_reduce <symbol> <side (buy/sell)> <amount> <price> [params_json]"
        echo "  Order only fills if it reduces an existing position."
        echo "Example: bybit_limit_reduce BTC/USDT:USDT sell 0.01 26500" # Reduce long position
        return 1
      fi
      local symbol="$1"
      local side=$(echo "$2" | tr '[:upper:]' '[:lower:]')
      local amount="$3"
      local price="$4"
      local params_json="${5:-{\}}"

       if [[ "$side" != "buy" && "$side" != "sell" ]]; then echo "Error: side must be 'buy' or 'sell'"; return 1; fi

      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    side = '$side'
    amount = float('$amount')
    price = float('$price')
    # Base params for reduce-only
    params = {'reduceOnly': True}
    # Merge with user-provided params
    user_params = json.loads('''$params_json''')
    params.update(user_params)

    if amount <= 0 or price <= 0:
        print('Error: Amount and Price must be positive.', file=sys.stderr); sys.exit(1)

    try:
        print(f'Attempting Reduce-Only Limit {side.capitalize()} Order: {amount} {symbol.split(\"/\")[0]} @ {price}...')
        # Use create_limit_buy/sell_order which should support reduceOnly param
        if side == 'buy':
            order = exchange.create_limit_buy_order(symbol, amount, price, params)
        else: # side == 'sell'
            order = exchange.create_limit_sell_order(symbol, amount, price, params)

        print('Reduce-Only Limit Order Submitted Successfully:')
        print(json.dumps(order, indent=2)) # Status indicates if accepted

    except ccxt.InsufficientFunds as e: # Might happen if order > position size or wrong side
         print(f'Error: Order would increase position or insufficient funds. Check position/side. Details: {e}', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.ExchangeError as e: # Bybit might reject if it increases position
        print(f'Exchange Error creating reduce-only limit order: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error creating reduce-only limit order: {e}', file=sys.stderr)
      "
    }

    # 47. Get Orderbook Top Bid/Ask (Quickly get best bid and ask prices)
    bybit_orderbook_top() {
      if [ -z "$1" ]; then echo "Usage: bybit_orderbook_top <symbol>"; return 1; fi
      local symbol="$1"
      _ccxt_bybit_python "
    symbol = '$symbol'
    try:
        # Fetch only level 1 of the order book
        orderbook = exchange.fetch_order_book(symbol, limit=1)
        if orderbook and orderbook.get('bids') and orderbook.get('asks'):
            best_bid_price = orderbook['bids'][0][0]
            best_bid_amount = orderbook['bids'][0][1]
            best_ask_price = orderbook['asks'][0][0]
            best_ask_amount = orderbook['asks'][0][1]
            spread = best_ask_price - best_bid_price
            spread_percent = (spread / best_ask_price) * 100 if best_ask_price else 0

            print(f'Top of Book for {symbol}:')
            print(f'  Best Bid: {best_bid_price} (Amount: {best_bid_amount})')
            print(f'  Best Ask: {best_ask_price} (Amount: {best_ask_amount})')
            print(f'  Spread:   {spread:.{exchange.markets[symbol]['precision']['price']}f} ({spread_percent:.4f}%)') # Format spread to price precision
            print(f'  Timestamp: {orderbook.get('datetime', 'N/A')}')
        else:
            print(f'Could not retrieve top bid/ask for {symbol}. Response empty or malformed.')
            # print(f'Raw response: {orderbook}') # Debug

    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching top of book for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching top of book for {symbol}: {e}', file=sys.stderr)
     "
    }

    # 48. Get Account Positions (All symbols, including zero positions if returned by API)
    # Note: fetch_positions() in CCXT usually returns only non-zero positions by default.
    # Check Bybit API docs if a specific call exists for *all* potential position slots.
    bybit_all_positions() {
      echo "Fetching all non-zero positions..."
      _ccxt_bybit_python "
    import json
    try:
        # Default fetch_positions retrieves open (non-zero) positions
        positions = exchange.fetch_positions() # Add symbol list [] to fetch for specific symbols

        # If Bybit API/CCXT returns zero positions, they will be included here.
        # If it only returns non-zero, this is equivalent to bybit_positions.

        if positions:
            print(f'Account Positions (Found {len(positions)}):')
            # Sort positions, e.g., by symbol
            for pos in sorted(positions, key=lambda x: x.get('symbol', '')):
                symbol = pos.get('symbol', 'N/A')
                side = pos.get('side', 'None') # 'long', 'short', or None/'' if closed/zero
                contracts = pos.get('contracts', 0) # Amount in contracts
                entry_price = pos.get('entryPrice', 'N/A')
                mark_price = pos.get('markPrice', 'N/A')
                liq_price = pos.get('liquidationPrice', 'N/A')
                unrealized_pnl = pos.get('unrealizedPnl', 'N/A')
                margin = pos.get('initialMargin', 'N/A')

                print(f\"\"\"\
      Symbol: {symbol}
        Side: {side.capitalize() if side else 'None'}, Size: {contracts}
        Entry: {entry_price}, Mark: {mark_price}, Liq: {liq_price}
        Margin: {margin}, UPNL: {unrealized_pnl}
    \"\"\")
        else:
            print('No positions found (API returned empty list).')

    except ccxt.NotSupported as e:
        print(f'Error: fetch_positions might not be fully supported: {e}', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching all positions: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching all positions: {e}', file=sys.stderr)
     "
    }

    # 49. Get Position Margin Details (Requires symbol)
    bybit_position_margin() {
      if [ -z "$1" ]; then echo "Usage: bybit_position_margin <symbol>"; return 1; fi
      local symbol="$1"
      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    try:
        # Fetch position details for the specific symbol
        positions = exchange.fetch_positions([symbol])
        position = None
        if positions:
             for p in positions: # Find the position matching the symbol requested
                  if p.get('symbol') == symbol:
                       position = p
                       break

        if position and position.get('contracts') and float(position.get('contracts', 0)) != 0:
            print(f'Position Margin Details for {symbol}:')
            initial_margin = position.get('initialMargin', 'N/A')
            maint_margin = position.get('maintenanceMargin', 'N/A')
            initial_margin_pct = position.get('initialMarginPercentage', 'N/A')
            maint_margin_pct = position.get('maintenanceMarginPercentage', 'N/A')
            margin_ratio = position.get('marginRatio', 'N/A') # Health indicator

            print(f'  Initial Margin: {initial_margin} ({initial_margin_pct * 100:.2f}%)' if initial_margin_pct else f'  Initial Margin: {initial_margin}')
            print(f'  Maintenance Margin: {maint_margin} ({maint_margin_pct * 100:.2f}%)' if maint_margin_pct else f'  Maintenance Margin: {maint_margin}')
            print(f'  Margin Ratio: {margin_ratio * 100:.2f}%' if margin_ratio else '  Margin Ratio: N/A')
            # print(f'Raw Position Info: {json.dumps(position, indent=2)}') # Debug
        elif position:
             print(f'No open position found for {symbol} (amount is zero).')
        else:
            print(f'Could not fetch position details for {symbol}.')

    except ccxt.NotSupported as e:
        print(f'Error: Fetching specific position margin details might not be fully supported: {e}', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching position margin for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching position margin for {symbol}: {e}', file=sys.stderr)
     "
    }

    # 50. Add Position Margin (Requires symbol, amount to add - for ISOLATED margin positions)
    # WARNING: Only applicable to Isolated Margin positions.
    bybit_add_position_margin() {
      if [ -z "$1" ] || [ -z "$2" ]; then
        echo "Usage: bybit_add_position_margin <symbol> <amount>"
        echo "  Adds margin to an ISOLATED position. Amount is positive."
        echo "Example: bybit_add_position_margin BTC/USDT:USDT 100" # Add 100 USDT margin
        return 1
      fi
      local symbol="$1"
      local amount="$2"
      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    amount = float('$amount')

    if amount <= 0:
        print('Error: Amount to add must be positive.', file=sys.stderr)
        sys.exit(1)

    try:
        # Check if add_margin is supported (might be modify_position or similar)
        # Bybit V5 API: POST /v5/position/add-margin
        # Check CCXT's unified method or use private call structure

        if not exchange.has.get('addMargin'): # Hypothetical specific method check
             # Fallback to private API call structure
             print(f'Info: Attempting via private API call structure for add margin...')
             path = 'v5/position/add-margin'
             method = 'privatePost'
             params = {
                 'symbol': exchange.market(symbol)['id'],
                 'margin': str(amount), # Amount as string
                 'category': 'linear' # Adjust category needed
             }
             market = exchange.market(symbol)
             if market.get('linear'): params['category'] = 'linear'
             elif market.get('inverse'): params['category'] = 'inverse'
             else: params['category'] = 'linear' # Default assumption

             api_method_name = f'{method}{path.replace("/", "").lower()}' # Construct method name approx
             if hasattr(exchange, api_method_name):
                  result = getattr(exchange, api_method_name)(params)
             else:
                  print(f'Error: Could not find corresponding CCXT method like {api_method_name}.', file=sys.stderr)
                  sys.exit(1)
        else:
            # If explicit add_margin exists
            # result = exchange.add_margin(symbol, amount)
            print('Error: Placeholder for explicit CCXT add_margin call.', file=sys.stderr)
            sys.exit(1)


        print(f'Request to add {amount} margin to {symbol} sent.')
        print(f'Response: {json.dumps(result, indent=2)}') # Check response for success/failure

    except ccxt.NotSupported as e:
         print(f'Error: Adding position margin not supported via checked methods. Check if position is Isolated. Details: {e}', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e: # E.g., position not isolated, insufficient wallet balance
        print(f'Exchange Error adding margin to {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error adding margin to {symbol}: {e}', file=sys.stderr)
     "
    }

    # 51. Reduce Position Margin (Requires symbol, amount to reduce - for ISOLATED margin positions)
    # WARNING: Only applicable to Isolated Margin positions. Reducing margin increases liquidation risk.
    bybit_reduce_position_margin() {
      if [ -z "$1" ] || [ -z "$2" ]; then
        echo "Usage: bybit_reduce_position_margin <symbol> <amount>"
        echo "  Reduces margin from an ISOLATED position. Amount is positive reduction amount."
        echo "WARNING: Increases liquidation risk. Ensure sufficient margin remains."
        echo "Example: bybit_reduce_position_margin BTC/USDT:USDT 50" # Reduce margin by 50 USDT
        return 1
      fi
      local symbol="$1"
      local amount="$2" # Amount to reduce by (positive number)
      _ccxt_bybit_python "
    import json
    symbol = '$symbol'
    amount = float('$amount')

    if amount <= 0:
        print('Error: Amount to reduce must be positive.', file=sys.stderr)
        sys.exit(1)

    try:
        # Check if reduce_margin or modify_position is supported
        # Bybit V5 API: POST /v5/position/add-margin (but with negative amount? Or dedicated endpoint?)
        # Let's assume add-margin with negative value or a reduce-margin endpoint.

        # Check for reduceMargin capability
        if not exchange.has.get('reduceMargin'): # Hypothetical check
             # Fallback to private API call using add-margin with negative sign
             print(f'Info: Attempting via private API call structure for reduce margin (using add-margin with negative)...')
             path = 'v5/position/add-margin' # Using add-margin endpoint
             method = 'privatePost'
             params = {
                 'symbol': exchange.market(symbol)['id'],
                 'margin': str(-amount), # **** Negative amount for reduction **** Check if Bybit API supports this.
                 'category': 'linear' # Adjust category if needed
             }
             market = exchange.market(symbol)
             if market.get('linear'): params['category'] = 'linear'
             elif market.get('inverse'): params['category'] = 'inverse'
             else: params['category'] = 'linear' # Default

             api_method_name = f'{method}{path.replace("/", "").lower()}'
             if hasattr(exchange, api_method_name):
                  result = getattr(exchange, api_method_name)(params)
             else:
                  print(f'Error: Could not find corresponding CCXT method like {api_method_name}.', file=sys.stderr)
                  sys.exit(1)
        else:
            # If explicit reduceMargin exists
            # result = exchange.reduce_margin(symbol, amount)
            print('Error: Placeholder for explicit CCXT reduce_margin call.', file=sys.stderr)
            sys.exit(1)


        print(f'Request to reduce margin by {amount} for {symbol} sent.')
        print(f'Response: {json.dumps(result, indent=2)}')

    except ccxt.NotSupported as e:
         print(f'Error: Reducing position margin not supported via checked methods. Check if position is Isolated. Details: {e}', file=sys.stderr)
    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e: # E.g., position not isolated, reduction below minimum required margin
        print(f'Exchange Error reducing margin for {symbol}: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error reducing margin for {symbol}: {e}', file=sys.stderr)
     "
    }

    # 52. Get Estimated Order Cost (Basic calculation - does not include fees/slippage)
    # Usage: bybit_order_cost <symbol> <side> <amount> <price>
    bybit_order_cost() {
      if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ] || [ -z "$4" ]; then
        echo "Usage: bybit_order_cost <symbol> <side (buy/sell)> <amount> <price>"
        echo "  Estimates cost = amount * price. Does not include fees or margin effects."
        echo "Example: bybit_order_cost BTC/USDT:USDT buy 0.01 27000"
        return 1
      fi
      local symbol="$1"
      local side=$(echo "$2" | tr '[:upper:]' '[:lower:]')
      local amount="$3"
      local price="$4"
      _ccxt_bybit_python "
    import decimal # Use decimal for precision
    symbol = '$symbol'
    side = '$side'
    try:
        amount = decimal.Decimal('$amount')
        price = decimal.Decimal('$price')
    except decimal.InvalidOperation:
        print('Error: Invalid amount or price.', file=sys.stderr); sys.exit(1)

    if amount <= 0 or price <= 0:
        print('Error: Amount and Price must be positive.', file=sys.stderr); sys.exit(1)

    # Get market details for quote currency
    try:
        market = exchange.market(symbol)
        quote_currency = market.get('quote', 'QUOTE')
        cost = amount * price
        print(f'Estimated Cost for {side.capitalize()} {amount} {market.get("base", "BASE")} at {price} {quote_currency}:')
        print(f'  Cost: {cost:.8f} {quote_currency}') # Adjust precision as needed
        print(f'Note: This is a basic calculation (amount * price) and does NOT include fees, slippage, or margin requirements.')

    except ccxt.BadSymbol:
         print(f'Error: Invalid symbol format \'{symbol}\'.', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error calculating order cost: {e}', file=sys.stderr)
     "
    }

    # 53. Get Account Risk / Margin Overview (Unified Account Info)
    bybit_account_risk() {
      echo "Fetching account margin and risk overview..."
      _ccxt_bybit_python "
    import json
    try:
        # fetch_balance often contains margin-related info, especially for unified account
        balance = exchange.fetch_balance()

        # Look for relevant keys in the response. Bybit V5 structure might be in balance['info']
        # Keys to look for: equity, unrealizedPnl, marginBalance, availableBalance, initialMargin, maintMargin, marginRatio etc.
        # These might be nested under account type (e.g., UNIFIED, CONTRACT)

        print('Account Risk / Margin Overview (Structure depends on account type):')
        print(json.dumps(balance.get('info', balance), indent=2)) # Print raw info or filtered balance

        # Example parsing (adjust keys based on actual response structure from above print)
        # unified_info = balance.get('info', {}).get('result', {}).get('list', [{}])[0] # Example path for V5 Unified balance list
        # if unified_info:
        #     account_type = unified_info.get('accountType', 'N/A')
        #     equity = unified_info.get('totalEquity', 'N/A')
        #     unrealized_pnl = unified_info.get('totalUnrealisedPnl', 'N/A')
        #     margin_balance = unified_info.get('totalMarginBalance', 'N/A')
        #     available_balance = unified_info.get('totalAvailableBalance', 'N/A')
        #     initial_margin = unified_info.get('totalInitialMargin', 'N/A')
        #     maint_margin = unified_info.get('totalMaintenanceMargin', 'N/A')

        #     print(f'\\nParsed Overview (Account Type: {account_type}):')
        #     print(f'  Equity: {equity}')
        #     print(f'  Margin Balance: {margin_balance}')
        #     print(f'  Available Balance: {available_balance}')
        #     print(f'  Unrealized PNL: {unrealized_pnl}')
        #     print(f'  Initial Margin Req: {initial_margin}')
        #     print(f'  Maintenance Margin Req: {maint_margin}')


    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching account risk info: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching account risk info: {e}', file=sys.stderr)
     "
    }

    # 54. Get Withdrawal History (Optional currency, optional limit, optional since/until)
    bybit_withdrawal_history() {
      # Usage: bybit_withdrawal_history [currency] [limit=20] [since_ms] [until_ms]
      local currency="${1:-None}"
      local limit="${2:-20}"
      local since="${3:-None}"
      local until="${4:-None}"
      _ccxt_bybit_python "
    import json
    currency = '$currency'.upper() if '$currency' != 'None' else None
    limit = int('$limit')
    since = int('$since') if '$since' != 'None' else None
    # 'until' might need to be passed in params dict for CCXT fetch_withdrawals
    params = {}
    if '$until' != 'None':
        params['until'] = int('$until')

    try:
        # Check if fetch_withdrawals is supported
        if not exchange.has.get('fetchWithdrawals'):
             print(f'Error: Fetching withdrawals not supported by CCXT for this exchange.', file=sys.stderr)
             sys.exit(1)

        withdrawals = exchange.fetch_withdrawals(code=currency, limit=limit, since=since, params=params)
        if withdrawals:
            print(f'Last {len(withdrawals)} Withdrawals{" for " + currency if currency else ""}:')
            print('  Timestamp | ID | Currency | Amount | Network | Address | TxID | Status | Fee')
            print('  ----------|----|----------|--------|---------|---------|------|--------|-----')
            # Withdrawals usually returned newest first
            for w in withdrawals:
                 dt = w.get('datetime', 'N/A')
                 wid = w.get('id', 'N/A')
                 curr = w.get('currency', 'N/A')
                 amt = w.get('amount', 'N/A')
                 net = w.get('network', w.get('info', {}).get('chain', 'N/A')) # Network info location varies
                 addr = w.get('address', 'N/A')
                 txid = w.get('txid', 'N/A')
                 stat = w.get('status', 'N/A') # e.g., 'pending', 'ok', 'failed', 'canceled'
                 fee_cost = w.get('fee', {}).get('cost', 'N/A') if w.get('fee') else 'N/A'
                 print(f'  {dt} | {wid} | {curr:<8} | {amt:<6} | {net:<7} | {addr[:10]}... | {txid[:10] if txid else "N/A"}... | {stat:<7} | {fee_cost}') # Truncate long fields
                 # print(json.dumps(w, indent=2)) # Debug full structure
        else:
            print(f'No withdrawal history found with the specified parameters.')

    except ccxt.NotSupported:
         print(f'Error: Fetching withdrawals not supported by exchange via CCXT.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret and permissions. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching withdrawal history: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching withdrawal history: {e}', file=sys.stderr)
     "
    }

    # 55. Withdraw Funds (Requires currency, address, amount, network/tag if needed)
    # **********************************************************************************
    # ** WARNING: USE WITH EXTREME CAUTION! REAL MONEY MOVEMENT! VERIFY ALL DETAILS! **
    # **********************************************************************************
    bybit_withdraw() {
      if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]; then
        echo "Usage: bybit_withdraw <currency> <address> <amount> [network] [tag/memo]"
        echo "**** WARNING: THIS EXECUTES A REAL WITHDRAWAL. DOUBLE CHECK ALL DETAILS ****"
        echo "Example (USDT on TRC20): bybit_withdraw USDT Txxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 10 TRC20"
        echo "Example (XRP with tag):  bybit_withdraw XRP ryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy 20 XRP 12345678"
        read -p "Type 'CONFIRM' to proceed with withdrawal: " confirmation
        if [[ "$confirmation" != "CONFIRM" ]]; then
            echo "Withdrawal cancelled."
            return 1
        fi
        echo "Proceeding with withdrawal..."
      fi

      local currency="$1"
      local address="$2"
      local amount="$3"
      local network="${4:-None}" # Network often required
      local tag="${5:-None}"     # Tag/Memo only if required by currency/network

      _ccxt_bybit_python "
    import json
    currency_code = '$currency'.upper()
    address = '$address'
    amount = float('$amount')
    network_code = '$network' if '$network' != 'None' else None
    tag = '$tag' if '$tag' != 'None' else None

    print(f'**** EXECUTING WITHDRAWAL ****')
    print(f'  Currency: {currency_code}')
    print(f'  Amount:   {amount}')
    print(f'  Address:  {address}')
    if network_code: print(f'  Network:  {network_code}')
    if tag:          print(f'  Tag/Memo: {tag}')
    print(f'****************************')


    # Prepare params for withdraw method
    # CCXT withdraw method usually takes code, amount, address, tag, params
    params = {}
    if network_code:
        # Check how CCXT expects network for Bybit withdrawals ('network', 'chain' in params?)
        params['network'] = network_code
        # Sometimes network is part of address validation implicitly, or required in params.
    # Tag might be passed as the 'tag' argument or within params, check CCXT docs.

    try:
        # Check if withdraw is supported
        if not exchange.has.get('withdraw'):
             print(f'Error: withdraw method not supported by CCXT for this exchange.', file=sys.stderr)
             sys.exit(1)

        # Execute the withdrawal
        # The 'tag' argument might be directly supported or need to go in params dict
        withdrawal_info = exchange.withdraw(currency_code, amount, address, tag=tag, params=params)

        print('Withdrawal request submitted successfully:')
        print(json.dumps(withdrawal_info, indent=2)) # Response includes withdrawal ID, status etc.

    except ccxt.InsufficientFunds as e:
         print(f'Error: Insufficient funds for withdrawal. Check balance and ensure funds are transferable. Details: {e}', file=sys.stderr)
    except ccxt.InvalidAddress as e:
         print(f'Error: Invalid withdrawal address or tag/network mismatch. Details: {e}', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret and withdrawal permissions. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e: # Handles other issues like withdrawal limits, network down, etc.
        print(f'Exchange Error initiating withdrawal: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error initiating withdrawal: {e}', file=sys.stderr)
     "
    }


    # 56. Get Deposit History (Optional currency, optional limit, optional since/until)
    bybit_deposit_history() {
      # Usage: bybit_deposit_history [currency] [limit=20] [since_ms] [until_ms]
      local currency="${1:-None}"
      local limit="${2:-20}"
      local since="${3:-None}"
      local until="${4:-None}"
      _ccxt_bybit_python "
    import json
    currency = '$currency'.upper() if '$currency' != 'None' else None
    limit = int('$limit')
    since = int('$since') if '$since' != 'None' else None
    params = {}
    if '$until' != 'None':
        params['until'] = int('$until')

    try:
        # Check if fetch_deposits is supported
        if not exchange.has.get('fetchDeposits'):
             print(f'Error: Fetching deposits not supported by CCXT for this exchange.', file=sys.stderr)
             sys.exit(1)

        deposits = exchange.fetch_deposits(code=currency, limit=limit, since=since, params=params)
        if deposits:
            print(f'Last {len(deposits)} Deposits{" for " + currency if currency else ""}:')
            print('  Timestamp | ID | Currency | Amount | Network | Address | TxID | Status')
            print('  ----------|----|----------|--------|---------|---------|------|--------')
            # Deposits usually returned newest first
            for d in deposits:
                 dt = d.get('datetime', 'N/A')
                 did = d.get('id', 'N/A')
                 curr = d.get('currency', 'N/A')
                 amt = d.get('amount', 'N/A')
                 net = d.get('network', d.get('info', {}).get('chain', 'N/A'))
                 addr = d.get('address', 'N/A')
                 txid = d.get('txid', 'N/A')
                 stat = d.get('status', 'N/A') # e.g., 'pending', 'ok'
                 print(f'  {dt} | {did} | {curr:<8} | {amt:<6} | {net:<7} | {addr[:10]}... | {txid[:10] if txid else "N/A"}... | {stat}')
                 # print(json.dumps(d, indent=2)) # Debug full structure
        else:
            print(f'No deposit history found with the specified parameters.')

    except ccxt.NotSupported:
         print(f'Error: Fetching deposits not supported by exchange via CCXT.', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret and permissions. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching deposit history: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching deposit history: {e}', file=sys.stderr)
     "
    }

    # 57. Get Positions Filtered by Risk Mode (Cross or Isolated)
    # Note: Requires fetching all positions and filtering, assumes marginMode is available in position data.
    bybit_positions_by_risk_mode() { # Renamed for clarity
      if [ -z "$1" ]; then echo "Usage: bybit_positions_by_risk_mode <isolated | cross>"; return 1; fi
      local risk_mode_filter=$(echo "$1" | tr '[:upper:]' '[:lower:]') # 'isolated' or 'cross'

      if [[ "$risk_mode_filter" != "isolated" && "$risk_mode_filter" != "cross" ]]; then
          echo "Error: Invalid risk mode. Use 'isolated' or 'cross'." >&2; return 1
      fi

      echo "Fetching all positions and filtering by margin mode '$risk_mode_filter'..."
      _ccxt_bybit_python "
    import json
    risk_mode_filter = '$risk_mode_filter'
    filtered_positions = []

    try:
        all_positions = exchange.fetch_positions() # Fetch all non-zero positions

        if all_positions:
            for pos in all_positions:
                # Check the marginMode field - location might vary (pos['marginMode'] or pos['info']['marginMode'])
                pos_margin_mode = pos.get('marginMode', pos.get('info', {}).get('marginMode', '')).lower()

                if pos_margin_mode == risk_mode_filter:
                    filtered_positions.append(pos)

            if filtered_positions:
                 print(f'Positions in {risk_mode_filter.capitalize()} Margin Mode ({len(filtered_positions)} Found):')
                 for pos in sorted(filtered_positions, key=lambda x: x.get('symbol', '')):
                      symbol = pos.get('symbol', 'N/A')
                      side = pos.get('side', 'None')
                      contracts = pos.get('contracts', 0)
                      entry_price = pos.get('entryPrice', 'N/A')
                      margin = pos.get('initialMargin', 'N/A')
                      print(f'  Symbol: {symbol}, Side: {side.capitalize() if side else "None"}, Size: {contracts}, Entry: {entry_price}, Margin: {margin}')
            else:
                 print(f'No positions found matching {risk_mode_filter.capitalize()} margin mode.')
                 print(f'(Checked {len(all_positions)} total non-zero positions)')

        else:
            print('No non-zero positions found in the account.')

    except ccxt.NotSupported as e:
        print(f'Error: Fetching positions or marginMode in position data might not be supported: {e}', file=sys.stderr)
    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching positions for filtering: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching or filtering positions: {e}', file=sys.stderr)
     "
    }


    # 58. Get Supported Order Types (via CCXT capabilities)
    bybit_order_types() {
      echo "Fetching supported order types reported by CCXT for Bybit..."
      _ccxt_bybit_python "
    try:
        # Check exchange capabilities for order types
        print('Supported Order Types (Based on CCXT exchange.has flags):')
        if exchange.has.get('createMarketOrder'): print('- Market')
        if exchange.has.get('createLimitOrder'): print('- Limit')
        if exchange.has.get('createPostOnlyOrder'): print('- Limit (Post-Only)') # Often implied by limit + param
        if exchange.has.get('createReduceOnlyOrder'): print('- Limit/Market (Reduce-Only)') # Often implied by order + param
        if exchange.has.get('createStopOrder') or exchange.has.get('createStopLimitOrder') or exchange.has.get('createStopMarketOrder'): print('- Stop (Limit/Market)')
        if exchange.has.get('createTakeProfitOrder') or exchange.has.get('createTakeProfitLimitOrder') or exchange.has.get('createTakeProfitMarketOrder'): print('- Take Profit (Limit/Market)')
        # Add checks for other types if relevant (e.g., TRAILING_STOP) using exchange.has['TrailingStopOrder'] etc.

        print('\\nNote: Actual support may depend on market type (spot/swap/futures) and specific parameters used.')
        # You can also inspect exchange.options or market['info'] for more details sometimes
        # print('\\nExchange Options:', exchange.options)

    except Exception as e:
        print(f'Unexpected error fetching order types: {e}', file=sys.stderr)
     "
    }

    # 59. Get Available Timeframes (for OHLCV)
    bybit_timeframes() {
      echo "Fetching available OHLCV timeframes from CCXT..."
      _ccxt_bybit_python "
    try:
        if hasattr(exchange, 'timeframes') and exchange.timeframes:
            print('Available OHLCV Timeframes:')
            # timeframes is usually a dictionary { '1m': '1m', '5m': '5m', ... }
            sorted_timeframes = sorted(exchange.timeframes.keys(), key=lambda t: (int(t[:-1]), t[-1]) if t[:-1].isdigit() else (999, t)) # Basic sort
            print(', '.join(sorted_timeframes))
        else:
            print('Could not retrieve timeframes information from exchange instance.')

    except Exception as e:
        print(f'Unexpected error fetching timeframes: {e}', file=sys.stderr)
     "
    }

    # 60. Get Account Info (Raw dump - can be very verbose)
    bybit_account_info() {
      echo "Fetching raw account information (can be verbose)..."
      _ccxt_bybit_python "
    import json
    try:
        # This is often mapped to fetch_balance or similar, and the detailed info is in the 'info' field.
        # Some exchanges might have a dedicated fetch_account method. Check exchange.has.
        if exchange.has.get('fetchAccount'): # Hypothetical check
            account_info = exchange.fetch_account()
        else:
            # Fallback to fetch_balance and display its 'info' field
            print(f'Info: fetchAccount not explicitly supported, showing raw info from fetch_balance instead.')
            balance_info = exchange.fetch_balance()
            account_info = balance_info.get('info', balance_info) # Use 'info' if present, else the whole structure

        print('Raw Account Information Dump:')
        print(json.dumps(account_info, indent=2))

    except ccxt.AuthenticationError as e:
        print(f'Authentication Error: Check API Key/Secret. Details: {e}', file=sys.stderr)
    except ccxt.ExchangeError as e:
        print(f'Exchange Error fetching account information: {e}', file=sys.stderr)
    except Exception as e:
        print(f'Unexpected error fetching account information: {e}', file=sys.stderr)
     "
    }

    # --- End CCXT Bybit Functions ---


    # --- Key bindings ---
    # Standard Emacs-style bindings often set by default, but can be explicit
    bindkey '^A' beginning-of-line
    bindkey '^E' end-of-line
    bindkey '^?' backward-delete-char # Backspace
    bindkey '^H' backward-delete-char # Some terminals use Ctrl+H
    bindkey '^W' backward-kill-word
    bindkey '^K' kill-line # Kill from cursor to end of line (use ^U for beginning)
    bindkey '^L' clear-screen
    bindkey '^R' history-incremental-search-backward
    # Common bindings for Home/End/Delete keys (may vary by terminal)
    bindkey '^[[H' beginning-of-line  # Home
    bindkey '^[[1~' beginning-of-line # Some terminals send this for Home
    bindkey '^[[F' end-of-line      # End
    bindkey '^[[4~' end-of-line      # Some terminals send this for End
    bindkey '^[[3~' delete-char      # Delete
    # Note: Alt+E is bound to _aichat_zsh_suggest above


    # --- Initialization ---

    # Initialize Zsh completion system
    # Needs to run after plugins and functions are defined/sourced
    autoload -Uz compinit && compinit -i # -i checks for insecure files/dirs

    # History Encryption/Decryption Hooks
    # Decrypt history if GPG file exists on shell start
    [[ -f "$HISTFILE.gpg" ]] && decrypt_history
    # Encrypt history on shell exit
    # Ensure GPG agent or password prompt is handled appropriately
    trap 'encrypt_history' EXIT

    # Welcome message
    welcome_message

    # Source Powerlevel10k configuration - Recommended to run p10k configure first
    # This should come AFTER Oh My Zsh and plugins are sourced.
    [[ -f ~/.p10k.zsh ]] && source ~/.p10k.zsh

    # End of ~/.zshrc
   
